{
  "package": "pathsim",
  "display_name": "PathSim",
  "modules": {
    "pathsim": {
      "name": "pathsim",
      "description": "",
      "docstring_html": "",
      "classes": [
        {
          "name": "Simulation",
          "description": "Class that performs transient analysis of the dynamical system, defined by the",
          "docstring_html": "<p>Class that performs transient analysis of the dynamical system, defined by the\nblocks and connecions. It manages all the blocks and connections and the timestep update.</p>\n<p>The global system equation is evaluated by fixed point iteration, so the information from\neach timestep gets distributed within the entire system and is available for all blocks at\nall times.</p>\n<p>The minimum number of fixed-point iterations 'iterations_min' is set to 'None' by default\nand then the length of the longest internal signal path (with passthrough) is used as the\nestimate for minimum number of iterations needed for the information to reach all instant\ntime blocks in each timestep. Dont change this unless you know that the actual path is\nshorter or something similar that prohibits instant time information flow.</p>\n<p>Convergence check for the fixed-point iteration loop with 'tolerance_fpi' is based on\nmax absolute error (max-norm) to previous iteration and should not be touched.</p>\n<p>Multiple numerical integrators are implemented in the 'pathsim.solvers' module.\nThe default solver is a fixed timestep 2nd order Strong Stability Preserving Runge Kutta\n(SSPRK22) method which is quite fast and has ok accuracy, especially if you are forced to\ntake small steps to cover the behaviour of forcing functions. Adaptive timestepping and\nimplicit integrators are also available.</p>\n<p>Manages an event handling system based on zero crossing detection. Uses 'Event' objects\nto monitor solver states of stateful blocks and applys transformations on the state in\ncase an event is detected.</p>\n<div class=\"section\" id=\"example\">\n<h4>Example</h4>\n<p>This is how to setup a simple system simulation using the 'Simulation' class:</p>\n<pre class=\"code python literal-block\">\nimport numpy as np\n\nfrom pathsim import Simulation, Connection\nfrom pathsim.blocks import Source, Integrator, Scope\n\nsrc = Source(lambda t: np.cos(2*np.pi*t))\nitg = Integrator()\nsco = Scope(labels=[&quot;source&quot;, &quot;integrator&quot;])\n\nsim = Simulation(\n    blocks=[src, itg, sco],\n    connections=[\n        Connection(src[0], itg[0], sco[0]),\n        Connection(itg[0], sco[1])\n        ],\n    dt=0.01\n    )\n\nsim.run(4)\nsim.plot()\n</pre>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>blocks <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">list[Block]</span></dt>\n<dd>blocks that define the system</dd>\n<dt>connections <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">list[Connection]</span></dt>\n<dd>connections that connect the blocks</dd>\n<dt>events <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">list[Event]</span></dt>\n<dd>list of event trackers (zero crossing detection, schedule, etc.)</dd>\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>transient simulation timestep in time units,\ndefault see ´SIM_TIMESTEP´ in ´_constants.py´</dd>\n<dt>dt_min <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>lower bound for transient simulation timestep,\ndefault see ´SIM_TIMESTEP_MIN´ in ´_constants.py´</dd>\n<dt>dt_max <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>upper bound for transient simulation timestep,\ndefault see ´SIM_TIMESTEP_MAX´ in ´_constants.py´</dd>\n<dt>Solver <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">Solver</span></dt>\n<dd>ODE solver class for numerical integration from ´pathsim.solvers´,\ndefault is ´pathsim.solvers.ssprk22.SSPRK22´ (2nd order expl. Runge Kutta)</dd>\n<dt>tolerance_fpi <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>absolute tolerance for convergence of algebraic loops\nand internal optimizers of implicit ODE solvers,\ndefault see ´SIM_TOLERANCE_FPI´ in ´_constants.py´</dd>\n<dt>iterations_max <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>maximum allowed number of iterations for implicit ODE\nsolver optimizers and algebraic loop solver,\ndefault see ´SIM_ITERATIONS_MAX´ in ´_constants.py´</dd>\n<dt>log <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool | string</span></dt>\n<dd>flag to enable logging, default see ´LOG_ENABLE´ in ´_constants.py´\n(alternatively a path to a log file can be specified)</dd>\n<dt>solver_kwargs <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">dict</span></dt>\n<dd>additional parameters for numerical solvers such as absolute\n(´tolerance_lte_abs´) and relative (´tolerance_lte_rel´) tolerance,\ndefaults are defined in ´_constants.py´</dd>\n</dl>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>time <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>global simulation time, starting at ´0.0´</dd>\n<dt>graph <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">Graph</span></dt>\n<dd>internal graph representation for fast system funcion evluations\nusing DAG with algebraic depths</dd>\n<dt>boosters <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">None | list[ConnectionBooster]</span></dt>\n<dd>list of boosters (fixed point accelerators) that wrap algebraic\nloop closing connections assembled from the system graph</dd>\n<dt>engine <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">Solver</span></dt>\n<dd>global integrator (ODE solver) instance serving as a dummy to\nget attributes and access to intermediate evaluation stages</dd>\n<dt>logger <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">logging.Logger</span></dt>\n<dd>global simulation logger</dd>\n<dt>_blocks_dyn <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">set[Block]</span></dt>\n<dd>blocks with internal ´Solver´ instances (stateful)</dd>\n<dt>_blocks_evt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">set[Block]</span></dt>\n<dd>blocks with internal events (discrete time, eventful)</dd>\n<dt>_active <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>flag for setting the simulation as active, used for interrupts</dd>\n</dl>\n</div>\n",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "signature": "(blocks = None, connections = None, events = None, dt = SIM_TIMESTEP, dt_min = SIM_TIMESTEP_MIN, dt_max = SIM_TIMESTEP_MAX, Solver = SSPRK22, tolerance_fpi = SIM_TOLERANCE_FPI, iterations_max = SIM_ITERATIONS_MAX, log = LOG_ENABLE, solver_kwargs = {})",
              "parameters": [
                {
                  "name": "blocks",
                  "type": null,
                  "default": "None",
                  "description": ""
                },
                {
                  "name": "connections",
                  "type": null,
                  "default": "None",
                  "description": ""
                },
                {
                  "name": "events",
                  "type": null,
                  "default": "None",
                  "description": ""
                },
                {
                  "name": "dt",
                  "type": null,
                  "default": "SIM_TIMESTEP",
                  "description": ""
                },
                {
                  "name": "dt_min",
                  "type": null,
                  "default": "SIM_TIMESTEP_MIN",
                  "description": ""
                },
                {
                  "name": "dt_max",
                  "type": null,
                  "default": "SIM_TIMESTEP_MAX",
                  "description": ""
                },
                {
                  "name": "Solver",
                  "type": null,
                  "default": "SSPRK22",
                  "description": ""
                },
                {
                  "name": "tolerance_fpi",
                  "type": null,
                  "default": "SIM_TOLERANCE_FPI",
                  "description": ""
                },
                {
                  "name": "iterations_max",
                  "type": null,
                  "default": "SIM_ITERATIONS_MAX",
                  "description": ""
                },
                {
                  "name": "log",
                  "type": null,
                  "default": "LOG_ENABLE",
                  "description": ""
                },
                {
                  "name": "solver_kwargs",
                  "type": null,
                  "default": "{}",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "plot",
              "description": "Plot the simulation results by calling all the blocks",
              "docstring_html": "<p>Plot the simulation results by calling all the blocks\nthat have visualization capabilities such as the 'Scope'\nand 'Spectrum'.</p>\n<p>This is a quality of life method. Blocks can be visualized\nindividually due to the object oriented nature, but it might\nbe nice to just call the plot metho globally and look at all\nthe results at once. Also works for models loaded from an\nexternal file.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>args <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">tuple</span></dt>\n<dd>args for the plot methods</dd>\n<dt>kwargs <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">dict</span></dt>\n<dd>kwargs for the plot method</dd>\n</dl>\n",
              "signature": "(args = (), kwargs = {})",
              "parameters": [
                {
                  "name": "args",
                  "type": null,
                  "default": "()",
                  "description": "args for the plot methods"
                },
                {
                  "name": "kwargs",
                  "type": null,
                  "default": "{}",
                  "description": "kwargs for the plot method"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "add_block",
              "description": "Adds a new block to the simulation, initializes its local solver",
              "docstring_html": "<p>Adds a new block to the simulation, initializes its local solver\ninstance and collects internal events of the new block.</p>\n<p>This works dynamically for running simulations.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>block <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">Block</span></dt>\n<dd>block to add to the simulation</dd>\n<dt>_defer_graph <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>flag for defering graph construction to a later stage</dd>\n</dl>\n",
              "signature": "(block, _defer_graph = False)",
              "parameters": [
                {
                  "name": "block",
                  "type": null,
                  "default": null,
                  "description": "block to add to the simulation"
                },
                {
                  "name": "_defer_graph",
                  "type": null,
                  "default": "False",
                  "description": "flag for defering graph construction to a later stage"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "add_connection",
              "description": "Adds a new connection to the simulaiton and checks if",
              "docstring_html": "<p>Adds a new connection to the simulaiton and checks if\nthe new connection overwrites any existing connections.</p>\n<p>This works dynamically for running simulations.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>connection <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">Connection</span></dt>\n<dd>connection to add to the simulation</dd>\n<dt>_defer_graph <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>flag for defering graph construction to a later stage</dd>\n</dl>\n",
              "signature": "(connection, _defer_graph = False)",
              "parameters": [
                {
                  "name": "connection",
                  "type": null,
                  "default": null,
                  "description": "connection to add to the simulation"
                },
                {
                  "name": "_defer_graph",
                  "type": null,
                  "default": "False",
                  "description": "flag for defering graph construction to a later stage"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "add_event",
              "description": "Checks and adds a new event to the simulation.",
              "docstring_html": "<p>Checks and adds a new event to the simulation.</p>\n<p>This works dynamically for running simulations.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>event <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">Event</span></dt>\n<dd>event to add to the simulation</dd>\n</dl>\n",
              "signature": "(event)",
              "parameters": [
                {
                  "name": "event",
                  "type": null,
                  "default": null,
                  "description": "event to add to the simulation"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "reset",
              "description": "Reset the blocks to their initial state and the global time of",
              "docstring_html": "<p>Reset the blocks to their initial state and the global time of\nthe simulation.</p>\n<p>For recording blocks such as 'Scope', their recorded\ndata is also reset.</p>\n<p>Resets linearization automatically, since resetting the blocks\nresets their internal operators.</p>\n<p>Afterwards the system function is evaluated with '_update' to update\nthe block inputs and outputs.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>time <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>simulation time for reset</dd>\n</dl>\n",
              "signature": "(time = 0.0)",
              "parameters": [
                {
                  "name": "time",
                  "type": null,
                  "default": "0.0",
                  "description": "simulation time for reset"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "linearize",
              "description": "Linearize the full system in the current simulation state",
              "docstring_html": "<p>Linearize the full system in the current simulation state\nat the current simulation time.</p>\n<p>This is achieved by linearizing algebraic and dynamic operators\nof the internal blocks. See definition of the 'Block' class.</p>\n<p>Before linearization, the global system function is evaluated\nto get the blocks into the current simulation state.\nThis is only really relevant if no solving attempt has been\nhappened before.</p>\n",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "delinearize",
              "description": "Revert the linearization of the full system.",
              "docstring_html": "<p>Revert the linearization of the full system.</p>\n",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "steadystate",
              "description": "Find steady state solution (DC operating point) of the system",
              "docstring_html": "<p>Find steady state solution (DC operating point) of the system\nby switching all blocks to steady state solver, solving the\nfixed point equations, then switching back.</p>\n<p>The steady state solver forces all the temporal derivatives, i.e.\nthe right hand side equation (including external inputs) of the\nengines of dynamic blocks to zero.</p>\n<div class=\"section\" id=\"note\">\n<h4>Note</h4>\n<p>This is really a sort of pseudo-steady-state solve. It does NOT compute\nthe limit <math xmlns=\"http://www.w3.org/1998/Math/MathML\">\n  <mi>t</mi>\n  <mo>→</mo>\n  <mi>∞</mi>\n</math> but rather forces all time\nderivatives to zero at a given moment in time.</p>\n<p>This means, for a given <cite>t</cite> it computes the block states <cite>x</cite> such that:</p>\n<div>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\">\n  <mn>0</mn>\n  <mo>=</mo>\n  <mi>f</mi>\n  <mo stretchy=\"false\">(</mo>\n  <mi>x</mi>\n  <mo>,</mo>\n  <mi>t</mi>\n  <mo stretchy=\"false\">)</mo>\n</math>\n</div>\n<p>instead of the real steady state:</p>\n<div>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\">\n  <munder>\n    <mo movablelimits=\"true\">lim</mo>\n    <mrow>\n      <mi>t</mi>\n      <mo>→</mo>\n      <mi>∞</mi>\n    </mrow>\n  </munder>\n  <mi>x</mi>\n  <mo stretchy=\"false\">(</mo>\n  <mi>t</mi>\n  <mo stretchy=\"false\">)</mo>\n</math>\n</div>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>reset <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>reset the simulation before solving for steady state (default False)</dd>\n</dl>\n</div>\n",
              "signature": "(reset = False)",
              "parameters": [
                {
                  "name": "reset",
                  "type": null,
                  "default": "False",
                  "description": "reset the simulation before solving for steady state (default False)"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "timestep_fixed_explicit",
              "description": "Advances the simulation by one timestep 'dt' for explicit fixed step solvers.",
              "docstring_html": "<p>Advances the simulation by one timestep 'dt' for explicit fixed step solvers.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>timestep</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>success <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>indicator if the timestep was successful</dd>\n<dt>max_error <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>maximum local truncation error from integration</dd>\n<dt>scale <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>rescale factor for timestep</dd>\n<dt>total_evals <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>total number of system evaluations</dd>\n<dt>total_solver_its <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>total number of implicit solver iterations</dd>\n</dl>\n",
              "signature": "(dt = None)",
              "parameters": [
                {
                  "name": "dt",
                  "type": null,
                  "default": "None",
                  "description": "timestep"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "timestep_fixed_implicit",
              "description": "Advances the simulation by one timestep 'dt' for implicit fixed step solvers.",
              "docstring_html": "<p>Advances the simulation by one timestep 'dt' for implicit fixed step solvers.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>timestep</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>success <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>indicator if the timestep was successful</dd>\n<dt>max_error <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>maximum local truncation error from integration</dd>\n<dt>scale <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>rescale factor for timestep</dd>\n<dt>total_evals <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>total number of system evaluations</dd>\n<dt>total_solver_its <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>total number of implicit solver iterations</dd>\n</dl>\n",
              "signature": "(dt = None)",
              "parameters": [
                {
                  "name": "dt",
                  "type": null,
                  "default": "None",
                  "description": "timestep"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "timestep_adaptive_explicit",
              "description": "Advances the simulation by one timestep 'dt' for explicit adaptive solvers.",
              "docstring_html": "<p>Advances the simulation by one timestep 'dt' for explicit adaptive solvers.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>timestep</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>success <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>indicator if the timestep was successful</dd>\n<dt>max_error <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>maximum local truncation error from integration</dd>\n<dt>scale <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>rescale factor for timestep</dd>\n<dt>total_evals <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>total number of system evaluations</dd>\n<dt>total_solver_its <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>total number of implicit solver iterations</dd>\n</dl>\n",
              "signature": "(dt = None)",
              "parameters": [
                {
                  "name": "dt",
                  "type": null,
                  "default": "None",
                  "description": "timestep"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "timestep_adaptive_implicit",
              "description": "Advances the simulation by one timestep 'dt' for implicit adaptive solvers.",
              "docstring_html": "<p>Advances the simulation by one timestep 'dt' for implicit adaptive solvers.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>timestep</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>success <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>indicator if the timestep was successful</dd>\n<dt>max_error <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>maximum local truncation error from integration</dd>\n<dt>scale <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>rescale factor for timestep</dd>\n<dt>total_evals <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>total number of system evaluations</dd>\n<dt>total_solver_its <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>total number of implicit solver iterations</dd>\n</dl>\n",
              "signature": "(dt = None)",
              "parameters": [
                {
                  "name": "dt",
                  "type": null,
                  "default": "None",
                  "description": "timestep"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "timestep",
              "description": "Advances the transient simulation by one timestep 'dt'.",
              "docstring_html": "<p>Advances the transient simulation by one timestep 'dt'.</p>\n<p>Automatic behavior selection based on selected <cite>Solver</cite> and <cite>adaptive</cite> flag:</p>\n<ul class=\"simple\">\n<li>Explicit solvers: Uses <cite>_update()</cite> for system evaluation</li>\n<li>Implicit solvers: Uses <cite>_solve()</cite> for implicit update equation</li>\n<li>Adaptive solvers (with adaptive=True): Reverts timestep if error too large\nor event not close</li>\n<li>Fixed solvers (or adaptive=False): Always completes timestep, resolves\nevents at detected time</li>\n</ul>\n<p>If discrete events are detected, they are handled according to stepping mode:</p>\n<ul class=\"simple\">\n<li>Fixed stepping: Events resolved at interpolated time within step</li>\n<li>Adaptive stepping: Events approached via timestep rescaling (secant method)</li>\n</ul>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>timestep size for transient simulation</dd>\n<dt>adaptive <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>explicitly enable/disable adaptive timestepping; when False, adaptive\nsolvers are forced to take fixed steps without error control (default True)</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>success <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>indicator if the timestep was successful</dd>\n<dt>max_error <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>maximum local truncation error from integration</dd>\n<dt>scale <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>rescale factor for timestep</dd>\n<dt>total_evals <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>total number of system evaluations</dd>\n<dt>total_solver_its <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>total number of implicit solver iterations</dd>\n</dl>\n",
              "signature": "(dt = None, adaptive = True)",
              "parameters": [
                {
                  "name": "dt",
                  "type": null,
                  "default": "None",
                  "description": "timestep size for transient simulation"
                },
                {
                  "name": "adaptive",
                  "type": null,
                  "default": "True",
                  "description": "explicitly enable/disable adaptive timestepping; when False, adaptive solvers are forced to take fixed steps without error control (default True)"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "step",
              "description": "Wraps 'Simulation.timestep' for backward compatibility",
              "docstring_html": "<p>Wraps 'Simulation.timestep' for backward compatibility</p>\n",
              "signature": "(dt = None, adaptive = True)",
              "parameters": [
                {
                  "name": "dt",
                  "type": null,
                  "default": "None",
                  "description": ""
                },
                {
                  "name": "adaptive",
                  "type": null,
                  "default": "True",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "collect",
              "description": "Collect all current simulation results from the internal",
              "docstring_html": "<p>Collect all current simulation results from the internal\nrecording blocks</p>\n<p><strong>Returns</strong></p>\n<p>results : dict</p>\n",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "stop",
              "description": "Set the flag for active simulation to 'False', intended to be",
              "docstring_html": "<p>Set the flag for active simulation to 'False', intended to be\ncalled from the outside (for example by events) to interrupt the\ntimestepping loop in 'run'.</p>\n",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "run",
              "description": "Perform multiple simulation timesteps for a given 'duration'.",
              "docstring_html": "<p>Perform multiple simulation timesteps for a given 'duration'.</p>\n<p>Tracks the total number of block evaluations (proxy for function\ncalls, although larger, since one function call of the system equation\nconsists of many block evaluations) and the total number of solver\niterations for implicit solvers.</p>\n<p>Additionally the progress of the simulation is tracked by a custom\n'ProgressTracker' class that is a dynamic generator and interfaces\nthe logging system.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>duration <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>simulation time (in time units)</dd>\n<dt>reset <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>reset the simulation before running (default False)</dd>\n<dt>adaptive <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>use adaptive timesteps if solver is adaptive (default True)</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>stats <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">dict</span></dt>\n<dd>stats of simulation run tracked by the 'ProgressTracker'</dd>\n</dl>\n",
              "signature": "(duration = 10, reset = False, adaptive = True)",
              "parameters": [
                {
                  "name": "duration",
                  "type": null,
                  "default": "10",
                  "description": "simulation time (in time units)"
                },
                {
                  "name": "reset",
                  "type": null,
                  "default": "False",
                  "description": "reset the simulation before running (default False)"
                },
                {
                  "name": "adaptive",
                  "type": null,
                  "default": "True",
                  "description": "use adaptive timesteps if solver is adaptive (default True)"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "run_streaming",
              "description": "Perform simulation with streaming output at a fixed wall-clock rate.",
              "docstring_html": "<p>Perform simulation with streaming output at a fixed wall-clock rate.</p>\n<p>This method runs the simulation as fast as possible while yielding\nintermediate results at a fixed rate defined by 'tickrate'. Useful\nfor real-time visualization and UI updates.</p>\n<p>The progress is tracked and logged using the 'ProgressTracker' class.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>duration <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>simulation time (in time units)</dd>\n<dt>reset <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>reset the simulation before running (default False)</dd>\n<dt>adaptive <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>use adaptive timesteps if solver is adaptive (default True)</dd>\n<dt>tickrate <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>output rate in Hz, i.e., yields per second of wall-clock time\n(default 10)</dd>\n<dt>func_callback <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">callable | None</span></dt>\n<dd>callback function that is called at every tick, can be used\nfor data extraction, its return value is yielded by this generator</dd>\n</dl>\n<p><strong>Yields</strong></p>\n<dl class=\"docutils\">\n<dt>result</dt>\n<dd>The return value of the 'func_callback' callable.</dd>\n</dl>\n",
              "signature": "(duration = 10, reset = False, adaptive = True, tickrate = 10, func_callback = None)",
              "parameters": [
                {
                  "name": "duration",
                  "type": null,
                  "default": "10",
                  "description": "simulation time (in time units)"
                },
                {
                  "name": "reset",
                  "type": null,
                  "default": "False",
                  "description": "reset the simulation before running (default False)"
                },
                {
                  "name": "adaptive",
                  "type": null,
                  "default": "True",
                  "description": "use adaptive timesteps if solver is adaptive (default True)"
                },
                {
                  "name": "tickrate",
                  "type": null,
                  "default": "10",
                  "description": "output rate in Hz, i.e., yields per second of wall-clock time (default 10)"
                },
                {
                  "name": "func_callback",
                  "type": null,
                  "default": "None",
                  "description": "callback function that is called at every tick, can be used for data extraction, its return value is yielded by this generator"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "run_realtime",
              "description": "Perform simulation paced to wall-clock time.",
              "docstring_html": "<p>Perform simulation paced to wall-clock time.</p>\n<p>This method runs the simulation synchronized to real time, optionally\nscaled by 'speed'. The simulation advances to match elapsed wall-clock\ntime, yielding results at the rate defined by 'tickrate'.</p>\n<p>Useful for interactive simulations, hardware-in-the-loop testing,\nor when simulation should match real-world timing.</p>\n<p>The progress is tracked and logged using the 'ProgressTracker' class.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>duration <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>simulation time (in time units)</dd>\n<dt>reset <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>reset the simulation before running (default False)</dd>\n<dt>adaptive <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>use adaptive timesteps if solver is adaptive (default True)</dd>\n<dt>tickrate <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>output rate in Hz, i.e., yields per second of wall-clock time\n(default 30)</dd>\n<dt>speed <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>time scaling factor where 1.0 is real-time, 2.0 is twice as fast,\n0.5 is half speed (default 1.0)</dd>\n<dt>func_callback <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">callable | None</span></dt>\n<dd>callback function that is called at every tick, can be used\nfor data extraction, its return value is yielded by this generator</dd>\n</dl>\n<p><strong>Yields</strong></p>\n<dl class=\"docutils\">\n<dt>result</dt>\n<dd>The return value of the 'func_callback' callable.</dd>\n</dl>\n",
              "signature": "(duration = 10, reset = False, adaptive = True, tickrate = 30, speed = 1.0, func_callback = None)",
              "parameters": [
                {
                  "name": "duration",
                  "type": null,
                  "default": "10",
                  "description": "simulation time (in time units)"
                },
                {
                  "name": "reset",
                  "type": null,
                  "default": "False",
                  "description": "reset the simulation before running (default False)"
                },
                {
                  "name": "adaptive",
                  "type": null,
                  "default": "True",
                  "description": "use adaptive timesteps if solver is adaptive (default True)"
                },
                {
                  "name": "tickrate",
                  "type": null,
                  "default": "30",
                  "description": "output rate in Hz, i.e., yields per second of wall-clock time (default 30)"
                },
                {
                  "name": "speed",
                  "type": null,
                  "default": "1.0",
                  "description": "time scaling factor where 1.0 is real-time, 2.0 is twice as fast, 0.5 is half speed (default 1.0)"
                },
                {
                  "name": "func_callback",
                  "type": null,
                  "default": "None",
                  "description": "callback function that is called at every tick, can be used for data extraction, its return value is yielded by this generator"
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "blocks",
              "description": "",
              "type": null,
              "value": "set()"
            },
            {
              "name": "connections",
              "description": "",
              "type": null,
              "value": "set()"
            },
            {
              "name": "events",
              "description": "",
              "type": null,
              "value": "set()"
            },
            {
              "name": "dt",
              "description": "",
              "type": null,
              "value": "dt"
            },
            {
              "name": "dt_min",
              "description": "",
              "type": null,
              "value": "dt_min"
            },
            {
              "name": "dt_max",
              "description": "",
              "type": null,
              "value": "dt_max"
            },
            {
              "name": "Solver",
              "description": "",
              "type": null,
              "value": "Solver"
            },
            {
              "name": "engine",
              "description": "",
              "type": null,
              "value": "Solver()"
            },
            {
              "name": "graph",
              "description": "",
              "type": null,
              "value": "None"
            },
            {
              "name": "boosters",
              "description": "",
              "type": null,
              "value": "None"
            },
            {
              "name": "tolerance_fpi",
              "description": "",
              "type": null,
              "value": "tolerance_fpi"
            },
            {
              "name": "solver_kwargs",
              "description": "",
              "type": null,
              "value": "solver_kwargs"
            },
            {
              "name": "iterations_max",
              "description": "",
              "type": null,
              "value": "iterations_max"
            },
            {
              "name": "log",
              "description": "",
              "type": null,
              "value": "log"
            },
            {
              "name": "time",
              "description": "",
              "type": null,
              "value": "0.0"
            },
            {
              "name": "logger",
              "description": "",
              "type": null,
              "value": "logger_mgr.get_logger('simulation')"
            },
            {
              "name": "size",
              "description": "Get size information of the simulation, such as total number",
              "type": null,
              "value": null
            }
          ],
          "parameters": [
            {
              "name": "blocks",
              "type": null,
              "default": "None",
              "description": "blocks that define the system"
            },
            {
              "name": "connections",
              "type": null,
              "default": "None",
              "description": "connections that connect the blocks"
            },
            {
              "name": "events",
              "type": null,
              "default": "None",
              "description": "list of event trackers (zero crossing detection, schedule, etc.)"
            },
            {
              "name": "dt",
              "type": null,
              "default": "SIM_TIMESTEP",
              "description": "transient simulation timestep in time units, default see ´SIM_TIMESTEP´ in ´_constants.py´"
            },
            {
              "name": "dt_min",
              "type": null,
              "default": "SIM_TIMESTEP_MIN",
              "description": "lower bound for transient simulation timestep, default see ´SIM_TIMESTEP_MIN´ in ´_constants.py´"
            },
            {
              "name": "dt_max",
              "type": null,
              "default": "SIM_TIMESTEP_MAX",
              "description": "upper bound for transient simulation timestep, default see ´SIM_TIMESTEP_MAX´ in ´_constants.py´"
            },
            {
              "name": "Solver",
              "type": null,
              "default": "SSPRK22",
              "description": "ODE solver class for numerical integration from ´pathsim.solvers´, default is ´pathsim.solvers.ssprk22.SSPRK22´ (2nd order expl. Runge Kutta)"
            },
            {
              "name": "tolerance_fpi",
              "type": null,
              "default": "SIM_TOLERANCE_FPI",
              "description": "absolute tolerance for convergence of algebraic loops and internal optimizers of implicit ODE solvers, default see ´SIM_TOLERANCE_FPI´ in ´_constants.py´"
            },
            {
              "name": "iterations_max",
              "type": null,
              "default": "SIM_ITERATIONS_MAX",
              "description": "maximum allowed number of iterations for implicit ODE solver optimizers and algebraic loop solver, default see ´SIM_ITERATIONS_MAX´ in ´_constants.py´"
            },
            {
              "name": "log",
              "type": null,
              "default": "LOG_ENABLE",
              "description": "flag to enable logging, default see ´LOG_ENABLE´ in ´_constants.py´ (alternatively a path to a log file can be specified)"
            },
            {
              "name": "solver_kwargs",
              "type": null,
              "default": "{}",
              "description": "additional parameters for numerical solvers such as absolute (´tolerance_lte_abs´) and relative (´tolerance_lte_rel´) tolerance, defaults are defined in ´_constants.py´"
            }
          ]
        },
        {
          "name": "Connection",
          "description": "Class to handle input-output relations of blocks by connecting them (directed graph)",
          "docstring_html": "<p>Class to handle input-output relations of blocks by connecting them (directed graph)\nand transfering data from the output port of the source block to the input port of\nthe target block.</p>\n<p>The default ports for connection are (0) -&gt; (0), since these are the default inputs\nthat are used in the SISO blocks.</p>\n<p><strong>Examples</strong></p>\n<p>Lets assume we have some generic blocks</p>\n<pre class=\"code python literal-block\">\nfrom pathsim.blocks._block import Block\n\nB1 = Block()\nB2 = Block()\nB3 = Block()\n</pre>\n<p>that we want to connect. We initialize a 'Connection' with the blocks directly\nas the arguments if we want to connect the default ports (0) -&gt; (0)</p>\n<pre class=\"code python literal-block\">\nfrom pathsim import Connection\n\nC = Connection(B1, B2)\n</pre>\n<p>which is a connection from block 'B1' to 'B2'. If we want to explicitly declare\nthe input and output ports we can do that by utilizing the '__getitem__' method\nof the blocks</p>\n<pre class=\"code python literal-block\">\nC = Connection(B1[0], B2[0])\n</pre>\n<p>which is exactly the default port setup. Connecting output port (1) of 'B1' to\nthe default input port (0) of 'B2' do</p>\n<pre class=\"code python literal-block\">\nC = Connection(B1[1], B2[0])\n</pre>\n<p>or just</p>\n<pre class=\"code python literal-block\">\nC = Connection(B1[1], B2).\n</pre>\n<p>The 'Connection' class also supports multiple targets for a single source.\nThis is specified by just adding more blocks with their respective ports into\nthe constructor like this:</p>\n<pre class=\"code python literal-block\">\nC = Connection(B1, B2[0], B2[1], B3)\n</pre>\n<p>The port definitions follow the same structure as for single target connections.</p>\n<p>'self'-connections also work without a problem. This is useful for modeling direct\nfeedback of a block to itself.</p>\n<p>Port definitions support slicing. This enables direct MIMO connections. For example\nconnecting ports 0, 1, 2 of 'B1' to ports 1, 2, 3 of 'B2' works like this:</p>\n<pre class=\"code python literal-block\">\nC = Connection(B1[0:2], B2[1:3])\n</pre>\n<p>Port definitions also support lists and tuples of 'int'. For example the slice\nabove is identical to this:</p>\n<pre class=\"code python literal-block\">\nC = Connection(B1[0, 1], B2[1, 2])\n</pre>\n<p>Or to be more programmatic about it, like this:</p>\n<pre class=\"code python literal-block\">\nprts_1 = [0, 1]\nprts_2 = [1, 2]\n\nC = Connection(B1[prts_1], B2[prts_2])\n</pre>\n<p>Another way to define the ports is by using strings. Some blocks have internal\naliases for the ports that can be used instead of the integer port indices to\ndefine the connections (or access the port data):</p>\n<pre class=\"code python literal-block\">\nC = Connection(B1[&quot;out&quot;], B2[&quot;in&quot;])\n</pre>\n<p>Or mixed with integer port indices:</p>\n<pre class=\"code python literal-block\">\nC = Connection(B1[&quot;out&quot;], B2[&quot;in&quot;])\n</pre>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>source <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">PortReference, Block</span></dt>\n<dd>source block and optional source output port</dd>\n<dt>targets <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">tuple[PortReference], tuple[Block]</span></dt>\n<dd>target blocks and optional target input ports</dd>\n</dl>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>_active <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>flag to set 'Connection' as active or inactive</dd>\n</dl>\n",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "signature": "(source, targets = ())",
              "parameters": [
                {
                  "name": "source",
                  "type": null,
                  "default": null,
                  "description": ""
                },
                {
                  "name": "targets",
                  "type": null,
                  "default": "()",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "get_blocks",
              "description": "Returns all the unique internal source and target blocks",
              "docstring_html": "<p>Returns all the unique internal source and target blocks\nof the connection instance</p>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>list[Block]</dt>\n<dd>internal unique blocks of the connection</dd>\n</dl>\n",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "on",
              "description": "",
              "docstring_html": "",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "off",
              "description": "",
              "docstring_html": "",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "update",
              "description": "Transfers data from the source block output port",
              "docstring_html": "<p>Transfers data from the source block output port\nto the target block input port.</p>\n",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "source",
              "description": "",
              "type": null,
              "value": "source if isinstance(source, PortReference) else PortReference(source)"
            },
            {
              "name": "targets",
              "description": "",
              "type": null,
              "value": "[(trg if isinstance(trg, PortReference) else PortReference(trg)) for trg in targets]"
            }
          ],
          "parameters": [
            {
              "name": "source",
              "type": null,
              "default": null,
              "description": "source block and optional source output port"
            },
            {
              "name": "targets",
              "type": null,
              "default": "()",
              "description": "target blocks and optional target input ports"
            }
          ]
        },
        {
          "name": "Duplex",
          "description": "Extension of the 'Connection' class, that defines bidirectional",
          "docstring_html": "<p>Extension of the 'Connection' class, that defines bidirectional\nconnections between two blocks by grouping together the inputs and\noutputs of the blocks into an IO-pair.</p>\n",
          "bases": [
            "Connection"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "signature": "(source, target)",
              "parameters": [
                {
                  "name": "source",
                  "type": null,
                  "default": null,
                  "description": ""
                },
                {
                  "name": "target",
                  "type": null,
                  "default": null,
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "update",
              "description": "Transfers data between the two target blocks",
              "docstring_html": "<p>Transfers data between the two target blocks\nand ports bidirectionally.</p>\n",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "source",
              "description": "",
              "type": null,
              "value": "source if isinstance(source, PortReference) else PortReference(source)"
            },
            {
              "name": "target",
              "description": "",
              "type": null,
              "value": "target if isinstance(target, PortReference) else PortReference(target)"
            },
            {
              "name": "targets",
              "description": "",
              "type": null,
              "value": "[self.target, self.source]"
            }
          ],
          "parameters": [
            {
              "name": "source",
              "type": null,
              "default": null,
              "description": ""
            },
            {
              "name": "target",
              "type": null,
              "default": null,
              "description": ""
            }
          ]
        },
        {
          "name": "Subsystem",
          "description": "Subsystem class that holds its own blocks and connecions and",
          "docstring_html": "<p>Subsystem class that holds its own blocks and connecions and\ncan natively interface with the main simulation loop.</p>\n<p>IO interface is realized by a special 'Interface' block, that has extra\nmethods for setting and getting inputs and outputs and serves\nas the interface of the internal blocks to the outside.</p>\n<p>The subsystem doesnt use its 'inputs' and 'outputs' dicts directly.\nIt exclusively handles data transfer via the 'Interface' block.</p>\n<p>This class can be used just like any other block during the simulation,\nsince it implements the required methods 'update' for the fixed-point\niteration (resolving algebraic loops with instant time blocks),\nthe 'step' method that performs timestepping (especially for dynamic\nblocks with internal states) and the 'solve' method for solving the\nimplicit update equation for implicit solvers.</p>\n<div class=\"section\" id=\"example\">\n<h4>Example</h4>\n<p>This is how we can wrap up multiple blocks within a subsystem.\nIn this case vanderpol system built from discrete components\ninstead of using an ODE block (in practice you should use\na monolithic ODE whenever possible due to performance).</p>\n<pre class=\"code python literal-block\">\nfrom pathsim import Subsystem, Interface, Connection\nfrom pathsim.blocks import Integrator, Function\n\n#van der Pol parameter\nmu = 1000\n\n#blocks in the subsystem\nIf = Interface() # this is the interface to the outside\nI1 = Integrator(2)\nI2 = Integrator(0)\nFn = Function(lambda x1, x2: mu*(1 - x1**2)*x2 - x1)\n\nsub_blocks = [If, I1, I2, Fn]\n\n#connections in the subsystem\nsub_connections = [\n    Connection(I2, I1, Fn[1], If[1]),\n    Connection(I1, Fn, If),\n    Connection(Fn, I2)\n    ]\n\n#the subsystem acts just like a normal block\nvdp = Subsystem(sub_blocks, sub_connections)\n</pre>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>blocks <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">list[Block] | None</span></dt>\n<dd>internal blocks of the subsystem</dd>\n<dt>connections <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">list[Connection] | None</span></dt>\n<dd>internal connections of the subsystem</dd>\n</dl>\n<p>events : list[Event] | None\ntolerance_fpi : float</p>\n<blockquote>\nabsolute tolerance for convergence of algebraic loops\ndefault see ´SIM_TOLERANCE_FPI´ in ´_constants.py´</blockquote>\n<dl class=\"docutils\">\n<dt>iterations_max <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>maximum allowed number of iterations for algebraic loop\nsolver, default see ´SIM_ITERATIONS_MAX´ in ´_constants.py´</dd>\n</dl>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>interface <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">Interface</span></dt>\n<dd>internal interface block for data transfer to the outside</dd>\n<dt>graph <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">Graph</span></dt>\n<dd>internal graph representation for fast system funcion\nevluations using DAG with algebraic depths</dd>\n<dt>boosters <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">None | list[ConnectionBooster]</span></dt>\n<dd>list of boosters (fixed point accelerators) that wrap\nalgebraic loop closing connections assembled from the\nsystem graph</dd>\n</dl>\n</div>\n",
          "bases": [
            "Block"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "signature": "(blocks = None, connections = None, events = None, tolerance_fpi = SIM_TOLERANCE_FPI, iterations_max = SIM_ITERATIONS_MAX)",
              "parameters": [
                {
                  "name": "blocks",
                  "type": null,
                  "default": "None",
                  "description": ""
                },
                {
                  "name": "connections",
                  "type": null,
                  "default": "None",
                  "description": ""
                },
                {
                  "name": "events",
                  "type": null,
                  "default": "None",
                  "description": ""
                },
                {
                  "name": "tolerance_fpi",
                  "type": null,
                  "default": "SIM_TOLERANCE_FPI",
                  "description": ""
                },
                {
                  "name": "iterations_max",
                  "type": null,
                  "default": "SIM_ITERATIONS_MAX",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "plot",
              "description": "Plot the simulation results by calling all the blocks",
              "docstring_html": "<p>Plot the simulation results by calling all the blocks\nthat have visualization capabilities such as the 'Scope'\nand 'Spectrum'.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>args <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">tuple</span></dt>\n<dd>args for the plot methods</dd>\n<dt>kwargs <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">dict</span></dt>\n<dd>kwargs for the plot method</dd>\n</dl>\n",
              "signature": "(args = (), kwargs = {})",
              "parameters": [
                {
                  "name": "args",
                  "type": null,
                  "default": "()",
                  "description": "args for the plot methods"
                },
                {
                  "name": "kwargs",
                  "type": null,
                  "default": "{}",
                  "description": "kwargs for the plot method"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "collect",
              "description": "Aggregate results from internal blocks.",
              "docstring_html": "<p>Aggregate results from internal blocks.</p>\n",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "reset",
              "description": "Reset the subsystem interface and all internal blocks",
              "docstring_html": "<p>Reset the subsystem interface and all internal blocks</p>\n",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "on",
              "description": "Activate the subsystem and all internal blocks, sets the boolean",
              "docstring_html": "<p>Activate the subsystem and all internal blocks, sets the boolean\nevaluation flag to 'True'.</p>\n",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "off",
              "description": "Deactivate the subsystem and all internal blocks, sets the boolean",
              "docstring_html": "<p>Deactivate the subsystem and all internal blocks, sets the boolean\nevaluation flag to 'False'. Also resets the subsystem.</p>\n",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "linearize",
              "description": "Linearize the algebraic and dynamic components of the internal blocks.",
              "docstring_html": "<p>Linearize the algebraic and dynamic components of the internal blocks.</p>\n<p>This is done by linearizing the internal 'Operator' and 'DynamicOperator'\ninstances of all the internal blocks of the subsystem in the current system\noperating point. The operators create 1st order tayler approximations\ninternally and use them on subsequent calls after linarization.</p>\n<p>Recursively traverses down the hierarchy for nested subsystems and linearizes\nall of them.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time</dd>\n</dl>\n",
              "signature": "(t)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "delinearize",
              "description": "Revert the linearization of the internal blocks.",
              "docstring_html": "<p>Revert the linearization of the internal blocks.</p>\n",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "sample",
              "description": "Update the internal connections again and sample data from",
              "docstring_html": "<p>Update the internal connections again and sample data from\nthe internal blocks that implement the 'sample' method.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time</dd>\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>integration timestep</dd>\n</dl>\n",
              "signature": "(t, dt)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time"
                },
                {
                  "name": "dt",
                  "type": null,
                  "default": null,
                  "description": "integration timestep"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "update",
              "description": "Update the instant time components of the internal blocks",
              "docstring_html": "<p>Update the instant time components of the internal blocks\nto evaluate the (distributed) system equation.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time</dd>\n</dl>\n",
              "signature": "(t)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "solve",
              "description": "Advance solution of implicit update equation",
              "docstring_html": "<p>Advance solution of implicit update equation\nfor internal blocks.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time</dd>\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>timestep</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>max_error <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>maximum error of implicit update equaiton</dd>\n</dl>\n",
              "signature": "(t, dt)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time"
                },
                {
                  "name": "dt",
                  "type": null,
                  "default": null,
                  "description": "timestep"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "step",
              "description": "Explicit component of timestep for internal blocks",
              "docstring_html": "<p>Explicit component of timestep for internal blocks\nincluding error propagation.</p>\n<p><strong>Notes</strong></p>\n<p>This is pretty much an exact copy of the '_step' method\nfrom the 'Simulation' class.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time</dd>\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>timestep</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>success <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>indicator if the timestep was successful</dd>\n<dt>max_error <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>maximum local truncation error from integration</dd>\n<dt>scale <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>rescale factor for timestep</dd>\n</dl>\n",
              "signature": "(t, dt)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time"
                },
                {
                  "name": "dt",
                  "type": null,
                  "default": null,
                  "description": "timestep"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "set_solver",
              "description": "Initialize all blocks with solver for numerical integration",
              "docstring_html": "<p>Initialize all blocks with solver for numerical integration\nand additional args for the solver such as tolerances, etc.</p>\n<p>If blocks already have solvers, change the numerical integrator\nto the 'Solver' class.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>Solver <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">Solver</span></dt>\n<dd>numerical solver definition</dd>\n<dt>parent <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">Solver</span></dt>\n<dd>numerical solver instance as parent</dd>\n<dt>solver_args <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">dict</span></dt>\n<dd>args to initialize solver with</dd>\n</dl>\n",
              "signature": "(Solver, parent, solver_args = {})",
              "parameters": [
                {
                  "name": "Solver",
                  "type": null,
                  "default": null,
                  "description": "numerical solver definition"
                },
                {
                  "name": "parent",
                  "type": null,
                  "default": null,
                  "description": "numerical solver instance as parent"
                },
                {
                  "name": "solver_args",
                  "type": null,
                  "default": "{}",
                  "description": "args to initialize solver with"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "revert",
              "description": "revert the internal blocks to the state",
              "docstring_html": "<p>revert the internal blocks to the state\nof the previous timestep</p>\n",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "buffer",
              "description": "buffer internal states of blocks with",
              "docstring_html": "<p>buffer internal states of blocks with\ninternal integration engines</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time for buffering</dd>\n</dl>\n",
              "signature": "(dt)",
              "parameters": [
                {
                  "name": "dt",
                  "type": null,
                  "default": null,
                  "description": "evaluation time for buffering"
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "engine",
              "description": "",
              "type": null,
              "value": "None"
            },
            {
              "name": "tolerance_fpi",
              "description": "",
              "type": null,
              "value": "tolerance_fpi"
            },
            {
              "name": "iterations_max",
              "description": "",
              "type": null,
              "value": "iterations_max"
            },
            {
              "name": "op_alg",
              "description": "",
              "type": null,
              "value": "None"
            },
            {
              "name": "op_dyn",
              "description": "",
              "type": null,
              "value": "None"
            },
            {
              "name": "graph",
              "description": "",
              "type": null,
              "value": "None"
            },
            {
              "name": "boosters",
              "description": "",
              "type": null,
              "value": "None"
            },
            {
              "name": "connections",
              "description": "",
              "type": null,
              "value": "set()"
            },
            {
              "name": "blocks",
              "description": "",
              "type": null,
              "value": "set()"
            },
            {
              "name": "interface",
              "description": "",
              "type": null,
              "value": "None"
            },
            {
              "name": "size",
              "description": "Get size information from subsystem, recursively assembled",
              "type": null,
              "value": null
            },
            {
              "name": "events",
              "description": "Recursively collect and return events spawned by the",
              "type": null,
              "value": null
            },
            {
              "name": "inputs",
              "description": "",
              "type": null,
              "value": null
            },
            {
              "name": "outputs",
              "description": "",
              "type": null,
              "value": null
            }
          ],
          "parameters": [
            {
              "name": "blocks",
              "type": null,
              "default": "None",
              "description": "internal blocks of the subsystem"
            },
            {
              "name": "connections",
              "type": null,
              "default": "None",
              "description": "internal connections of the subsystem"
            },
            {
              "name": "events",
              "type": null,
              "default": "None",
              "description": ""
            },
            {
              "name": "tolerance_fpi",
              "type": null,
              "default": "SIM_TOLERANCE_FPI",
              "description": "absolute tolerance for convergence of algebraic loops default see ´SIM_TOLERANCE_FPI´ in ´_constants.py´"
            },
            {
              "name": "iterations_max",
              "type": null,
              "default": "SIM_ITERATIONS_MAX",
              "description": "maximum allowed number of iterations for algebraic loop solver, default see ´SIM_ITERATIONS_MAX´ in ´_constants.py´"
            }
          ]
        },
        {
          "name": "Interface",
          "description": "Bare-bone block that serves as a data interface for the 'Subsystem' class.",
          "docstring_html": "<p>Bare-bone block that serves as a data interface for the 'Subsystem' class.</p>\n<p>It works like this:</p>\n<ul class=\"simple\">\n<li>Internal blocks of the subsystem are connected to the inputs and outputs\nof this Interface block via the internal connections.</li>\n<li>It behaves like a normal block (inherits the main 'Block' class methods).</li>\n<li>It implements some special methods to get and set the inputs and outputs\nof the blocks, that are used to translate between the internal blocks of the\nsubsystem and the inputs and outputs of the subsystem.</li>\n<li>Handles data transfer to and from the internal subsystem blocks\nto and from the inputs and outputs of the subsystem.</li>\n</ul>\n",
          "bases": [
            "Block"
          ],
          "methods": [
            {
              "name": "register_port_map",
              "description": "Update the input and output registers of the interface block with port mappings",
              "docstring_html": "<p>Update the input and output registers of the interface block with port mappings</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>port_map_in <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">dict[str: int]</span></dt>\n<dd>port alias mapping for block inputs</dd>\n<dt>port_map_out <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">dict[str: int]</span></dt>\n<dd>port alias mapping for block outputs</dd>\n</dl>\n",
              "signature": "(port_map_in, port_map_out)",
              "parameters": [
                {
                  "name": "port_map_in",
                  "type": null,
                  "default": null,
                  "description": "port alias mapping for block inputs"
                },
                {
                  "name": "port_map_out",
                  "type": null,
                  "default": null,
                  "description": "port alias mapping for block outputs"
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [],
          "parameters": []
        },
        {
          "name": "LoggerManager",
          "description": "Singleton class for centralized logging configuration in PathSim.",
          "docstring_html": "<p>Singleton class for centralized logging configuration in PathSim.</p>\n<p>Provides a unified interface for creating and configuring loggers throughout\nthe PathSim package. All loggers follow a hierarchical naming scheme under\nthe 'pathsim' root logger, allowing fine-grained control over logging levels\nand output destinations.</p>\n<p>The singleton pattern ensures that logging configuration is consistent across\nthe entire application, with all modules sharing the same handler setup and\nformatting rules.</p>\n<p><strong>Examples</strong></p>\n<pre class=\"code python literal-block\">\n# Create and configure logging in one step\nfrom pathsim.utils.logger import LoggerManager\n\nmgr = LoggerManager(\n    enabled=True,\n    output=&quot;simulation.log&quot;,  # File path or None for stdout\n    level=logging.INFO\n)\n\n# Get a logger for a specific module\nlogger = mgr.get_logger(&quot;simulation&quot;)\nlogger.info(&quot;Simulation started&quot;)\n\n# Set different log levels for different modules\nmgr.set_level(logging.DEBUG, &quot;progress&quot;)\nmgr.set_level(logging.WARNING, &quot;analysis&quot;)\n\n# Reconfigure later if needed\nmgr.configure(enabled=False)  # Disable logging\n</pre>\n<p><strong>Notes</strong></p>\n<p>The LoggerManager uses a hierarchical logger structure:</p>\n<ul>\n<li><p class=\"first\">pathsim (root)\n- pathsim.simulation\n- pathsim.progress</p>\n<blockquote>\n<ul class=\"simple\">\n<li>pathsim.progress.TRANSIENT</li>\n<li>pathsim.progress.STEADYSTATE</li>\n</ul>\n</blockquote>\n<ul class=\"simple\">\n<li>pathsim.analysis\n- pathsim.analysis.timer\n- pathsim.analysis.profiler</li>\n</ul>\n</li>\n</ul>\n<p>This hierarchy allows you to control logging at different granularities:\nset the level on 'pathsim' to affect all loggers, or set it on\n'pathsim.progress' to affect only progress tracking loggers.</p>\n",
          "bases": [],
          "methods": [
            {
              "name": "__new__",
              "description": "Ensure only one instance exists (singleton pattern).",
              "docstring_html": "<p>Ensure only one instance exists (singleton pattern).</p>\n",
              "signature": "(cls, enabled = False, output = None, level = logging.INFO, format = None, date_format = '%H:%M:%S')",
              "parameters": [
                {
                  "name": "cls",
                  "type": null,
                  "default": null,
                  "description": ""
                },
                {
                  "name": "enabled",
                  "type": null,
                  "default": "False",
                  "description": ""
                },
                {
                  "name": "output",
                  "type": null,
                  "default": "None",
                  "description": ""
                },
                {
                  "name": "level",
                  "type": null,
                  "default": "logging.INFO",
                  "description": ""
                },
                {
                  "name": "format",
                  "type": null,
                  "default": "None",
                  "description": ""
                },
                {
                  "name": "date_format",
                  "type": null,
                  "default": "'%H:%M:%S'",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "__init__",
              "description": "Initialize the logger manager and setup root logger.",
              "docstring_html": "<p>Initialize the logger manager and setup root logger.</p>\n<p>Configuration is applied immediately on first instantiation if enabled=True.\nSubsequent instantiations return the existing singleton (parameters ignored).\nUse configure() to change settings after initialization.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>enabled <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool, optional</span></dt>\n<dd>Whether logging is enabled. Defaults to False.</dd>\n<dt>output <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">str or None, optional</span></dt>\n<dd>Output destination. If string, logs to file. If None, logs to stdout.\nDefaults to None.</dd>\n<dt>level <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int, optional</span></dt>\n<dd>Logging level. Defaults to logging.INFO.</dd>\n<dt>format <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">str or None, optional</span></dt>\n<dd>Log message format. Defaults to &quot;%(asctime)s - %(levelname)s - %(message)s&quot;.</dd>\n<dt>date_format <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">str or None, optional</span></dt>\n<dd>Date format for timestamps. Defaults to '%H:%M:%S'.</dd>\n</dl>\n",
              "signature": "(enabled = False, output = None, level = logging.INFO, format = None, date_format = '%H:%M:%S')",
              "parameters": [
                {
                  "name": "enabled",
                  "type": null,
                  "default": "False",
                  "description": "Whether logging is enabled. Defaults to False."
                },
                {
                  "name": "output",
                  "type": null,
                  "default": "None",
                  "description": "Output destination. If string, logs to file. If None, logs to stdout. Defaults to None."
                },
                {
                  "name": "level",
                  "type": null,
                  "default": "logging.INFO",
                  "description": "Logging level. Defaults to logging.INFO."
                },
                {
                  "name": "format",
                  "type": null,
                  "default": "None",
                  "description": "Log message format. Defaults to \"%(asctime)s - %(levelname)s - %(message)s\"."
                },
                {
                  "name": "date_format",
                  "type": null,
                  "default": "'%H:%M:%S'",
                  "description": "Date format for timestamps. Defaults to '%H:%M:%S'."
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "configure",
              "description": "Configure the root PathSim logger and all child loggers.",
              "docstring_html": "<p>Configure the root PathSim logger and all child loggers.</p>\n<p>This method sets up the logging system with the specified parameters.\nAll loggers created via get_logger() will inherit this configuration.\nCan be called multiple times to reconfigure logging.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>enabled <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool, optional</span></dt>\n<dd>Whether logging is enabled. If False, all logging is disabled.\nDefaults to True.</dd>\n<dt>output <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">str or None, optional</span></dt>\n<dd>Output destination for logs. If a string, interpreted as a file path\nand logs are written to that file. If None, logs are written to stdout.\nDefaults to None (stdout).</dd>\n<dt>level <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int, optional</span></dt>\n<dd>Logging level (e.g., logging.DEBUG, logging.INFO, logging.WARNING).\nDefaults to logging.INFO.</dd>\n<dt>format <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">str or None, optional</span></dt>\n<dd>Log message format string. If None, uses default format.\nDefaults to &quot;%(asctime)s - %(levelname)s - %(message)s&quot;.</dd>\n<dt>date_format <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">str or None, optional</span></dt>\n<dd>Date format string for timestamps (e.g., '%H:%M:%S').\nIf None, uses default format. Defaults to None.</dd>\n</dl>\n<p><strong>Examples</strong></p>\n<pre class=\"code python literal-block\">\nmgr = LoggerManager()\n\n# Log to stdout with INFO level\nmgr.configure(enabled=True)\n\n# Log to file with DEBUG level\nmgr.configure(enabled=True, output=&quot;debug.log&quot;, level=logging.DEBUG)\n\n# Disable all logging\nmgr.configure(enabled=False)\n\n# Custom format with time only\nmgr.configure(\n    enabled=True,\n    format=&quot;%(asctime)s - %(message)s&quot;,\n    date_format='%H:%M:%S'\n)\n</pre>\n",
              "signature": "(enabled = True, output = None, level = logging.INFO, format = None, date_format = None)",
              "parameters": [
                {
                  "name": "enabled",
                  "type": null,
                  "default": "True",
                  "description": "Whether logging is enabled. If False, all logging is disabled. Defaults to True."
                },
                {
                  "name": "output",
                  "type": null,
                  "default": "None",
                  "description": "Output destination for logs. If a string, interpreted as a file path and logs are written to that file. If None, logs are written to stdout. Defaults to None (stdout)."
                },
                {
                  "name": "level",
                  "type": null,
                  "default": "logging.INFO",
                  "description": "Logging level (e.g., logging.DEBUG, logging.INFO, logging.WARNING). Defaults to logging.INFO."
                },
                {
                  "name": "format",
                  "type": null,
                  "default": "None",
                  "description": "Log message format string. If None, uses default format. Defaults to \"%(asctime)s - %(levelname)s - %(message)s\"."
                },
                {
                  "name": "date_format",
                  "type": null,
                  "default": "None",
                  "description": "Date format string for timestamps (e.g., '%H:%M:%S'). If None, uses default format. Defaults to None."
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "get_logger",
              "description": "Get or create a logger with PathSim hierarchy.",
              "docstring_html": "<p>Get or create a logger with PathSim hierarchy.</p>\n<p>Returns a logger under the 'pathsim' namespace. The logger inherits\nconfiguration from the root logger but can be individually configured\nvia set_level().</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>name <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">str</span></dt>\n<dd>Name of the logger, will be prefixed with 'pathsim.' to create\nhierarchical logger (e.g., 'simulation' -&gt; 'pathsim.simulation').</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>logging.Logger</dt>\n<dd>Logger instance with the specified name under pathsim hierarchy.</dd>\n</dl>\n<p><strong>Examples</strong></p>\n<pre class=\"code python literal-block\">\nmgr = LoggerManager()\nmgr.configure(enabled=True)\n\n# Get logger for simulation module\nsim_logger = mgr.get_logger(&quot;simulation&quot;)\nsim_logger.info(&quot;Starting simulation&quot;)\n\n# Get logger for progress tracking\nprogress_logger = mgr.get_logger(&quot;progress.TRANSIENT&quot;)\nprogress_logger.debug(&quot;Progress update&quot;)\n</pre>\n",
              "signature": "(name)",
              "parameters": [
                {
                  "name": "name",
                  "type": null,
                  "default": null,
                  "description": "Name of the logger, will be prefixed with 'pathsim.' to create hierarchical logger (e.g., 'simulation' -> 'pathsim.simulation')."
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "set_level",
              "description": "Set logging level globally or for a specific module.",
              "docstring_html": "<p>Set logging level globally or for a specific module.</p>\n<p>Allows fine-grained control over logging verbosity. Can set the level\nfor all loggers (when module=None) or for a specific logger in the\nhierarchy.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>level <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>Logging level (e.g., logging.DEBUG, logging.INFO, logging.WARNING,\nlogging.ERROR, logging.CRITICAL).</dd>\n<dt>module <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">str or None, optional</span></dt>\n<dd>Module name to set level for (e.g., 'progress', 'analysis.timer').\nIf None, sets level for the root pathsim logger, affecting all\nchild loggers that don't have their own level set. Defaults to None.</dd>\n</dl>\n<p><strong>Examples</strong></p>\n<pre class=\"code python literal-block\">\nmgr = LoggerManager()\nmgr.configure(enabled=True)\n\n# Set global level to INFO\nmgr.set_level(logging.INFO)\n\n# Set debug level for progress tracking only\nmgr.set_level(logging.DEBUG, &quot;progress&quot;)\n\n# Quiet analysis logs\nmgr.set_level(logging.WARNING, &quot;analysis&quot;)\n</pre>\n",
              "signature": "(level, module = None)",
              "parameters": [
                {
                  "name": "level",
                  "type": null,
                  "default": null,
                  "description": "Logging level (e.g., logging.DEBUG, logging.INFO, logging.WARNING, logging.ERROR, logging.CRITICAL)."
                },
                {
                  "name": "module",
                  "type": null,
                  "default": "None",
                  "description": "Module name to set level for (e.g., 'progress', 'analysis.timer'). If None, sets level for the root pathsim logger, affecting all child loggers that don't have their own level set. Defaults to None."
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "is_enabled",
              "description": "Check if logging is currently enabled.",
              "docstring_html": "<p>Check if logging is currently enabled.</p>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>bool</dt>\n<dd>True if logging is enabled, False otherwise.</dd>\n</dl>\n",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "get_effective_level",
              "description": "Get the effective logging level.",
              "docstring_html": "<p>Get the effective logging level.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>module <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">str or None, optional</span></dt>\n<dd>Module name to check level for. If None, returns root logger level.\nDefaults to None.</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>int</dt>\n<dd>The effective logging level (e.g., logging.INFO).</dd>\n</dl>\n",
              "signature": "(module = None)",
              "parameters": [
                {
                  "name": "module",
                  "type": null,
                  "default": "None",
                  "description": "Module name to check level for. If None, returns root logger level. Defaults to None."
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [],
          "parameters": [
            {
              "name": "enabled",
              "type": null,
              "default": "False",
              "description": "Whether logging is enabled. Defaults to False."
            },
            {
              "name": "output",
              "type": null,
              "default": "None",
              "description": "Output destination. If string, logs to file. If None, logs to stdout. Defaults to None."
            },
            {
              "name": "level",
              "type": null,
              "default": "logging.INFO",
              "description": "Logging level. Defaults to logging.INFO."
            },
            {
              "name": "format",
              "type": null,
              "default": "None",
              "description": "Log message format. Defaults to \"%(asctime)s - %(levelname)s - %(message)s\"."
            },
            {
              "name": "date_format",
              "type": null,
              "default": "'%H:%M:%S'",
              "description": "Date format for timestamps. Defaults to '%H:%M:%S'."
            }
          ]
        }
      ],
      "functions": [],
      "submodules": [
        "connection",
        "simulation",
        "subsystem",
        "blocks",
        "events",
        "optim",
        "solvers",
        "utils"
      ]
    },
    "pathsim.blocks": {
      "name": "pathsim.blocks",
      "description": "",
      "docstring_html": "",
      "classes": [
        {
          "name": "Block",
          "description": "Base 'Block' object that defines the inputs, outputs and the connect method.",
          "docstring_html": "<p>Base 'Block' object that defines the inputs, outputs and the connect method.</p>\n<p>Block interconnections are handeled via the io interface of the blocks.\nIt is realized by dicts for the 'inputs' and for the 'outputs', where the\nkey of the dict is the input/output channel and the corresponding value is\nthe input/output value.</p>\n<p>The block can spawn discrete events that are handled by the main simulation\nfor triggers, discrete time blocks, etc.</p>\n<p>Mathematically the block behavior is defined by two operators in most cases</p>\n<pre class=\"math\">\n\\begin{eqnarray}\n\\dot{x} &amp;= f_\\mathrm{dyn}(x, u, t)\\\\\n       y &amp;= f_\\mathrm{alg}(x, u, t)\n\\end{eqnarray}\n</pre>\n<p>they are algebraic operators for the algebraic path of the block and for the\ndynamic path that feeds into the internal numerical integration engine.</p>\n<p>There are special cases where one or both of them are not defined, also for\npurely algebraic blocks such as multipliers and functions, there exists a\nsimplified operator definition:</p>\n<div>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\">\n  <mi>y</mi>\n  <mo>=</mo>\n  <msub>\n    <mi>f</mi>\n    <mi>alg</mi>\n  </msub>\n  <mo stretchy=\"false\">(</mo>\n  <mi>u</mi>\n  <mo stretchy=\"false\">)</mo>\n</math>\n</div>\n<div class=\"section\" id=\"note\">\n<h4>Note</h4>\n<p>This block is not intended to be used directly and serves as a base\nclass definition for other blocks to be inherited.</p>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>inputs <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">Register</span></dt>\n<dd>input value register of block</dd>\n<dt>outputs <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">Register</span></dt>\n<dd>output value register of block</dd>\n<dt>engine <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">None | Solver</span></dt>\n<dd>numerical integrator instance</dd>\n<dt>events <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">list[Event]</span></dt>\n<dd>list of internal events, for mixed signal blocks</dd>\n<dt>_active <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>flag that sets the block active or inactive</dd>\n<dt>op_alg <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">Operator | DynamicOperator | None</span></dt>\n<dd>internal callable operator for algebraic components of block</dd>\n<dt>op_dyn <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">DynamicOperator | None</span></dt>\n<dd>internal callable operator for dynamic (ODE) components of block</dd>\n</dl>\n</div>\n",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "info",
              "description": "Get block metadata for introspection and UI integration.",
              "docstring_html": "<p>Get block metadata for introspection and UI integration.</p>\n<p>Returns a dictionary containing block type information, port mappings,\nand parameter definitions. Results are cached per class.</p>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>info <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">dict</span></dt>\n<dd><p class=\"first\">Block metadata with the following keys:\n- type : str</p>\n<blockquote>\nClass name of the block</blockquote>\n<ul class=\"last simple\">\n<li><dl class=\"first docutils\">\n<dt>description <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">str</span></dt>\n<dd>Block docstring</dd>\n</dl>\n</li>\n<li><dl class=\"first docutils\">\n<dt>shape <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">tuple</span></dt>\n<dd>Input/output shape (n_inputs, n_outputs)</dd>\n</dl>\n</li>\n<li><dl class=\"first docutils\">\n<dt>size <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>State vector size</dd>\n</dl>\n</li>\n<li><dl class=\"first docutils\">\n<dt>in_labels <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">dict</span></dt>\n<dd>Input port name to index mapping</dd>\n</dl>\n</li>\n<li><dl class=\"first docutils\">\n<dt>out_labels <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">dict</span></dt>\n<dd>Output port name to index mapping</dd>\n</dl>\n</li>\n<li><dl class=\"first docutils\">\n<dt>parameters <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">dict</span></dt>\n<dd>Parameter names mapped to their default values</dd>\n</dl>\n</li>\n</ul>\n</dd>\n</dl>\n",
              "signature": "(cls)",
              "parameters": [
                {
                  "name": "cls",
                  "type": null,
                  "default": null,
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "classmethod"
            },
            {
              "name": "plot",
              "description": "Block specific visualization, enables plotting",
              "docstring_html": "<p>Block specific visualization, enables plotting\naccess from the simulation level.</p>\n<p>This gets primarily used by the visualization blocks\nsuch as the 'Scope' and 'Spectrum'.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>args <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">tuple</span></dt>\n<dd>args for the plot methods</dd>\n<dt>kwargs <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">dict</span></dt>\n<dd>kwargs for the plot method</dd>\n</dl>\n",
              "signature": "(args = (), kwargs = {})",
              "parameters": [
                {
                  "name": "args",
                  "type": null,
                  "default": "()",
                  "description": "args for the plot methods"
                },
                {
                  "name": "kwargs",
                  "type": null,
                  "default": "{}",
                  "description": "kwargs for the plot method"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "on",
              "description": "Activate the block and all internal events, sets the boolean",
              "docstring_html": "<p>Activate the block and all internal events, sets the boolean\nevaluation flag to 'True'.</p>\n",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "off",
              "description": "Deactivate the block and all internal events, sets the boolean",
              "docstring_html": "<p>Deactivate the block and all internal events, sets the boolean\nevaluation flag to 'False'. Also resets the block.</p>\n",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "reset",
              "description": "Reset the blocks inputs and outputs and also its internal solver,",
              "docstring_html": "<p>Reset the blocks inputs and outputs and also its internal solver,\nif the block has a solver instance.</p>\n",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "linearize",
              "description": "Linearize the algebraic and dynamic components of the block.",
              "docstring_html": "<p>Linearize the algebraic and dynamic components of the block.</p>\n<p>This is done by linearizing the internal 'Operator' and 'DynamicOperator'\ninstances in the current system operating point. The operators create\n1st order taylor approximations internally and use them on subsequent\ncalls after linarization.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time</dd>\n</dl>\n",
              "signature": "(t)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "delinearize",
              "description": "Revert the linearization of the blocks algebraic and dynamic components.",
              "docstring_html": "<p>Revert the linearization of the blocks algebraic and dynamic components.</p>\n<p>This is resets the internal 'Operator' and 'DynamicOperator' instances,\ndeleting the linear surrogate model and using the original function for\nsubsequent calls.</p>\n",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "set_solver",
              "description": "Initialize the numerical integration engine with local truncation error",
              "docstring_html": "<p>Initialize the numerical integration engine with local truncation error\ntolerance if required.</p>\n<p>If the block already has an integration engine, it is changed.\nIf the block does not have an 'initial_value' attribute, this method\ndoes nothing (block is not dynamic).</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>Solver <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">Solver</span></dt>\n<dd>numerical integrator class</dd>\n<dt>parent <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">None | Solver</span></dt>\n<dd>numerical integrator instance for stage synchronization</dd>\n<dt>solver_args <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">dict</span></dt>\n<dd>additional args for the solver</dd>\n</dl>\n",
              "signature": "(Solver, parent, solver_args = {})",
              "parameters": [
                {
                  "name": "Solver",
                  "type": null,
                  "default": null,
                  "description": "numerical integrator class"
                },
                {
                  "name": "parent",
                  "type": null,
                  "default": null,
                  "description": "numerical integrator instance for stage synchronization"
                },
                {
                  "name": "solver_args",
                  "type": null,
                  "default": "{}",
                  "description": "additional args for the solver"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "revert",
              "description": "Revert the block to the state of the previous timestep, if the",
              "docstring_html": "<p>Revert the block to the state of the previous timestep, if the\nblock has a solver instance indicated by the 'has_engine' flag.</p>\n<p>This is required for adaptive solvers to revert the state to the\nprevious timestep.</p>\n",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "buffer",
              "description": "Buffer current internal state of the block and the current timestep",
              "docstring_html": "<p>Buffer current internal state of the block and the current timestep\nif the block has a solver instance (is stateful).</p>\n<p>This is required for multistage, multistep and adaptive integrators.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>integration timestep</dd>\n</dl>\n",
              "signature": "(dt)",
              "parameters": [
                {
                  "name": "dt",
                  "type": null,
                  "default": null,
                  "description": "integration timestep"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "sample",
              "description": "Samples the data of the blocks inputs or internal state when called.",
              "docstring_html": "<p>Samples the data of the blocks inputs or internal state when called.</p>\n<p>This can record block parameters after a succesful timestep such as\nfor the 'Scope' and 'Delay' blocks but also for sampling from a random\ndistribution in the 'RNG' and the noise blocks.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time for sampling</dd>\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>integration timestep</dd>\n</dl>\n",
              "signature": "(t, dt)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time for sampling"
                },
                {
                  "name": "dt",
                  "type": null,
                  "default": null,
                  "description": "integration timestep"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "read",
              "description": "Read data from recording blocks.",
              "docstring_html": "<p>Read data from recording blocks.</p>\n<div class=\"section\" id=\"note\">\n<h4>Note</h4>\n<p>Not implemented by default, special recording blocks\nimplement this method.</p>\n</div>\n",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "collect",
              "description": "Yield (category, id, data) tuples for recording blocks to simplify",
              "docstring_html": "<p>Yield (category, id, data) tuples for recording blocks to simplify\nglobal data collection from all recording blocks.</p>\n<div class=\"section\" id=\"note\">\n<h4>Note</h4>\n<p>Yields an empty generator by default, needs to be implemented by\nspecial recording blocks.</p>\n</div>\n",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "get_all",
              "description": "Retrieves and returns internal states of engine (if available)",
              "docstring_html": "<p>Retrieves and returns internal states of engine (if available)\nand the block inputs and outputs as arrays for use outside.</p>\n<p>Either for monitoring, postprocessing or event detection.\nIn any case this enables easy access to the current block state.</p>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>inputs <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array</span></dt>\n<dd>block input register</dd>\n<dt>outputs <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array</span></dt>\n<dd>block output register</dd>\n<dt>states <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array</span></dt>\n<dd>internal states of the block</dd>\n</dl>\n",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "update",
              "description": "The 'update' method is called iteratively for all blocks to evaluate the",
              "docstring_html": "<p>The 'update' method is called iteratively for all blocks to evaluate the\nalgebraic components of the global system ode from the DAG.</p>\n<p>It is meant for instant time blocks (blocks that dont have a delay due to the\ntimestep, such as Amplifier, etc.) and updates the 'outputs' of the block\ndirectly based on the 'inputs' and possibly internal states.</p>\n<div class=\"section\" id=\"note\">\n<h4>Note</h4>\n<p>The implementation of the 'update' method in the base 'Block' class is intended\nas a fallback and is not performance optimized. Special blocks might reimplement\nthis method differently for higher performance, for example SISO or MISO blocks.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time</dd>\n</dl>\n</div>\n",
              "signature": "(t)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "solve",
              "description": "The 'solve' method performs one iterative solution step that is required",
              "docstring_html": "<p>The 'solve' method performs one iterative solution step that is required\nto solve the implicit update equation of the solver if an implicit solver\n(numerical integrator) is used.</p>\n<p>It returns the relative difference between the new updated solution\nand the previous iteration of the solution to track convergence within\nan outer loop.</p>\n<p>This only has to be implemented by blocks that have an internal\nintegration engine with an implicit solver.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time</dd>\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>integration timestep</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>error <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>solver residual norm</dd>\n</dl>\n",
              "signature": "(t, dt)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time"
                },
                {
                  "name": "dt",
                  "type": null,
                  "default": null,
                  "description": "integration timestep"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "step",
              "description": "The 'step' method is used in transient simulations and performs an action",
              "docstring_html": "<p>The 'step' method is used in transient simulations and performs an action\n(numeric integration timestep, recording data, etc.) based on the current\ninputs and the current internal state.</p>\n<p>It performs one timestep for the internal states. For instant time blocks,\nthe 'step' method does not has to be implemented specifically.</p>\n<p>The method handles timestepping for dynamic blocks with internal states\nsuch as 'Integrator', 'StateSpace', etc.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time</dd>\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>integration timestep</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>success <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>step was successful</dd>\n<dt>error <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>local truncation error from adaptive integrators</dd>\n<dt>scale <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float | None</span></dt>\n<dd>timestep rescale from adaptive integrators, None if no rescale needed</dd>\n</dl>\n",
              "signature": "(t, dt)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time"
                },
                {
                  "name": "dt",
                  "type": null,
                  "default": null,
                  "description": "integration timestep"
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "input_port_labels",
              "description": "",
              "type": null,
              "value": "None"
            },
            {
              "name": "output_port_labels",
              "description": "",
              "type": null,
              "value": "None"
            },
            {
              "name": "inputs",
              "description": "",
              "type": null,
              "value": "Register(mapping=(self.input_port_labels and self.input_port_labels.copy()))"
            },
            {
              "name": "outputs",
              "description": "",
              "type": null,
              "value": "Register(mapping=(self.output_port_labels and self.output_port_labels.copy()))"
            },
            {
              "name": "engine",
              "description": "",
              "type": null,
              "value": "None"
            },
            {
              "name": "events",
              "description": "",
              "type": null,
              "value": "[]"
            },
            {
              "name": "op_alg",
              "description": "",
              "type": null,
              "value": "None"
            },
            {
              "name": "op_dyn",
              "description": "",
              "type": null,
              "value": "None"
            },
            {
              "name": "size",
              "description": "Get size information from block, such as",
              "type": null,
              "value": null
            },
            {
              "name": "shape",
              "description": "Get the number of input and output ports of the block",
              "type": null,
              "value": null
            }
          ],
          "parameters": []
        },
        {
          "name": "DynamicOperator",
          "description": "Operator class for dynamic system function evaluation and linearization.",
          "docstring_html": "<p>Operator class for dynamic system function evaluation and linearization.</p>\n<p>This class wraps a dynamic system function with signature f(x, u, t) to provide\nboth direct evaluation and linear approximation capabilities. When linearized\naround operating points (x0, u0), subsequent calls use the first-order Taylor\napproximation</p>\n<div>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\">\n  <mi>f</mi>\n  <mo stretchy=\"false\">(</mo>\n  <mi>x</mi>\n  <mo>,</mo>\n  <mi>u</mi>\n  <mo>,</mo>\n  <mi>t</mi>\n  <mo stretchy=\"false\">)</mo>\n  <mo>≈</mo>\n  <mi>f</mi>\n  <mo stretchy=\"false\">(</mo>\n  <msub>\n    <mi>x</mi>\n    <mn>0</mn>\n  </msub>\n  <mo>,</mo>\n  <msub>\n    <mi>u</mi>\n    <mn>0</mn>\n  </msub>\n  <mo>,</mo>\n  <mi>t</mi>\n  <mo stretchy=\"false\">)</mo>\n  <mo>+</mo>\n  <msub>\n    <mi>J</mi>\n    <mi>x</mi>\n  </msub>\n  <mo stretchy=\"false\">(</mo>\n  <msub>\n    <mi>x</mi>\n    <mn>0</mn>\n  </msub>\n  <mo>,</mo>\n  <msub>\n    <mi>u</mi>\n    <mn>0</mn>\n  </msub>\n  <mo>,</mo>\n  <mi>t</mi>\n  <mo stretchy=\"false\">)</mo>\n  <mo stretchy=\"false\">(</mo>\n  <mi>x</mi>\n  <mo>−</mo>\n  <msub>\n    <mi>x</mi>\n    <mn>0</mn>\n  </msub>\n  <mo stretchy=\"false\">)</mo>\n  <mo>+</mo>\n  <msub>\n    <mi>J</mi>\n    <mi>u</mi>\n  </msub>\n  <mo stretchy=\"false\">(</mo>\n  <msub>\n    <mi>x</mi>\n    <mn>0</mn>\n  </msub>\n  <mo>,</mo>\n  <msub>\n    <mi>u</mi>\n    <mn>0</mn>\n  </msub>\n  <mo>,</mo>\n  <mi>t</mi>\n  <mo stretchy=\"false\">)</mo>\n  <mo stretchy=\"false\">(</mo>\n  <mi>u</mi>\n  <mo>−</mo>\n  <msub>\n    <mi>u</mi>\n    <mn>0</mn>\n  </msub>\n  <mo stretchy=\"false\">)</mo>\n</math>\n</div>\n<p>instead of evaluating the function.</p>\n<p>The class supports multiple methods for Jacobian computation: user-provided analytical\nJacobians, automatic differentiation via the Value class, and numerical differentiation\nas a fallback.</p>\n<div class=\"section\" id=\"example\">\n<h4>Example</h4>\n<p>Basic usage with automatic differentiation:</p>\n<pre class=\"code python literal-block\">\ndef system(x, u, t):\n    return -0.5*x + 2*u\n\nop = Operator(system)\n\n# Direct function evaluation\ny1 = op(x=1.0, u=0.5, t=0.0)\n\n# Linearize at current point\nop.linearize(x=1.0, u=0.5, t=0.0)\n\n# Use linear approximation\ny2 = op(x=1.1, u=0.6, t=0.1)\n</pre>\n<p>With user-provided Jacobians:</p>\n<pre class=\"code python literal-block\">\ndef system(x, u, t):\n    return -0.5*x + 2*u\n\ndef jac_x(x, u, t):\n    return -0.5\n\ndef jac_u(x, u, t):\n    return 2.0\n\nop = Operator(system, jac_x=jac_x, jac_u=jac_u)\n\nop.linearize(x=1.0, u=0.5, t=0.0)\n</pre>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>func <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">callable</span></dt>\n<dd>The function to wrap with signature func(x, u, t)</dd>\n<dt>jac_x <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">callable, optional</span></dt>\n<dd>Optional analytical Jacobian with respect to x. If None, automatic or\nnumerical differentiation will be used.</dd>\n<dt>jac_u <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">callable, optional</span></dt>\n<dd>Optional analytical Jacobian with respect to u. If None, automatic or\nnumerical differentiation will be used.</dd>\n</dl>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>f0 <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array_like</span></dt>\n<dd>Function evaluation at operating point</dd>\n<dt>x0 <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array_like</span></dt>\n<dd>State operating point</dd>\n<dt>u0 <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array_like</span></dt>\n<dd>Input operating point</dd>\n<dt>Jx <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array_like</span></dt>\n<dd>Jacobian matrix with respect to x at operating point</dd>\n<dt>Ju <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array_like</span></dt>\n<dd>Jacobian matrix with respect to u at operating point</dd>\n</dl>\n</div>\n",
          "bases": [
            "object"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "signature": "(func, jac_x = None, jac_u = None)",
              "parameters": [
                {
                  "name": "func",
                  "type": null,
                  "default": null,
                  "description": ""
                },
                {
                  "name": "jac_x",
                  "type": null,
                  "default": "None",
                  "description": ""
                },
                {
                  "name": "jac_u",
                  "type": null,
                  "default": "None",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "jac_x",
              "description": "Compute the Jacobian matrix with respect to x.",
              "docstring_html": "<p>Compute the Jacobian matrix with respect to x.</p>\n<p>Uses the following methods in order of preference:\n1. User-provided analytical Jacobian if available\n2. Automatic differentiation via Value class\n3. Numerical differentiation as fallback</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>x <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array_like</span></dt>\n<dd>State vector</dd>\n<dt>u <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array_like</span></dt>\n<dd>Input vector</dd>\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>Time</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>jacobian <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">ndarray</span></dt>\n<dd>Jacobian matrix with respect to x</dd>\n</dl>\n",
              "signature": "(x, u, t)",
              "parameters": [
                {
                  "name": "x",
                  "type": null,
                  "default": null,
                  "description": "State vector"
                },
                {
                  "name": "u",
                  "type": null,
                  "default": null,
                  "description": "Input vector"
                },
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "Time Returns -------"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "jac_u",
              "description": "Compute the Jacobian matrix with respect to u.",
              "docstring_html": "<p>Compute the Jacobian matrix with respect to u.</p>\n<p>Uses the following methods in order of preference:\n1. User-provided analytical Jacobian if available\n2. Automatic differentiation via Value class\n3. Numerical differentiation as fallback</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>x <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array_like</span></dt>\n<dd>State vector</dd>\n<dt>u <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array_like</span></dt>\n<dd>Input vector</dd>\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>Time</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>jacobian <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">ndarray</span></dt>\n<dd>Jacobian matrix with respect to u</dd>\n</dl>\n",
              "signature": "(x, u, t)",
              "parameters": [
                {
                  "name": "x",
                  "type": null,
                  "default": null,
                  "description": "State vector"
                },
                {
                  "name": "u",
                  "type": null,
                  "default": null,
                  "description": "Input vector"
                },
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "Time Returns -------"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "linearize",
              "description": "Linearize the function at point (x, u, t).",
              "docstring_html": "<p>Linearize the function at point (x, u, t).</p>\n<p>Computes and stores the function value and Jacobians at the operating point.\nAfter linearization, calls to the operator will use the linear\napproximation until reset() is called.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>x <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array_like</span></dt>\n<dd>State vector</dd>\n<dt>u <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array_like</span></dt>\n<dd>Input vector</dd>\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>Time</dd>\n</dl>\n",
              "signature": "(x, u, t)",
              "parameters": [
                {
                  "name": "x",
                  "type": null,
                  "default": null,
                  "description": "State vector"
                },
                {
                  "name": "u",
                  "type": null,
                  "default": null,
                  "description": "Input vector"
                },
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "Time"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "reset",
              "description": "Reset the linearization.",
              "docstring_html": "<p>Reset the linearization.</p>\n<p>Clears the stored linearization points and Jacobians, causing the\noperator to evaluate the function directly on subsequent calls.</p>\n",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "f0",
              "description": "",
              "type": null,
              "value": "None"
            },
            {
              "name": "x0",
              "description": "",
              "type": null,
              "value": "None"
            },
            {
              "name": "u0",
              "description": "",
              "type": null,
              "value": "None"
            },
            {
              "name": "Jx",
              "description": "",
              "type": null,
              "value": "None"
            },
            {
              "name": "Ju",
              "description": "",
              "type": null,
              "value": "None"
            }
          ],
          "parameters": [
            {
              "name": "func",
              "type": null,
              "default": null,
              "description": "The function to wrap with signature func(x, u, t)"
            },
            {
              "name": "jac_x",
              "type": null,
              "default": "None",
              "description": "Optional analytical Jacobian with respect to x. If None, automatic or numerical differentiation will be used."
            },
            {
              "name": "jac_u",
              "type": null,
              "default": "None",
              "description": "Optional analytical Jacobian with respect to u. If None, automatic or numerical differentiation will be used."
            }
          ]
        },
        {
          "name": "Differentiator",
          "description": "Differentiates the input signal.",
          "docstring_html": "<p>Differentiates the input signal.</p>\n<p>Uses a first order transfer function with a pole at the origin which implements\na high pass filter. Supports vector input.</p>\n<div>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\">\n  <msub>\n    <mi>H</mi>\n    <mi>diff</mi>\n  </msub>\n  <mo stretchy=\"false\">(</mo>\n  <mi>s</mi>\n  <mo stretchy=\"false\">)</mo>\n  <mo>=</mo>\n  <mfrac>\n    <mi>s</mi>\n    <mrow>\n      <mn>1</mn>\n      <mo>+</mo>\n      <mi>s</mi>\n      <mo stretchy=\"false\">/</mo>\n      <msub>\n        <mi>f</mi>\n        <mi>max</mi>\n      </msub>\n    </mrow>\n  </mfrac>\n</math>\n</div>\n<p>The approximation holds for signals up to a frequency of approximately f_max.</p>\n<div class=\"section\" id=\"note\">\n<h4>Note</h4>\n<p>Depending on <cite>f_max</cite>, the resulting system might become stiff or ill conditioned!\nAs a practical choice set <cite>f_max</cite> to 3x the highest expected signal frequency.</p>\n</div>\n<div class=\"section\" id=\"note-1\">\n<h4>Note</h4>\n<p>Since this is an approximation of real differentiation, the approximation will not hold\nif there are high frequency components present in the signal. For example if you have\ndiscontinuities such as steps or squere waves.</p>\n</div>\n<div class=\"section\" id=\"example\">\n<h4>Example</h4>\n<p>The block is initialized like this:</p>\n<pre class=\"code python literal-block\">\n#cutoff at 1kHz\nD = Differentiator(f_max=1e3)\n</pre>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>f_max <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>highest expected signal frequency</dd>\n</dl>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>op_dyn <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">DynamicOperator</span></dt>\n<dd>internal dynamic operator for ODE component</dd>\n<dt>op_alg <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">DynamicOperator</span></dt>\n<dd>internal algebraic operator</dd>\n</dl>\n</div>\n",
          "bases": [
            "Block"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "signature": "(f_max = 100.0)",
              "parameters": [
                {
                  "name": "f_max",
                  "type": null,
                  "default": "100.0",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "update",
              "description": "update system equation fixed point loop,",
              "docstring_html": "<p>update system equation fixed point loop,\nwith convergence control</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time</dd>\n</dl>\n",
              "signature": "(t)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "solve",
              "description": "advance solution of implicit update equation",
              "docstring_html": "<p>advance solution of implicit update equation</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time</dd>\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>integration timestep</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>error <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>solver residual norm</dd>\n</dl>\n",
              "signature": "(t, dt)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time"
                },
                {
                  "name": "dt",
                  "type": null,
                  "default": null,
                  "description": "integration timestep"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "step",
              "description": "compute update step with integration engine",
              "docstring_html": "<p>compute update step with integration engine</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time</dd>\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>integration timestep</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>success <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>step was successful</dd>\n<dt>error <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>local truncation error from adaptive integrators</dd>\n<dt>scale <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>timestep rescale from adaptive integrators</dd>\n</dl>\n",
              "signature": "(t, dt)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time"
                },
                {
                  "name": "dt",
                  "type": null,
                  "default": null,
                  "description": "integration timestep"
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "f_max",
              "description": "",
              "type": null,
              "value": "f_max"
            },
            {
              "name": "initial_value",
              "description": "",
              "type": null,
              "value": "0.0"
            },
            {
              "name": "op_dyn",
              "description": "",
              "type": null,
              "value": "DynamicOperator(func=(lambda x, u, t: self.f_max * (u - x)), jac_x=(lambda x, u, t: -self.f_max * np.eye(len(u))))"
            },
            {
              "name": "op_alg",
              "description": "",
              "type": null,
              "value": "DynamicOperator(func=(lambda x, u, t: self.f_max * (u - x)), jac_x=(lambda x, u, t: -self.f_max * np.eye(len(u))), jac_u=(lambda x, u, t: self.f_max * np.eye(len(u))))"
            }
          ],
          "parameters": [
            {
              "name": "f_max",
              "type": null,
              "default": "100.0",
              "description": "highest expected signal frequency"
            }
          ]
        },
        {
          "name": "Integrator",
          "description": "Integrates the input signal.",
          "docstring_html": "<p>Integrates the input signal.</p>\n<p>Uses a numerical integration engine like this:</p>\n<div>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\">\n  <mi>y</mi>\n  <mo stretchy=\"false\">(</mo>\n  <mi>t</mi>\n  <mo stretchy=\"false\">)</mo>\n  <mo>=</mo>\n  <msubsup>\n    <mo>∫</mo>\n    <mn>0</mn>\n    <mi>t</mi>\n  </msubsup>\n  <mi>u</mi>\n  <mo stretchy=\"false\">(</mo>\n  <mi>τ</mi>\n  <mo stretchy=\"false\">)</mo>\n  <mspace width=\"0.25em\"></mspace>\n  <mi>d</mi>\n  <mi>τ</mi>\n</math>\n</div>\n<p>or in differential form like this:</p>\n<pre class=\"math\">\n\\begin{eqnarray}\n    \\dot{x}(t) &amp;= u(t) \\\\\n           y(t) &amp;= x(t)\n\\end{eqnarray}\n</pre>\n<p>The Integrator block is inherently MIMO capable, so <cite>u</cite>\nand <cite>y</cite> can be vectors.</p>\n<div class=\"section\" id=\"example\">\n<h4>Example</h4>\n<p>This is how to initialize the integrator:</p>\n<pre class=\"code python literal-block\">\n#initial value 0.0\ni1 = Integrator()\n\n#initial value 2.5\ni2 = Integrator(2.5)\n</pre>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>initial_value <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float, array</span></dt>\n<dd>initial value of integrator</dd>\n</dl>\n</div>\n",
          "bases": [
            "Block"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "signature": "(initial_value = 0.0)",
              "parameters": [
                {
                  "name": "initial_value",
                  "type": null,
                  "default": "0.0",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "update",
              "description": "update system equation fixed point loop",
              "docstring_html": "<p>update system equation fixed point loop</p>\n<div class=\"section\" id=\"note\">\n<h4>Note</h4>\n<p>integrator does not have passthrough, therefore this\nmethod is performance optimized for this case</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time</dd>\n</dl>\n</div>\n",
              "signature": "(t)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "solve",
              "description": "advance solution of implicit update equation of the solver",
              "docstring_html": "<p>advance solution of implicit update equation of the solver</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time</dd>\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>integration timestep</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>error <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>solver residual norm</dd>\n</dl>\n",
              "signature": "(t, dt)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time"
                },
                {
                  "name": "dt",
                  "type": null,
                  "default": null,
                  "description": "integration timestep"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "step",
              "description": "compute timestep update with integration engine",
              "docstring_html": "<p>compute timestep update with integration engine</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time</dd>\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>integration timestep</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>success <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>step was successful</dd>\n<dt>error <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>local truncation error from adaptive integrators</dd>\n<dt>scale <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>timestep rescale from adaptive integrators</dd>\n</dl>\n",
              "signature": "(t, dt)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time"
                },
                {
                  "name": "dt",
                  "type": null,
                  "default": null,
                  "description": "integration timestep"
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "initial_value",
              "description": "",
              "type": null,
              "value": "initial_value"
            }
          ],
          "parameters": [
            {
              "name": "initial_value",
              "type": null,
              "default": "0.0",
              "description": "initial value of integrator"
            }
          ]
        },
        {
          "name": "Register",
          "description": "This class is a intended to be used for the inputs and outputs of blocks.",
          "docstring_html": "<p>This class is a intended to be used for the inputs and outputs of blocks.</p>\n<p>Its basic functionality is similar to a <cite>dict</cite> but with some additional methods\nand implemented as a numpy array for fast data transfer.</p>\n<p>The core functionality is that values can be added dynamically and the size of the\nregister doesnt have to be specified. It also implements some methods to interact\nwith numpy arrays and to streamline convergence checks.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>size <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int, optional</span></dt>\n<dd>initial size of the register</dd>\n<dt>mapping <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">dict[str: int]</span></dt>\n<dd>string aliases for integer ports</dd>\n</dl>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>_data <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">np.ndarray</span></dt>\n<dd>internal numpy array that holds the values</dd>\n<dt>_mapping <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">dict[str: int]</span></dt>\n<dd>internal mapping for port aliases from string to int (index)</dd>\n</dl>\n",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "signature": "(size = None, mapping = None, dtype = np.float64)",
              "parameters": [
                {
                  "name": "size",
                  "type": null,
                  "default": "None",
                  "description": ""
                },
                {
                  "name": "mapping",
                  "type": null,
                  "default": "None",
                  "description": ""
                },
                {
                  "name": "dtype",
                  "type": null,
                  "default": "np.float64",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "resize",
              "description": "Resize the internal data array to accommodate more entries.",
              "docstring_html": "<p>Resize the internal data array to accommodate more entries.</p>\n<p>Creates a new zero-filled array instead of in-place resize to avoid\nnumpy ValueError when other references to the array exist (e.g., from\nfancy indexing in PortReference).</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>size <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>new size for the internal data array</dd>\n</dl>\n",
              "signature": "(size)",
              "parameters": [
                {
                  "name": "size",
                  "type": null,
                  "default": null,
                  "description": "new size for the internal data array"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "reset",
              "description": "Set all stored values to zero.",
              "docstring_html": "<p>Set all stored values to zero.</p>\n",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "to_array",
              "description": "Returns a copy of the internal array.",
              "docstring_html": "<p>Returns a copy of the internal array.</p>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>arr <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">np.ndarray</span></dt>\n<dd>converted register as array</dd>\n</dl>\n",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "update_from_array",
              "description": "Update the register values from an array in place.",
              "docstring_html": "<p>Update the register values from an array in place.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>arr <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">np.ndarray, list, tuple, float</span></dt>\n<dd>array or scalar that is used to update internal register values</dd>\n</dl>\n",
              "signature": "(arr)",
              "parameters": [
                {
                  "name": "arr",
                  "type": null,
                  "default": null,
                  "description": "array or scalar that is used to update internal register values"
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [],
          "parameters": [
            {
              "name": "size",
              "type": null,
              "default": "None",
              "description": "initial size of the register"
            },
            {
              "name": "mapping",
              "type": null,
              "default": "None",
              "description": "string aliases for integer ports"
            },
            {
              "name": "dtype",
              "type": null,
              "default": "np.float64",
              "description": ""
            }
          ]
        },
        {
          "name": "Operator",
          "description": "Operator class for function evaluation and linearization.",
          "docstring_html": "<p>Operator class for function evaluation and linearization.</p>\n<p>This class wraps a function to provide both direct evaluation and linear approximation\ncapabilities. When linearized around a point x0, subsequent calls use the first-order\nTaylor approximation</p>\n<div>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\">\n  <mi>f</mi>\n  <mo stretchy=\"false\">(</mo>\n  <mi>x</mi>\n  <mo stretchy=\"false\">)</mo>\n  <mo>≈</mo>\n  <mi>f</mi>\n  <mo stretchy=\"false\">(</mo>\n  <msub>\n    <mi>x</mi>\n    <mn>0</mn>\n  </msub>\n  <mo stretchy=\"false\">)</mo>\n  <mo>+</mo>\n  <mi>𝐉</mi>\n  <mo stretchy=\"false\">(</mo>\n  <msub>\n    <mi>x</mi>\n    <mn>0</mn>\n  </msub>\n  <mo stretchy=\"false\">)</mo>\n  <mo stretchy=\"false\">(</mo>\n  <mi>x</mi>\n  <mo>−</mo>\n  <msub>\n    <mi>x</mi>\n    <mn>0</mn>\n  </msub>\n  <mo stretchy=\"false\">)</mo>\n</math>\n</div>\n<p>instead of evaluating the function.</p>\n<p>The class supports multiple methods for Jacobian computation: user-provided analytical\nJacobians, automatic differentiation via the Value class, and numerical differentiation\nas a fallback.</p>\n<div class=\"section\" id=\"example\">\n<h4>Example</h4>\n<p>Basic usage with automatic differentiation:</p>\n<pre class=\"code python literal-block\">\ndef f(x):\n    return x**2 + np.sin(x)\n\nop = Operator(f)\n\n# Direct function evaluation\ny1 = op(2.0)\n\n# Linearize at current point\nop.linearize(2.0)\n\n# Use linear approximation\ny2 = op(2.1)  # Returns f(2.0) + J(2.0) (2.1-2.0)\n</pre>\n<p>With user-provided Jacobian:</p>\n<pre class=\"code python literal-block\">\ndef f(x):\n    return x**2 + np.sin(x)\n\ndef df_dx(x):\n    return 2*x + np.cos(x)\n\nop = Operator(f, jac=df_dx)\n\nop.linearize(2.0)  # Uses df_dx for Jacobian\n</pre>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>func <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">callable</span></dt>\n<dd>The function to wrap</dd>\n<dt>jac <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">callable, optional</span></dt>\n<dd>Optional analytical Jacobian of func. If None, automatic or numerical\ndifferentiation will be used.</dd>\n</dl>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>f0 <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array_like</span></dt>\n<dd>function evaluation at operating point</dd>\n<dt>x0 <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array_like</span></dt>\n<dd>operating point</dd>\n<dt>J <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array_like</span></dt>\n<dd>jacobian matrix at operating point</dd>\n</dl>\n</div>\n",
          "bases": [
            "object"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "signature": "(func, jac = None)",
              "parameters": [
                {
                  "name": "func",
                  "type": null,
                  "default": null,
                  "description": ""
                },
                {
                  "name": "jac",
                  "type": null,
                  "default": "None",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "jac",
              "description": "Compute the Jacobian matrix at point x.",
              "docstring_html": "<p>Compute the Jacobian matrix at point x.</p>\n<p>Uses the following methods in order of preference:\n1. User-provided analytical Jacobian if available\n2. Automatic differentiation via Value class\n3. Numerical differentiation as fallback</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>x <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array_like</span></dt>\n<dd>Point at which to evaluate the Jacobian</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>jacobian <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">ndarray</span></dt>\n<dd>Jacobian matrix at x</dd>\n</dl>\n",
              "signature": "(x)",
              "parameters": [
                {
                  "name": "x",
                  "type": null,
                  "default": null,
                  "description": "Point at which to evaluate the Jacobian Returns -------"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "linearize",
              "description": "Linearize the function at point x.",
              "docstring_html": "<p>Linearize the function at point x.</p>\n<p>Computes and stores both the function value and its Jacobian at x.\nAfter linearization, calls to the operator will use the linear\napproximation until reset() is called.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>x <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array_like</span></dt>\n<dd>Point at which to linearize the function</dd>\n</dl>\n",
              "signature": "(x)",
              "parameters": [
                {
                  "name": "x",
                  "type": null,
                  "default": null,
                  "description": "Point at which to linearize the function"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "reset",
              "description": "Reset the linearization.",
              "docstring_html": "<p>Reset the linearization.</p>\n<p>Clears the stored linearization point and Jacobian, causing the\noperator to evaluate the function directly on subsequent calls.</p>\n",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "f0",
              "description": "",
              "type": null,
              "value": "None"
            },
            {
              "name": "x0",
              "description": "",
              "type": null,
              "value": "None"
            },
            {
              "name": "J",
              "description": "",
              "type": null,
              "value": "None"
            }
          ],
          "parameters": [
            {
              "name": "func",
              "type": null,
              "default": null,
              "description": "The function to wrap"
            },
            {
              "name": "jac",
              "type": null,
              "default": "None",
              "description": "Optional analytical Jacobian of func. If None, automatic or numerical differentiation will be used."
            }
          ]
        },
        {
          "name": "Multiplier",
          "description": "Multiplies all signals from all input ports (MISO).",
          "docstring_html": "<p>Multiplies all signals from all input ports (MISO).</p>\n<div>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\">\n  <mi>y</mi>\n  <mo stretchy=\"false\">(</mo>\n  <mi>t</mi>\n  <mo stretchy=\"false\">)</mo>\n  <mo>=</mo>\n  <munder>\n    <mo movablelimits=\"true\">∏</mo>\n    <mi>i</mi>\n  </munder>\n  <msub>\n    <mi>u</mi>\n    <mi>i</mi>\n  </msub>\n  <mo stretchy=\"false\">(</mo>\n  <mi>t</mi>\n  <mo stretchy=\"false\">)</mo>\n</math>\n</div>\n<div class=\"section\" id=\"note\">\n<h4>Note</h4>\n<p>This block is purely algebraic and its operation (<cite>op_alg</cite>) will be called\nmultiple times per timestep, each time when <cite>Simulation._update(t)</cite> is\ncalled in the global simulation loop.</p>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>op_alg <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">Operator</span></dt>\n<dd>internal algebraic operator that wraps 'prod'</dd>\n</dl>\n</div>\n",
          "bases": [
            "Block"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "update",
              "description": "update system equation",
              "docstring_html": "<p>update system equation</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time</dd>\n</dl>\n",
              "signature": "(t)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time"
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "input_port_labels",
              "description": "",
              "type": null,
              "value": "None"
            },
            {
              "name": "output_port_labels",
              "description": "",
              "type": null,
              "value": "{'out': 0}"
            },
            {
              "name": "op_alg",
              "description": "",
              "type": null,
              "value": "Operator(func=prod, jac=(lambda x: np.array([[(prod(np.delete(x, i))) for i in (range(len(x)))]])))"
            }
          ],
          "parameters": []
        },
        {
          "name": "Schedule",
          "description": "Subclass of base 'Event' that triggers dependent on the evaluation time.",
          "docstring_html": "<p>Subclass of base 'Event' that triggers dependent on the evaluation time.</p>\n<p>Monitors time in every timestep and triggers periodically (period). This event\ndoes not have an event function as the event condition only depends on time.</p>\n<pre class=\"code literal-block\">\ntime == next_schedule_time -&gt; event\n</pre>\n<div class=\"section\" id=\"example\">\n<h4>Example</h4>\n<p>Initialize a scheduled event handler like this:</p>\n<pre class=\"code python literal-block\">\n#define the action function (callback)\ndef act(t):\n    #do something at event resolution\n    pass\n\n#initialize the event manager\nE = Schedule(\n    t_start=0,    #starting at t=0\n    t_end=None,   #never ending\n    t_period=3,   #triggering every 3 time units\n    func_act=act  #resulting in a callback\n    )\n</pre>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t_start <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>starting time for schedule</dd>\n<dt>t_end <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>termination time for schedule</dd>\n<dt>t_period <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>time period of schedule, when events are triggered</dd>\n<dt>func_act <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">callable</span></dt>\n<dd>action function for event resolution</dd>\n<dt>tolerance <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>tolerance to check if detection is close to actual event</dd>\n</dl>\n</div>\n",
          "bases": [
            "Event"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "signature": "(t_start = 0, t_end = None, t_period = 1, func_act = None, tolerance = TOLERANCE)",
              "parameters": [
                {
                  "name": "t_start",
                  "type": null,
                  "default": "0",
                  "description": ""
                },
                {
                  "name": "t_end",
                  "type": null,
                  "default": "None",
                  "description": ""
                },
                {
                  "name": "t_period",
                  "type": null,
                  "default": "1",
                  "description": ""
                },
                {
                  "name": "func_act",
                  "type": null,
                  "default": "None",
                  "description": ""
                },
                {
                  "name": "tolerance",
                  "type": null,
                  "default": "TOLERANCE",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "estimate",
              "description": "Estimate the time until the next scheduled event.",
              "docstring_html": "<p>Estimate the time until the next scheduled event.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time for estimation</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>float</dt>\n<dd>estimated time until next event</dd>\n</dl>\n",
              "signature": "(t)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time for estimation"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "buffer",
              "description": "Buffer the current time to history",
              "docstring_html": "<p>Buffer the current time to history</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>buffer time</dd>\n</dl>\n",
              "signature": "(t)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "buffer time"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "detect",
              "description": "Check if the event condition is satisfied, i.e. if the",
              "docstring_html": "<p>Check if the event condition is satisfied, i.e. if the\ntime period switch is within the current timestep.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time for detection</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>detected <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>was an event detected?</dd>\n<dt>close <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>are we close to the event?</dd>\n<dt>ratio <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>interpolated event location ratio in timestep</dd>\n</dl>\n",
              "signature": "(t)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time for detection"
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "t_start",
              "description": "",
              "type": null,
              "value": "t_start"
            },
            {
              "name": "t_period",
              "description": "",
              "type": null,
              "value": "t_period"
            },
            {
              "name": "t_end",
              "description": "",
              "type": null,
              "value": "t_end"
            }
          ],
          "parameters": [
            {
              "name": "t_start",
              "type": null,
              "default": "0",
              "description": "starting time for schedule"
            },
            {
              "name": "t_end",
              "type": null,
              "default": "None",
              "description": "termination time for schedule"
            },
            {
              "name": "t_period",
              "type": null,
              "default": "1",
              "description": "time period of schedule, when events are triggered"
            },
            {
              "name": "func_act",
              "type": null,
              "default": "None",
              "description": "action function for event resolution"
            },
            {
              "name": "tolerance",
              "type": null,
              "default": "TOLERANCE",
              "description": "tolerance to check if detection is close to actual event"
            }
          ]
        },
        {
          "name": "ADC",
          "description": "Models an ideal Analog-to-Digital Converter (ADC).",
          "docstring_html": "<p>Models an ideal Analog-to-Digital Converter (ADC).</p>\n<p>This block samples an analog input signal periodically, quantizes it\naccording to the specified number of bits and input span, and outputs\nthe resulting digital code on multiple output ports. The sampling\nis triggered by a scheduled event.</p>\n<p>Functionality:</p>\n<ol class=\"arabic simple\">\n<li>Samples the analog input <cite>inputs[0]</cite> at intervals of <cite>T</cite>, starting after delay <cite>tau</cite>.</li>\n<li>Clips the input voltage to the defined <cite>span</cite> [min_voltage, max_voltage].</li>\n<li>Scales the clipped voltage to the range [0, 1].</li>\n<li>Quantizes the scaled value to an integer code between 0 and 2^n_bits - 1 using flooring.</li>\n<li>Converts the integer code to an n_bits binary representation.</li>\n<li>Outputs the binary code on ports 0 (LSB) to n_bits-1 (MSB).</li>\n</ol>\n<p>Ideal characteristics:</p>\n<ul class=\"simple\">\n<li>Instantaneous sampling at scheduled times.</li>\n<li>Perfect, noise-free quantization.</li>\n<li>No aperture jitter or other dynamic errors.</li>\n</ul>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>n_bits <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int, optional</span></dt>\n<dd>Number of bits for the digital output code. Default is 4.</dd>\n<dt>span <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">list[float] or tuple[float], optional</span></dt>\n<dd>The valid analog input value range [min_voltage, max_voltage].\nInputs outside this range will be clipped. Default is [-1, 1].</dd>\n<dt>T <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float, optional</span></dt>\n<dd>Sampling period (time between samples). Default is 1 time unit.</dd>\n<dt>tau <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float, optional</span></dt>\n<dd>Initial delay before the first sample is taken. Default is 0.</dd>\n</dl>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>events <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">list[Schedule]</span></dt>\n<dd>Internal scheduled event responsible for periodic sampling and conversion.</dd>\n</dl>\n",
          "bases": [
            "Block"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "signature": "(n_bits = 4, span = [-1, 1], T = 1, tau = 0)",
              "parameters": [
                {
                  "name": "n_bits",
                  "type": null,
                  "default": "4",
                  "description": ""
                },
                {
                  "name": "span",
                  "type": null,
                  "default": "[-1, 1]",
                  "description": ""
                },
                {
                  "name": "T",
                  "type": null,
                  "default": "1",
                  "description": ""
                },
                {
                  "name": "tau",
                  "type": null,
                  "default": "0",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "input_port_labels",
              "description": "",
              "type": null,
              "value": "{'in': 0}"
            },
            {
              "name": "output_port_labels",
              "description": "",
              "type": null,
              "value": "None"
            },
            {
              "name": "n_bits",
              "description": "",
              "type": null,
              "value": "n_bits"
            },
            {
              "name": "span",
              "description": "",
              "type": null,
              "value": "span"
            },
            {
              "name": "T",
              "description": "",
              "type": null,
              "value": "T"
            },
            {
              "name": "tau",
              "description": "",
              "type": null,
              "value": "tau"
            },
            {
              "name": "events",
              "description": "",
              "type": null,
              "value": "[Schedule(t_start=tau, t_period=T, func_act=_sample)]"
            }
          ],
          "parameters": [
            {
              "name": "n_bits",
              "type": null,
              "default": "4",
              "description": "Number of bits for the digital output code. Default is 4."
            },
            {
              "name": "span",
              "type": null,
              "default": "[-1, 1]",
              "description": "The valid analog input value range [min_voltage, max_voltage]. Inputs outside this range will be clipped. Default is [-1, 1]."
            },
            {
              "name": "T",
              "type": null,
              "default": "1",
              "description": "Sampling period (time between samples). Default is 1 time unit."
            },
            {
              "name": "tau",
              "type": null,
              "default": "0",
              "description": "Initial delay before the first sample is taken. Default is 0."
            }
          ]
        },
        {
          "name": "DAC",
          "description": "Models an ideal Digital-to-Analog Converter (DAC).",
          "docstring_html": "<p>Models an ideal Digital-to-Analog Converter (DAC).</p>\n<p>This block reads a digital input code periodically from its input ports,\nreconstructs the corresponding analog value based on the number of bits\nand output span, and holds the output constant between updates. The update\nis triggered by a scheduled event.</p>\n<p>Functionality:</p>\n<ol class=\"arabic simple\">\n<li>Reads the digital code from input ports 0 (LSB) to n_bits-1 (MSB) at intervals of <cite>T</cite>, starting after delay <cite>tau</cite>.</li>\n<li>Interprets the inputs as an unsigned binary integer code.</li>\n<li>Converts the integer code to a fractional value between 0 and (2^n_bits - 1) / 2^n_bits.</li>\n<li>Scales this fractional value to the specified analog output <cite>span</cite>.</li>\n<li>Outputs the resulting analog value on <cite>outputs[0]</cite>.</li>\n<li>Holds the output value constant until the next scheduled update.</li>\n</ol>\n<p>Ideal characteristics:</p>\n<ul class=\"simple\">\n<li>Instantaneous update at scheduled times.</li>\n<li>Perfect, noise-free reconstruction.</li>\n<li>No glitches or settling time.</li>\n</ul>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>n_bits <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int, optional</span></dt>\n<dd>Number of digital input bits expected. Default is 4.</dd>\n<dt>span <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">list[float] or tuple[float], optional</span></dt>\n<dd>The analog output value range [min_voltage, max_voltage] corresponding\nto the digital codes 0 and 2^n_bits - 1, respectively (approximately).\nDefault is [-1, 1].</dd>\n<dt>T <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float, optional</span></dt>\n<dd>Update period (time between output updates). Default is 1 time unit.</dd>\n<dt>tau <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float, optional</span></dt>\n<dd>Initial delay before the first output update. Default is 0.</dd>\n</dl>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>events <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">list[Schedule]</span></dt>\n<dd>Internal scheduled event responsible for periodic updates.</dd>\n</dl>\n",
          "bases": [
            "Block"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "signature": "(n_bits = 4, span = [-1, 1], T = 1, tau = 0)",
              "parameters": [
                {
                  "name": "n_bits",
                  "type": null,
                  "default": "4",
                  "description": ""
                },
                {
                  "name": "span",
                  "type": null,
                  "default": "[-1, 1]",
                  "description": ""
                },
                {
                  "name": "T",
                  "type": null,
                  "default": "1",
                  "description": ""
                },
                {
                  "name": "tau",
                  "type": null,
                  "default": "0",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "input_port_labels",
              "description": "",
              "type": null,
              "value": "None"
            },
            {
              "name": "output_port_labels",
              "description": "",
              "type": null,
              "value": "{'out': 0}"
            },
            {
              "name": "n_bits",
              "description": "",
              "type": null,
              "value": "n_bits"
            },
            {
              "name": "span",
              "description": "",
              "type": null,
              "value": "span"
            },
            {
              "name": "T",
              "description": "",
              "type": null,
              "value": "T"
            },
            {
              "name": "tau",
              "description": "",
              "type": null,
              "value": "tau"
            },
            {
              "name": "events",
              "description": "",
              "type": null,
              "value": "[Schedule(t_start=tau, t_period=T, func_act=_sample)]"
            }
          ],
          "parameters": [
            {
              "name": "n_bits",
              "type": null,
              "default": "4",
              "description": "Number of digital input bits expected. Default is 4."
            },
            {
              "name": "span",
              "type": null,
              "default": "[-1, 1]",
              "description": "The analog output value range [min_voltage, max_voltage] corresponding to the digital codes 0 and 2^n_bits - 1, respectively (approximately). Default is [-1, 1]."
            },
            {
              "name": "T",
              "type": null,
              "default": "1",
              "description": "Update period (time between output updates). Default is 1 time unit."
            },
            {
              "name": "tau",
              "type": null,
              "default": "0",
              "description": "Initial delay before the first output update. Default is 0."
            }
          ]
        },
        {
          "name": "ZeroCrossing",
          "description": "Subclass of base 'Event' that triggers if the event function crosses zero.",
          "docstring_html": "<p>Subclass of base 'Event' that triggers if the event function crosses zero.\nThis is a bidirectional zero-crossing detector.</p>\n<p>Monitors system state by evaluating an event function (func_evt) with scalar output and\ntesting for zero crossings (sign changes).</p>\n<pre class=\"code literal-block\">\nfunc_evt(time) -&gt; event?\n</pre>\n<p>If an event is detected, some action (func_act) is performed on the system state.</p>\n<pre class=\"code literal-block\">\nfunc_evt(time) == 0 -&gt; event -&gt; func_act(time)\n</pre>\n<div class=\"section\" id=\"example\">\n<h4>Example</h4>\n<p>Initialize a zero-crossing event handler like this:</p>\n<pre class=\"code python literal-block\">\n# define the event function\ndef evt(t):\n    # here we have a zero-crossing at 't==10'\n    return t - 10\n\n# define the action function (callback)\ndef act(t):\n    # do something at event resolution\n    pass\n\n# initialize the event manager\nE = ZeroCrossing(\n    func_evt=evt,  # the event function\n    func_act=act   # the action function\n    )\n</pre>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>func_evt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">callable</span></dt>\n<dd>event function, where zeros are events</dd>\n<dt>func_act <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">callable</span></dt>\n<dd>action function for event resolution</dd>\n<dt>tolerance <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>tolerance to check if detection is close to actual event</dd>\n</dl>\n</div>\n",
          "bases": [
            "Event"
          ],
          "methods": [
            {
              "name": "detect",
              "description": "Evaluate the event function and check for zero-crossings",
              "docstring_html": "<p>Evaluate the event function and check for zero-crossings</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time for detection</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>detected <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>was an event detected?</dd>\n<dt>close <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>are we close to the event?</dd>\n<dt>ratio <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>interpolated event location as ratio of timestep</dd>\n</dl>\n",
              "signature": "(t)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time for detection"
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [],
          "parameters": []
        },
        {
          "name": "Comparator",
          "description": "Comparator block that sets output depending on predefined thresholds for the input.",
          "docstring_html": "<p>Comparator block that sets output depending on predefined thresholds for the input.</p>\n<p>Sets the output to '1' if the input signal crosses a predefined threshold and to '-1'\nif it crosses in the reverse direction.</p>\n<p>This is realized by the block spawning a zero-crossing event detector that watches\nthe input of the block and locates the transition up to a tolerance.</p>\n<p>The block output is determined by a simple sign check in\nthe 'update' method.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>threshold <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>threshold value for the comparator</dd>\n<dt>tolerance <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>tolerance for zero crossing detection</dd>\n<dt>span <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">list[float] or tuple[float], optional</span></dt>\n<dd>output value range [min, max]</dd>\n</dl>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>events <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">list[ZeroCrossing]</span></dt>\n<dd>internal zero crossing event</dd>\n</dl>\n",
          "bases": [
            "Block"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "signature": "(threshold = 0, tolerance = 0.0001, span = [-1, 1])",
              "parameters": [
                {
                  "name": "threshold",
                  "type": null,
                  "default": "0",
                  "description": ""
                },
                {
                  "name": "tolerance",
                  "type": null,
                  "default": "0.0001",
                  "description": ""
                },
                {
                  "name": "span",
                  "type": null,
                  "default": "[-1, 1]",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "update",
              "description": "update system equation for fixed point loop,",
              "docstring_html": "<p>update system equation for fixed point loop,\nhere just setting the outputs</p>\n<div class=\"section\" id=\"note\">\n<h4>Note</h4>\n<p>no direct passthrough, so the 'update' method\nis optimized for this case</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>error <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>absolute error to previous iteration for convergence\ncontrol (here '0.0' because discrete block)</dd>\n</dl>\n</div>\n",
              "signature": "(t)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time"
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "input_port_labels",
              "description": "",
              "type": null,
              "value": "{'in': 0}"
            },
            {
              "name": "output_port_labels",
              "description": "",
              "type": null,
              "value": "{'out': 0}"
            },
            {
              "name": "threshold",
              "description": "",
              "type": null,
              "value": "threshold"
            },
            {
              "name": "tolerance",
              "description": "",
              "type": null,
              "value": "tolerance"
            },
            {
              "name": "span",
              "description": "",
              "type": null,
              "value": "span"
            },
            {
              "name": "events",
              "description": "",
              "type": null,
              "value": "[ZeroCrossing(func_evt=func_evt, tolerance=tolerance)]"
            }
          ],
          "parameters": [
            {
              "name": "threshold",
              "type": null,
              "default": "0",
              "description": "threshold value for the comparator"
            },
            {
              "name": "tolerance",
              "type": null,
              "default": "0.0001",
              "description": "tolerance for zero crossing detection"
            },
            {
              "name": "span",
              "type": null,
              "default": "[-1, 1]",
              "description": "output value range [min, max]"
            }
          ]
        },
        {
          "name": "SampleHold",
          "description": "Samples the inputs periodically and produces them at the output.",
          "docstring_html": "<p>Samples the inputs periodically and produces them at the output.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>T <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>sampling period</dd>\n<dt>tau <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>delay</dd>\n</dl>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>events <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">list[Schedule]</span></dt>\n<dd>internal scheduled event for periodic sampling</dd>\n</dl>\n",
          "bases": [
            "Block"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "signature": "(T = 1, tau = 0)",
              "parameters": [
                {
                  "name": "T",
                  "type": null,
                  "default": "1",
                  "description": ""
                },
                {
                  "name": "tau",
                  "type": null,
                  "default": "0",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "T",
              "description": "",
              "type": null,
              "value": "T"
            },
            {
              "name": "tau",
              "description": "",
              "type": null,
              "value": "tau"
            },
            {
              "name": "events",
              "description": "",
              "type": null,
              "value": "[Schedule(t_start=tau, t_period=T, func_act=_sample)]"
            }
          ],
          "parameters": [
            {
              "name": "T",
              "type": null,
              "default": "1",
              "description": "sampling period"
            },
            {
              "name": "tau",
              "type": null,
              "default": "0",
              "description": "delay Attributes ----------"
            }
          ]
        },
        {
          "name": "Amplifier",
          "description": "Amplifies the input signal by multiplication with a constant gain term.",
          "docstring_html": "<p>Amplifies the input signal by multiplication with a constant gain term.</p>\n<p>Like this:</p>\n<div>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\">\n  <mi>y</mi>\n  <mo stretchy=\"false\">(</mo>\n  <mi>t</mi>\n  <mo stretchy=\"false\">)</mo>\n  <mo>=</mo>\n  <mi>gain</mi>\n  <mo>⋅</mo>\n  <mi>u</mi>\n  <mo stretchy=\"false\">(</mo>\n  <mi>t</mi>\n  <mo stretchy=\"false\">)</mo>\n</math>\n</div>\n<div class=\"section\" id=\"note\">\n<h4>Note</h4>\n<p>This block is purely algebraic and its operation (<cite>op_alg</cite>) will be called\nmultiple times per timestep, each time when <cite>Simulation._update(t)</cite> is\ncalled in the global simulation loop.</p>\n</div>\n<div class=\"section\" id=\"example\">\n<h4>Example</h4>\n<p>The block is initialized like this:</p>\n<pre class=\"code python literal-block\">\n#amplification by factor 5\nA = Amplifier(gain=5)\n</pre>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>gain <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>amplifier gain</dd>\n</dl>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>op_alg <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">Operator</span></dt>\n<dd>internal algebraic operator</dd>\n</dl>\n</div>\n",
          "bases": [
            "Block"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "signature": "(gain = 1.0)",
              "parameters": [
                {
                  "name": "gain",
                  "type": null,
                  "default": "1.0",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "update",
              "description": "update system equation in fixed point loop",
              "docstring_html": "<p>update system equation in fixed point loop</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time</dd>\n</dl>\n",
              "signature": "(t)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time"
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "gain",
              "description": "",
              "type": null,
              "value": "gain"
            },
            {
              "name": "op_alg",
              "description": "",
              "type": null,
              "value": "Operator(func=(lambda x: x * self.gain), jac=(lambda x: self.gain * np.eye(len(x))))"
            }
          ],
          "parameters": [
            {
              "name": "gain",
              "type": null,
              "default": "1.0",
              "description": "amplifier gain"
            }
          ]
        },
        {
          "name": "Function",
          "description": "Arbitrary MIMO function block, defined by a function or `lambda` expression.",
          "docstring_html": "<p>Arbitrary MIMO function block, defined by a function or <cite>lambda</cite> expression.</p>\n<p>The function can have multiple arguments that are then provided\nby the input channels of the function block.</p>\n<p>Form multi input, the function has to specify multiple arguments\nand for multi output, the aoutputs have to be provided as a\ntuple or list.</p>\n<p>In the context of the global system, this block implements algebraic\ncomponents of the global system ODE/DAE.</p>\n<div>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\">\n  <mover accent=\"true\">\n    <mi>y</mi>\n    <mo stretchy=\"false\" scriptlevel=\"+1\">→</mo>\n  </mover>\n  <mo>=</mo>\n  <mi>func</mi>\n  <mo stretchy=\"false\">(</mo>\n  <mover accent=\"true\">\n    <mi>u</mi>\n    <mo stretchy=\"false\" scriptlevel=\"+1\">→</mo>\n  </mover>\n  <mo stretchy=\"false\">)</mo>\n</math>\n</div>\n<div class=\"section\" id=\"note\">\n<h4>Note</h4>\n<p>This block is purely algebraic and its operation (<cite>op_alg</cite>) will be called\nmultiple times per timestep, each time when <cite>Simulation._update(t)</cite> is\ncalled in the global simulation loop.\nTherefore <cite>func</cite> must be purely algebraic and not introduce states,\ndelay, etc. For interfacing with external stateful APIs, use the\n<cite>Wrapper</cite> block.</p>\n</div>\n<div class=\"section\" id=\"note-1\">\n<h4>Note</h4>\n<p>If the outputs are provided as a single numpy array, they are\nconsidered a single output. For MIMO, output has to be tuple.</p>\n</div>\n<div class=\"section\" id=\"example\">\n<h4>Example</h4>\n<p>consider the function:</p>\n<pre class=\"code python literal-block\">\nfrom pathsim.blocks import Function\n\ndef f(a, b, c):\n    return a**2, a*b, b/c\n\nfn = Function(f)\n</pre>\n<p>then, when the block is uldated, the input channels of the block are\nassigned to the function arguments following this scheme:</p>\n<pre class=\"code literal-block\">\ninputs[0] -&gt; a\ninputs[1] -&gt; b\ninputs[2] -&gt; c\n</pre>\n<p>and the function outputs are assigned to the\noutput channels of the block in the same way:</p>\n<pre class=\"code literal-block\">\na**2 -&gt; outputs[0]\na*b  -&gt; outputs[1]\nb/c  -&gt; outputs[2]\n</pre>\n<p>Because the <cite>Function</cite> block only has a single argument, it can be\nused to decorate a function and make it a <cite>PathSim</cite> block. This might\nbe handy in some cases to keep definitions concise and localized\nin the code:</p>\n<pre class=\"code python literal-block\">\nfrom pathsim.blocks import Function\n\n#does the same as the definition above\n\n&#64;Function\ndef fn(a, b, c):\n    return a**2, a*b, b/c\n\n#'fn' is now a PathSim block\n</pre>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>func <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">callable</span></dt>\n<dd>MIMO function that defines algebraic block IO behaviour, signature <cite>func(*tuple)</cite></dd>\n</dl>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>op_alg <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">Operator</span></dt>\n<dd>internal algebraic operator that wraps <cite>func</cite></dd>\n</dl>\n</div>\n",
          "bases": [
            "Block"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "signature": "(func = lambda x: x)",
              "parameters": [
                {
                  "name": "func",
                  "type": null,
                  "default": "lambda x: x",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "update",
              "description": "Evaluate function block as part of algebraic component",
              "docstring_html": "<p>Evaluate function block as part of algebraic component\nof global system DAE.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time</dd>\n</dl>\n",
              "signature": "(t)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time"
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "func",
              "description": "",
              "type": null,
              "value": "func"
            },
            {
              "name": "op_alg",
              "description": "",
              "type": null,
              "value": "Operator(func=(lambda x: func(*x)))"
            }
          ],
          "parameters": [
            {
              "name": "func",
              "type": null,
              "default": "lambda x: x",
              "description": "MIMO function that defines algebraic block IO behaviour, signature `func(*tuple)`"
            }
          ]
        },
        {
          "name": "DynamicalFunction",
          "description": "Arbitrary MIMO time and input dependent function block.",
          "docstring_html": "<p>Arbitrary MIMO time and input dependent function block.</p>\n<p>The function signature needs two arguments <cite>f(u, t)</cite> where <cite>u</cite> is\nthe (possibly vectorial) block input and <cite>t</cite> is a time dependency.</p>\n<div>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\">\n  <mover accent=\"true\">\n    <mi>y</mi>\n    <mo stretchy=\"false\" scriptlevel=\"+1\">→</mo>\n  </mover>\n  <mo>=</mo>\n  <mi>func</mi>\n  <mo stretchy=\"false\">(</mo>\n  <mover accent=\"true\">\n    <mi>u</mi>\n    <mo stretchy=\"false\" scriptlevel=\"+1\">→</mo>\n  </mover>\n  <mo>,</mo>\n  <mi>t</mi>\n  <mo stretchy=\"false\">)</mo>\n</math>\n</div>\n<div class=\"section\" id=\"note\">\n<h4>Note</h4>\n<p>This block does essentially the same as <cite>Function</cite> but with different\nrequirements for the signature of the function to be wrapped.\nBlock inputs are packed into an array <cite>u</cite> and this block additionally\naccepts time dependency in the function provided.\nThats where the prefix <cite>Dynamical..</cite> comes from.</p>\n</div>\n<div class=\"section\" id=\"example\">\n<h4>Example</h4>\n<p>Lets say we want to implement a super simple model for a voltage controlled\noscillator (VCO), where the block input controls the frequency of a sine wave\nat the output.</p>\n<pre class=\"code python literal-block\">\nimport numpy as np\nfrom pathsim.blocks import DynamicalFunction\n\nf_0 = 100\n\ndef f_vco(u, t):\n    return np.sin(2*np.pi*f_0*u*t)\n\nvco = DynamicalFunction(f_vco)\n</pre>\n<p>Using it as a decorator also works:</p>\n<pre class=\"code python literal-block\">\nimport numpy as np\nfrom pathsim.blocks import DynamicalFunction\n\nf_0 = 100\n\n&#64;DynamicalFunction\ndef vco(u, t):\n    return np.sin(2*np.pi*f_0*u*t)\n\n#'vco' is now a PathSim block\n</pre>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>func <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">callable</span></dt>\n<dd>function that defines algebraic block IO behaviour with time dependency,\nsignature <cite>func(u, t)</cite> where <cite>u</cite> is <cite>numpy.ndarray</cite> and <cite>t</cite> is <cite>float</cite></dd>\n</dl>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>op_alg <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">DynamicOperator</span></dt>\n<dd>internal operator that wraps <cite>func</cite></dd>\n</dl>\n</div>\n",
          "bases": [
            "Block"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "signature": "(func = lambda u, t: u)",
              "parameters": [
                {
                  "name": "func",
                  "type": null,
                  "default": "lambda u, t: u",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "update",
              "description": "Evaluate function with time dependency as part of algebraic",
              "docstring_html": "<p>Evaluate function with time dependency as part of algebraic\ncomponent of global system DAE.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time</dd>\n</dl>\n",
              "signature": "(t)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time"
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "func",
              "description": "",
              "type": null,
              "value": "func"
            },
            {
              "name": "op_alg",
              "description": "",
              "type": null,
              "value": "DynamicOperator(lambda x, u, t: func(u, t))"
            }
          ],
          "parameters": [
            {
              "name": "func",
              "type": null,
              "default": "lambda u, t: u",
              "description": "function that defines algebraic block IO behaviour with time dependency, signature `func(u, t)` where `u` is `numpy.ndarray` and `t` is `float`"
            }
          ]
        },
        {
          "name": "RealtimePlotter",
          "description": "Class that manages a realtime plotting window that",
          "docstring_html": "<p>Class that manages a realtime plotting window that\ncan stream in x-y-data and update accordingly</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>max_samples <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>maximum number of samples to plot</dd>\n<dt>update_interval <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>time in seconds between refreshs</dd>\n<dt>labels <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">list[str]</span></dt>\n<dd>labels for plot traces</dd>\n<dt>x_label <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">str</span></dt>\n<dd>label for x-axis</dd>\n<dt>y_label <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">str</span></dt>\n<dd>label for y-axis</dd>\n</dl>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>fig <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">matplotlib.pyplot.figure</span></dt>\n<dd>internal figure of the realtime plotter</dd>\n<dt>ax <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">matplotlib.pyplot.axis</span></dt>\n<dd>internal axis of the realtime plotter</dd>\n</dl>\n",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "signature": "(max_samples = None, update_interval = 1, labels = [], x_label = '', y_label = '')",
              "parameters": [
                {
                  "name": "max_samples",
                  "type": null,
                  "default": "None",
                  "description": ""
                },
                {
                  "name": "update_interval",
                  "type": null,
                  "default": "1",
                  "description": ""
                },
                {
                  "name": "labels",
                  "type": null,
                  "default": "[]",
                  "description": ""
                },
                {
                  "name": "x_label",
                  "type": null,
                  "default": "''",
                  "description": ""
                },
                {
                  "name": "y_label",
                  "type": null,
                  "default": "''",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "update_all",
              "description": "update the plot completely with new data",
              "docstring_html": "<p>update the plot completely with new data</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>x <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array[float]</span></dt>\n<dd>new x values to plot</dd>\n<dt>y <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array[float]</span></dt>\n<dd>new y values to plot</dd>\n</dl>\n",
              "signature": "(x, y)",
              "parameters": [
                {
                  "name": "x",
                  "type": null,
                  "default": null,
                  "description": "new x values to plot"
                },
                {
                  "name": "y",
                  "type": null,
                  "default": null,
                  "description": "new y values to plot"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "update",
              "description": "update the plot with new data",
              "docstring_html": "<p>update the plot with new data</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>x <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>new x value to add</dd>\n<dt>y <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>new y value to add</dd>\n</dl>\n",
              "signature": "(x, y)",
              "parameters": [
                {
                  "name": "x",
                  "type": null,
                  "default": null,
                  "description": "new x value to add"
                },
                {
                  "name": "y",
                  "type": null,
                  "default": null,
                  "description": "new y value to add"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "show",
              "description": "",
              "docstring_html": "",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "on_close",
              "description": "",
              "docstring_html": "",
              "signature": "(event)",
              "parameters": [
                {
                  "name": "event",
                  "type": null,
                  "default": null,
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "max_samples",
              "description": "",
              "type": null,
              "value": "max_samples"
            },
            {
              "name": "update_interval",
              "description": "",
              "type": null,
              "value": "update_interval"
            },
            {
              "name": "labels",
              "description": "",
              "type": null,
              "value": "labels"
            },
            {
              "name": "x_label",
              "description": "",
              "type": null,
              "value": "x_label"
            },
            {
              "name": "y_label",
              "description": "",
              "type": null,
              "value": "y_label"
            },
            {
              "name": "lines",
              "description": "",
              "type": null,
              "value": "[]"
            },
            {
              "name": "data",
              "description": "",
              "type": null,
              "value": "[]"
            },
            {
              "name": "last_update",
              "description": "",
              "type": null,
              "value": "time.time()"
            },
            {
              "name": "is_running",
              "description": "",
              "type": null,
              "value": "True"
            },
            {
              "name": "legend",
              "description": "",
              "type": null,
              "value": "None"
            },
            {
              "name": "lined",
              "description": "",
              "type": null,
              "value": "{}"
            }
          ],
          "parameters": [
            {
              "name": "max_samples",
              "type": null,
              "default": "None",
              "description": "maximum number of samples to plot"
            },
            {
              "name": "update_interval",
              "type": null,
              "default": "1",
              "description": "time in seconds between refreshs"
            },
            {
              "name": "labels",
              "type": null,
              "default": "[]",
              "description": "labels for plot traces"
            },
            {
              "name": "x_label",
              "type": null,
              "default": "''",
              "description": "label for x-axis"
            },
            {
              "name": "y_label",
              "type": null,
              "default": "''",
              "description": "label for y-axis"
            }
          ]
        },
        {
          "name": "Spectrum",
          "description": "Block for fourier spectrum analysis (spectrum analyzer).",
          "docstring_html": "<p>Block for fourier spectrum analysis (spectrum analyzer).</p>\n<p>Computes continuous time running fourier transform (RFT) of the incoming signal.</p>\n<p>A time threshold can be set by 't_wait' to start recording data only after the\nsimulation time is larger then the specified waiting time, i.e. 't - t_wait &gt; dt'.\nThis is useful for recording the steady state after all the transients have settled.</p>\n<p>An exponential forgetting factor 'alpha' can be specified for realtime spectral\nanalysis. It biases the spectral components exponentially to the most recent signal\nvalues by applying a single sided exponential window like this:</p>\n<div>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\">\n  <msubsup>\n    <mo>∫</mo>\n    <mn>0</mn>\n    <mi>t</mi>\n  </msubsup>\n  <mi>u</mi>\n  <mo stretchy=\"false\">(</mo>\n  <mi>τ</mi>\n  <mo stretchy=\"false\">)</mo>\n  <mi>exp</mi>\n  <mo>&ApplyFunction;</mo>\n  <mo stretchy=\"false\">(</mo>\n  <mi>α</mi>\n  <mo stretchy=\"false\">(</mo>\n  <mi>t</mi>\n  <mo>−</mo>\n  <mi>τ</mi>\n  <mo stretchy=\"false\">)</mo>\n  <mo stretchy=\"false\">)</mo>\n  <mi>exp</mi>\n  <mo>&ApplyFunction;</mo>\n  <mo stretchy=\"false\">(</mo>\n  <mo form=\"prefix\">−</mo>\n  <mi>j</mi>\n  <mi>ω</mi>\n  <mi>τ</mi>\n  <mo stretchy=\"false\">)</mo>\n  <mspace width=\"0.25em\"></mspace>\n  <mi>d</mi>\n  <mi>τ</mi>\n</math>\n</div>\n<p>It is also known as the 'exponentially forgetting transform' (EFT) and a form of\nshort time fourier transform (STFT). It is implemented as a 1st order statespace model</p>\n<div>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\">\n  <mover accent=\"true\">\n    <mi>x</mi>\n    <mo stretchy=\"false\">˙</mo>\n  </mover>\n  <mo>=</mo>\n  <mo form=\"prefix\">−</mo>\n  <mi>α</mi>\n  <mi>x</mi>\n  <mo>+</mo>\n  <mi>exp</mi>\n  <mo>&ApplyFunction;</mo>\n  <mo stretchy=\"false\">(</mo>\n  <mo form=\"prefix\">−</mo>\n  <mi>j</mi>\n  <mi>ω</mi>\n  <mi>t</mi>\n  <mo stretchy=\"false\">)</mo>\n  <mi>u</mi>\n</math>\n</div>\n<p>where 'u' is the input signal and 'x' is the state variable that represents the\ncomplex fourier coefficient to the frequency 'omega'. The ODE is integrated using the\nnumerical integration engine of the block.</p>\n<div class=\"section\" id=\"example\">\n<h4>Example</h4>\n<p>This is how to initialize it:</p>\n<pre class=\"code python literal-block\">\nimport numpy as np\n\n#linear frequencies (0Hz, DC -&gt; 1kHz)\nsp1 = Spectrum(\n    freq=np.linspace(0, 1e3, 100),\n    labels=['x1', 'x2'] #labels for two inputs\n    )\n\n#log frequencies (1Hz -&gt; 1kHz)\nsp2 = Spectrum(\n    freq=np.logspace(0, 3, 100)\n    )\n\n#log frequencies including DC (0Hz, DC + 1Hz -&gt; 1kHz)\nsp3 = Spectrum(\n    freq=np.hstack([0.0, np.logspace(0, 3, 100)])\n    )\n\n#arbitrary frequencies\nsp4 = Spectrum(\n    freq=np.array([0, 0.5, 20, 1e3])\n    )\n</pre>\n</div>\n<div class=\"section\" id=\"note\">\n<h4>Note</h4>\n<p>This block is relatively slow! But it is valuable for long running simulations\nwith few evaluation frequencies, where just FFT'ing the time series data\nwouldnt be efficient OR if only the evaluation at weirdly spaced frequencies\nis required. Otherwise its more efficient to just do an FFT on the time\nseries recording after the simulation has finished.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>freq <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array[float]</span></dt>\n<dd>list of evaluation frequencies for RFT, can be arbitrarily spaced</dd>\n<dt>t_wait <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>wait time before starting RFT</dd>\n<dt>alpha <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>exponential forgetting factor for realtime spectrum</dd>\n<dt>labels <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">list[str]</span></dt>\n<dd>labels for the inputs</dd>\n</dl>\n</div>\n",
          "bases": [
            "Block"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "signature": "(freq = [], t_wait = 0.0, alpha = 0.0, labels = [])",
              "parameters": [
                {
                  "name": "freq",
                  "type": null,
                  "default": "[]",
                  "description": ""
                },
                {
                  "name": "t_wait",
                  "type": null,
                  "default": "0.0",
                  "description": ""
                },
                {
                  "name": "alpha",
                  "type": null,
                  "default": "0.0",
                  "description": ""
                },
                {
                  "name": "labels",
                  "type": null,
                  "default": "[]",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "reset",
              "description": "",
              "docstring_html": "",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "read",
              "description": "Read the recorded spectrum",
              "docstring_html": "<p>Read the recorded spectrum</p>\n<div class=\"section\" id=\"example\">\n<h4>Example</h4>\n<p>This is how to get the recorded spectrum:</p>\n<pre class=\"code python literal-block\">\nimport numpy as np\n\n#linear frequencies (0Hz, DC -&gt; 1kHz)\nspc = Spectrum(\n    freq=np.linspace(0, 1e3, 100),\n    labels=['x1', 'x2'] #labels for two inputs\n    )\n\n#... run the simulation ...\n\n#read the complex spectra of x1 and x2\nfreq, [X1, X2] = spc.read()\n</pre>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>freq <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array[float]</span></dt>\n<dd>evaluation frequencies</dd>\n<dt>spec <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array[complex]</span></dt>\n<dd>complex spectrum</dd>\n</dl>\n</div>\n",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "collect",
              "description": "Yield (category, id, data) tuples for recording blocks to simplify",
              "docstring_html": "<p>Yield (category, id, data) tuples for recording blocks to simplify\nglobal data collection from all recording blocks.</p>\n",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "solve",
              "description": "advance solution of implicit update equation of the solver",
              "docstring_html": "<p>advance solution of implicit update equation of the solver</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time</dd>\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>integration timestep</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>error <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>solver residual norm</dd>\n</dl>\n",
              "signature": "(t, dt)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time"
                },
                {
                  "name": "dt",
                  "type": null,
                  "default": null,
                  "description": "integration timestep"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "step",
              "description": "compute timestep update with integration engine",
              "docstring_html": "<p>compute timestep update with integration engine</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time</dd>\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>integration timestep</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>success <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>step was successful</dd>\n<dt>error <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>local truncation error from adaptive integrators</dd>\n<dt>scale <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>timestep rescale from adaptive integrators</dd>\n</dl>\n",
              "signature": "(t, dt)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time"
                },
                {
                  "name": "dt",
                  "type": null,
                  "default": null,
                  "description": "integration timestep"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "sample",
              "description": "sample time of successfull timestep for waiting period",
              "docstring_html": "<p>sample time of successfull timestep for waiting period</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>sampling time</dd>\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>integration timestep</dd>\n</dl>\n",
              "signature": "(t, dt)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "sampling time"
                },
                {
                  "name": "dt",
                  "type": null,
                  "default": null,
                  "description": "integration timestep"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "plot",
              "description": "Directly create a plot of the recorded data for visualization.",
              "docstring_html": "<p>Directly create a plot of the recorded data for visualization.</p>\n<p>The 'fig' and 'ax' objects are accessible as attributes of the 'Spectrum' instance\nfrom the outside for saving, or modification, etc.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>args <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">tuple</span></dt>\n<dd>args for ax.plot</dd>\n<dt>kwargs <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">dict</span></dt>\n<dd>kwargs for ax.plot</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>fig <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">matplotlib.figure</span></dt>\n<dd>internal figure instance</dd>\n<dt>ax <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">matplotlib.axis</span></dt>\n<dd>internal axis instance</dd>\n</dl>\n",
              "signature": "(args = (), kwargs = {})",
              "parameters": [
                {
                  "name": "args",
                  "type": null,
                  "default": "()",
                  "description": "args for ax.plot"
                },
                {
                  "name": "kwargs",
                  "type": null,
                  "default": "{}",
                  "description": "kwargs for ax.plot"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "save",
              "description": "Save the recording of the spectrum to a csv file",
              "docstring_html": "<p>Save the recording of the spectrum to a csv file</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>path <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">str</span></dt>\n<dd>path where to save the recording as a csv file</dd>\n</dl>\n",
              "signature": "(path = 'spectrum.csv')",
              "parameters": [
                {
                  "name": "path",
                  "type": null,
                  "default": "'spectrum.csv'",
                  "description": "path where to save the recording as a csv file"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "update",
              "description": "update system equation for fixed point loop,",
              "docstring_html": "<p>update system equation for fixed point loop,\nhere just setting the outputs</p>\n<div class=\"section\" id=\"note\">\n<h4>Note</h4>\n<p>Spectrum block has no passthrough, so the 'update' method\nis optimized for this case</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time</dd>\n</dl>\n</div>\n",
              "signature": "(t)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time"
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "input_port_labels",
              "description": "",
              "type": null,
              "value": "None"
            },
            {
              "name": "output_port_labels",
              "description": "",
              "type": null,
              "value": "{}"
            },
            {
              "name": "t_wait",
              "description": "",
              "type": null,
              "value": "t_wait"
            },
            {
              "name": "t_sample",
              "description": "",
              "type": null,
              "value": "0.0"
            },
            {
              "name": "time",
              "description": "",
              "type": null,
              "value": "0.0"
            },
            {
              "name": "alpha",
              "description": "",
              "type": null,
              "value": "alpha"
            },
            {
              "name": "labels",
              "description": "",
              "type": null,
              "value": "labels"
            },
            {
              "name": "freq",
              "description": "",
              "type": null,
              "value": "np.array(freq)"
            },
            {
              "name": "omega",
              "description": "",
              "type": null,
              "value": "2.0 * np.pi * self.freq"
            },
            {
              "name": "initial_value",
              "description": "",
              "type": null,
              "value": "0.0"
            }
          ],
          "parameters": [
            {
              "name": "freq",
              "type": null,
              "default": "[]",
              "description": "list of evaluation frequencies for RFT, can be arbitrarily spaced"
            },
            {
              "name": "t_wait",
              "type": null,
              "default": "0.0",
              "description": "wait time before starting RFT"
            },
            {
              "name": "alpha",
              "type": null,
              "default": "0.0",
              "description": "exponential forgetting factor for realtime spectrum"
            },
            {
              "name": "labels",
              "type": null,
              "default": "[]",
              "description": "labels for the inputs"
            }
          ]
        },
        {
          "name": "RealtimeSpectrum",
          "description": "An extension of the 'Spectrum' block that also initializes a realtime plotter.",
          "docstring_html": "<p>An extension of the 'Spectrum' block that also initializes a realtime plotter.</p>\n<p>Creates an interactive plotting window while the simulation is running.\nOtherwise implements the same functionality as the regular 'Spectrum' block.</p>\n<div class=\"section\" id=\"note\">\n<h4>Note</h4>\n<p>Due to the plotting being relatively expensive, including this block slows down\nthe simulation significantly but may still be valuable for debugging and testing.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>freq <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array[float]</span></dt>\n<dd>list of evaluation frequencies for RFT, can be arbitrarily spaced</dd>\n<dt>t_wait <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>wait time before starting RFT</dd>\n<dt>alpha <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>exponential forgetting factor for realtime spectrum</dd>\n<dt>labels <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">list[str]</span></dt>\n<dd>labels for the inputs</dd>\n</dl>\n</div>\n",
          "bases": [
            "Spectrum"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "signature": "(freq = [], t_wait = 0.0, alpha = 0.0, labels = [])",
              "parameters": [
                {
                  "name": "freq",
                  "type": null,
                  "default": "[]",
                  "description": ""
                },
                {
                  "name": "t_wait",
                  "type": null,
                  "default": "0.0",
                  "description": ""
                },
                {
                  "name": "alpha",
                  "type": null,
                  "default": "0.0",
                  "description": ""
                },
                {
                  "name": "labels",
                  "type": null,
                  "default": "[]",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "step",
              "description": "compute timestep update with integration engine",
              "docstring_html": "<p>compute timestep update with integration engine</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time</dd>\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>integration timestep</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>success <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>step was successful</dd>\n<dt>error <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>local truncation error from adaptive integrators</dd>\n<dt>scale <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>timestep rescale from adaptive integrators</dd>\n</dl>\n",
              "signature": "(t, dt)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time"
                },
                {
                  "name": "dt",
                  "type": null,
                  "default": null,
                  "description": "integration timestep"
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "plotter",
              "description": "",
              "type": null,
              "value": "RealtimePlotter(update_interval=0.1, labels=labels, x_label='freq [Hz]', y_label='magnitude')"
            }
          ],
          "parameters": [
            {
              "name": "freq",
              "type": null,
              "default": "[]",
              "description": "list of evaluation frequencies for RFT, can be arbitrarily spaced"
            },
            {
              "name": "t_wait",
              "type": null,
              "default": "0.0",
              "description": "wait time before starting RFT"
            },
            {
              "name": "alpha",
              "type": null,
              "default": "0.0",
              "description": "exponential forgetting factor for realtime spectrum"
            },
            {
              "name": "labels",
              "type": null,
              "default": "[]",
              "description": "labels for the inputs"
            }
          ]
        },
        {
          "name": "ScheduleList",
          "description": "Subclass of base 'Schedule' that triggers dependent on the evaluation time.",
          "docstring_html": "<p>Subclass of base 'Schedule' that triggers dependent on the evaluation time.</p>\n<p>Monitors time in every timestep and triggers at the next event time from the\ntime list. This event does not have an event function as the event condition\nonly depends on time.</p>\n<pre class=\"code literal-block\">\ntime == next_scheduled_time -&gt; event\n</pre>\n<div class=\"section\" id=\"example\">\n<h4>Example</h4>\n<p>Initialize a scheduled event handler like this:</p>\n<pre class=\"code python literal-block\">\n#define the action function (callback)\ndef act(t):\n    #do something at event resolution\n    pass\n\n#initialize the event manager\nE = ScheduleList(\n    times_evt=[1, 5, 12, 300],  #event times where to trigger\n    func_act=act                #resulting in a callback\n    )\n</pre>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>times_evt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">list[float]</span></dt>\n<dd>list of event times in ascending order</dd>\n<dt>func_act <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">callable</span></dt>\n<dd>action function for event resolution</dd>\n<dt>tolerance <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>tolerance to check if detection is close to actual event</dd>\n</dl>\n</div>\n",
          "bases": [
            "Schedule"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "signature": "(times_evt, func_act = None, tolerance = TOLERANCE)",
              "parameters": [
                {
                  "name": "times_evt",
                  "type": null,
                  "default": null,
                  "description": ""
                },
                {
                  "name": "func_act",
                  "type": null,
                  "default": "None",
                  "description": ""
                },
                {
                  "name": "tolerance",
                  "type": null,
                  "default": "TOLERANCE",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "detect",
              "description": "Check if the event condition is satisfied, i.e. if the",
              "docstring_html": "<p>Check if the event condition is satisfied, i.e. if the\ntime period switch is within the current timestep.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time for detection</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>detected <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>was an event detected?</dd>\n<dt>close <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>are we close to the event?</dd>\n<dt>ratio <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>interpolated event location ratio in timestep</dd>\n</dl>\n",
              "signature": "(t)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time for detection"
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "times_evt",
              "description": "",
              "type": null,
              "value": "times_evt"
            }
          ],
          "parameters": [
            {
              "name": "times_evt",
              "type": null,
              "default": null,
              "description": "list of event times in ascending order"
            },
            {
              "name": "func_act",
              "type": null,
              "default": "None",
              "description": "action function for event resolution"
            },
            {
              "name": "tolerance",
              "type": null,
              "default": "TOLERANCE",
              "description": "tolerance to check if detection is close to actual event"
            }
          ]
        },
        {
          "name": "Constant",
          "description": "Produces a constant output signal (SISO).",
          "docstring_html": "<p>Produces a constant output signal (SISO).</p>\n<div>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\">\n  <mi>y</mi>\n  <mo stretchy=\"false\">(</mo>\n  <mi>t</mi>\n  <mo stretchy=\"false\">)</mo>\n  <mo>=</mo>\n  <mi>c</mi>\n  <mi>o</mi>\n  <mi>n</mi>\n  <mi>s</mi>\n  <mi>t</mi>\n  <mo>.</mo>\n</math>\n</div>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>value <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>constant defining block output</dd>\n</dl>\n",
          "bases": [
            "Block"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "signature": "(value = 1)",
              "parameters": [
                {
                  "name": "value",
                  "type": null,
                  "default": "1",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "update",
              "description": "update system equation fixed point loop",
              "docstring_html": "<p>update system equation fixed point loop</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>error <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>absolute error to previous iteration for convergence\ncontrol (always '0.0' because source-type)</dd>\n</dl>\n",
              "signature": "(t)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time"
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "input_port_labels",
              "description": "",
              "type": null,
              "value": "{}"
            },
            {
              "name": "output_port_labels",
              "description": "",
              "type": null,
              "value": "{'out': 0}"
            },
            {
              "name": "value",
              "description": "",
              "type": null,
              "value": "value"
            }
          ],
          "parameters": [
            {
              "name": "value",
              "type": null,
              "default": "1",
              "description": "constant defining block output"
            }
          ]
        },
        {
          "name": "Source",
          "description": "Source that produces an arbitrary time dependent output defined by `func` (callable).",
          "docstring_html": "<p>Source that produces an arbitrary time dependent output defined by <cite>func</cite> (callable).</p>\n<div>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\">\n  <mi>y</mi>\n  <mo stretchy=\"false\">(</mo>\n  <mi>t</mi>\n  <mo stretchy=\"false\">)</mo>\n  <mo>=</mo>\n  <mi>func</mi>\n  <mo stretchy=\"false\">(</mo>\n  <mi>t</mi>\n  <mo stretchy=\"false\">)</mo>\n</math>\n</div>\n<div class=\"section\" id=\"note\">\n<h4>Note</h4>\n<p>This block is purely algebraic and its internal function (<cite>func</cite>) will\nbe called multiple times per timestep, each time when <cite>Simulation._update(t)</cite>\nis called in the global simulation loop.</p>\n</div>\n<div class=\"section\" id=\"example\">\n<h4>Example</h4>\n<p>For example a ramp:</p>\n<pre class=\"code python literal-block\">\nfrom pathsim.blocks import Source\n\nsrc = Source(lambda t : t)\n</pre>\n<p>or a simple sinusoid with some frequency:</p>\n<pre class=\"code python literal-block\">\nimport numpy as np\nfrom pathsim.blocks import Source\n\n#some parameter\nomega = 100\n\n#the function that gets evaluated\ndef f(t):\n    return np.sin(omega * t)\n\nsrc = Source(f)\n</pre>\n<p>Because the <cite>Source</cite> block only has a single argument, it can be\nused to decorate a function and make it a <cite>PathSim</cite> block. This might\nbe handy in some cases to keep definitions concise and localized\nin the code:</p>\n<pre class=\"code python literal-block\">\nimport numpy as np\nfrom pathsim.blocks import Source\n\n#does the same as the definition above\n\n&#64;Source\ndef src(t):\n    omega = 100\n    return np.sin(omega * t)\n\n#'src' is now a PathSim block\n</pre>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>func <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">callable</span></dt>\n<dd>function defining time dependent block output</dd>\n</dl>\n</div>\n",
          "bases": [
            "Block"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "signature": "(func = lambda t: 1)",
              "parameters": [
                {
                  "name": "func",
                  "type": null,
                  "default": "lambda t: 1",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "update",
              "description": "update system equation fixed point loop",
              "docstring_html": "<p>update system equation fixed point loop\nby evaluating the internal function 'func'</p>\n<div class=\"section\" id=\"note\">\n<h4>Note</h4>\n<p>No direct passthrough, so the <cite>update</cite> method\nis optimized and has no convergence check</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time</dd>\n</dl>\n</div>\n",
              "signature": "(t)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time"
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "input_port_labels",
              "description": "",
              "type": null,
              "value": "{}"
            },
            {
              "name": "output_port_labels",
              "description": "",
              "type": null,
              "value": "{'out': 0}"
            },
            {
              "name": "func",
              "description": "",
              "type": null,
              "value": "func"
            }
          ],
          "parameters": [
            {
              "name": "func",
              "type": null,
              "default": "lambda t: 1",
              "description": "function defining time dependent block output"
            }
          ]
        },
        {
          "name": "TriangleWaveSource",
          "description": "Source block that generates an analog triangle wave",
          "docstring_html": "<p>Source block that generates an analog triangle wave</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>frequency <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>frequency of the triangle wave</dd>\n<dt>amplitude <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>amplitude of the triangle wave</dd>\n<dt>phase <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>phase of the triangle wave</dd>\n</dl>\n",
          "bases": [
            "Source"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "signature": "(frequency = 1, amplitude = 1, phase = 0)",
              "parameters": [
                {
                  "name": "frequency",
                  "type": null,
                  "default": "1",
                  "description": ""
                },
                {
                  "name": "amplitude",
                  "type": null,
                  "default": "1",
                  "description": ""
                },
                {
                  "name": "phase",
                  "type": null,
                  "default": "0",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "amplitude",
              "description": "",
              "type": null,
              "value": "amplitude"
            },
            {
              "name": "frequency",
              "description": "",
              "type": null,
              "value": "frequency"
            },
            {
              "name": "phase",
              "description": "",
              "type": null,
              "value": "phase"
            }
          ],
          "parameters": [
            {
              "name": "frequency",
              "type": null,
              "default": "1",
              "description": "frequency of the triangle wave"
            },
            {
              "name": "amplitude",
              "type": null,
              "default": "1",
              "description": "amplitude of the triangle wave"
            },
            {
              "name": "phase",
              "type": null,
              "default": "0",
              "description": "phase of the triangle wave"
            }
          ]
        },
        {
          "name": "SinusoidalSource",
          "description": "Source block that generates a sinusoid wave",
          "docstring_html": "<p>Source block that generates a sinusoid wave</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>frequency <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>frequency of the sinusoid</dd>\n<dt>amplitude <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>amplitude of the sinusoid</dd>\n<dt>phase <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>phase of the sinusoid</dd>\n</dl>\n",
          "bases": [
            "Source"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "signature": "(frequency = 1, amplitude = 1, phase = 0)",
              "parameters": [
                {
                  "name": "frequency",
                  "type": null,
                  "default": "1",
                  "description": ""
                },
                {
                  "name": "amplitude",
                  "type": null,
                  "default": "1",
                  "description": ""
                },
                {
                  "name": "phase",
                  "type": null,
                  "default": "0",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "amplitude",
              "description": "",
              "type": null,
              "value": "amplitude"
            },
            {
              "name": "frequency",
              "description": "",
              "type": null,
              "value": "frequency"
            },
            {
              "name": "phase",
              "description": "",
              "type": null,
              "value": "phase"
            }
          ],
          "parameters": [
            {
              "name": "frequency",
              "type": null,
              "default": "1",
              "description": "frequency of the sinusoid"
            },
            {
              "name": "amplitude",
              "type": null,
              "default": "1",
              "description": "amplitude of the sinusoid"
            },
            {
              "name": "phase",
              "type": null,
              "default": "0",
              "description": "phase of the sinusoid"
            }
          ]
        },
        {
          "name": "GaussianPulseSource",
          "description": "Source block that generates a gaussian pulse",
          "docstring_html": "<p>Source block that generates a gaussian pulse</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>amplitude <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>amplitude of the gaussian pulse</dd>\n<dt>f_max <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>maximum frequency component of the gaussian pulse (steepness)</dd>\n<dt>tau <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>time delay of the gaussian pulse</dd>\n</dl>\n",
          "bases": [
            "Source"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "signature": "(amplitude = 1, f_max = 1000.0, tau = 0.0)",
              "parameters": [
                {
                  "name": "amplitude",
                  "type": null,
                  "default": "1",
                  "description": ""
                },
                {
                  "name": "f_max",
                  "type": null,
                  "default": "1000.0",
                  "description": ""
                },
                {
                  "name": "tau",
                  "type": null,
                  "default": "0.0",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "outputs",
              "description": "",
              "type": null,
              "value": "Register(mapping={'out': 0})"
            },
            {
              "name": "amplitude",
              "description": "",
              "type": null,
              "value": "amplitude"
            },
            {
              "name": "f_max",
              "description": "",
              "type": null,
              "value": "f_max"
            },
            {
              "name": "tau",
              "description": "",
              "type": null,
              "value": "tau"
            }
          ],
          "parameters": [
            {
              "name": "amplitude",
              "type": null,
              "default": "1",
              "description": "amplitude of the gaussian pulse"
            },
            {
              "name": "f_max",
              "type": null,
              "default": "1000.0",
              "description": "maximum frequency component of the gaussian pulse (steepness)"
            },
            {
              "name": "tau",
              "type": null,
              "default": "0.0",
              "description": "time delay of the gaussian pulse"
            }
          ]
        },
        {
          "name": "SinusoidalPhaseNoiseSource",
          "description": "Sinusoidal source with cumulative and white phase noise.",
          "docstring_html": "<p>Sinusoidal source with cumulative and white phase noise.</p>\n<p>Generates a sinusoid with additive phase noise from two components:</p>\n<ul class=\"simple\">\n<li>White phase noise: sampled from a normal distribution at each sample</li>\n<li>Cumulative phase noise: integrated random walk process</li>\n</ul>\n<p>The output is given by:</p>\n<div>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\">\n  <mi>y</mi>\n  <mo stretchy=\"false\">(</mo>\n  <mi>t</mi>\n  <mo stretchy=\"false\">)</mo>\n  <mo>=</mo>\n  <mi>A</mi>\n  <mi>sin</mi>\n  <mo>&ApplyFunction;</mo>\n  <mrow>\n    <mo>(</mo>\n    <mi>ω</mi>\n    <mi>t</mi>\n    <mo>+</mo>\n    <msub>\n      <mi>φ</mi>\n      <mn>0</mn>\n    </msub>\n    <mo>+</mo>\n    <msub>\n      <mi>σ</mi>\n      <mi>w</mi>\n    </msub>\n    <msub>\n      <mi>n</mi>\n      <mi>w</mi>\n    </msub>\n    <mo stretchy=\"false\">(</mo>\n    <mi>t</mi>\n    <mo stretchy=\"false\">)</mo>\n    <mo>+</mo>\n    <msub>\n      <mi>σ</mi>\n      <mi>c</mi>\n    </msub>\n    <msubsup>\n      <mo>∫</mo>\n      <mn>0</mn>\n      <mi>t</mi>\n    </msubsup>\n    <msub>\n      <mi>n</mi>\n      <mi>c</mi>\n    </msub>\n    <mo stretchy=\"false\">(</mo>\n    <mi>τ</mi>\n    <mo stretchy=\"false\">)</mo>\n    <mi>d</mi>\n    <mi>τ</mi>\n    <mo>)</mo>\n  </mrow>\n</math>\n</div>\n<p>where <math xmlns=\"http://www.w3.org/1998/Math/MathML\">\n  <mi>A</mi>\n</math> is amplitude, <math xmlns=\"http://www.w3.org/1998/Math/MathML\">\n  <mi>ω</mi>\n  <mo>=</mo>\n  <mn>2</mn>\n  <mi>π</mi>\n  <mi>f</mi>\n</math> is angular frequency,\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\">\n  <msub>\n    <mi>φ</mi>\n    <mn>0</mn>\n  </msub>\n</math> is initial phase, <math xmlns=\"http://www.w3.org/1998/Math/MathML\">\n  <msub>\n    <mi>σ</mi>\n    <mi>w</mi>\n  </msub>\n</math> and <math xmlns=\"http://www.w3.org/1998/Math/MathML\">\n  <msub>\n    <mi>σ</mi>\n    <mi>c</mi>\n  </msub>\n</math> are\nthe white and cumulative noise weights, and <math xmlns=\"http://www.w3.org/1998/Math/MathML\">\n  <msub>\n    <mi>n</mi>\n    <mi>w</mi>\n  </msub>\n  <mo stretchy=\"false\">(</mo>\n  <mi>t</mi>\n  <mo stretchy=\"false\">)</mo>\n</math> and <math xmlns=\"http://www.w3.org/1998/Math/MathML\">\n  <msub>\n    <mi>n</mi>\n    <mi>c</mi>\n  </msub>\n  <mo stretchy=\"false\">(</mo>\n  <mi>t</mi>\n  <mo stretchy=\"false\">)</mo>\n</math> are\nindependent standard normal random processes sampled at the specified sampling period.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>frequency <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>frequency of the sinusoid</dd>\n<dt>amplitude <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>amplitude of the sinusoid</dd>\n<dt>phase <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>initial phase of the sinusoid (radians)</dd>\n<dt>sig_cum <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>weight for cumulative phase noise contribution</dd>\n<dt>sig_white <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>weight for white phase noise contribution</dd>\n<dt>sampling_period <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float, None</span></dt>\n<dd>time between phase noise samples. If None,\nnoise is sampled every timestep (default is 0.1)</dd>\n</dl>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>omega <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>angular frequency of the sinusoid, derived from <cite>frequency</cite></dd>\n<dt>noise_1 <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>internal noise value for white phase noise</dd>\n<dt>noise_2 <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>internal noise value for cumulative phase noise</dd>\n<dt>events <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">list[Schedule]</span></dt>\n<dd>scheduled event for periodic sampling (only if sampling_period is set)</dd>\n</dl>\n",
          "bases": [
            "Block"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "signature": "(frequency = 1, amplitude = 1, phase = 0, sig_cum = 0, sig_white = 0, sampling_period = 0.1)",
              "parameters": [
                {
                  "name": "frequency",
                  "type": null,
                  "default": "1",
                  "description": ""
                },
                {
                  "name": "amplitude",
                  "type": null,
                  "default": "1",
                  "description": ""
                },
                {
                  "name": "phase",
                  "type": null,
                  "default": "0",
                  "description": ""
                },
                {
                  "name": "sig_cum",
                  "type": null,
                  "default": "0",
                  "description": ""
                },
                {
                  "name": "sig_white",
                  "type": null,
                  "default": "0",
                  "description": ""
                },
                {
                  "name": "sampling_period",
                  "type": null,
                  "default": "0.1",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "reset",
              "description": "Reset block state including noise samples.",
              "docstring_html": "<p>Reset block state including noise samples.</p>\n",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "update",
              "description": "Update system equation for fixed point loop, evaluating the",
              "docstring_html": "<p>Update system equation for fixed point loop, evaluating the\nsinusoid with phase noise.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time</dd>\n</dl>\n",
              "signature": "(t)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "sample",
              "description": "Sample from a normal distribution after successful timestep.",
              "docstring_html": "<p>Sample from a normal distribution after successful timestep.</p>\n<p>Only used when sampling_period is None (continuous sampling).</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time</dd>\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>integration timestep</dd>\n</dl>\n",
              "signature": "(t, dt)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time"
                },
                {
                  "name": "dt",
                  "type": null,
                  "default": null,
                  "description": "integration timestep"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "solve",
              "description": "Advance solution of implicit update equation for cumulative noise integration.",
              "docstring_html": "<p>Advance solution of implicit update equation for cumulative noise integration.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time</dd>\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>integration timestep</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>float</dt>\n<dd>error estimate (always 0.0 for noise source)</dd>\n</dl>\n",
              "signature": "(t, dt)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time"
                },
                {
                  "name": "dt",
                  "type": null,
                  "default": null,
                  "description": "integration timestep Returns ------- float error estimate (always 0.0 for noise source)"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "step",
              "description": "Compute update step with integration engine for cumulative noise.",
              "docstring_html": "<p>Compute update step with integration engine for cumulative noise.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time</dd>\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>integration timestep</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>tuple</dt>\n<dd>(accepted, error, scale_factor) - always (True, 0.0, None) for noise</dd>\n</dl>\n",
              "signature": "(t, dt)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time"
                },
                {
                  "name": "dt",
                  "type": null,
                  "default": null,
                  "description": "integration timestep Returns ------- tuple (accepted, error, scale_factor) - always (True, 0.0, None) for noise"
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "input_port_labels",
              "description": "",
              "type": null,
              "value": "{}"
            },
            {
              "name": "output_port_labels",
              "description": "",
              "type": null,
              "value": "{'out': 0}"
            },
            {
              "name": "amplitude",
              "description": "",
              "type": null,
              "value": "amplitude"
            },
            {
              "name": "frequency",
              "description": "",
              "type": null,
              "value": "frequency"
            },
            {
              "name": "phase",
              "description": "",
              "type": null,
              "value": "phase"
            },
            {
              "name": "sampling_period",
              "description": "",
              "type": null,
              "value": "sampling_period"
            },
            {
              "name": "omega",
              "description": "",
              "type": null,
              "value": "2 * np.pi * self.frequency"
            },
            {
              "name": "sig_cum",
              "description": "",
              "type": null,
              "value": "sig_cum"
            },
            {
              "name": "sig_white",
              "description": "",
              "type": null,
              "value": "sig_white"
            },
            {
              "name": "noise_1",
              "description": "",
              "type": null,
              "value": "np.random.normal()"
            },
            {
              "name": "noise_2",
              "description": "",
              "type": null,
              "value": "np.random.normal()"
            },
            {
              "name": "initial_value",
              "description": "",
              "type": null,
              "value": "0.0"
            },
            {
              "name": "events",
              "description": "",
              "type": null,
              "value": "[Schedule(t_start=0, t_period=sampling_period, func_act=_sample_noise)]"
            }
          ],
          "parameters": [
            {
              "name": "frequency",
              "type": null,
              "default": "1",
              "description": "frequency of the sinusoid"
            },
            {
              "name": "amplitude",
              "type": null,
              "default": "1",
              "description": "amplitude of the sinusoid"
            },
            {
              "name": "phase",
              "type": null,
              "default": "0",
              "description": "initial phase of the sinusoid (radians)"
            },
            {
              "name": "sig_cum",
              "type": null,
              "default": "0",
              "description": "weight for cumulative phase noise contribution"
            },
            {
              "name": "sig_white",
              "type": null,
              "default": "0",
              "description": "weight for white phase noise contribution"
            },
            {
              "name": "sampling_period",
              "type": null,
              "default": "0.1",
              "description": "time between phase noise samples. If None, noise is sampled every timestep (default is 0.1)"
            }
          ]
        },
        {
          "name": "ChirpPhaseNoiseSource",
          "description": "Chirp source, sinusoid with frequency ramp up and ramp down, plus phase noise.",
          "docstring_html": "<p>Chirp source, sinusoid with frequency ramp up and ramp down, plus phase noise.</p>\n<p>This works by using a time dependent triangle wave for the frequency\nand integrating it with a numerical integration engine to get a\ncontinuous phase. This phase is then used to evaluate a sinusoid.</p>\n<p>Additionally the chirp source can have white and cumulative phase noise.\nMathematically it looks like this for the contributions to the phase from\nthe triangular wave:</p>\n<div>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\">\n  <msub>\n    <mi>φ</mi>\n    <mi>t</mi>\n  </msub>\n  <mo stretchy=\"false\">(</mo>\n  <mi>t</mi>\n  <mo stretchy=\"false\">)</mo>\n  <mo>=</mo>\n  <msubsup>\n    <mo>∫</mo>\n    <mn>0</mn>\n    <mi>t</mi>\n  </msubsup>\n  <msub>\n    <mi>tri</mi>\n    <mrow>\n      <msub>\n        <mi>f</mi>\n        <mn>0</mn>\n      </msub>\n      <mo>,</mo>\n      <mi>B</mi>\n      <mo>,</mo>\n      <mi>T</mi>\n    </mrow>\n  </msub>\n  <mo stretchy=\"false\">(</mo>\n  <mi>τ</mi>\n  <mo stretchy=\"false\">)</mo>\n  <mspace width=\"0.1667em\"></mspace>\n  <mi>d</mi>\n  <mi>τ</mi>\n</math>\n</div>\n<p>And from the white (w) and cumulative (c) noise:</p>\n<div>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\">\n  <msub>\n    <mi>φ</mi>\n    <mi>n</mi>\n  </msub>\n  <mo stretchy=\"false\">(</mo>\n  <mi>t</mi>\n  <mo stretchy=\"false\">)</mo>\n  <mo>=</mo>\n  <msub>\n    <mi>σ</mi>\n    <mi>w</mi>\n  </msub>\n  <mspace width=\"0.1667em\"></mspace>\n  <msub>\n    <mi>n</mi>\n    <mi>w</mi>\n  </msub>\n  <mo stretchy=\"false\">(</mo>\n  <mi>t</mi>\n  <mo stretchy=\"false\">)</mo>\n  <mo>+</mo>\n  <msub>\n    <mi>σ</mi>\n    <mi>c</mi>\n  </msub>\n  <msubsup>\n    <mo>∫</mo>\n    <mn>0</mn>\n    <mi>t</mi>\n  </msubsup>\n  <msub>\n    <mi>n</mi>\n    <mi>c</mi>\n  </msub>\n  <mo stretchy=\"false\">(</mo>\n  <mi>τ</mi>\n  <mo stretchy=\"false\">)</mo>\n  <mspace width=\"0.1667em\"></mspace>\n  <mi>d</mi>\n  <mi>τ</mi>\n</math>\n</div>\n<p>The phase contributions are then used to evaluate a sinusoid to get the final chirp signal:</p>\n<div>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\">\n  <mi>y</mi>\n  <mo stretchy=\"false\">(</mo>\n  <mi>t</mi>\n  <mo stretchy=\"false\">)</mo>\n  <mo>=</mo>\n  <mi>A</mi>\n  <mi>sin</mi>\n  <mo>&ApplyFunction;</mo>\n  <mo stretchy=\"false\">(</mo>\n  <msub>\n    <mi>φ</mi>\n    <mi>t</mi>\n  </msub>\n  <mo stretchy=\"false\">(</mo>\n  <mi>t</mi>\n  <mo stretchy=\"false\">)</mo>\n  <mo>+</mo>\n  <msub>\n    <mi>φ</mi>\n    <mi>n</mi>\n  </msub>\n  <mo stretchy=\"false\">(</mo>\n  <mi>t</mi>\n  <mo stretchy=\"false\">)</mo>\n  <mo>+</mo>\n  <msub>\n    <mi>φ</mi>\n    <mn>0</mn>\n  </msub>\n  <mo stretchy=\"false\">)</mo>\n</math>\n</div>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>amplitude <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>amplitude of the chirp signal</dd>\n<dt>f0 <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>start frequency of the chirp signal</dd>\n<dt>BW <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>bandwidth of the frequency ramp of the chirp signal</dd>\n<dt>T <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>period of the frequency ramp of the chirp signal</dd>\n<dt>phase <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>phase of sinusoid (initial, radians)</dd>\n<dt>sig_cum <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>weight for cumulative phase noise contribution</dd>\n<dt>sig_white <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>weight for white phase noise contribution</dd>\n<dt>sampling_period <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float, None</span></dt>\n<dd>time between phase noise samples. If None,\nnoise is sampled every timestep (default is 0.1)</dd>\n</dl>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>noise_1 <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>internal noise value for white phase noise</dd>\n<dt>noise_2 <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>internal noise value for cumulative phase noise</dd>\n<dt>events <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">list[Schedule]</span></dt>\n<dd>scheduled event for periodic sampling (only if sampling_period is set)</dd>\n</dl>\n",
          "bases": [
            "Block"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "signature": "(amplitude = 1, f0 = 1, BW = 1, T = 1, phase = 0, sig_cum = 0, sig_white = 0, sampling_period = 0.1)",
              "parameters": [
                {
                  "name": "amplitude",
                  "type": null,
                  "default": "1",
                  "description": ""
                },
                {
                  "name": "f0",
                  "type": null,
                  "default": "1",
                  "description": ""
                },
                {
                  "name": "BW",
                  "type": null,
                  "default": "1",
                  "description": ""
                },
                {
                  "name": "T",
                  "type": null,
                  "default": "1",
                  "description": ""
                },
                {
                  "name": "phase",
                  "type": null,
                  "default": "0",
                  "description": ""
                },
                {
                  "name": "sig_cum",
                  "type": null,
                  "default": "0",
                  "description": ""
                },
                {
                  "name": "sig_white",
                  "type": null,
                  "default": "0",
                  "description": ""
                },
                {
                  "name": "sampling_period",
                  "type": null,
                  "default": "0.1",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "reset",
              "description": "Reset block state including noise samples.",
              "docstring_html": "<p>Reset block state including noise samples.</p>\n",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "sample",
              "description": "Sample from a normal distribution after successful timestep",
              "docstring_html": "<p>Sample from a normal distribution after successful timestep\nto update internal noise samples.</p>\n<p>Only used when sampling_period is None (continuous sampling).</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time</dd>\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>integration timestep</dd>\n</dl>\n",
              "signature": "(t, dt)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time"
                },
                {
                  "name": "dt",
                  "type": null,
                  "default": null,
                  "description": "integration timestep"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "update",
              "description": "Update the block output, assemble phase and evaluate the sinusoid.",
              "docstring_html": "<p>Update the block output, assemble phase and evaluate the sinusoid.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time</dd>\n</dl>\n",
              "signature": "(t)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "solve",
              "description": "Advance implicit solver of implicit integration engine, evaluate",
              "docstring_html": "<p>Advance implicit solver of implicit integration engine, evaluate\nthe triangle wave and cumulative noise RNG.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time</dd>\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>integration timestep</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>float</dt>\n<dd>error estimate (always 0.0 for chirp source)</dd>\n</dl>\n",
              "signature": "(t, dt)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time"
                },
                {
                  "name": "dt",
                  "type": null,
                  "default": null,
                  "description": "integration timestep Returns ------- float error estimate (always 0.0 for chirp source)"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "step",
              "description": "Compute update step with integration engine, evaluate the triangle wave",
              "docstring_html": "<p>Compute update step with integration engine, evaluate the triangle wave\nand cumulative noise RNG.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time</dd>\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>integration timestep</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>tuple</dt>\n<dd>(accepted, error, scale_factor) - always (True, 0.0, None) for chirp</dd>\n</dl>\n",
              "signature": "(t, dt)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time"
                },
                {
                  "name": "dt",
                  "type": null,
                  "default": null,
                  "description": "integration timestep Returns ------- tuple (accepted, error, scale_factor) - always (True, 0.0, None) for chirp"
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "input_port_labels",
              "description": "",
              "type": null,
              "value": "{}"
            },
            {
              "name": "output_port_labels",
              "description": "",
              "type": null,
              "value": "{'out': 0}"
            },
            {
              "name": "amplitude",
              "description": "",
              "type": null,
              "value": "amplitude"
            },
            {
              "name": "phase",
              "description": "",
              "type": null,
              "value": "phase"
            },
            {
              "name": "f0",
              "description": "",
              "type": null,
              "value": "f0"
            },
            {
              "name": "BW",
              "description": "",
              "type": null,
              "value": "BW"
            },
            {
              "name": "T",
              "description": "",
              "type": null,
              "value": "T"
            },
            {
              "name": "sig_cum",
              "description": "",
              "type": null,
              "value": "sig_cum"
            },
            {
              "name": "sig_white",
              "description": "",
              "type": null,
              "value": "sig_white"
            },
            {
              "name": "sampling_period",
              "description": "",
              "type": null,
              "value": "sampling_period"
            },
            {
              "name": "noise_1",
              "description": "",
              "type": null,
              "value": "np.random.normal()"
            },
            {
              "name": "noise_2",
              "description": "",
              "type": null,
              "value": "np.random.normal()"
            },
            {
              "name": "initial_value",
              "description": "",
              "type": null,
              "value": "0.0"
            },
            {
              "name": "events",
              "description": "",
              "type": null,
              "value": "[Schedule(t_start=0, t_period=sampling_period, func_act=_sample_noise)]"
            }
          ],
          "parameters": [
            {
              "name": "amplitude",
              "type": null,
              "default": "1",
              "description": "amplitude of the chirp signal"
            },
            {
              "name": "f0",
              "type": null,
              "default": "1",
              "description": "start frequency of the chirp signal"
            },
            {
              "name": "BW",
              "type": null,
              "default": "1",
              "description": "bandwidth of the frequency ramp of the chirp signal"
            },
            {
              "name": "T",
              "type": null,
              "default": "1",
              "description": "period of the frequency ramp of the chirp signal"
            },
            {
              "name": "phase",
              "type": null,
              "default": "0",
              "description": "phase of sinusoid (initial, radians)"
            },
            {
              "name": "sig_cum",
              "type": null,
              "default": "0",
              "description": "weight for cumulative phase noise contribution"
            },
            {
              "name": "sig_white",
              "type": null,
              "default": "0",
              "description": "weight for white phase noise contribution"
            },
            {
              "name": "sampling_period",
              "type": null,
              "default": "0.1",
              "description": "time between phase noise samples. If None, noise is sampled every timestep (default is 0.1)"
            }
          ]
        },
        {
          "name": "ChirpSource",
          "description": "Alias for ChirpPhaseNoiseSource.",
          "docstring_html": "<p>Alias for ChirpPhaseNoiseSource.</p>\n",
          "bases": [
            "ChirpPhaseNoiseSource"
          ],
          "methods": [],
          "attributes": [],
          "parameters": []
        },
        {
          "name": "PulseSource",
          "description": "Generates a periodic pulse waveform with defined rise and fall times.",
          "docstring_html": "<p>Generates a periodic pulse waveform with defined rise and fall times.</p>\n<p>Scheduled events trigger phase changes (low, rising, high, falling),\nand the <cite>update</cite> method calculates the output value based on the\ncurrent phase, performing linear interpolation during rise and fall.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>amplitude <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float, optional</span></dt>\n<dd>Peak amplitude of the pulse. Default is 1.0.</dd>\n<dt>T <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float, optional</span></dt>\n<dd>Period of the pulse train. Must be positive. Default is 1.0.</dd>\n<dt>t_rise <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float, optional</span></dt>\n<dd>Duration of the rising edge. Default is 0.0.</dd>\n<dt>t_fall <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float, optional</span></dt>\n<dd>Duration of the falling edge. Default is 0.0.</dd>\n<dt>tau <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float, optional</span></dt>\n<dd>Initial delay before the first pulse cycle begins. Default is 0.0.</dd>\n<dt>duty <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float, optional</span></dt>\n<dd>Duty cycle, ratio of the pulse ON duration (plateau time only)\nto the total period T (must be between 0 and 1). Default is 0.5.\nThe high plateau duration is <cite>T * duty</cite>.</dd>\n</dl>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>events <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">list[Schedule]</span></dt>\n<dd>Internal scheduled events triggering phase transitions.</dd>\n<dt>_phase <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">str</span></dt>\n<dd>Current phase of the pulse ('low', 'rising', 'high', 'falling').</dd>\n<dt>_phase_start_time <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>Simulation time when the current phase began.</dd>\n</dl>\n",
          "bases": [
            "Block"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "signature": "(amplitude = 1.0, T = 1.0, t_rise = 0.0, t_fall = 0.0, tau = 0.0, duty = 0.5)",
              "parameters": [
                {
                  "name": "amplitude",
                  "type": null,
                  "default": "1.0",
                  "description": ""
                },
                {
                  "name": "T",
                  "type": null,
                  "default": "1.0",
                  "description": ""
                },
                {
                  "name": "t_rise",
                  "type": null,
                  "default": "0.0",
                  "description": ""
                },
                {
                  "name": "t_fall",
                  "type": null,
                  "default": "0.0",
                  "description": ""
                },
                {
                  "name": "tau",
                  "type": null,
                  "default": "0.0",
                  "description": ""
                },
                {
                  "name": "duty",
                  "type": null,
                  "default": "0.5",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "reset",
              "description": "Resets the block state.",
              "docstring_html": "<p>Resets the block state.</p>\n<div class=\"section\" id=\"note\">\n<h4>Note</h4>\n<blockquote>\nThis block has a special implementation of reset where <tt class=\"docutils literal\">t</tt> can be provided\nto reset the block's state to the specified time.\nThis is done by changing the phase of the pulse + resetting all the internal events.</blockquote>\n<p><strong>Parameters</strong></p>\n<blockquote>\n<dl class=\"docutils\">\n<dt>t: float, optional</dt>\n<dd>Time to reset the block state at. If None, resets to initial state.</dd>\n</dl>\n</blockquote>\n</div>\n",
              "signature": "(t: float = None)",
              "parameters": [
                {
                  "name": "t",
                  "type": "float",
                  "default": "None",
                  "description": "Time to reset the block state at. If None, resets to initial state."
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "update",
              "description": "Calculate the pulse output value based on the current phase.",
              "docstring_html": "<p>Calculate the pulse output value based on the current phase.\nPerforms linear interpolation during 'rising' and 'falling' phases.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time</dd>\n</dl>\n",
              "signature": "(t)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time"
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "input_port_labels",
              "description": "",
              "type": null,
              "value": "{}"
            },
            {
              "name": "output_port_labels",
              "description": "",
              "type": null,
              "value": "{'out': 0}"
            },
            {
              "name": "amplitude",
              "description": "",
              "type": null,
              "value": "amplitude"
            },
            {
              "name": "T",
              "description": "",
              "type": null,
              "value": "T"
            },
            {
              "name": "t_rise",
              "description": "",
              "type": null,
              "value": "max(TOLERANCE, t_rise)"
            },
            {
              "name": "t_fall",
              "description": "",
              "type": null,
              "value": "max(TOLERANCE, t_fall)"
            },
            {
              "name": "tau",
              "description": "",
              "type": null,
              "value": "tau"
            },
            {
              "name": "duty",
              "description": "",
              "type": null,
              "value": "duty"
            },
            {
              "name": "events",
              "description": "",
              "type": null,
              "value": "[_E_rising, _E_high, _E_falling, _E_low]"
            }
          ],
          "parameters": [
            {
              "name": "amplitude",
              "type": null,
              "default": "1.0",
              "description": "Peak amplitude of the pulse. Default is 1.0."
            },
            {
              "name": "T",
              "type": null,
              "default": "1.0",
              "description": "Period of the pulse train. Must be positive. Default is 1.0."
            },
            {
              "name": "t_rise",
              "type": null,
              "default": "0.0",
              "description": "Duration of the rising edge. Default is 0.0."
            },
            {
              "name": "t_fall",
              "type": null,
              "default": "0.0",
              "description": "Duration of the falling edge. Default is 0.0."
            },
            {
              "name": "tau",
              "type": null,
              "default": "0.0",
              "description": "Initial delay before the first pulse cycle begins. Default is 0.0."
            },
            {
              "name": "duty",
              "type": null,
              "default": "0.5",
              "description": "Duty cycle, ratio of the pulse ON duration (plateau time only) to the total period T (must be between 0 and 1). Default is 0.5. The high plateau duration is `T * duty`."
            }
          ]
        },
        {
          "name": "Pulse",
          "description": "Alias for PulseSource.",
          "docstring_html": "<p>Alias for PulseSource.</p>\n",
          "bases": [
            "PulseSource"
          ],
          "methods": [],
          "attributes": [],
          "parameters": []
        },
        {
          "name": "ClockSource",
          "description": "Discrete time clock source block.",
          "docstring_html": "<p>Discrete time clock source block.</p>\n<p>Utilizes scheduled events to periodically set\nthe block output to 0 or 1 at discrete times.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>T <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>period of the clock</dd>\n<dt>tau <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>clock delay</dd>\n</dl>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>events <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">list[Schedule]</span></dt>\n<dd>internal scheduled event list</dd>\n</dl>\n",
          "bases": [
            "Block"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "signature": "(T = 1, tau = 0)",
              "parameters": [
                {
                  "name": "T",
                  "type": null,
                  "default": "1",
                  "description": ""
                },
                {
                  "name": "tau",
                  "type": null,
                  "default": "0",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "input_port_labels",
              "description": "",
              "type": null,
              "value": "{}"
            },
            {
              "name": "output_port_labels",
              "description": "",
              "type": null,
              "value": "{'out': 0}"
            },
            {
              "name": "T",
              "description": "",
              "type": null,
              "value": "T"
            },
            {
              "name": "tau",
              "description": "",
              "type": null,
              "value": "tau"
            },
            {
              "name": "events",
              "description": "",
              "type": null,
              "value": "[Schedule(t_start=tau, t_period=T, func_act=clk_up), Schedule(t_start=(tau + T / 2), t_period=T, func_act=clk_down)]"
            }
          ],
          "parameters": [
            {
              "name": "T",
              "type": null,
              "default": "1",
              "description": "period of the clock"
            },
            {
              "name": "tau",
              "type": null,
              "default": "0",
              "description": "clock delay"
            }
          ]
        },
        {
          "name": "Clock",
          "description": "Alias for ClockSource.",
          "docstring_html": "<p>Alias for ClockSource.</p>\n",
          "bases": [
            "ClockSource"
          ],
          "methods": [],
          "attributes": [],
          "parameters": []
        },
        {
          "name": "SquareWaveSource",
          "description": "Discrete time square wave source.",
          "docstring_html": "<p>Discrete time square wave source.</p>\n<p>Utilizes scheduled events to periodically set\nthe block output at discrete times.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>amplitude <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>amplitude of the square wave signal</dd>\n<dt>frequency <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>frequency of the square wave signal</dd>\n<dt>phase <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>phase of the square wave signal</dd>\n</dl>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>events <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">list[Schedule]</span></dt>\n<dd>internal scheduled events</dd>\n</dl>\n",
          "bases": [
            "Block"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "signature": "(amplitude = 1, frequency = 1, phase = 0)",
              "parameters": [
                {
                  "name": "amplitude",
                  "type": null,
                  "default": "1",
                  "description": ""
                },
                {
                  "name": "frequency",
                  "type": null,
                  "default": "1",
                  "description": ""
                },
                {
                  "name": "phase",
                  "type": null,
                  "default": "0",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "input_port_labels",
              "description": "",
              "type": null,
              "value": "{}"
            },
            {
              "name": "output_port_labels",
              "description": "",
              "type": null,
              "value": "{'out': 0}"
            },
            {
              "name": "amplitude",
              "description": "",
              "type": null,
              "value": "amplitude"
            },
            {
              "name": "frequency",
              "description": "",
              "type": null,
              "value": "frequency"
            },
            {
              "name": "phase",
              "description": "",
              "type": null,
              "value": "phase"
            },
            {
              "name": "events",
              "description": "",
              "type": null,
              "value": "[Schedule(t_start=(1 / frequency * phase / 360), t_period=(1 / frequency), func_act=sqw_up), Schedule(t_start=(1 / frequency * (phase / 360 + 0.5)), t_period=(1 / frequency), func_act=sqw_down)]"
            }
          ],
          "parameters": [
            {
              "name": "amplitude",
              "type": null,
              "default": "1",
              "description": "amplitude of the square wave signal"
            },
            {
              "name": "frequency",
              "type": null,
              "default": "1",
              "description": "frequency of the square wave signal"
            },
            {
              "name": "phase",
              "type": null,
              "default": "0",
              "description": "phase of the square wave signal"
            }
          ]
        },
        {
          "name": "StepSource",
          "description": "Discrete time unit step (or multi step) source block.",
          "docstring_html": "<p>Discrete time unit step (or multi step) source block.</p>\n<p>Utilizes a scheduled event to set the block output\nto the specified output levels at the defined event times.</p>\n<p>The arguments can be vectorial and in that case, the output is set to the\namplitude that corresponds to the defined delay like a zero-order-hold stage.\nThis functionality enables adding external or time series measurement data\ninto the system.</p>\n<p><strong>Examples</strong></p>\n<p>This is how to use the source as a unit step source:</p>\n<pre class=\"code python literal-block\">\nfrom pathsim.blocks import StepSource\n\n#default, starts at 0, jumps to 1\nstp = StepSource()\n</pre>\n<p>And this is how to configure it with multiple consecutive steps:</p>\n<pre class=\"code python literal-block\">\nfrom pathsim.blocks import StepSource\n\n#starts at 0, jumps to 1 at 1, jumps to -1 at 2 and jumps back to 0 at 3\nstp = StepSource(amplitude=[1, -1, 0], tau=[1, 2, 3])\n</pre>\n<p>Similarly implementing measured time series data via zoh:</p>\n<pre class=\"code python literal-block\">\nimport numpy as np\nfrom pathsim.blocks import StepSource\n\n#some random time series arrays\ntimes, data = np.linspace(0, 100, 1000), np.random.rand(1000)\n\n#pass them to the block\nstp = StepSource(amplitude=data, tau=times)\n</pre>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>amplitude <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float | list[float]</span></dt>\n<dd>amplitude of the step signal, or amplitudes / output\nlevels of the multiple steps</dd>\n<dt>tau <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float | list[float]</span></dt>\n<dd>delay of the step, or delays of the different steps</dd>\n</dl>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>Evt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">ScheduleList</span></dt>\n<dd>internal scheduled event directly accessible</dd>\n<dt>events <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">list[ScheduleList]</span></dt>\n<dd>list of interna events</dd>\n</dl>\n",
          "bases": [
            "Block"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "signature": "(amplitude = 1, tau = 0.0)",
              "parameters": [
                {
                  "name": "amplitude",
                  "type": null,
                  "default": "1",
                  "description": ""
                },
                {
                  "name": "tau",
                  "type": null,
                  "default": "0.0",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "input_port_labels",
              "description": "",
              "type": null,
              "value": "{}"
            },
            {
              "name": "output_port_labels",
              "description": "",
              "type": null,
              "value": "{'out': 0}"
            },
            {
              "name": "amplitude",
              "description": "",
              "type": null,
              "value": "amplitude if isinstance(amplitude, (list, np.ndarray)) else [amplitude]"
            },
            {
              "name": "tau",
              "description": "",
              "type": null,
              "value": "tau if isinstance(tau, (list, np.ndarray)) else [tau]"
            },
            {
              "name": "Evt",
              "description": "",
              "type": null,
              "value": "ScheduleList(times_evt=(self.tau), func_act=stp_set)"
            },
            {
              "name": "events",
              "description": "",
              "type": null,
              "value": "[self.Evt]"
            }
          ],
          "parameters": [
            {
              "name": "amplitude",
              "type": null,
              "default": "1",
              "description": "amplitude of the step signal, or amplitudes / output levels of the multiple steps"
            },
            {
              "name": "tau",
              "type": null,
              "default": "0.0",
              "description": "delay of the step, or delays of the different steps"
            }
          ]
        },
        {
          "name": "Step",
          "description": "Alias for StepSource.",
          "docstring_html": "<p>Alias for StepSource.</p>\n",
          "bases": [
            "StepSource"
          ],
          "methods": [],
          "attributes": [],
          "parameters": []
        },
        {
          "name": "Wrapper",
          "description": "Wrapper block for discrete implementation and external code integration.",
          "docstring_html": "<p>Wrapper block for discrete implementation and external code integration.</p>\n<p>The <cite>Wrapper</cite> class is designed to call the internal <cite>func</cite> at fixed intervals\nusing an internal <cite>Schedule</cite> event. This makes it particularly useful for wrapping\nexternal code or implementing discrete-time systems.</p>\n<p>Essentially this block does the same as <cite>Function</cite> with the difference that its\nnot evaluated continuously but periodically at discrete times.</p>\n<div class=\"section\" id=\"example\">\n<h4>Example</h4>\n<p>There are two ways to setup the <cite>Wrapper</cite>, first and standard way is to define\na function to be wrapped and pass it to the block initializer:</p>\n<pre class=\"code python literal-block\">\nfrom pathsim.blocks import Wrapper\n\n#function to be wrapped\ndef func(a, b, c):\n    return a * (b + c)\n\nwrp = Wrapper(func, T=0.1)\n</pre>\n<p>Another option is to use the <cite>dec</cite> classmethod, which might be more convenient\nin some situations:</p>\n<pre class=\"code python literal-block\">\nfrom pathsim.blocks import Wrapper\n\n&#64;Wrapper.dec(T=0.1)\ndef wrp(a, b, c):\n    return a * (b + c)\n</pre>\n<p>This way the internal function of the block <cite>wrp</cite> will be evaluated with a period\nof <cite>T=0.1</cite> and its outputs updated accordingly.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>func <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">callable</span></dt>\n<dd>function that defines algebraic block IO behaviour</dd>\n<dt>T <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>sampling period for the wrapped function</dd>\n<dt>tau <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>delay time for the start time of the event</dd>\n</dl>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>Evt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">Schedule</span></dt>\n<dd>internal event. Used for periodic sampling the wrapped method</dd>\n</dl>\n</div>\n",
          "bases": [
            "Block"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "signature": "(func = None, T = 1, tau = 0)",
              "parameters": [
                {
                  "name": "func",
                  "type": null,
                  "default": "None",
                  "description": ""
                },
                {
                  "name": "T",
                  "type": null,
                  "default": "1",
                  "description": ""
                },
                {
                  "name": "tau",
                  "type": null,
                  "default": "0",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "update",
              "description": "Update system equation for fixed point loop.",
              "docstring_html": "<p>Update system equation for fixed point loop.</p>\n<div class=\"section\" id=\"note\">\n<h4>Note</h4>\n<p>No direct passthrough, the <cite>Wrapper</cite> block doesnt\nimplement the <cite>update</cite> method. The behavior is\ndefined by the <cite>func</cite> arg.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time</dd>\n</dl>\n</div>\n",
              "signature": "(t)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "dec",
              "description": "decorator for direct instance construction from func",
              "docstring_html": "<p>decorator for direct instance construction from func</p>\n<div class=\"section\" id=\"example\">\n<h4>Example</h4>\n<p>Decorate a function definition to directly make it\na <cite>Wrapper</cite> block instance:</p>\n<p>from pathsim.blocks import Wrapper</p>\n<p>&#64;Wrapper.dec(T=0.1)\ndef wrp(a, b, c):</p>\n<blockquote>\nreturn a * (b + c)</blockquote>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>tau <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>delay time for the start time of the wrapper sampling</dd>\n<dt>T <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>sampling period for calling the <cite>wrapped</cite> function</dd>\n</dl>\n</div>\n",
              "signature": "(cls, T = 1, tau = 0)",
              "parameters": [
                {
                  "name": "cls",
                  "type": null,
                  "default": null,
                  "description": ""
                },
                {
                  "name": "T",
                  "type": null,
                  "default": "1",
                  "description": "sampling period for calling the `wrapped` function"
                },
                {
                  "name": "tau",
                  "type": null,
                  "default": "0",
                  "description": "delay time for the start time of the wrapper sampling"
                }
              ],
              "returns": null,
              "method_type": "classmethod"
            }
          ],
          "attributes": [
            {
              "name": "func",
              "description": "",
              "type": null,
              "value": "func"
            },
            {
              "name": "Evt",
              "description": "",
              "type": null,
              "value": "Schedule(t_start=tau, t_period=T, func_act=_sample)"
            },
            {
              "name": "events",
              "description": "",
              "type": null,
              "value": "[self.Evt]"
            },
            {
              "name": "tau",
              "description": "Getter for tau",
              "type": null,
              "value": null
            },
            {
              "name": "T",
              "description": "Get the sampling period of the block",
              "type": null,
              "value": null
            }
          ],
          "parameters": [
            {
              "name": "func",
              "type": null,
              "default": "None",
              "description": "function that defines algebraic block IO behaviour"
            },
            {
              "name": "T",
              "type": null,
              "default": "1",
              "description": "sampling period for the wrapped function"
            },
            {
              "name": "tau",
              "type": null,
              "default": "0",
              "description": "delay time for the start time of the event Attributes ----------"
            }
          ]
        },
        {
          "name": "ZeroCrossingUp",
          "description": "Modification of standard 'ZeroCrossing' event where events are only triggered",
          "docstring_html": "<p>Modification of standard 'ZeroCrossing' event where events are only triggered\nif the event function changes sign from negative to positive (up). Also called\nunidirectional zero-crossing.</p>\n",
          "bases": [
            "Event"
          ],
          "methods": [
            {
              "name": "detect",
              "description": "Evaluate the event function and check for zero-crossings",
              "docstring_html": "<p>Evaluate the event function and check for zero-crossings</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time for detection</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>detected <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>was an event detected?</dd>\n<dt>close <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>are we close to the event?</dd>\n<dt>ratio <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>interpolated event location as ratio of timestep</dd>\n</dl>\n",
              "signature": "(t)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time for detection"
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [],
          "parameters": []
        },
        {
          "name": "ZeroCrossingDown",
          "description": "Modification of standard 'ZeroCrossing' event where events are only triggered",
          "docstring_html": "<p>Modification of standard 'ZeroCrossing' event where events are only triggered\nif the event function changes sign from positive to negative (down). Also called\nunidirectional zero-crossing.</p>\n",
          "bases": [
            "Event"
          ],
          "methods": [
            {
              "name": "detect",
              "description": "Evaluate the event function and check for zero-crossings",
              "docstring_html": "<p>Evaluate the event function and check for zero-crossings</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time for detection</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>detected <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>was an event detected?</dd>\n<dt>close <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>are we close to the event?</dd>\n<dt>ratio <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>interpolated event location as ratio of timestep</dd>\n</dl>\n",
              "signature": "(t)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time for detection"
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [],
          "parameters": []
        },
        {
          "name": "Counter",
          "description": "Counts the number of detected bidirectional threshold crossings.",
          "docstring_html": "<p>Counts the number of detected bidirectional threshold crossings.</p>\n<p>Uses zero-crossing events for the detection and and sets the output\naccordingly.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>start <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>counter start (initial condition)</dd>\n<dt>threshold <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>threshold for zero crossing</dd>\n</dl>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>E <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">ZeroCrossing</span></dt>\n<dd>internal event manager</dd>\n<dt>events <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">list[ZeroCrossing]</span></dt>\n<dd>internal zero crossing event</dd>\n</dl>\n",
          "bases": [
            "Block"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "signature": "(start = 0, threshold = 0.0)",
              "parameters": [
                {
                  "name": "start",
                  "type": null,
                  "default": "0",
                  "description": ""
                },
                {
                  "name": "threshold",
                  "type": null,
                  "default": "0.0",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "update",
              "description": "update system equation for fixed point loop,",
              "docstring_html": "<p>update system equation for fixed point loop,\nhere just setting the outputs</p>\n<div class=\"section\" id=\"note\">\n<h4>Note</h4>\n<p>no direct passthrough, so the 'update' method\nis optimized for this case</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time</dd>\n</dl>\n</div>\n",
              "signature": "(t)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time"
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "input_port_labels",
              "description": "",
              "type": null,
              "value": "{'in': 0}"
            },
            {
              "name": "output_port_labels",
              "description": "",
              "type": null,
              "value": "{'out': 0}"
            },
            {
              "name": "start",
              "description": "",
              "type": null,
              "value": "start"
            },
            {
              "name": "threshold",
              "description": "",
              "type": null,
              "value": "threshold"
            },
            {
              "name": "E",
              "description": "",
              "type": null,
              "value": "ZeroCrossing(func_evt=(lambda t: self.inputs[0] - self.threshold))"
            },
            {
              "name": "events",
              "description": "",
              "type": null,
              "value": "[self.E]"
            }
          ],
          "parameters": [
            {
              "name": "start",
              "type": null,
              "default": "0",
              "description": "counter start (initial condition)"
            },
            {
              "name": "threshold",
              "type": null,
              "default": "0.0",
              "description": "threshold for zero crossing"
            }
          ]
        },
        {
          "name": "CounterUp",
          "description": "Counts the number of detected unidirectional (lo->hi) threshold crossings.",
          "docstring_html": "<p>Counts the number of detected unidirectional (lo-&gt;hi) threshold crossings.</p>\n<div class=\"section\" id=\"note\">\n<h4>Note</h4>\n<p>This is a modification of 'Counter' which only counts\nunidirectional zero-crossings (low -&gt; high)</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>start <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>counter start (initial condition)</dd>\n<dt>threshold <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>threshold for zero crossing</dd>\n</dl>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>E <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">ZeroCrossingUp</span></dt>\n<dd>internal event manager</dd>\n<dt>events <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">list[ZeroCrossing]</span></dt>\n<dd>internal zero crossing event</dd>\n</dl>\n</div>\n",
          "bases": [
            "Counter"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "signature": "(start = 0, threshold = 0.0)",
              "parameters": [
                {
                  "name": "start",
                  "type": null,
                  "default": "0",
                  "description": ""
                },
                {
                  "name": "threshold",
                  "type": null,
                  "default": "0.0",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "E",
              "description": "",
              "type": null,
              "value": "ZeroCrossingUp(func_evt=(lambda t: self.inputs[0] - self.threshold))"
            },
            {
              "name": "events",
              "description": "",
              "type": null,
              "value": "[self.E]"
            }
          ],
          "parameters": [
            {
              "name": "start",
              "type": null,
              "default": "0",
              "description": "counter start (initial condition)"
            },
            {
              "name": "threshold",
              "type": null,
              "default": "0.0",
              "description": "threshold for zero crossing"
            }
          ]
        },
        {
          "name": "CounterDown",
          "description": "Counts the number of detected unidirectional (hi->lo) threshold crossings.",
          "docstring_html": "<p>Counts the number of detected unidirectional (hi-&gt;lo) threshold crossings.</p>\n<div class=\"section\" id=\"note\">\n<h4>Note</h4>\n<p>This is a modification of 'Counter' which only counts\nunidirectional zero-crossings (high -&gt; low)</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>start <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>counter start (initial condition)</dd>\n<dt>threshold <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>threshold for zero crossing</dd>\n</dl>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>E <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">ZeroCrossingDown</span></dt>\n<dd>internal event manager</dd>\n<dt>events <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">list[ZeroCrossing]</span></dt>\n<dd>internal zero crossing event</dd>\n</dl>\n</div>\n",
          "bases": [
            "Counter"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "signature": "(start = 0, threshold = 0.0)",
              "parameters": [
                {
                  "name": "start",
                  "type": null,
                  "default": "0",
                  "description": ""
                },
                {
                  "name": "threshold",
                  "type": null,
                  "default": "0.0",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "E",
              "description": "",
              "type": null,
              "value": "ZeroCrossingDown(func_evt=(lambda t: self.inputs[0] - self.threshold))"
            },
            {
              "name": "events",
              "description": "",
              "type": null,
              "value": "[self.E]"
            }
          ],
          "parameters": [
            {
              "name": "start",
              "type": null,
              "default": "0",
              "description": "counter start (initial condition)"
            },
            {
              "name": "threshold",
              "type": null,
              "default": "0.0",
              "description": "threshold for zero crossing"
            }
          ]
        },
        {
          "name": "StateSpace",
          "description": "Linear time invariant (LTI) multi input multi output (MIMO) state space model.",
          "docstring_html": "<p>Linear time invariant (LTI) multi input multi output (MIMO) state space model.</p>\n<pre class=\"math\">\n\\begin{eqnarray}\n    \\dot{x} &amp;= \\mathbf{A} x + \\mathbf{B} u \\\\\n           y &amp;= \\mathbf{C} x + \\mathbf{D} u\n\\end{eqnarray}\n</pre>\n<p>where <cite>A</cite>, <cite>B</cite>, <cite>C</cite> and <cite>D</cite> are the state space matrices, <cite>x</cite> is the state,\n<cite>u</cite> the input and <cite>y</cite> the output vector.</p>\n<div class=\"section\" id=\"example\">\n<h4>Example</h4>\n<p>A SISO state space block with two internal states can be initialized\nlike this:</p>\n<pre class=\"code python literal-block\">\nS = StateSpace(\n    A=-np.eye(2),\n    B=np.ones((2, 1)),\n    C=np.ones((1, 2)),\n    D=1.0\n    )\n</pre>\n<p>and a MIMO (2 in, 2 out) state space block with three internal states\ncan be initialized like this:</p>\n<pre class=\"code python literal-block\">\nS = StateSpace(\n    A=-np.eye(3),\n    B=np.ones((3, 2)),\n    C=np.ones((2, 3)),\n    D=np.ones((2, 2))\n    )\n</pre>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>A, B, C, D <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array_like</span></dt>\n<dd>real valued state space matrices</dd>\n<dt>initial_value <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array_like, None</span></dt>\n<dd>initial state / initial condition</dd>\n</dl>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>op_dyn <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">DynamicOperator</span></dt>\n<dd>internal dynamic operator for state equation</dd>\n<dt>op_alg <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">DynamicOperator</span></dt>\n<dd>internal algebraic operator for mapping to outputs</dd>\n</dl>\n</div>\n",
          "bases": [
            "Block"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "signature": "(A = -1.0, B = 1.0, C = -1.0, D = 1.0, initial_value = None)",
              "parameters": [
                {
                  "name": "A",
                  "type": null,
                  "default": "-1.0",
                  "description": ""
                },
                {
                  "name": "B",
                  "type": null,
                  "default": "1.0",
                  "description": ""
                },
                {
                  "name": "C",
                  "type": null,
                  "default": "-1.0",
                  "description": ""
                },
                {
                  "name": "D",
                  "type": null,
                  "default": "1.0",
                  "description": ""
                },
                {
                  "name": "initial_value",
                  "type": null,
                  "default": "None",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "solve",
              "description": "advance solution of implicit update equation of the solver",
              "docstring_html": "<p>advance solution of implicit update equation of the solver</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time</dd>\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>integration timestep</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>error <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>solver residual norm</dd>\n</dl>\n",
              "signature": "(t, dt)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time"
                },
                {
                  "name": "dt",
                  "type": null,
                  "default": null,
                  "description": "integration timestep"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "step",
              "description": "compute timestep update with integration engine",
              "docstring_html": "<p>compute timestep update with integration engine</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time</dd>\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>integration timestep</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>success <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>step was successful</dd>\n<dt>error <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>local truncation error from adaptive integrators</dd>\n<dt>scale <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>timestep rescale from adaptive integrators</dd>\n</dl>\n",
              "signature": "(t, dt)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time"
                },
                {
                  "name": "dt",
                  "type": null,
                  "default": null,
                  "description": "integration timestep"
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "A",
              "description": "",
              "type": null,
              "value": "np.atleast_2d(A)"
            },
            {
              "name": "B",
              "description": "",
              "type": null,
              "value": "np.atleast_1d(B)"
            },
            {
              "name": "C",
              "description": "",
              "type": null,
              "value": "np.atleast_1d(C)"
            },
            {
              "name": "D",
              "description": "",
              "type": null,
              "value": "np.atleast_1d(D)"
            },
            {
              "name": "inputs",
              "description": "",
              "type": null,
              "value": "Register(n_in)"
            },
            {
              "name": "outputs",
              "description": "",
              "type": null,
              "value": "Register(n_out)"
            },
            {
              "name": "initial_value",
              "description": "",
              "type": null,
              "value": "np.zeros(n)"
            },
            {
              "name": "op_dyn",
              "description": "",
              "type": null,
              "value": "DynamicOperator(func=(lambda x, u, t: np.dot(self.A, x) + np.dot(self.B, u)), jac_x=(lambda x, u, t: self.A), jac_u=(lambda x, u, t: self.B))"
            },
            {
              "name": "op_alg",
              "description": "",
              "type": null,
              "value": "DynamicOperator(func=(lambda x, u, t: np.dot(self.C, x) + np.dot(self.D, u)), jac_x=(lambda x, u, t: self.C), jac_u=(lambda x, u, t: self.D))"
            }
          ],
          "parameters": [
            {
              "name": "A",
              "type": null,
              "default": "-1.0",
              "description": ""
            },
            {
              "name": "B",
              "type": null,
              "default": "1.0",
              "description": ""
            },
            {
              "name": "C",
              "type": null,
              "default": "-1.0",
              "description": ""
            },
            {
              "name": "D",
              "type": null,
              "default": "1.0",
              "description": "real valued state space matrices"
            },
            {
              "name": "initial_value",
              "type": null,
              "default": "None",
              "description": "initial state / initial condition"
            }
          ]
        },
        {
          "name": "ButterworthLowpassFilter",
          "description": "Direct implementation of a low pass butterworth filter block.",
          "docstring_html": "<p>Direct implementation of a low pass butterworth filter block.</p>\n<p>Follows the same structure as the 'StateSpace' block in the\n'pathsim.blocks' module. The numerator and denominator of the\nfilter transfer function are generated and then the transfer\nfunction is realized as a state space model.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>Fc <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>corner frequency of the filter in [Hz]</dd>\n<dt>n <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>filter order</dd>\n</dl>\n",
          "bases": [
            "StateSpace"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "signature": "(Fc = 100, n = 2)",
              "parameters": [
                {
                  "name": "Fc",
                  "type": null,
                  "default": "100",
                  "description": ""
                },
                {
                  "name": "n",
                  "type": null,
                  "default": "2",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "input_port_labels",
              "description": "",
              "type": null,
              "value": "{'in': 0}"
            },
            {
              "name": "output_port_labels",
              "description": "",
              "type": null,
              "value": "{'out': 0}"
            },
            {
              "name": "Fc",
              "description": "",
              "type": null,
              "value": "Fc"
            },
            {
              "name": "n",
              "description": "",
              "type": null,
              "value": "n"
            }
          ],
          "parameters": [
            {
              "name": "Fc",
              "type": null,
              "default": "100",
              "description": "corner frequency of the filter in [Hz]"
            },
            {
              "name": "n",
              "type": null,
              "default": "2",
              "description": "filter order"
            }
          ]
        },
        {
          "name": "ButterworthHighpassFilter",
          "description": "Direct implementation of a high pass butterworth filter block.",
          "docstring_html": "<p>Direct implementation of a high pass butterworth filter block.</p>\n<p>Follows the same structure as the 'StateSpace' block in the\n'pathsim.blocks' module. The numerator and denominator of the\nfilter transfer function are generated and then the transfer\nfunction is realized as a state space model.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>Fc <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>corner frequency of the filter in [Hz]</dd>\n<dt>n <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>filter order</dd>\n</dl>\n",
          "bases": [
            "StateSpace"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "signature": "(Fc = 100, n = 2)",
              "parameters": [
                {
                  "name": "Fc",
                  "type": null,
                  "default": "100",
                  "description": ""
                },
                {
                  "name": "n",
                  "type": null,
                  "default": "2",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "input_port_labels",
              "description": "",
              "type": null,
              "value": "{'in': 0}"
            },
            {
              "name": "output_port_labels",
              "description": "",
              "type": null,
              "value": "{'out': 0}"
            },
            {
              "name": "Fc",
              "description": "",
              "type": null,
              "value": "Fc"
            },
            {
              "name": "n",
              "description": "",
              "type": null,
              "value": "n"
            }
          ],
          "parameters": [
            {
              "name": "Fc",
              "type": null,
              "default": "100",
              "description": "corner frequency of the filter in [Hz]"
            },
            {
              "name": "n",
              "type": null,
              "default": "2",
              "description": "filter order"
            }
          ]
        },
        {
          "name": "ButterworthBandpassFilter",
          "description": "Direct implementation of a bandpass butterworth filter block.",
          "docstring_html": "<p>Direct implementation of a bandpass butterworth filter block.</p>\n<p>Follows the same structure as the 'StateSpace' block in the\n'pathsim.blocks' module. The numerator and denominator of the\nfilter transfer function are generated and then the transfer\nfunction is realized as a state space model.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>Fc <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">list[float]</span></dt>\n<dd>corner frequencies (left, right) of the filter in [Hz]</dd>\n<dt>n <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>filter order</dd>\n</dl>\n",
          "bases": [
            "StateSpace"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "signature": "(Fc = [50, 100], n = 2)",
              "parameters": [
                {
                  "name": "Fc",
                  "type": null,
                  "default": "[50, 100]",
                  "description": ""
                },
                {
                  "name": "n",
                  "type": null,
                  "default": "2",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "input_port_labels",
              "description": "",
              "type": null,
              "value": "{'in': 0}"
            },
            {
              "name": "output_port_labels",
              "description": "",
              "type": null,
              "value": "{'out': 0}"
            },
            {
              "name": "Fc",
              "description": "",
              "type": null,
              "value": "np.asarray(Fc)"
            },
            {
              "name": "n",
              "description": "",
              "type": null,
              "value": "n"
            }
          ],
          "parameters": [
            {
              "name": "Fc",
              "type": null,
              "default": "[50, 100]",
              "description": "corner frequencies (left, right) of the filter in [Hz]"
            },
            {
              "name": "n",
              "type": null,
              "default": "2",
              "description": "filter order"
            }
          ]
        },
        {
          "name": "ButterworthBandstopFilter",
          "description": "Direct implementation of a bandstop butterworth filter block.",
          "docstring_html": "<p>Direct implementation of a bandstop butterworth filter block.</p>\n<p>Follows the same structure as the 'StateSpace' block in the\n'pathsim.blocks' module. The numerator and denominator of the\nfilter transfer function are generated and then the transfer\nfunction is realized as a state space model.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>Fc <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">tuple[float], list[float]</span></dt>\n<dd>corner frequencies (left, right) of the filter in [Hz]</dd>\n<dt>n <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>filter order</dd>\n</dl>\n",
          "bases": [
            "StateSpace"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "signature": "(Fc = [50, 100], n = 2)",
              "parameters": [
                {
                  "name": "Fc",
                  "type": null,
                  "default": "[50, 100]",
                  "description": ""
                },
                {
                  "name": "n",
                  "type": null,
                  "default": "2",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "input_port_labels",
              "description": "",
              "type": null,
              "value": "{'in': 0}"
            },
            {
              "name": "output_port_labels",
              "description": "",
              "type": null,
              "value": "{'out': 0}"
            },
            {
              "name": "Fc",
              "description": "",
              "type": null,
              "value": "np.asarray(Fc)"
            },
            {
              "name": "n",
              "description": "",
              "type": null,
              "value": "n"
            }
          ],
          "parameters": [
            {
              "name": "Fc",
              "type": null,
              "default": "[50, 100]",
              "description": "corner frequencies (left, right) of the filter in [Hz]"
            },
            {
              "name": "n",
              "type": null,
              "default": "2",
              "description": "filter order"
            }
          ]
        },
        {
          "name": "AllpassFilter",
          "description": "Direct implementation of a first order allpass filter, or a cascade",
          "docstring_html": "<p>Direct implementation of a first order allpass filter, or a cascade\nof n 1st order allpass filters</p>\n<div>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\">\n  <mi>H</mi>\n  <mo stretchy=\"false\">(</mo>\n  <mi>s</mi>\n  <mo stretchy=\"false\">)</mo>\n  <mo>=</mo>\n  <mfrac>\n    <mrow>\n      <mi>s</mi>\n      <mo>−</mo>\n      <mn>2</mn>\n      <mi>π</mi>\n      <msub>\n        <mi>f</mi>\n        <mi>s</mi>\n      </msub>\n    </mrow>\n    <mrow>\n      <mi>s</mi>\n      <mo>+</mo>\n      <mn>2</mn>\n      <mi>π</mi>\n      <msub>\n        <mi>f</mi>\n        <mi>s</mi>\n      </msub>\n    </mrow>\n  </mfrac>\n</math>\n</div>\n<p>where f_s is the frequency, where the 1st order allpass has a 90 deg phase shift.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>fs <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>frequency for 90 deg phase shift of 1st order allpass</dd>\n<dt>n <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>number of cascades</dd>\n</dl>\n",
          "bases": [
            "StateSpace"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "signature": "(fs = 100, n = 1)",
              "parameters": [
                {
                  "name": "fs",
                  "type": null,
                  "default": "100",
                  "description": ""
                },
                {
                  "name": "n",
                  "type": null,
                  "default": "1",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "input_port_labels",
              "description": "",
              "type": null,
              "value": "{'in': 0}"
            },
            {
              "name": "output_port_labels",
              "description": "",
              "type": null,
              "value": "{'out': 0}"
            },
            {
              "name": "fs",
              "description": "",
              "type": null,
              "value": "fs"
            },
            {
              "name": "n",
              "description": "",
              "type": null,
              "value": "n"
            }
          ],
          "parameters": [
            {
              "name": "fs",
              "type": null,
              "default": "100",
              "description": "frequency for 90 deg phase shift of 1st order allpass"
            },
            {
              "name": "n",
              "type": null,
              "default": "1",
              "description": "number of cascades"
            }
          ]
        },
        {
          "name": "Switch",
          "description": "Switch block that selects between its inputs.",
          "docstring_html": "<p>Switch block that selects between its inputs.</p>\n<div class=\"section\" id=\"example\">\n<h4>Example</h4>\n<p>The block is initialized like this:</p>\n<pre class=\"code python literal-block\">\n#default None -&gt; no passthrough\ns1 = Switch()\n\n#selecting port 2 as passthrough\ns2 = Switch(2)\n\n#change the state of the switch to port 3\ns2.select(3)\n</pre>\n<p>Sets block output depending on <cite>self.state</cite> like this:</p>\n<pre class=\"code literal-block\">\nstate == None -&gt; outputs[0] = 0\n\nstate == 0 -&gt; outputs[0] = inputs[0]\n\nstate == 1 -&gt; outputs[0] = inputs[1]\n\nstate == 2 -&gt; outputs[0] = inputs[2]\n\n...\n</pre>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>state <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int, None</span></dt>\n<dd>state of the switch</dd>\n</dl>\n</div>\n",
          "bases": [
            "Block"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "signature": "(state = None)",
              "parameters": [
                {
                  "name": "state",
                  "type": null,
                  "default": "None",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "select",
              "description": "This method is unique to the `Switch` block and intended",
              "docstring_html": "<p>This method is unique to the <cite>Switch</cite> block and intended\nto be used from outside the simulation level for selecting\nthe input ports for the switch state.</p>\n<p>This can be achieved for example with the event management\nsystem and its callback/action functions.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>state <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int, None</span></dt>\n<dd>switch state / input port selection</dd>\n</dl>\n",
              "signature": "(state = 0)",
              "parameters": [
                {
                  "name": "state",
                  "type": null,
                  "default": "0",
                  "description": "switch state / input port selection"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "update",
              "description": "Update switch output depending on inputs and switch state.",
              "docstring_html": "<p>Update switch output depending on inputs and switch state.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time</dd>\n</dl>\n",
              "signature": "(t)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time"
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "input_port_labels",
              "description": "",
              "type": null,
              "value": "None"
            },
            {
              "name": "output_port_labels",
              "description": "",
              "type": null,
              "value": "{'out': 0}"
            },
            {
              "name": "state",
              "description": "",
              "type": null,
              "value": "state"
            }
          ],
          "parameters": [
            {
              "name": "state",
              "type": null,
              "default": "None",
              "description": "state of the switch"
            }
          ]
        },
        {
          "name": "DynamicalSystem",
          "description": "This block implements a nonlinear dynamical system / nonlinear state space model.",
          "docstring_html": "<p>This block implements a nonlinear dynamical system / nonlinear state space model.</p>\n<p>Its basically the same as the <cite>ODE</cite> block with the addition of an output equation\nthat takes the state, input and time as arguments:</p>\n<pre class=\"math\">\n\\begin{eqnarray}\n    \\dot{x}(t) =&amp; \\mathrm{func}_\\mathrm{dyn}(x(t), u(t), t) \\\\\n           y(t) =&amp; \\mathrm{func}_\\mathrm{alg}(x(t), u(t), t)\n\\end{eqnarray}\n</pre>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>func_dyn <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">callable</span></dt>\n<dd>right hand side function of ode-part of the system</dd>\n<dt>func_alg <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">callable</span></dt>\n<dd>output function of the system</dd>\n<dt>initial_value <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array[float]</span></dt>\n<dd>initial state / initial condition</dd>\n<dt>jac_dyn <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">callable | None</span></dt>\n<dd>optional jacobian of <cite>func_dyn</cite> to improve convergence\nfor implicit ode solvers</dd>\n</dl>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>op_dyn <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">DynamicOperator</span></dt>\n<dd>internal dynamic operator for <cite>func_dyn</cite></dd>\n<dt>op_alg <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">DynamicOperator</span></dt>\n<dd>internal dynamic operator for <cite>func_alg</cite></dd>\n</dl>\n",
          "bases": [
            "Block"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "signature": "(func_dyn = lambda x, u, t: -x, func_alg = lambda x, u, t: x, initial_value = 0.0, jac_dyn = None)",
              "parameters": [
                {
                  "name": "func_dyn",
                  "type": null,
                  "default": "lambda x, u, t: -x",
                  "description": ""
                },
                {
                  "name": "func_alg",
                  "type": null,
                  "default": "lambda x, u, t: x",
                  "description": ""
                },
                {
                  "name": "initial_value",
                  "type": null,
                  "default": "0.0",
                  "description": ""
                },
                {
                  "name": "jac_dyn",
                  "type": null,
                  "default": "None",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "update",
              "description": "update system equation for fixed point loop, by evaluating the",
              "docstring_html": "<p>update system equation for fixed point loop, by evaluating the\noutput function of the system</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time</dd>\n</dl>\n",
              "signature": "(t)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "solve",
              "description": "advance solution of implicit update equation of the solver",
              "docstring_html": "<p>advance solution of implicit update equation of the solver</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time</dd>\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>integration timestep</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>error <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>solver residual norm</dd>\n</dl>\n",
              "signature": "(t, dt)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time"
                },
                {
                  "name": "dt",
                  "type": null,
                  "default": null,
                  "description": "integration timestep"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "step",
              "description": "compute timestep update with integration engine",
              "docstring_html": "<p>compute timestep update with integration engine</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time</dd>\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>integration timestep</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>success <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>step was successful</dd>\n<dt>error <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>local truncation error from adaptive integrators</dd>\n<dt>scale <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>timestep rescale from adaptive integrators</dd>\n</dl>\n",
              "signature": "(t, dt)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time"
                },
                {
                  "name": "dt",
                  "type": null,
                  "default": null,
                  "description": "integration timestep"
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "func_dyn",
              "description": "",
              "type": null,
              "value": "func_dyn"
            },
            {
              "name": "func_alg",
              "description": "",
              "type": null,
              "value": "func_alg"
            },
            {
              "name": "jac_dyn",
              "description": "",
              "type": null,
              "value": "jac_dyn"
            },
            {
              "name": "initial_value",
              "description": "",
              "type": null,
              "value": "initial_value"
            },
            {
              "name": "op_dyn",
              "description": "",
              "type": null,
              "value": "DynamicOperator(func=func_dyn, jac_x=jac_dyn)"
            },
            {
              "name": "op_alg",
              "description": "",
              "type": null,
              "value": "DynamicOperator(func=func_alg)"
            }
          ],
          "parameters": [
            {
              "name": "func_dyn",
              "type": null,
              "default": "lambda x, u, t: -x",
              "description": "right hand side function of ode-part of the system"
            },
            {
              "name": "func_alg",
              "type": null,
              "default": "lambda x, u, t: x",
              "description": "output function of the system"
            },
            {
              "name": "initial_value",
              "type": null,
              "default": "0.0",
              "description": "initial state / initial condition"
            },
            {
              "name": "jac_dyn",
              "type": null,
              "default": "None",
              "description": "optional jacobian of `func_dyn` to improve convergence for implicit ode solvers"
            }
          ]
        },
        {
          "name": "KalmanFilter",
          "description": "Discrete-time Kalman filter for state estimation.",
          "docstring_html": "<p>Discrete-time Kalman filter for state estimation.</p>\n<p>Implements the standard Kalman filter algorithm to estimate the state of a\nlinear dynamic system from noisy measurements. The filter recursively updates\nstate estimates by combining predictions from a system model with incoming\nmeasurements, weighted by their respective uncertainties.</p>\n<p>The filter processes measurements at each time step through a two-stage process:\nprediction (using the system model) and update (incorporating measurements).</p>\n<p>The system model is:</p>\n<div>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\">\n  <msub>\n    <mi>x</mi>\n    <mrow>\n      <mi>k</mi>\n      <mo>+</mo>\n      <mn>1</mn>\n    </mrow>\n  </msub>\n  <mo>=</mo>\n  <mi>F</mi>\n  <msub>\n    <mi>x</mi>\n    <mi>k</mi>\n  </msub>\n  <mo>+</mo>\n  <mi>B</mi>\n  <msub>\n    <mi>u</mi>\n    <mi>k</mi>\n  </msub>\n  <mo>+</mo>\n  <msub>\n    <mi>w</mi>\n    <mi>k</mi>\n  </msub>\n</math>\n</div>\n<div>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\">\n  <msub>\n    <mi>z</mi>\n    <mi>k</mi>\n  </msub>\n  <mo>=</mo>\n  <mi>H</mi>\n  <msub>\n    <mi>x</mi>\n    <mi>k</mi>\n  </msub>\n  <mo>+</mo>\n  <msub>\n    <mi>v</mi>\n    <mi>k</mi>\n  </msub>\n</math>\n</div>\n<p>where <math xmlns=\"http://www.w3.org/1998/Math/MathML\">\n  <msub>\n    <mi>w</mi>\n    <mi>k</mi>\n  </msub>\n  <mo>∼</mo>\n  <mi>𝒩</mi>\n  <mo stretchy=\"false\">(</mo>\n  <mn>0</mn>\n  <mo>,</mo>\n  <mi>Q</mi>\n  <mo stretchy=\"false\">)</mo>\n</math> is process noise and\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\">\n  <msub>\n    <mi>v</mi>\n    <mi>k</mi>\n  </msub>\n  <mo>∼</mo>\n  <mi>𝒩</mi>\n  <mo stretchy=\"false\">(</mo>\n  <mn>0</mn>\n  <mo>,</mo>\n  <mi>R</mi>\n  <mo stretchy=\"false\">)</mo>\n</math> is measurement noise.</p>\n<p>At each time step, the filter performs:</p>\n<p><strong>Prediction:</strong></p>\n<div>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\">\n  <munderover>\n    <mi>x</mi>\n    <mrow>\n      <mi>k</mi>\n      <mo stretchy=\"false\">|</mo>\n      <mi>k</mi>\n      <mo>−</mo>\n      <mn>1</mn>\n    </mrow>\n    <mo stretchy=\"false\">ˆ</mo>\n  </munderover>\n  <mo>=</mo>\n  <mi>F</mi>\n  <munderover>\n    <mi>x</mi>\n    <mrow>\n      <mi>k</mi>\n      <mo>−</mo>\n      <mn>1</mn>\n    </mrow>\n    <mo stretchy=\"false\">ˆ</mo>\n  </munderover>\n  <mo>+</mo>\n  <mi>B</mi>\n  <msub>\n    <mi>u</mi>\n    <mi>k</mi>\n  </msub>\n</math>\n</div>\n<div>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\">\n  <msub>\n    <mi>P</mi>\n    <mrow>\n      <mi>k</mi>\n      <mo stretchy=\"false\">|</mo>\n      <mi>k</mi>\n      <mo>−</mo>\n      <mn>1</mn>\n    </mrow>\n  </msub>\n  <mo>=</mo>\n  <mi>F</mi>\n  <msub>\n    <mi>P</mi>\n    <mrow>\n      <mi>k</mi>\n      <mo>−</mo>\n      <mn>1</mn>\n    </mrow>\n  </msub>\n  <msup>\n    <mi>F</mi>\n    <mi>T</mi>\n  </msup>\n  <mo>+</mo>\n  <mi>Q</mi>\n</math>\n</div>\n<p><strong>Update:</strong></p>\n<div>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\">\n  <msub>\n    <mi>y</mi>\n    <mi>k</mi>\n  </msub>\n  <mo>=</mo>\n  <msub>\n    <mi>z</mi>\n    <mi>k</mi>\n  </msub>\n  <mo>−</mo>\n  <mi>H</mi>\n  <munderover>\n    <mi>x</mi>\n    <mrow>\n      <mi>k</mi>\n      <mo stretchy=\"false\">|</mo>\n      <mi>k</mi>\n      <mo>−</mo>\n      <mn>1</mn>\n    </mrow>\n    <mo stretchy=\"false\">ˆ</mo>\n  </munderover>\n</math>\n</div>\n<div>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\">\n  <msub>\n    <mi>S</mi>\n    <mi>k</mi>\n  </msub>\n  <mo>=</mo>\n  <mi>H</mi>\n  <msub>\n    <mi>P</mi>\n    <mrow>\n      <mi>k</mi>\n      <mo stretchy=\"false\">|</mo>\n      <mi>k</mi>\n      <mo>−</mo>\n      <mn>1</mn>\n    </mrow>\n  </msub>\n  <msup>\n    <mi>H</mi>\n    <mi>T</mi>\n  </msup>\n  <mo>+</mo>\n  <mi>R</mi>\n</math>\n</div>\n<div>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\">\n  <msub>\n    <mi>K</mi>\n    <mi>k</mi>\n  </msub>\n  <mo>=</mo>\n  <msub>\n    <mi>P</mi>\n    <mrow>\n      <mi>k</mi>\n      <mo stretchy=\"false\">|</mo>\n      <mi>k</mi>\n      <mo>−</mo>\n      <mn>1</mn>\n    </mrow>\n  </msub>\n  <msup>\n    <mi>H</mi>\n    <mi>T</mi>\n  </msup>\n  <msubsup>\n    <mi>S</mi>\n    <mi>k</mi>\n    <mrow>\n      <mo>−</mo>\n      <mn>1</mn>\n    </mrow>\n  </msubsup>\n</math>\n</div>\n<div>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\">\n  <munderover>\n    <mi>x</mi>\n    <mi>k</mi>\n    <mo stretchy=\"false\">ˆ</mo>\n  </munderover>\n  <mo>=</mo>\n  <munderover>\n    <mi>x</mi>\n    <mrow>\n      <mi>k</mi>\n      <mo stretchy=\"false\">|</mo>\n      <mi>k</mi>\n      <mo>−</mo>\n      <mn>1</mn>\n    </mrow>\n    <mo stretchy=\"false\">ˆ</mo>\n  </munderover>\n  <mo>+</mo>\n  <msub>\n    <mi>K</mi>\n    <mi>k</mi>\n  </msub>\n  <msub>\n    <mi>y</mi>\n    <mi>k</mi>\n  </msub>\n</math>\n</div>\n<div>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\">\n  <msub>\n    <mi>P</mi>\n    <mi>k</mi>\n  </msub>\n  <mo>=</mo>\n  <mo stretchy=\"false\">(</mo>\n  <mi>I</mi>\n  <mo>−</mo>\n  <msub>\n    <mi>K</mi>\n    <mi>k</mi>\n  </msub>\n  <mi>H</mi>\n  <mo stretchy=\"false\">)</mo>\n  <msub>\n    <mi>P</mi>\n    <mrow>\n      <mi>k</mi>\n      <mo stretchy=\"false\">|</mo>\n      <mi>k</mi>\n      <mo>−</mo>\n      <mn>1</mn>\n    </mrow>\n  </msub>\n</math>\n</div>\n<div class=\"section\" id=\"note\">\n<h4>Note</h4>\n<p>The block expects inputs in the following order:</p>\n<ul class=\"simple\">\n<li>First m inputs: measurements <math xmlns=\"http://www.w3.org/1998/Math/MathML\">\n  <mi>z</mi>\n</math></li>\n<li>Next p inputs (if B is provided): control inputs <math xmlns=\"http://www.w3.org/1998/Math/MathML\">\n  <mi>u</mi>\n</math></li>\n</ul>\n<p>The block outputs the n-dimensional state estimate <math xmlns=\"http://www.w3.org/1998/Math/MathML\">\n  <mover accent=\"true\">\n    <mi>x</mi>\n    <mo stretchy=\"false\">ˆ</mo>\n  </mover>\n</math>.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>F <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">ndarray</span></dt>\n<dd>State transition matrix (n x n). Describes how the state evolves from one\ntime step to the next.</dd>\n<dt>H <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">ndarray</span></dt>\n<dd>Measurement matrix (m x n). Maps the state space to the measurement space.</dd>\n<dt>Q <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">ndarray</span></dt>\n<dd>Process noise covariance matrix (n x n). Represents uncertainty in the\nsystem model.</dd>\n<dt>R <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">ndarray</span></dt>\n<dd>Measurement noise covariance matrix (m x m). Represents uncertainty in\nthe measurements.</dd>\n<dt>B <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">ndarray, optional</span></dt>\n<dd>Control input matrix (n x p). Maps control inputs to state changes.\nDefault is None (no control input).</dd>\n<dt>x0 <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">ndarray, optional</span></dt>\n<dd>Initial state estimate (n,). Default is zero vector.</dd>\n<dt>P0 <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">ndarray, optional</span></dt>\n<dd>Initial error covariance matrix (n x n). Default is identity matrix.</dd>\n</dl>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>x <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">ndarray</span></dt>\n<dd>Current state estimate <math xmlns=\"http://www.w3.org/1998/Math/MathML\">\n  <munderover>\n    <mi>x</mi>\n    <mi>k</mi>\n    <mo stretchy=\"false\">ˆ</mo>\n  </munderover>\n</math></dd>\n<dt>P <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">ndarray</span></dt>\n<dd>Current error covariance matrix <math xmlns=\"http://www.w3.org/1998/Math/MathML\">\n  <msub>\n    <mi>P</mi>\n    <mi>k</mi>\n  </msub>\n</math></dd>\n<dt>n <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>State dimension</dd>\n<dt>m <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>Measurement dimension</dd>\n<dt>p <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>Control input dimension</dd>\n</dl>\n</div>\n",
          "bases": [
            "Block"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "signature": "(F, H, Q, R, B = None, x0 = None, P0 = None, dt = None)",
              "parameters": [
                {
                  "name": "F",
                  "type": null,
                  "default": null,
                  "description": ""
                },
                {
                  "name": "H",
                  "type": null,
                  "default": null,
                  "description": ""
                },
                {
                  "name": "Q",
                  "type": null,
                  "default": null,
                  "description": ""
                },
                {
                  "name": "R",
                  "type": null,
                  "default": null,
                  "description": ""
                },
                {
                  "name": "B",
                  "type": null,
                  "default": "None",
                  "description": ""
                },
                {
                  "name": "x0",
                  "type": null,
                  "default": "None",
                  "description": ""
                },
                {
                  "name": "P0",
                  "type": null,
                  "default": "None",
                  "description": ""
                },
                {
                  "name": "dt",
                  "type": null,
                  "default": "None",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "sample",
              "description": "Sample after successful timestep.",
              "docstring_html": "<p>Sample after successful timestep.</p>\n<p>Updates the internal state estimate using the current measurements and\ncontrol inputs, then outputs the updated state estimate.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time for sampling</dd>\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>integration timestep</dd>\n</dl>\n",
              "signature": "(t, dt)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time for sampling"
                },
                {
                  "name": "dt",
                  "type": null,
                  "default": null,
                  "description": "integration timestep"
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "F",
              "description": "",
              "type": null,
              "value": "F"
            },
            {
              "name": "H",
              "description": "",
              "type": null,
              "value": "H"
            },
            {
              "name": "Q",
              "description": "",
              "type": null,
              "value": "Q"
            },
            {
              "name": "R",
              "description": "",
              "type": null,
              "value": "R"
            },
            {
              "name": "B",
              "description": "",
              "type": null,
              "value": "B"
            },
            {
              "name": "dt",
              "description": "",
              "type": null,
              "value": "dt"
            },
            {
              "name": "x",
              "description": "",
              "type": null,
              "value": "np.zeros(self.n) if x0 is None else x0"
            },
            {
              "name": "P",
              "description": "",
              "type": null,
              "value": "np.eye(self.n) if P0 is None else P0"
            },
            {
              "name": "inputs",
              "description": "",
              "type": null,
              "value": "Register(size=(self.m + self.p))"
            },
            {
              "name": "outputs",
              "description": "",
              "type": null,
              "value": "Register(size=(self.n))"
            },
            {
              "name": "events",
              "description": "",
              "type": null,
              "value": "[Schedule(t_period=(self.dt), func_act=(lambda _: self._kf_update()))]"
            }
          ],
          "parameters": [
            {
              "name": "F",
              "type": null,
              "default": null,
              "description": "State transition matrix (n x n). Describes how the state evolves from one time step to the next."
            },
            {
              "name": "H",
              "type": null,
              "default": null,
              "description": "Measurement matrix (m x n). Maps the state space to the measurement space."
            },
            {
              "name": "Q",
              "type": null,
              "default": null,
              "description": "Process noise covariance matrix (n x n). Represents uncertainty in the system model."
            },
            {
              "name": "R",
              "type": null,
              "default": null,
              "description": "Measurement noise covariance matrix (m x m). Represents uncertainty in the measurements."
            },
            {
              "name": "B",
              "type": null,
              "default": "None",
              "description": "Control input matrix (n x p). Maps control inputs to state changes. Default is None (no control input)."
            },
            {
              "name": "x0",
              "type": null,
              "default": "None",
              "description": "Initial state estimate (n,). Default is zero vector."
            },
            {
              "name": "P0",
              "type": null,
              "default": "None",
              "description": "Initial error covariance matrix (n x n). Default is identity matrix."
            },
            {
              "name": "dt",
              "type": null,
              "default": "None",
              "description": ""
            }
          ]
        },
        {
          "name": "Adder",
          "description": "Summs / adds up all input signals to a single output signal (MISO)",
          "docstring_html": "<p>Summs / adds up all input signals to a single output signal (MISO)</p>\n<p>This is how it works in the default case</p>\n<div>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\">\n  <mi>y</mi>\n  <mo stretchy=\"false\">(</mo>\n  <mi>t</mi>\n  <mo stretchy=\"false\">)</mo>\n  <mo>=</mo>\n  <munder>\n    <mo movablelimits=\"true\">∑</mo>\n    <mi>i</mi>\n  </munder>\n  <msub>\n    <mi>u</mi>\n    <mi>i</mi>\n  </msub>\n  <mo stretchy=\"false\">(</mo>\n  <mi>t</mi>\n  <mo stretchy=\"false\">)</mo>\n</math>\n</div>\n<p>and like this when additional operations are defined</p>\n<div>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\">\n  <mi>y</mi>\n  <mo stretchy=\"false\">(</mo>\n  <mi>t</mi>\n  <mo stretchy=\"false\">)</mo>\n  <mo>=</mo>\n  <munder>\n    <mo movablelimits=\"true\">∑</mo>\n    <mi>i</mi>\n  </munder>\n  <msub>\n    <mi>op</mi>\n    <mi>i</mi>\n  </msub>\n  <mo>⋅</mo>\n  <msub>\n    <mi>u</mi>\n    <mi>i</mi>\n  </msub>\n  <mo stretchy=\"false\">(</mo>\n  <mi>t</mi>\n  <mo stretchy=\"false\">)</mo>\n</math>\n</div>\n<div class=\"section\" id=\"example\">\n<h4>Example</h4>\n<p>This is the default initialization that just adds up all the inputs:</p>\n<pre class=\"code python literal-block\">\nA = Adder()\n</pre>\n<p>and this is the initialization with specific operations that subtracts\nthe second from first input and neglects all others:</p>\n<pre class=\"code python literal-block\">\nA = Adder('+-')\n</pre>\n</div>\n<div class=\"section\" id=\"note\">\n<h4>Note</h4>\n<p>This block is purely algebraic and its operation (<cite>op_alg</cite>) will be called\nmultiple times per timestep, each time when <cite>Simulation._update(t)</cite> is\ncalled in the global simulation loop.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>operations <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">str, optional</span></dt>\n<dd>optional string of operations to be applied before\nsummation, i.e. '+-' will compute the difference,\n'None' will just perform regular sum</dd>\n</dl>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>_ops <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">dict</span></dt>\n<dd>dict that maps string operations to numerical</dd>\n<dt>_ops_array <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array_like</span></dt>\n<dd>operations converted to array</dd>\n<dt>op_alg <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">Operator</span></dt>\n<dd>internal algebraic operator</dd>\n</dl>\n</div>\n",
          "bases": [
            "Block"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "signature": "(operations = None)",
              "parameters": [
                {
                  "name": "operations",
                  "type": null,
                  "default": "None",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "update",
              "description": "update system equation in fixed point loop for",
              "docstring_html": "<p>update system equation in fixed point loop for\nalgebraic loops, with optional error control</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time</dd>\n</dl>\n",
              "signature": "(t)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time"
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "input_port_labels",
              "description": "",
              "type": null,
              "value": "None"
            },
            {
              "name": "output_port_labels",
              "description": "",
              "type": null,
              "value": "{'out': 0}"
            },
            {
              "name": "operations",
              "description": "",
              "type": null,
              "value": "operations"
            },
            {
              "name": "op_alg",
              "description": "",
              "type": null,
              "value": "Operator(func=sum, jac=(lambda x: np.ones((1, len(x)))))"
            }
          ],
          "parameters": [
            {
              "name": "operations",
              "type": null,
              "default": "None",
              "description": "optional string of operations to be applied before summation, i.e. '+-' will compute the difference, 'None' will just perform regular sum"
            }
          ]
        },
        {
          "name": "Scope",
          "description": "Block for recording time domain data with variable sampling period.",
          "docstring_html": "<p>Block for recording time domain data with variable sampling period.</p>\n<p>A time threshold can be set by <cite>t_wait</cite> to start recording data after the simulation\ntime is larger then the specified waiting time, i.e. <cite>t - t_wait &gt; 0</cite>.\nThis is useful for recording data only after all the transients have settled.</p>\n<p>The block uses an internal <cite>Schedule</cite> event, when <cite>sampling_period</cite> is provided,\notherwise it just samples at every simulation timestep.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>sampling_period <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float, None</span></dt>\n<dd>time between samples, default is every timestep</dd>\n<dt>t_wait <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>wait time before starting recording, optional</dd>\n<dt>labels <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">list[str]</span></dt>\n<dd>labels for the scope traces, and for the csv, optional</dd>\n</dl>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>recording_time <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">list[float]</span></dt>\n<dd>recorded time points</dd>\n<dt>recording_data <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">list[float]</span></dt>\n<dd>recorded data points</dd>\n<dt>_incremental_idx <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>index for incremental reading of accumulated data since last\ncall of incremental read</dd>\n<dt>_sample_next_timestep <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>flag to indicate this is a timestep to sample, only used for\nevent based sampling when <cite>sampling_period</cite> is provided as an arg</dd>\n<dt>events <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">list[Schedule]</span></dt>\n<dd>internal scheduled event for periodic input sampling when\n<cite>sampling_period</cite> is provided</dd>\n</dl>\n",
          "bases": [
            "Block"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "signature": "(sampling_period = None, t_wait = 0.0, labels = None)",
              "parameters": [
                {
                  "name": "sampling_period",
                  "type": null,
                  "default": "None",
                  "description": ""
                },
                {
                  "name": "t_wait",
                  "type": null,
                  "default": "0.0",
                  "description": ""
                },
                {
                  "name": "labels",
                  "type": null,
                  "default": "None",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "reset",
              "description": "",
              "docstring_html": "",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "read",
              "description": "Return the recorded time domain data and the corresponding",
              "docstring_html": "<p>Return the recorded time domain data and the corresponding\ntime for all input ports</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>incremental <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>read the data incrementally, only return new data\nthat has accumulated after the last incremental read call</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>time <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array[float]</span></dt>\n<dd>recorded time points</dd>\n<dt>data <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array[obj]</span></dt>\n<dd>recorded data points</dd>\n</dl>\n",
              "signature": "(incremental = False)",
              "parameters": [
                {
                  "name": "incremental",
                  "type": null,
                  "default": "False",
                  "description": "read the data incrementally, only return new data that has accumulated after the last incremental read call"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "collect",
              "description": "Yield (category, id, data) tuples for recording blocks to simplify",
              "docstring_html": "<p>Yield (category, id, data) tuples for recording blocks to simplify\nglobal data collection from all recording blocks.</p>\n",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "sample",
              "description": "Sample the data from all inputs. Skips duplicate timestamps to maintain",
              "docstring_html": "<p>Sample the data from all inputs. Skips duplicate timestamps to maintain\nunique time points in the recording.</p>\n<p>If <cite>sampling_period</cite> is provided, this depends on the flag <cite>_sample_next_timestep</cite>,\nset by the internal <cite>Schedule</cite> event.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time for sampling</dd>\n</dl>\n",
              "signature": "(t, dt)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time for sampling"
                },
                {
                  "name": "dt",
                  "type": null,
                  "default": null,
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "plot",
              "description": "Directly create a plot of the recorded data for quick visualization and debugging.",
              "docstring_html": "<p>Directly create a plot of the recorded data for quick visualization and debugging.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>args <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">tuple</span></dt>\n<dd>args for ax.plot</dd>\n<dt>kwargs <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">dict</span></dt>\n<dd>kwargs for ax.plot</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>fig <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">matplotlib.figure</span></dt>\n<dd>internal figure instance</dd>\n<dt>ax <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">matplotlib.axis</span></dt>\n<dd>internal axis instance</dd>\n</dl>\n",
              "signature": "(args = (), kwargs = {})",
              "parameters": [
                {
                  "name": "args",
                  "type": null,
                  "default": "()",
                  "description": "args for ax.plot"
                },
                {
                  "name": "kwargs",
                  "type": null,
                  "default": "{}",
                  "description": "kwargs for ax.plot"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "plot2D",
              "description": "Directly create a 2D plot of the recorded data for quick visualization and debugging.",
              "docstring_html": "<p>Directly create a 2D plot of the recorded data for quick visualization and debugging.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>args <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">tuple</span></dt>\n<dd>args for ax.plot</dd>\n<dt>axes <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">tuple[int]</span></dt>\n<dd>axes / ports to select for 2d plot</dd>\n<dt>kwargs <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">dict</span></dt>\n<dd>kwargs for ax.plot</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>fig <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">matplotlib.figure</span></dt>\n<dd>internal figure instance</dd>\n<dt>ax <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">matplotlib.axis</span></dt>\n<dd>internal axis instance</dd>\n</dl>\n",
              "signature": "(args = (), axes = (0, 1), kwargs = {})",
              "parameters": [
                {
                  "name": "args",
                  "type": null,
                  "default": "()",
                  "description": "args for ax.plot"
                },
                {
                  "name": "axes",
                  "type": null,
                  "default": "(0, 1)",
                  "description": "axes / ports to select for 2d plot"
                },
                {
                  "name": "kwargs",
                  "type": null,
                  "default": "{}",
                  "description": "kwargs for ax.plot"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "plot3D",
              "description": "Directly create a 3D plot of the recorded data for quick visualization.",
              "docstring_html": "<p>Directly create a 3D plot of the recorded data for quick visualization.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>args <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">tuple</span></dt>\n<dd>args for ax.plot</dd>\n<dt>axes <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">tuple[int]</span></dt>\n<dd>indices of the three data channels (ports) to plot (default: (0, 1, 2)).</dd>\n<dt>kwargs <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">dict</span></dt>\n<dd>kwargs for ax.plot</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>fig <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">matplotlib.figure</span></dt>\n<dd>internal figure instance.</dd>\n<dt>ax <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">matplotlib.axes._axes.Axes3D</span></dt>\n<dd>internal 3D axis instance.</dd>\n</dl>\n",
              "signature": "(args = (), axes = (0, 1, 2), kwargs = {})",
              "parameters": [
                {
                  "name": "args",
                  "type": null,
                  "default": "()",
                  "description": "args for ax.plot"
                },
                {
                  "name": "axes",
                  "type": null,
                  "default": "(0, 1, 2)",
                  "description": "indices of the three data channels (ports) to plot (default: (0, 1, 2))."
                },
                {
                  "name": "kwargs",
                  "type": null,
                  "default": "{}",
                  "description": "kwargs for ax.plot"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "save",
              "description": "Save the recording of the scope to a csv file.",
              "docstring_html": "<p>Save the recording of the scope to a csv file.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>path <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">str</span></dt>\n<dd>path where to save the recording as a csv file</dd>\n</dl>\n",
              "signature": "(path = 'scope.csv')",
              "parameters": [
                {
                  "name": "path",
                  "type": null,
                  "default": "'scope.csv'",
                  "description": "path where to save the recording as a csv file"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "update",
              "description": "update system equation for fixed point loop,",
              "docstring_html": "<p>update system equation for fixed point loop,\nhere just setting the outputs</p>\n<div class=\"section\" id=\"note\">\n<h4>Note</h4>\n<p>Scope has no passthrough, so the 'update' method\nis optimized for this case (does nothing)</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>error <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>absolute error to previous iteration for convergence\ncontrol (always '0.0' because sink-type)</dd>\n</dl>\n</div>\n",
              "signature": "(t)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time"
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "input_port_labels",
              "description": "",
              "type": null,
              "value": "None"
            },
            {
              "name": "output_port_labels",
              "description": "",
              "type": null,
              "value": "{}"
            },
            {
              "name": "t_wait",
              "description": "",
              "type": null,
              "value": "t_wait"
            },
            {
              "name": "sampling_period",
              "description": "",
              "type": null,
              "value": "sampling_period"
            },
            {
              "name": "labels",
              "description": "",
              "type": null,
              "value": "labels if labels is not None else []"
            },
            {
              "name": "recording_time",
              "description": "",
              "type": null,
              "value": "[]"
            },
            {
              "name": "recording_data",
              "description": "",
              "type": null,
              "value": "[]"
            },
            {
              "name": "events",
              "description": "",
              "type": null,
              "value": "[Schedule(t_start=t_wait, t_period=sampling_period, func_act=_sample)]"
            }
          ],
          "parameters": [
            {
              "name": "sampling_period",
              "type": null,
              "default": "None",
              "description": "time between samples, default is every timestep"
            },
            {
              "name": "t_wait",
              "type": null,
              "default": "0.0",
              "description": "wait time before starting recording, optional"
            },
            {
              "name": "labels",
              "type": null,
              "default": "None",
              "description": "labels for the scope traces, and for the csv, optional"
            }
          ]
        },
        {
          "name": "RealtimeScope",
          "description": "An extension of the 'Scope' block that initializes a realtime plotter.",
          "docstring_html": "<p>An extension of the 'Scope' block that initializes a realtime plotter.</p>\n<p>Creates an interactive plotting window while the simulation is running.\nOtherwise implements the same functionality as the regular 'Scope' block.</p>\n<div class=\"section\" id=\"note\">\n<h4>Note</h4>\n<p>Due to the plotting being relatively expensive, including this block\nslows down the simulation significantly but may still be valuable for\ndebugging and testing.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>sampling_period <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float, None</span></dt>\n<dd>time between samples, default is every timestep</dd>\n<dt>t_wait <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>wait time before starting recording</dd>\n<dt>labels <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">list[str]</span></dt>\n<dd>labels for the scope traces, and for the csv</dd>\n<dt>max_samples <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int, None</span></dt>\n<dd>number of samples for realtime display, all per default</dd>\n</dl>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>plotter <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">RealtimePlotter</span></dt>\n<dd>instance of a RealtimePlotter</dd>\n</dl>\n</div>\n",
          "bases": [
            "Scope"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "signature": "(sampling_period = None, t_wait = 0.0, labels = [], max_samples = None)",
              "parameters": [
                {
                  "name": "sampling_period",
                  "type": null,
                  "default": "None",
                  "description": ""
                },
                {
                  "name": "t_wait",
                  "type": null,
                  "default": "0.0",
                  "description": ""
                },
                {
                  "name": "labels",
                  "type": null,
                  "default": "[]",
                  "description": ""
                },
                {
                  "name": "max_samples",
                  "type": null,
                  "default": "None",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "sample",
              "description": "Sample the data from all inputs, and overwrites existing timepoints,",
              "docstring_html": "<p>Sample the data from all inputs, and overwrites existing timepoints,\nsince we use a dict for storing the recorded data.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time for sampling</dd>\n</dl>\n",
              "signature": "(t, dt)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time for sampling"
                },
                {
                  "name": "dt",
                  "type": null,
                  "default": null,
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "plotter",
              "description": "",
              "type": null,
              "value": "RealtimePlotter(max_samples=max_samples, update_interval=0.1, labels=labels, x_label='time [s]', y_label='')"
            }
          ],
          "parameters": [
            {
              "name": "sampling_period",
              "type": null,
              "default": "None",
              "description": "time between samples, default is every timestep"
            },
            {
              "name": "t_wait",
              "type": null,
              "default": "0.0",
              "description": "wait time before starting recording"
            },
            {
              "name": "labels",
              "type": null,
              "default": "[]",
              "description": "labels for the scope traces, and for the csv"
            },
            {
              "name": "max_samples",
              "type": null,
              "default": "None",
              "description": "number of samples for realtime display, all per default"
            }
          ]
        },
        {
          "name": "AdaptiveBuffer",
          "description": "A class that manages an adaptive buffer for delay modeling which is primarily",
          "docstring_html": "<p>A class that manages an adaptive buffer for delay modeling which is primarily\nused in the pathsim 'Delay' block but might have future applications aswell.</p>\n<p>It implements a linear interpolation for arbitrary time lookup.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>delay <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>time delay in seconds</dd>\n</dl>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>buffer_t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">deque</span></dt>\n<dd>deque that collects the time data for buffering</dd>\n<dt>buffer_v <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">deque</span></dt>\n<dd>deque that collects the value data for buffering</dd>\n<dt>ns <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>savety for buffer truncation</dd>\n</dl>\n",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "signature": "(delay)",
              "parameters": [
                {
                  "name": "delay",
                  "type": null,
                  "default": null,
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "add",
              "description": "adding a new datapoint to the buffer",
              "docstring_html": "<p>adding a new datapoint to the buffer</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>time to add</dd>\n<dt>value <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float, int, complex</span></dt>\n<dd>numerical value to add</dd>\n</dl>\n",
              "signature": "(t, value)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "time to add"
                },
                {
                  "name": "value",
                  "type": null,
                  "default": null,
                  "description": "numerical value to add"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "interp",
              "description": "interpolate buffer at defined lookup time",
              "docstring_html": "<p>interpolate buffer at defined lookup time</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>time for interpolation</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>out <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float, array</span></dt>\n<dd>interpolated value</dd>\n</dl>\n",
              "signature": "(t)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "time for interpolation"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "get",
              "description": "lookup datapoint from buffer with",
              "docstring_html": "<p>lookup datapoint from buffer with\ndelay at <cite>t_lookup = t - delay</cite></p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>time for lookup with delay</dd>\n</dl>\n",
              "signature": "(t)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "time for lookup with delay"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "clear",
              "description": "clear the buffer, reset everything",
              "docstring_html": "<p>clear the buffer, reset everything</p>\n",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "delay",
              "description": "",
              "type": null,
              "value": "delay"
            },
            {
              "name": "buffer_t",
              "description": "",
              "type": null,
              "value": "deque()"
            },
            {
              "name": "buffer_v",
              "description": "",
              "type": null,
              "value": "deque()"
            },
            {
              "name": "ns",
              "description": "",
              "type": null,
              "value": "5"
            }
          ],
          "parameters": [
            {
              "name": "delay",
              "type": null,
              "default": null,
              "description": "time delay in seconds"
            }
          ]
        },
        {
          "name": "Delay",
          "description": "Delays the input signal by a time constant 'tau' in seconds.",
          "docstring_html": "<p>Delays the input signal by a time constant 'tau' in seconds.</p>\n<p>Mathematically this block creates a time delay of the input signal like this:</p>\n<div>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\">\n  <mi>y</mi>\n  <mo stretchy=\"false\">(</mo>\n  <mi>t</mi>\n  <mo stretchy=\"false\">)</mo>\n  <mo>=</mo>\n  <mrow>\n    <mo rspace=\"0.17em\">{</mo>\n    <mtable columnalign=\"left\" class=\"cases\">\n      <mtr>\n        <mtd>\n          <mi>x</mi>\n          <mo stretchy=\"false\">(</mo>\n          <mi>t</mi>\n          <mo>−</mo>\n          <mi>τ</mi>\n          <mo stretchy=\"false\">)</mo>\n        </mtd>\n        <mtd>\n          <mo>,</mo>\n          <mi>t</mi>\n          <mo>≥</mo>\n          <mi>τ</mi>\n        </mtd>\n      </mtr>\n      <mtr>\n        <mtd>\n          <mn>0</mn>\n        </mtd>\n        <mtd>\n          <mo>,</mo>\n          <mi>t</mi>\n          <mo>&lt;</mo>\n          <mi>τ</mi>\n        </mtd>\n      </mtr>\n    </mtable>\n  </mrow>\n</math>\n</div>\n<div class=\"section\" id=\"note\">\n<h4>Note</h4>\n<p>The internal adaptive buffer uses interpolation for the evaluation. This is\nrequired to be compatible with variable step solvers. It has a drawback however.\nThe order of the ode solver used will degrade when this block is used, due to\nthe interpolation.</p>\n</div>\n<div class=\"section\" id=\"note-1\">\n<h4>Note</h4>\n<p>This block supports vector input, meaning we can have multiple parallel\ndelay paths through this block.</p>\n</div>\n<div class=\"section\" id=\"example\">\n<h4>Example</h4>\n<p>The block is initialized like this:</p>\n<pre class=\"code python literal-block\">\n#5 time units delay\nD = Delay(tau=5)\n</pre>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>tau <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>delay time constant</dd>\n</dl>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>_buffer <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">AdaptiveBuffer</span></dt>\n<dd>internal interpolatable adaptive rolling buffer</dd>\n</dl>\n</div>\n",
          "bases": [
            "Block"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "signature": "(tau = 0.001)",
              "parameters": [
                {
                  "name": "tau",
                  "type": null,
                  "default": "0.001",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "reset",
              "description": "",
              "docstring_html": "",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "update",
              "description": "Evaluation of the buffer at different times",
              "docstring_html": "<p>Evaluation of the buffer at different times\nvia interpolation.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time</dd>\n</dl>\n",
              "signature": "(t)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "sample",
              "description": "Sample input values and time of sampling",
              "docstring_html": "<p>Sample input values and time of sampling\nand add them to the buffer.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time for sampling</dd>\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>integration timestep</dd>\n</dl>\n",
              "signature": "(t, dt)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time for sampling"
                },
                {
                  "name": "dt",
                  "type": null,
                  "default": null,
                  "description": "integration timestep"
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "tau",
              "description": "",
              "type": null,
              "value": "tau"
            }
          ],
          "parameters": [
            {
              "name": "tau",
              "type": null,
              "default": "0.001",
              "description": "delay time constant"
            }
          ]
        },
        {
          "name": "WhiteNoise",
          "description": "White noise source with Gaussian distribution.",
          "docstring_html": "<p>White noise source with Gaussian distribution.</p>\n<p>Generates uncorrelated random samples with either constant amplitude\n(<tt class=\"docutils literal\">standard_deviation</tt> mode) or timestep-scaled amplitude for stochastic\nintegration (<tt class=\"docutils literal\">spectral_density</tt> mode).</p>\n<p>In spectral density mode, output is scaled as √(S₀/dt) so that integrating\nthe noise yields correct statistical properties (Wiener process).</p>\n<div class=\"section\" id=\"note\">\n<h4>Note</h4>\n<p>If <tt class=\"docutils literal\">spectral_density</tt> is provided, it takes precedence over <tt class=\"docutils literal\">standard_deviation</tt>.\nIf <tt class=\"docutils literal\">sampling_period</tt> is set, noise is sampled at fixed intervals (zero-order hold).</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>standard_deviation <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>output standard deviation for constant-amplitude mode (default: 1.0)</dd>\n<dt>spectral_density <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float, optional</span></dt>\n<dd>power spectral density S₀ in [signal²/Hz]</dd>\n<dt>sampling_period <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float, optional</span></dt>\n<dd>time between samples, if None samples every timestep</dd>\n<dt>seed <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int, optional</span></dt>\n<dd>random seed for reproducibility</dd>\n</dl>\n</div>\n",
          "bases": [
            "Block"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "signature": "(standard_deviation = 1.0, spectral_density = None, sampling_period = None, seed = None)",
              "parameters": [
                {
                  "name": "standard_deviation",
                  "type": null,
                  "default": "1.0",
                  "description": ""
                },
                {
                  "name": "spectral_density",
                  "type": null,
                  "default": "None",
                  "description": ""
                },
                {
                  "name": "sampling_period",
                  "type": null,
                  "default": "None",
                  "description": ""
                },
                {
                  "name": "seed",
                  "type": null,
                  "default": "None",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "sample",
              "description": "Generate new noise sample after successful timestep.",
              "docstring_html": "<p>Generate new noise sample after successful timestep.</p>\n<p>Only generates new samples in continuous mode (sampling_period=None).</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time</dd>\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>integration timestep</dd>\n</dl>\n",
              "signature": "(t, dt)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time"
                },
                {
                  "name": "dt",
                  "type": null,
                  "default": null,
                  "description": "integration timestep"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "update",
              "description": "",
              "docstring_html": "",
              "signature": "(t)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "input_port_labels",
              "description": "",
              "type": null,
              "value": "{}"
            },
            {
              "name": "output_port_labels",
              "description": "",
              "type": null,
              "value": "{'out': 0}"
            },
            {
              "name": "standard_deviation",
              "description": "",
              "type": null,
              "value": "standard_deviation"
            },
            {
              "name": "spectral_density",
              "description": "",
              "type": null,
              "value": "spectral_density"
            },
            {
              "name": "sampling_period",
              "description": "",
              "type": null,
              "value": "sampling_period"
            },
            {
              "name": "events",
              "description": "",
              "type": null,
              "value": "[Schedule(t_start=0, t_period=sampling_period, func_act=_set)]"
            }
          ],
          "parameters": [
            {
              "name": "standard_deviation",
              "type": null,
              "default": "1.0",
              "description": "output standard deviation for constant-amplitude mode (default: 1.0)"
            },
            {
              "name": "spectral_density",
              "type": null,
              "default": "None",
              "description": "power spectral density S₀ in [signal²/Hz]"
            },
            {
              "name": "sampling_period",
              "type": null,
              "default": "None",
              "description": "time between samples, if None samples every timestep"
            },
            {
              "name": "seed",
              "type": null,
              "default": "None",
              "description": "random seed for reproducibility"
            }
          ]
        },
        {
          "name": "PinkNoise",
          "description": "Pink noise (1/f noise) source using the Voss-McCartney algorithm.",
          "docstring_html": "<p>Pink noise (1/f noise) source using the Voss-McCartney algorithm.</p>\n<p>Generates noise with power spectral density proportional to 1/f, where\nlower frequencies have more power than higher frequencies.</p>\n<p>The algorithm maintains <tt class=\"docutils literal\">num_octaves</tt> independent random values representing\ndifferent frequency bands. At each sample, one octave is updated based on the\nbinary representation of the sample counter, creating the characteristic 1/f\nspectrum through the superposition of different update rates.</p>\n<div class=\"section\" id=\"note\">\n<h4>Note</h4>\n<p>If <tt class=\"docutils literal\">spectral_density</tt> is provided, it takes precedence over <tt class=\"docutils literal\">standard_deviation</tt>.\nIf <tt class=\"docutils literal\">sampling_period</tt> is set, noise is sampled at fixed intervals (zero-order hold).</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>standard_deviation <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>approximate output standard deviation (default: 1.0)</dd>\n<dt>spectral_density <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float, optional</span></dt>\n<dd>power spectral density, output scaled as √(S₀/(N·dt))</dd>\n<dt>num_octaves <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>number of frequency bands in algorithm (default: 16)</dd>\n<dt>sampling_period <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float, optional</span></dt>\n<dd>time between samples, if None samples every timestep</dd>\n<dt>seed <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int, optional</span></dt>\n<dd>random seed for reproducibility</dd>\n</dl>\n</div>\n",
          "bases": [
            "Block"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "signature": "(standard_deviation = 1.0, spectral_density = None, num_octaves = 16, sampling_period = None, seed = None)",
              "parameters": [
                {
                  "name": "standard_deviation",
                  "type": null,
                  "default": "1.0",
                  "description": ""
                },
                {
                  "name": "spectral_density",
                  "type": null,
                  "default": "None",
                  "description": ""
                },
                {
                  "name": "num_octaves",
                  "type": null,
                  "default": "16",
                  "description": ""
                },
                {
                  "name": "sampling_period",
                  "type": null,
                  "default": "None",
                  "description": ""
                },
                {
                  "name": "seed",
                  "type": null,
                  "default": "None",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "reset",
              "description": "Reset the noise generator state.",
              "docstring_html": "<p>Reset the noise generator state.</p>\n<p>Resets the sample counter and reinitializes all octave values.</p>\n",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "sample",
              "description": "Generate new noise sample after successful timestep.",
              "docstring_html": "<p>Generate new noise sample after successful timestep.</p>\n<p>Only generates new samples in continuous mode (sampling_period=None).</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time</dd>\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>integration timestep</dd>\n</dl>\n",
              "signature": "(t, dt)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time"
                },
                {
                  "name": "dt",
                  "type": null,
                  "default": null,
                  "description": "integration timestep"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "update",
              "description": "",
              "docstring_html": "",
              "signature": "(t)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "input_port_labels",
              "description": "",
              "type": null,
              "value": "{}"
            },
            {
              "name": "output_port_labels",
              "description": "",
              "type": null,
              "value": "{'out': 0}"
            },
            {
              "name": "standard_deviation",
              "description": "",
              "type": null,
              "value": "standard_deviation"
            },
            {
              "name": "spectral_density",
              "description": "",
              "type": null,
              "value": "spectral_density"
            },
            {
              "name": "num_octaves",
              "description": "",
              "type": null,
              "value": "num_octaves"
            },
            {
              "name": "sampling_period",
              "description": "",
              "type": null,
              "value": "sampling_period"
            },
            {
              "name": "n_samples",
              "description": "",
              "type": null,
              "value": "0"
            },
            {
              "name": "octave_values",
              "description": "",
              "type": null,
              "value": "self._rng.normal(0, 1, self.num_octaves)"
            },
            {
              "name": "events",
              "description": "",
              "type": null,
              "value": "[Schedule(t_start=0, t_period=sampling_period, func_act=_set)]"
            }
          ],
          "parameters": [
            {
              "name": "standard_deviation",
              "type": null,
              "default": "1.0",
              "description": "approximate output standard deviation (default: 1.0)"
            },
            {
              "name": "spectral_density",
              "type": null,
              "default": "None",
              "description": "power spectral density, output scaled as √(S₀/(N·dt))"
            },
            {
              "name": "num_octaves",
              "type": null,
              "default": "16",
              "description": "number of frequency bands in algorithm (default: 16)"
            },
            {
              "name": "sampling_period",
              "type": null,
              "default": "None",
              "description": "time between samples, if None samples every timestep"
            },
            {
              "name": "seed",
              "type": null,
              "default": "None",
              "description": "random seed for reproducibility"
            }
          ]
        },
        {
          "name": "LUT",
          "description": "N-dimensional lookup table with linear interpolation functionality.",
          "docstring_html": "<p>N-dimensional lookup table with linear interpolation functionality.</p>\n<p>This class implements a multi-dimensional lookup table that uses scipy's\nLinearNDInterpolator <a class=\"footnote-reference\" href=\"#scipy\" id=\"footnote-reference-1\">[1]</a> for piecewise linear interpolation in N-dimensional\nspace. The interpolation is based on Delaunay triangulation of the input points,\nproviding smooth linear interpolation between data points. For points outside\nthe convex hull of the input data, the interpolator returns NaN values.</p>\n<p>The LUT acts as a Function block.</p>\n<p><strong>References</strong></p>\n<table class=\"docutils footnote\" frame=\"void\" id=\"scipy\" rules=\"none\">\n<colgroup><col class=\"label\" /><col /></colgroup>\n<tbody valign=\"top\">\n<tr><td class=\"label\"><a class=\"fn-backref\" href=\"#footnote-reference-1\">[1]</a></td><td><a class=\"reference external\" href=\"https://docs.scipy.org/doc/scipy-1.16.1/reference/generated/scipy.interpolate.LinearNDInterpolator.html\">https://docs.scipy.org/doc/scipy-1.16.1/reference/generated/scipy.interpolate.LinearNDInterpolator.html</a></td></tr>\n</tbody>\n</table>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>points <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array_like of shape (n, ndim)</span></dt>\n<dd>2-D array of data point coordinates where n is the number of points\nand ndim is the dimensionality of the space. Each row represents a\nsingle data point in ndim-dimensional space.</dd>\n<dt>values <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array_like of shape (n,) or (n, m)</span></dt>\n<dd>N-D array of data values at the corresponding points. If 1-D, represents\nscalar values at each point. If 2-D, each column represents a different\noutput dimension (m output values per input point).</dd>\n</dl>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>points <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">ndarray</span></dt>\n<dd>Stored array of input point coordinates.</dd>\n<dt>values <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">ndarray</span></dt>\n<dd>Stored array of output values at each point.</dd>\n<dt>inter <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">scipy.interpolate.LinearNDInterpolator</span></dt>\n<dd>The scipy linear interpolator object used for interpolation.</dd>\n</dl>\n",
          "bases": [
            "Function"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "signature": "(points = None, values = None)",
              "parameters": [
                {
                  "name": "points",
                  "type": null,
                  "default": "None",
                  "description": ""
                },
                {
                  "name": "values",
                  "type": null,
                  "default": "None",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "points",
              "description": "",
              "type": null,
              "value": "np.asarray(points) if points is not None else np.ones(2)"
            },
            {
              "name": "values",
              "description": "",
              "type": null,
              "value": "np.asarray(values) if values is not None else np.ones(2)"
            },
            {
              "name": "inter",
              "description": "",
              "type": null,
              "value": "LinearNDInterpolator(self.points, self.values)"
            }
          ],
          "parameters": [
            {
              "name": "points",
              "type": null,
              "default": "None",
              "description": "2-D array of data point coordinates where n is the number of points and ndim is the dimensionality of the space. Each row represents a single data point in ndim-dimensional space."
            },
            {
              "name": "values",
              "type": null,
              "default": "None",
              "description": "N-D array of data values at the corresponding points. If 1-D, represents scalar values at each point. If 2-D, each column represents a different output dimension (m output values per input point)."
            }
          ]
        },
        {
          "name": "LUT1D",
          "description": "One-dimensional lookup table with linear interpolation functionality.",
          "docstring_html": "<p>One-dimensional lookup table with linear interpolation functionality.</p>\n<p>This class implements a 1-dimensional lookup table that uses scipy's interp1d <a class=\"footnote-reference\" href=\"#scipy\" id=\"footnote-reference-1\">[1]</a>\nfor piecewise linear interpolation along a single axis. The interpolation\nprovides linear interpolation between adjacent data points and supports\nextrapolation beyond the input data range using the 'extrapolate' fill mode.</p>\n<p>The LUT1D acts as a Function block.</p>\n<p><strong>References</strong></p>\n<table class=\"docutils footnote\" frame=\"void\" id=\"scipy\" rules=\"none\">\n<colgroup><col class=\"label\" /><col /></colgroup>\n<tbody valign=\"top\">\n<tr><td class=\"label\"><a class=\"fn-backref\" href=\"#footnote-reference-1\">[1]</a></td><td><a class=\"reference external\" href=\"https://docs.scipy.org/doc/scipy-1.16.1/reference/generated/scipy.interpolate.interp1d.html\">https://docs.scipy.org/doc/scipy-1.16.1/reference/generated/scipy.interpolate.interp1d.html</a></td></tr>\n</tbody>\n</table>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>points <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array_like of shape (n,)</span></dt>\n<dd>1-D array of monotonically increasing data point coordinates where n\nis the number of points. These represent the independent variable values\nat which the dependent values are known.</dd>\n<dt>values <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array_like of shape (n,) or (n, m)</span></dt>\n<dd>1-D or 2-D array of data values at the corresponding points. If 1-D,\nrepresents scalar values at each point. If 2-D with shape (n, m),\neach column represents a different output dimension, allowing the\nlookup table to return m-dimensional vectors.</dd>\n<dt>fill_value <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float or str, optional</span></dt>\n<dd>The value to use for points outside the interpolation range. If &quot;extrapolate&quot;,\nthe interpolator will use linear extrapolation. Default is &quot;extrapolate&quot;.\nSee <a class=\"reference external\" href=\"https://docs.scipy.org/doc/scipy-1.16.1/reference/generated/scipy.interpolate.interp1d.html\">https://docs.scipy.org/doc/scipy-1.16.1/reference/generated/scipy.interpolate.interp1d.html</a> for more details</dd>\n</dl>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>points <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">ndarray</span></dt>\n<dd>Flattened array of input point coordinates, stored as 1-D array.</dd>\n<dt>values <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">ndarray</span></dt>\n<dd>Stored array of output values at each point, preserving original shape.</dd>\n<dt>inter <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">scipy.interpolate.interp1d</span></dt>\n<dd>The scipy 1D interpolator object used for linear interpolation with\nextrapolation enabled beyond the data range.</dd>\n</dl>\n",
          "bases": [
            "Function"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "signature": "(points = None, values = None, fill_value = 'extrapolate')",
              "parameters": [
                {
                  "name": "points",
                  "type": null,
                  "default": "None",
                  "description": ""
                },
                {
                  "name": "values",
                  "type": null,
                  "default": "None",
                  "description": ""
                },
                {
                  "name": "fill_value",
                  "type": null,
                  "default": "'extrapolate'",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "points",
              "description": "",
              "type": null,
              "value": "np.asarray(points).flatten() if points is not None else np.ones(2)"
            },
            {
              "name": "values",
              "description": "",
              "type": null,
              "value": "np.asarray(values) if values is not None else np.ones(2)"
            },
            {
              "name": "inter",
              "description": "",
              "type": null,
              "value": "interp1d(self.points, self.values, fill_value=fill_value)"
            }
          ],
          "parameters": [
            {
              "name": "points",
              "type": null,
              "default": "None",
              "description": "1-D array of monotonically increasing data point coordinates where n is the number of points. These represent the independent variable values at which the dependent values are known."
            },
            {
              "name": "values",
              "type": null,
              "default": "None",
              "description": "1-D or 2-D array of data values at the corresponding points. If 1-D, represents scalar values at each point. If 2-D with shape (n, m), each column represents a different output dimension, allowing the lookup table to return m-dimensional vectors."
            },
            {
              "name": "fill_value",
              "type": null,
              "default": "'extrapolate'",
              "description": "The value to use for points outside the interpolation range. If \"extrapolate\", the interpolator will use linear extrapolation. Default is \"extrapolate\". See https://docs.scipy.org/doc/scipy-1.16.1/reference/generated/scipy.interpolate.interp1d.html for more details"
            }
          ]
        },
        {
          "name": "Relay",
          "description": "Relay block with hysteresis (Schmitt trigger).",
          "docstring_html": "<p>Relay block with hysteresis (Schmitt trigger).</p>\n<p>Switches output between two values based on input crossing upper and lower\nthresholds. The hysteresis prevents rapid switching when input is noisy.</p>\n<p>When input rises above <cite>threshold_up</cite>, output switches to <cite>value_up</cite>.\nWhen input falls below <cite>threshold_down</cite>, output switches to <cite>value_down</cite>.</p>\n<p><strong>Examples</strong></p>\n<p>Basic thermostat that turns heater on below 19°C, off above 21°C:</p>\n<pre class=\"code python literal-block\">\nfrom pathsim.blocks import Relay\n\nthermostat = Relay(\n    threshold_up=21.0,\n    threshold_down=19.0,\n    value_up=0.0,\n    value_down=1.0\n    )\n</pre>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>threshold_up <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>threshold for transitioning to upper relay state <cite>value_up</cite> (default: 1.0)</dd>\n<dt>threshold_down <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>threshold for transitioning to lower relay state <cite>value_down</cite> (default: 0.0)</dd>\n<dt>value_up <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>value for upper relay state (default: 1.0)</dd>\n<dt>value_down <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>value for lower relay state (default: 0.0)</dd>\n</dl>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>events <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">list[ZeroCrossingUp, ZeroCrossingDown]</span></dt>\n<dd>internal zero crossing events for relay state transitions</dd>\n</dl>\n",
          "bases": [
            "Block"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "signature": "(threshold_up = 1.0, threshold_down = 0.0, value_up = 1.0, value_down = 0.0)",
              "parameters": [
                {
                  "name": "threshold_up",
                  "type": null,
                  "default": "1.0",
                  "description": ""
                },
                {
                  "name": "threshold_down",
                  "type": null,
                  "default": "0.0",
                  "description": ""
                },
                {
                  "name": "value_up",
                  "type": null,
                  "default": "1.0",
                  "description": ""
                },
                {
                  "name": "value_down",
                  "type": null,
                  "default": "0.0",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "update",
              "description": "update system equation for fixed point loop,",
              "docstring_html": "<p>update system equation for fixed point loop,\nhere just setting the outputs</p>\n<div class=\"section\" id=\"note\">\n<h4>Note</h4>\n<p>No pasthrough, setting block outputs is done\nby the internal events.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time</dd>\n</dl>\n</div>\n",
              "signature": "(t)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time"
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "input_port_labels",
              "description": "",
              "type": null,
              "value": "{'in': 0}"
            },
            {
              "name": "output_port_labels",
              "description": "",
              "type": null,
              "value": "{'out': 0}"
            },
            {
              "name": "threshold_up",
              "description": "",
              "type": null,
              "value": "threshold_up"
            },
            {
              "name": "threshold_down",
              "description": "",
              "type": null,
              "value": "threshold_down"
            },
            {
              "name": "value_up",
              "description": "",
              "type": null,
              "value": "value_up"
            },
            {
              "name": "value_down",
              "description": "",
              "type": null,
              "value": "value_down"
            },
            {
              "name": "events",
              "description": "",
              "type": null,
              "value": "[ZeroCrossingUp(func_evt=(_check(self.threshold_up)), func_act=(_set(self.value_up))), ZeroCrossingDown(func_evt=(_check(self.threshold_down)), func_act=(_set(self.value_down)))]"
            }
          ],
          "parameters": [
            {
              "name": "threshold_up",
              "type": null,
              "default": "1.0",
              "description": "threshold for transitioning to upper relay state `value_up` (default: 1.0)"
            },
            {
              "name": "threshold_down",
              "type": null,
              "default": "0.0",
              "description": "threshold for transitioning to lower relay state `value_down` (default: 0.0)"
            },
            {
              "name": "value_up",
              "type": null,
              "default": "1.0",
              "description": "value for upper relay state (default: 1.0)"
            },
            {
              "name": "value_down",
              "type": null,
              "default": "0.0",
              "description": "value for lower relay state (default: 0.0)"
            }
          ]
        },
        {
          "name": "Math",
          "description": "Base math block.",
          "docstring_html": "<p>Base math block.</p>\n<div class=\"section\" id=\"note\">\n<h4>Note</h4>\n<p>This block doesnt implement any functionality itself.\nIts intended to be used as a base for the elementary math blocks.\nIts <strong>not</strong> intended to be used directly!</p>\n</div>\n",
          "bases": [
            "Block"
          ],
          "methods": [
            {
              "name": "update",
              "description": "update algebraic component of system equation",
              "docstring_html": "<p>update algebraic component of system equation</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time</dd>\n</dl>\n",
              "signature": "(t)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time"
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [],
          "parameters": []
        },
        {
          "name": "Sin",
          "description": "Sine operator block.",
          "docstring_html": "<p>Sine operator block.</p>\n<p>This block supports vector inputs. This is the operation it does:</p>\n<div>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\">\n  <mover accent=\"true\">\n    <mi>y</mi>\n    <mo stretchy=\"false\" scriptlevel=\"+1\">→</mo>\n  </mover>\n  <mo>=</mo>\n  <mi>sin</mi>\n  <mo>&ApplyFunction;</mo>\n  <mo stretchy=\"false\">(</mo>\n  <mover accent=\"true\">\n    <mi>u</mi>\n    <mo stretchy=\"false\" scriptlevel=\"+1\">→</mo>\n  </mover>\n  <mo stretchy=\"false\">)</mo>\n</math>\n</div>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>op_alg <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">Operator</span></dt>\n<dd>internal algebraic operator</dd>\n</dl>\n",
          "bases": [
            "Math"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "op_alg",
              "description": "",
              "type": null,
              "value": "Operator(func=(np.sin), jac=(lambda x: np.diag(np.cos(x))))"
            }
          ],
          "parameters": []
        },
        {
          "name": "Cos",
          "description": "Cosine operator block.",
          "docstring_html": "<p>Cosine operator block.</p>\n<p>This block supports vector inputs. This is the operation it does:</p>\n<div>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\">\n  <mover accent=\"true\">\n    <mi>y</mi>\n    <mo stretchy=\"false\" scriptlevel=\"+1\">→</mo>\n  </mover>\n  <mo>=</mo>\n  <mi>cos</mi>\n  <mo>&ApplyFunction;</mo>\n  <mo stretchy=\"false\">(</mo>\n  <mover accent=\"true\">\n    <mi>u</mi>\n    <mo stretchy=\"false\" scriptlevel=\"+1\">→</mo>\n  </mover>\n  <mo stretchy=\"false\">)</mo>\n</math>\n</div>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>op_alg <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">Operator</span></dt>\n<dd>internal algebraic operator</dd>\n</dl>\n",
          "bases": [
            "Math"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "op_alg",
              "description": "",
              "type": null,
              "value": "Operator(func=(np.cos), jac=(lambda x: -np.diag(np.sin(x))))"
            }
          ],
          "parameters": []
        },
        {
          "name": "Sqrt",
          "description": "Square root operator block.",
          "docstring_html": "<p>Square root operator block.</p>\n<p>This block supports vector inputs. This is the operation it does:</p>\n<div>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\">\n  <mover accent=\"true\">\n    <mi>y</mi>\n    <mo stretchy=\"false\" scriptlevel=\"+1\">→</mo>\n  </mover>\n  <mo>=</mo>\n  <msqrt>\n    <mo stretchy=\"false\">|</mo>\n    <mover accent=\"true\">\n      <mi>u</mi>\n      <mo stretchy=\"false\" scriptlevel=\"+1\">→</mo>\n    </mover>\n    <mo stretchy=\"false\">|</mo>\n  </msqrt>\n</math>\n</div>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>op_alg <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">Operator</span></dt>\n<dd>internal algebraic operator</dd>\n</dl>\n",
          "bases": [
            "Math"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "op_alg",
              "description": "",
              "type": null,
              "value": "Operator(func=(lambda x: np.sqrt(abs(x))), jac=(lambda x: np.diag(1 / np.sqrt(abs(x)))))"
            }
          ],
          "parameters": []
        },
        {
          "name": "Abs",
          "description": "Absolute value operator block.",
          "docstring_html": "<p>Absolute value operator block.</p>\n<p>This block supports vector inputs. This is the operation it does:</p>\n<div>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\">\n  <mover accent=\"true\">\n    <mi>y</mi>\n    <mo stretchy=\"false\" scriptlevel=\"+1\">→</mo>\n  </mover>\n  <mo>=</mo>\n  <mo>|</mo>\n  <mo stretchy=\"false\">|</mo>\n  <mover accent=\"true\">\n    <mi>u</mi>\n    <mo stretchy=\"false\" scriptlevel=\"+1\">→</mo>\n  </mover>\n  <mo>|</mo>\n  <mo stretchy=\"false\">|</mo>\n</math>\n</div>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>op_alg <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">Operator</span></dt>\n<dd>internal algebraic operator</dd>\n</dl>\n",
          "bases": [
            "Math"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "op_alg",
              "description": "",
              "type": null,
              "value": "Operator(func=(lambda x: abs(x)), jac=(lambda x: np.diag(np.sign(x))))"
            }
          ],
          "parameters": []
        },
        {
          "name": "Pow",
          "description": "Raise to power operator block.",
          "docstring_html": "<p>Raise to power operator block.</p>\n<p>This block supports vector inputs. This is the operation it does:</p>\n<div>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\">\n  <mover accent=\"true\">\n    <mi>y</mi>\n    <mo stretchy=\"false\" scriptlevel=\"+1\">→</mo>\n  </mover>\n  <mo>=</mo>\n  <msup>\n    <mover accent=\"true\">\n      <mi>u</mi>\n      <mo stretchy=\"false\" scriptlevel=\"+1\">→</mo>\n    </mover>\n    <mi>p</mi>\n  </msup>\n</math>\n</div>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>exponent <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float, array_like</span></dt>\n<dd>exponent to raise the input to the power of</dd>\n</dl>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>op_alg <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">Operator</span></dt>\n<dd>internal algebraic operator</dd>\n</dl>\n",
          "bases": [
            "Math"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "signature": "(exponent = 2)",
              "parameters": [
                {
                  "name": "exponent",
                  "type": null,
                  "default": "2",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "exponent",
              "description": "",
              "type": null,
              "value": "exponent"
            },
            {
              "name": "op_alg",
              "description": "",
              "type": null,
              "value": "Operator(func=(lambda x: np.power(x, self.exponent)), jac=(lambda x: np.diag(self.exponent * np.power(x, self.exponent - 1))))"
            }
          ],
          "parameters": [
            {
              "name": "exponent",
              "type": null,
              "default": "2",
              "description": "exponent to raise the input to the power of Attributes ----------"
            }
          ]
        },
        {
          "name": "PowProd",
          "description": "Power-Product operator block.",
          "docstring_html": "<p>Power-Product operator block.</p>\n<p>This block raises each input to a power and then multiplies all results together:</p>\n<div>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\">\n  <mi>y</mi>\n  <mo>=</mo>\n  <munder>\n    <mo movablelimits=\"true\">∏</mo>\n    <mi>i</mi>\n  </munder>\n  <msubsup>\n    <mi>u</mi>\n    <mi>i</mi>\n    <msub>\n      <mi>p</mi>\n      <mi>i</mi>\n    </msub>\n  </msubsup>\n</math>\n</div>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>exponents <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float, array_like</span></dt>\n<dd>exponent(s) to raise the inputs to the power of. If scalar,\napplies same exponent to all inputs.</dd>\n</dl>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>op_alg <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">Operator</span></dt>\n<dd>internal algebraic operator</dd>\n</dl>\n",
          "bases": [
            "Math"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "signature": "(exponents = 2)",
              "parameters": [
                {
                  "name": "exponents",
                  "type": null,
                  "default": "2",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "exponents",
              "description": "",
              "type": null,
              "value": "exponents"
            },
            {
              "name": "op_alg",
              "description": "",
              "type": null,
              "value": "Operator(func=(lambda x: np.prod(np.power(x, self.exponents))), jac=_jac)"
            }
          ],
          "parameters": [
            {
              "name": "exponents",
              "type": null,
              "default": "2",
              "description": "exponent(s) to raise the inputs to the power of. If scalar, applies same exponent to all inputs. Attributes ----------"
            }
          ]
        },
        {
          "name": "Exp",
          "description": "Exponential operator block.",
          "docstring_html": "<p>Exponential operator block.</p>\n<p>This block supports vector inputs. This is the operation it does:</p>\n<div>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\">\n  <mover accent=\"true\">\n    <mi>y</mi>\n    <mo stretchy=\"false\" scriptlevel=\"+1\">→</mo>\n  </mover>\n  <mo>=</mo>\n  <msup>\n    <mi>e</mi>\n    <mover accent=\"true\">\n      <mi>u</mi>\n      <mo stretchy=\"false\" scriptlevel=\"+1\">→</mo>\n    </mover>\n  </msup>\n</math>\n</div>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>op_alg <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">Operator</span></dt>\n<dd>internal algebraic operator</dd>\n</dl>\n",
          "bases": [
            "Math"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "op_alg",
              "description": "",
              "type": null,
              "value": "Operator(func=(np.exp), jac=(lambda x: np.diag(np.exp(x))))"
            }
          ],
          "parameters": []
        },
        {
          "name": "Log",
          "description": "Natural logarithm operator block.",
          "docstring_html": "<p>Natural logarithm operator block.</p>\n<p>This block supports vector inputs. This is the operation it does:</p>\n<div>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\">\n  <mover accent=\"true\">\n    <mi>y</mi>\n    <mo stretchy=\"false\" scriptlevel=\"+1\">→</mo>\n  </mover>\n  <mo>=</mo>\n  <mi>ln</mi>\n  <mo>&ApplyFunction;</mo>\n  <mo stretchy=\"false\">(</mo>\n  <mover accent=\"true\">\n    <mi>u</mi>\n    <mo stretchy=\"false\" scriptlevel=\"+1\">→</mo>\n  </mover>\n  <mo stretchy=\"false\">)</mo>\n</math>\n</div>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>op_alg <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">Operator</span></dt>\n<dd>internal algebraic operator</dd>\n</dl>\n",
          "bases": [
            "Math"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "op_alg",
              "description": "",
              "type": null,
              "value": "Operator(func=(np.log), jac=(lambda x: np.diag(1 / x)))"
            }
          ],
          "parameters": []
        },
        {
          "name": "Log10",
          "description": "Base-10 logarithm operator block.",
          "docstring_html": "<p>Base-10 logarithm operator block.</p>\n<p>This block supports vector inputs. This is the operation it does:</p>\n<div>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\">\n  <mover accent=\"true\">\n    <mi>y</mi>\n    <mo stretchy=\"false\" scriptlevel=\"+1\">→</mo>\n  </mover>\n  <mo>=</mo>\n  <msub>\n    <mi>log</mi>\n    <mn>10</mn>\n  </msub>\n  <mo stretchy=\"false\">(</mo>\n  <mover accent=\"true\">\n    <mi>u</mi>\n    <mo stretchy=\"false\" scriptlevel=\"+1\">→</mo>\n  </mover>\n  <mo stretchy=\"false\">)</mo>\n</math>\n</div>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>op_alg <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">Operator</span></dt>\n<dd>internal algebraic operator</dd>\n</dl>\n",
          "bases": [
            "Math"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "op_alg",
              "description": "",
              "type": null,
              "value": "Operator(func=(np.log10), jac=(lambda x: np.diag(1 / (x * np.log(10)))))"
            }
          ],
          "parameters": []
        },
        {
          "name": "Tan",
          "description": "Tangent operator block.",
          "docstring_html": "<p>Tangent operator block.</p>\n<p>This block supports vector inputs. This is the operation it does:</p>\n<div>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\">\n  <mover accent=\"true\">\n    <mi>y</mi>\n    <mo stretchy=\"false\" scriptlevel=\"+1\">→</mo>\n  </mover>\n  <mo>=</mo>\n  <mi>tan</mi>\n  <mo>&ApplyFunction;</mo>\n  <mo stretchy=\"false\">(</mo>\n  <mover accent=\"true\">\n    <mi>u</mi>\n    <mo stretchy=\"false\" scriptlevel=\"+1\">→</mo>\n  </mover>\n  <mo stretchy=\"false\">)</mo>\n</math>\n</div>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>op_alg <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">Operator</span></dt>\n<dd>internal algebraic operator</dd>\n</dl>\n",
          "bases": [
            "Math"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "op_alg",
              "description": "",
              "type": null,
              "value": "Operator(func=(np.tan), jac=(lambda x: np.diag(1 / np.cos(x) ** 2)))"
            }
          ],
          "parameters": []
        },
        {
          "name": "Sinh",
          "description": "Hyperbolic sine operator block.",
          "docstring_html": "<p>Hyperbolic sine operator block.</p>\n<p>This block supports vector inputs. This is the operation it does:</p>\n<div>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\">\n  <mover accent=\"true\">\n    <mi>y</mi>\n    <mo stretchy=\"false\" scriptlevel=\"+1\">→</mo>\n  </mover>\n  <mo>=</mo>\n  <mi>sinh</mi>\n  <mo>&ApplyFunction;</mo>\n  <mo stretchy=\"false\">(</mo>\n  <mover accent=\"true\">\n    <mi>u</mi>\n    <mo stretchy=\"false\" scriptlevel=\"+1\">→</mo>\n  </mover>\n  <mo stretchy=\"false\">)</mo>\n</math>\n</div>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>op_alg <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">Operator</span></dt>\n<dd>internal algebraic operator</dd>\n</dl>\n",
          "bases": [
            "Math"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "op_alg",
              "description": "",
              "type": null,
              "value": "Operator(func=(np.sinh), jac=(lambda x: np.diag(np.cosh(x))))"
            }
          ],
          "parameters": []
        },
        {
          "name": "Cosh",
          "description": "Hyperbolic cosine operator block.",
          "docstring_html": "<p>Hyperbolic cosine operator block.</p>\n<p>This block supports vector inputs. This is the operation it does:</p>\n<div>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\">\n  <mover accent=\"true\">\n    <mi>y</mi>\n    <mo stretchy=\"false\" scriptlevel=\"+1\">→</mo>\n  </mover>\n  <mo>=</mo>\n  <mi>cosh</mi>\n  <mo>&ApplyFunction;</mo>\n  <mo stretchy=\"false\">(</mo>\n  <mover accent=\"true\">\n    <mi>u</mi>\n    <mo stretchy=\"false\" scriptlevel=\"+1\">→</mo>\n  </mover>\n  <mo stretchy=\"false\">)</mo>\n</math>\n</div>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>op_alg <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">Operator</span></dt>\n<dd>internal algebraic operator</dd>\n</dl>\n",
          "bases": [
            "Math"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "op_alg",
              "description": "",
              "type": null,
              "value": "Operator(func=(np.cosh), jac=(lambda x: np.diag(np.sinh(x))))"
            }
          ],
          "parameters": []
        },
        {
          "name": "Tanh",
          "description": "Hyperbolic tangent operator block.",
          "docstring_html": "<p>Hyperbolic tangent operator block.</p>\n<p>This block supports vector inputs. This is the operation it does:</p>\n<div>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\">\n  <mover accent=\"true\">\n    <mi>y</mi>\n    <mo stretchy=\"false\" scriptlevel=\"+1\">→</mo>\n  </mover>\n  <mo>=</mo>\n  <mi>tanh</mi>\n  <mo>&ApplyFunction;</mo>\n  <mo stretchy=\"false\">(</mo>\n  <mover accent=\"true\">\n    <mi>u</mi>\n    <mo stretchy=\"false\" scriptlevel=\"+1\">→</mo>\n  </mover>\n  <mo stretchy=\"false\">)</mo>\n</math>\n</div>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>op_alg <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">Operator</span></dt>\n<dd>internal algebraic operator</dd>\n</dl>\n",
          "bases": [
            "Math"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "op_alg",
              "description": "",
              "type": null,
              "value": "Operator(func=(np.tanh), jac=(lambda x: np.diag(1 - np.tanh(x) ** 2)))"
            }
          ],
          "parameters": []
        },
        {
          "name": "Atan",
          "description": "Arctangent operator block.",
          "docstring_html": "<p>Arctangent operator block.</p>\n<p>This block supports vector inputs. This is the operation it does:</p>\n<div>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\">\n  <mover accent=\"true\">\n    <mi>y</mi>\n    <mo stretchy=\"false\" scriptlevel=\"+1\">→</mo>\n  </mover>\n  <mo>=</mo>\n  <mi>arctan</mi>\n  <mo>&ApplyFunction;</mo>\n  <mo stretchy=\"false\">(</mo>\n  <mover accent=\"true\">\n    <mi>u</mi>\n    <mo stretchy=\"false\" scriptlevel=\"+1\">→</mo>\n  </mover>\n  <mo stretchy=\"false\">)</mo>\n</math>\n</div>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>op_alg <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">Operator</span></dt>\n<dd>internal algebraic operator</dd>\n</dl>\n",
          "bases": [
            "Math"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "op_alg",
              "description": "",
              "type": null,
              "value": "Operator(func=(np.arctan), jac=(lambda x: np.diag(1 / (1 + x ** 2))))"
            }
          ],
          "parameters": []
        },
        {
          "name": "Norm",
          "description": "Vector norm operator block.",
          "docstring_html": "<p>Vector norm operator block.</p>\n<p>This block computes the Euclidean norm of the input vector:</p>\n<div>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\">\n  <mi>y</mi>\n  <mo>=</mo>\n  <mo>‖</mo>\n  <mover accent=\"true\">\n    <mi>u</mi>\n    <mo stretchy=\"false\" scriptlevel=\"+1\">→</mo>\n  </mover>\n  <msub>\n    <mo>‖</mo>\n    <mn>2</mn>\n  </msub>\n  <mo>=</mo>\n  <msqrt>\n    <munder>\n      <mo movablelimits=\"true\">∑</mo>\n      <mi>i</mi>\n    </munder>\n    <msubsup>\n      <mi>u</mi>\n      <mi>i</mi>\n      <mn>2</mn>\n    </msubsup>\n  </msqrt>\n</math>\n</div>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>op_alg <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">Operator</span></dt>\n<dd>internal algebraic operator</dd>\n</dl>\n",
          "bases": [
            "Math"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "op_alg",
              "description": "",
              "type": null,
              "value": "Operator(func=(np.linalg.norm), jac=(lambda x: (x / np.linalg.norm(x)).reshape(1, -1)))"
            }
          ],
          "parameters": []
        },
        {
          "name": "Mod",
          "description": "Modulo operator block.",
          "docstring_html": "<p>Modulo operator block.</p>\n<p>This block supports vector inputs. This is the operation it does:</p>\n<div>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\">\n  <mover accent=\"true\">\n    <mi>y</mi>\n    <mo stretchy=\"false\" scriptlevel=\"+1\">→</mo>\n  </mover>\n  <mo>=</mo>\n  <mover accent=\"true\">\n    <mi>u</mi>\n    <mo stretchy=\"false\" scriptlevel=\"+1\">→</mo>\n  </mover>\n  <mo lspace=\"0.278em\" rspace=\"0.278em\">mod</mo>\n  <mi>m</mi>\n</math>\n</div>\n<div class=\"section\" id=\"note\">\n<h4>Note</h4>\n<p>modulo is not differentiable at discontinuities</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>modulus <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>modulus value</dd>\n</dl>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>op_alg <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">Operator</span></dt>\n<dd>internal algebraic operator</dd>\n</dl>\n</div>\n",
          "bases": [
            "Math"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "signature": "(modulus = 1.0)",
              "parameters": [
                {
                  "name": "modulus",
                  "type": null,
                  "default": "1.0",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "modulus",
              "description": "",
              "type": null,
              "value": "modulus"
            },
            {
              "name": "op_alg",
              "description": "",
              "type": null,
              "value": "Operator(func=(lambda x: np.mod(x, self.modulus)), jac=(lambda x: np.diag(np.ones_like(x))))"
            }
          ],
          "parameters": [
            {
              "name": "modulus",
              "type": null,
              "default": "1.0",
              "description": "modulus value Attributes ----------"
            }
          ]
        },
        {
          "name": "Clip",
          "description": "Clipping/saturation operator block.",
          "docstring_html": "<p>Clipping/saturation operator block.</p>\n<p>This block supports vector inputs. This is the operation it does:</p>\n<div>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\">\n  <mover accent=\"true\">\n    <mi>y</mi>\n    <mo stretchy=\"false\" scriptlevel=\"+1\">→</mo>\n  </mover>\n  <mo>=</mo>\n  <mtext>clip</mtext>\n  <mo stretchy=\"false\">(</mo>\n  <mover accent=\"true\">\n    <mi>u</mi>\n    <mo stretchy=\"false\" scriptlevel=\"+1\">→</mo>\n  </mover>\n  <mo>,</mo>\n  <msub>\n    <mi>u</mi>\n    <mrow>\n      <mi>m</mi>\n      <mi>i</mi>\n      <mi>n</mi>\n    </mrow>\n  </msub>\n  <mo>,</mo>\n  <msub>\n    <mi>u</mi>\n    <mrow>\n      <mi>m</mi>\n      <mi>a</mi>\n      <mi>x</mi>\n    </mrow>\n  </msub>\n  <mo stretchy=\"false\">)</mo>\n</math>\n</div>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>min_val <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float, array_like</span></dt>\n<dd>minimum clipping value</dd>\n<dt>max_val <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float, array_like</span></dt>\n<dd>maximum clipping value</dd>\n</dl>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>op_alg <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">Operator</span></dt>\n<dd>internal algebraic operator</dd>\n</dl>\n",
          "bases": [
            "Math"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "signature": "(min_val = -1.0, max_val = 1.0)",
              "parameters": [
                {
                  "name": "min_val",
                  "type": null,
                  "default": "-1.0",
                  "description": ""
                },
                {
                  "name": "max_val",
                  "type": null,
                  "default": "1.0",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "min_val",
              "description": "",
              "type": null,
              "value": "min_val"
            },
            {
              "name": "max_val",
              "description": "",
              "type": null,
              "value": "max_val"
            },
            {
              "name": "op_alg",
              "description": "",
              "type": null,
              "value": "Operator(func=(lambda x: np.clip(x, self.min_val, self.max_val)), jac=_clip_jac)"
            }
          ],
          "parameters": [
            {
              "name": "min_val",
              "type": null,
              "default": "-1.0",
              "description": "minimum clipping value"
            },
            {
              "name": "max_val",
              "type": null,
              "default": "1.0",
              "description": "maximum clipping value Attributes ----------"
            }
          ]
        },
        {
          "name": "Matrix",
          "description": "Linear matrix operation (matrix-vector product).",
          "docstring_html": "<p>Linear matrix operation (matrix-vector product).</p>\n<p>This block supports vector inputs. This is the operation it does:</p>\n<div>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\">\n  <mover accent=\"true\">\n    <mi>y</mi>\n    <mo stretchy=\"false\" scriptlevel=\"+1\">→</mo>\n  </mover>\n  <mo>=</mo>\n  <mi>𝐀</mi>\n  <mover accent=\"true\">\n    <mi>u</mi>\n    <mo stretchy=\"false\" scriptlevel=\"+1\">→</mo>\n  </mover>\n</math>\n</div>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>A <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">np.ndarray</span></dt>\n<dd>matrix, 2d array with dim=2</dd>\n</dl>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>op_alg <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">Operator</span></dt>\n<dd>internal algebraic operator</dd>\n</dl>\n",
          "bases": [
            "Math"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "signature": "(A = np.eye(1))",
              "parameters": [
                {
                  "name": "A",
                  "type": null,
                  "default": "np.eye(1)",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "inputs",
              "description": "",
              "type": null,
              "value": "Register(size=m)"
            },
            {
              "name": "outputs",
              "description": "",
              "type": null,
              "value": "Register(size=n)"
            },
            {
              "name": "A",
              "description": "",
              "type": null,
              "value": "A"
            },
            {
              "name": "op_alg",
              "description": "",
              "type": null,
              "value": "Operator(func=(lambda u: np.dot(self.A, u)), jac=(lambda u: self.A))"
            }
          ],
          "parameters": [
            {
              "name": "A",
              "type": null,
              "default": "np.eye(1)",
              "description": "matrix, 2d array with dim=2 Attributes ----------"
            }
          ]
        },
        {
          "name": "PID",
          "description": "Proportional-Integral-Differntiation (PID) controller.",
          "docstring_html": "<p>Proportional-Integral-Differntiation (PID) controller.</p>\n<p>The transfer function is defined as</p>\n<div>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\">\n  <msub>\n    <mi>H</mi>\n    <mi>diff</mi>\n  </msub>\n  <mo stretchy=\"false\">(</mo>\n  <mi>s</mi>\n  <mo stretchy=\"false\">)</mo>\n  <mo>=</mo>\n  <msub>\n    <mi>K</mi>\n    <mi>p</mi>\n  </msub>\n  <mo>+</mo>\n  <msub>\n    <mi>K</mi>\n    <mi>i</mi>\n  </msub>\n  <mfrac>\n    <mn>1</mn>\n    <mi>s</mi>\n  </mfrac>\n  <mo>+</mo>\n  <msub>\n    <mi>K</mi>\n    <mi>d</mi>\n  </msub>\n  <mfrac>\n    <mi>s</mi>\n    <mrow>\n      <mn>1</mn>\n      <mo>+</mo>\n      <mi>s</mi>\n      <mo stretchy=\"false\">/</mo>\n      <msub>\n        <mi>f</mi>\n        <mi>max</mi>\n      </msub>\n    </mrow>\n  </mfrac>\n</math>\n</div>\n<p>where the differentiation is approximated by a high pass filter that holds\nfor signals up to a frequency of approximately <cite>f_max</cite>.</p>\n<div class=\"section\" id=\"note\">\n<h4>Note</h4>\n<p>Depending on <cite>f_max</cite>, the resulting system might become stiff or ill conditioned!\nAs a practical choice set <cite>f_max</cite> to 3x the highest expected signal frequency.\nSince this block uses an approximation of real differentiation, the approximation will\nnot hold if there are high frequency components present in the signal. For example if\nyou have discontinuities such as steps or square waves.</p>\n</div>\n<div class=\"section\" id=\"note-1\">\n<h4>Note</h4>\n<p>This block supports vector input, meaning we can have multiple parallel\nPID paths through this block.</p>\n</div>\n<div class=\"section\" id=\"example\">\n<h4>Example</h4>\n<p>The block is initialized like this:</p>\n<pre class=\"code python literal-block\">\n#cutoff at 1kHz\npid = PID(Kp=2, Ki=0.5, Kd=0.1, f_max=1e3)\n</pre>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>Kp <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>poroportional controller coefficient</dd>\n<dt>Ki <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>integral controller coefficient</dd>\n<dt>Kd <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>differentiator controller coefficient</dd>\n<dt>f_max <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>highest expected signal frequency</dd>\n</dl>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>op_dyn <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">DynamicOperator</span></dt>\n<dd>internal dynamic operator for ODE component</dd>\n<dt>op_alg <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">DynamicOperator</span></dt>\n<dd>internal algebraic operator</dd>\n</dl>\n</div>\n",
          "bases": [
            "Block"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "signature": "(Kp = 0, Ki = 0, Kd = 0, f_max = 100)",
              "parameters": [
                {
                  "name": "Kp",
                  "type": null,
                  "default": "0",
                  "description": ""
                },
                {
                  "name": "Ki",
                  "type": null,
                  "default": "0",
                  "description": ""
                },
                {
                  "name": "Kd",
                  "type": null,
                  "default": "0",
                  "description": ""
                },
                {
                  "name": "f_max",
                  "type": null,
                  "default": "100",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "update",
              "description": "update system equation fixed point loop, with convergence control",
              "docstring_html": "<p>update system equation fixed point loop, with convergence control</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time</dd>\n</dl>\n",
              "signature": "(t)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "solve",
              "description": "advance solution of implicit update equation",
              "docstring_html": "<p>advance solution of implicit update equation</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time</dd>\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>integration timestep</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>error <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>solver residual norm</dd>\n</dl>\n",
              "signature": "(t, dt)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time"
                },
                {
                  "name": "dt",
                  "type": null,
                  "default": null,
                  "description": "integration timestep"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "step",
              "description": "compute update step with integration engine",
              "docstring_html": "<p>compute update step with integration engine</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time</dd>\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>integration timestep</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>success <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>step was successful</dd>\n<dt>error <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>local truncation error from adaptive integrators</dd>\n<dt>scale <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>timestep rescale from adaptive integrators</dd>\n</dl>\n",
              "signature": "(t, dt)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time"
                },
                {
                  "name": "dt",
                  "type": null,
                  "default": null,
                  "description": "integration timestep"
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "Kp",
              "description": "",
              "type": null,
              "value": "Kp"
            },
            {
              "name": "Ki",
              "description": "",
              "type": null,
              "value": "Ki"
            },
            {
              "name": "Kd",
              "description": "",
              "type": null,
              "value": "Kd"
            },
            {
              "name": "f_max",
              "description": "",
              "type": null,
              "value": "f_max"
            },
            {
              "name": "initial_value",
              "description": "",
              "type": null,
              "value": "np.zeros(2)"
            },
            {
              "name": "op_dyn",
              "description": "",
              "type": null,
              "value": "DynamicOperator(func=_f_pid)"
            },
            {
              "name": "op_alg",
              "description": "",
              "type": null,
              "value": "DynamicOperator(func=_g_pid, jac_x=_jac_x_g_pid, jac_u=_jac_u_g_pid)"
            }
          ],
          "parameters": [
            {
              "name": "Kp",
              "type": null,
              "default": "0",
              "description": "poroportional controller coefficient"
            },
            {
              "name": "Ki",
              "type": null,
              "default": "0",
              "description": "integral controller coefficient"
            },
            {
              "name": "Kd",
              "type": null,
              "default": "0",
              "description": "differentiator controller coefficient"
            },
            {
              "name": "f_max",
              "type": null,
              "default": "100",
              "description": "highest expected signal frequency"
            }
          ]
        },
        {
          "name": "AntiWindupPID",
          "description": "Proportional-Integral-Differntiation (PID) controller with anti-windup mechanism (back-calculation).",
          "docstring_html": "<p>Proportional-Integral-Differntiation (PID) controller with anti-windup mechanism (back-calculation).</p>\n<p>Anti-windup mechanisms are needed when the magnitude of the control signal\nfrom the PID controller is limited by some real world saturation. In these cases,\nthe integrator will continue to acumulate the control error and &quot;wind itself up&quot;.\nOnce the setpoint is reached, this can result in significant overshoots. This\nimplementation adds a conditional feedback term to the internal integrator that\n&quot;unwinds&quot; it when the PID output crosses some limits. This is pretty much a\ndeadzone feedback element for the integrator.</p>\n<p>Mathematically, this block implements the following set of ODEs</p>\n<pre class=\"math\">\n\\begin{eqnarray}\n\\dot{x}_1 =&amp; f_\\mathrm{max} (u - x_1) \\\\\n\\dot{x}_2 =&amp; u - w \\\\\n\\end{eqnarray}\n</pre>\n<p>with the anti-windup feedback (depending on the pid output)</p>\n<div>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\">\n  <mi>w</mi>\n  <mo>=</mo>\n  <msub>\n    <mi>K</mi>\n    <mi>s</mi>\n  </msub>\n  <mo stretchy=\"false\">(</mo>\n  <mi>y</mi>\n  <mo>−</mo>\n  <mo>min</mo>\n  <mo stretchy=\"false\">(</mo>\n  <mo>max</mo>\n  <mo stretchy=\"false\">(</mo>\n  <mi>y</mi>\n  <mo>,</mo>\n  <msub>\n    <mi>y</mi>\n    <mi>min</mi>\n  </msub>\n  <mo stretchy=\"false\">)</mo>\n  <mo>,</mo>\n  <msub>\n    <mi>y</mi>\n    <mi>max</mi>\n  </msub>\n  <mo stretchy=\"false\">)</mo>\n  <mo stretchy=\"false\">)</mo>\n</math>\n</div>\n<p>and the output itself</p>\n<div>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\">\n  <mi>y</mi>\n  <mo>=</mo>\n  <msub>\n    <mi>K</mi>\n    <mi>p</mi>\n  </msub>\n  <mi>u</mi>\n  <mo>−</mo>\n  <msub>\n    <mi>K</mi>\n    <mi>d</mi>\n  </msub>\n  <msub>\n    <mi>f</mi>\n    <mi>max</mi>\n  </msub>\n  <msub>\n    <mi>x</mi>\n    <mn>1</mn>\n  </msub>\n  <mo>+</mo>\n  <msub>\n    <mi>K</mi>\n    <mi>i</mi>\n  </msub>\n  <msub>\n    <mi>x</mi>\n    <mn>2</mn>\n  </msub>\n</math>\n</div>\n<div class=\"section\" id=\"note\">\n<h4>Note</h4>\n<p>Depending on <cite>f_max</cite>, the resulting system might become stiff or ill conditioned!\nAs a practical choice set <cite>f_max</cite> to 3x the highest expected signal frequency.\nSince this block uses an approximation of real differentiation, the approximation will\nnot hold if there are high frequency components present in the signal. For example if\nyou have discontinuities such as steps or squere waves.</p>\n</div>\n<div class=\"section\" id=\"example\">\n<h4>Example</h4>\n<p>The block is initialized like this:</p>\n<pre class=\"code python literal-block\">\n#cutoff at 1kHz, windup limits at [-5, 5]\npid = AntiWindupPID(Kp=2, Ki=0.5, Kd=0.1, f_max=1e3, limits=[-5, 5])\n</pre>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>Kp <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>poroportional controller coefficient</dd>\n<dt>Ki <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>integral controller coefficient</dd>\n<dt>Kd <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>differentiator controller coefficient</dd>\n<dt>f_max <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>highest expected signal frequency</dd>\n<dt>Ks <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>feedback term for back calculation for anti-windup control of integrator</dd>\n<dt>limits <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array_like[float]</span></dt>\n<dd>lower and upper limit for PID output that triggers anti-windup of integrator</dd>\n</dl>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>op_dyn <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">DynamicOperator</span></dt>\n<dd>internal dynamic operator for ODE component</dd>\n<dt>op_alg <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">DynamicOperator</span></dt>\n<dd>internal algebraic operator</dd>\n</dl>\n</div>\n",
          "bases": [
            "PID"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "signature": "(Kp = 0, Ki = 0, Kd = 0, f_max = 100, Ks = 10, limits = [-10, 10])",
              "parameters": [
                {
                  "name": "Kp",
                  "type": null,
                  "default": "0",
                  "description": ""
                },
                {
                  "name": "Ki",
                  "type": null,
                  "default": "0",
                  "description": ""
                },
                {
                  "name": "Kd",
                  "type": null,
                  "default": "0",
                  "description": ""
                },
                {
                  "name": "f_max",
                  "type": null,
                  "default": "100",
                  "description": ""
                },
                {
                  "name": "Ks",
                  "type": null,
                  "default": "10",
                  "description": ""
                },
                {
                  "name": "limits",
                  "type": null,
                  "default": "[-10, 10]",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "Ks",
              "description": "",
              "type": null,
              "value": "Ks"
            },
            {
              "name": "limits",
              "description": "",
              "type": null,
              "value": "limits"
            },
            {
              "name": "op_dyn",
              "description": "",
              "type": null,
              "value": "DynamicOperator(func=_f_pid)"
            },
            {
              "name": "op_alg",
              "description": "",
              "type": null,
              "value": "DynamicOperator(func=_g_pid, jac_x=_jac_x_g_pid, jac_u=_jac_u_g_pid)"
            }
          ],
          "parameters": [
            {
              "name": "Kp",
              "type": null,
              "default": "0",
              "description": "poroportional controller coefficient"
            },
            {
              "name": "Ki",
              "type": null,
              "default": "0",
              "description": "integral controller coefficient"
            },
            {
              "name": "Kd",
              "type": null,
              "default": "0",
              "description": "differentiator controller coefficient"
            },
            {
              "name": "f_max",
              "type": null,
              "default": "100",
              "description": "highest expected signal frequency"
            },
            {
              "name": "Ks",
              "type": null,
              "default": "10",
              "description": "feedback term for back calculation for anti-windup control of integrator"
            },
            {
              "name": "limits",
              "type": null,
              "default": "[-10, 10]",
              "description": "lower and upper limit for PID output that triggers anti-windup of integrator"
            }
          ]
        },
        {
          "name": "TransferFunctionPRC",
          "description": "This block defines a LTI (MIMO for pole residue) transfer function.",
          "docstring_html": "<p>This block defines a LTI (MIMO for pole residue) transfer function.</p>\n<p>The transfer function is defined in pole-residue-constant (PRC) form</p>\n<div>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\">\n  <mi>𝐇</mi>\n  <mo stretchy=\"false\">(</mo>\n  <mi>s</mi>\n  <mo stretchy=\"false\">)</mo>\n  <mo>=</mo>\n  <mi>𝐂</mi>\n  <mo>+</mo>\n  <munderover>\n    <mo movablelimits=\"true\">∑</mo>\n    <mi>n</mi>\n    <mi>N</mi>\n  </munderover>\n  <mfrac>\n    <msub>\n      <mi>𝐑</mi>\n      <mi>n</mi>\n    </msub>\n    <mrow>\n      <mi>s</mi>\n      <mo>−</mo>\n      <msub>\n        <mi>p</mi>\n        <mi>n</mi>\n      </msub>\n    </mrow>\n  </mfrac>\n</math>\n</div>\n<p>where 'Poles' are the scalar (possibly complex conjugate) poles of the\ntransfer function and 'Residues' are the possibly matrix valued (in MIMO case)\nand complex conjugate residues of the transfer function. 'Const' has same\nshape as 'Residues'.</p>\n<p>Upon initialization, the state space realization of the transfer\nfunction is computed using a minimal gilbert realization.</p>\n<p>The resulting state space model of the form</p>\n<pre class=\"math\">\n\\begin{eqnarray}\n    \\dot{x} &amp;= \\mathbf{A} x + \\mathbf{B} u \\\\\n           y &amp;= \\mathbf{C} x + \\mathbf{D} u\n\\end{eqnarray}\n</pre>\n<p>is handled the same as the 'StateSpace' block, where <cite>A</cite>, <cite>B</cite>, <cite>C</cite> and <cite>D</cite>\nare the state space matrices, <cite>x</cite> is the internal state, <cite>u</cite> the input and\n<cite>y</cite> the output vector.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>Poles <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array</span></dt>\n<dd>transfer function poles</dd>\n<dt>Residues <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array</span></dt>\n<dd>transfer function residues</dd>\n<dt>Const <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array, float</span></dt>\n<dd>constant term of transfer function</dd>\n</dl>\n",
          "bases": [
            "StateSpace"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "signature": "(Poles = [], Residues = [], Const = 0.0)",
              "parameters": [
                {
                  "name": "Poles",
                  "type": null,
                  "default": "[]",
                  "description": ""
                },
                {
                  "name": "Residues",
                  "type": null,
                  "default": "[]",
                  "description": ""
                },
                {
                  "name": "Const",
                  "type": null,
                  "default": "0.0",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [],
          "parameters": [
            {
              "name": "Poles",
              "type": null,
              "default": "[]",
              "description": "transfer function poles"
            },
            {
              "name": "Residues",
              "type": null,
              "default": "[]",
              "description": "transfer function residues"
            },
            {
              "name": "Const",
              "type": null,
              "default": "0.0",
              "description": "constant term of transfer function"
            }
          ]
        },
        {
          "name": "TransferFunction",
          "description": "Alias for TransferFunctionPRC.",
          "docstring_html": "<p>Alias for TransferFunctionPRC.</p>\n",
          "bases": [
            "TransferFunctionPRC"
          ],
          "methods": [],
          "attributes": [],
          "parameters": []
        },
        {
          "name": "TransferFunctionZPG",
          "description": "This block defines a LTI (SISO) transfer function.",
          "docstring_html": "<p>This block defines a LTI (SISO) transfer function.</p>\n<p>The transfer function is defined in zeros-poles-gain (ZPG) form</p>\n<div>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\">\n  <mi>𝐇</mi>\n  <mo stretchy=\"false\">(</mo>\n  <mi>s</mi>\n  <mo stretchy=\"false\">)</mo>\n  <mo>=</mo>\n  <mi>k</mi>\n  <mfrac>\n    <mrow>\n      <mo stretchy=\"false\">(</mo>\n      <mi>s</mi>\n      <mo>−</mo>\n      <msub>\n        <mi>z</mi>\n        <mn>1</mn>\n      </msub>\n      <mo stretchy=\"false\">)</mo>\n      <mo stretchy=\"false\">(</mo>\n      <mi>s</mi>\n      <mo>−</mo>\n      <msub>\n        <mi>z</mi>\n        <mn>2</mn>\n      </msub>\n      <mo stretchy=\"false\">)</mo>\n      <mi>⋯</mi>\n      <mo stretchy=\"false\">(</mo>\n      <mi>s</mi>\n      <mo>−</mo>\n      <msub>\n        <mi>z</mi>\n        <mi>m</mi>\n      </msub>\n      <mo stretchy=\"false\">)</mo>\n    </mrow>\n    <mrow>\n      <mo stretchy=\"false\">(</mo>\n      <mi>s</mi>\n      <mo>−</mo>\n      <msub>\n        <mi>p</mi>\n        <mn>1</mn>\n      </msub>\n      <mo stretchy=\"false\">)</mo>\n      <mo stretchy=\"false\">(</mo>\n      <mi>s</mi>\n      <mo>−</mo>\n      <msub>\n        <mi>p</mi>\n        <mn>2</mn>\n      </msub>\n      <mo stretchy=\"false\">)</mo>\n      <mi>⋯</mi>\n      <mo stretchy=\"false\">(</mo>\n      <mi>s</mi>\n      <mo>−</mo>\n      <msub>\n        <mi>p</mi>\n        <mi>n</mi>\n      </msub>\n      <mo stretchy=\"false\">)</mo>\n    </mrow>\n  </mfrac>\n</math>\n</div>\n<p>where <cite>Zeros</cite> are the scalar (possibly complex conjugate) zeros of the\ntransfer function, and <cite>Poles</cite> are the poles (denominator zeros) of the\ntransfer function. <cite>Gain</cite> is the scalar factor <cite>k</cite>.</p>\n<p>Upon initialization, the state space realization of the transfer function is\ncomputed using <cite>scipy.signal.ZerosPolesGain(Zeros, Poles, Gain).to_ss()</cite>.</p>\n<p>The resulting state space model of the form</p>\n<pre class=\"math\">\n\\begin{eqnarray}\n    \\dot{x} &amp;= \\mathbf{A} x + \\mathbf{B} u \\\\\n           y &amp;= \\mathbf{C} x + \\mathbf{D} u\n\\end{eqnarray}\n</pre>\n<p>is handled the same as the 'StateSpace' block, where <cite>A</cite>, <cite>B</cite>, <cite>C</cite> and <cite>D</cite>\nare the state space matrices, <cite>x</cite> is the internal state, <cite>u</cite> the input and\n<cite>y</cite> the output vector.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>Poles <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array_like</span></dt>\n<dd>transfer function poles</dd>\n<dt>Zeros <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array_like</span></dt>\n<dd>transfer function zeros</dd>\n<dt>Gain <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>gain term of transfer function</dd>\n</dl>\n",
          "bases": [
            "StateSpace"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "signature": "(Zeros = [], Poles = [-1], Gain = 1.0)",
              "parameters": [
                {
                  "name": "Zeros",
                  "type": null,
                  "default": "[]",
                  "description": ""
                },
                {
                  "name": "Poles",
                  "type": null,
                  "default": "[-1]",
                  "description": ""
                },
                {
                  "name": "Gain",
                  "type": null,
                  "default": "1.0",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "input_port_labels",
              "description": "",
              "type": null,
              "value": "{'in': 0}"
            },
            {
              "name": "output_port_labels",
              "description": "",
              "type": null,
              "value": "{'out': 0}"
            }
          ],
          "parameters": [
            {
              "name": "Zeros",
              "type": null,
              "default": "[]",
              "description": "transfer function zeros"
            },
            {
              "name": "Poles",
              "type": null,
              "default": "[-1]",
              "description": "transfer function poles"
            },
            {
              "name": "Gain",
              "type": null,
              "default": "1.0",
              "description": "gain term of transfer function"
            }
          ]
        },
        {
          "name": "TransferFunctionNumDen",
          "description": "This block defines a LTI (SISO) transfer function.",
          "docstring_html": "<p>This block defines a LTI (SISO) transfer function.</p>\n<p>The transfer function is defined in polynomial (numerator-denominator) form</p>\n<pre class=\"math\">\n\\mathbf{H}(s) = \\frac{b_n + b_{n-1} s + \\dots + b_{0} s^n}{a_m + a_{m-1} s + \\dots + a_{0} s^m}\n</pre>\n<p>where <cite>Num</cite> is the list of numerator polynomial coefficients and <cite>Den</cite> the\nlist of denominator coefficients.</p>\n<p>Upon initialization, the state space realization of the transfer function is\ncomputed using <cite>scipy.signal.TransferFunction(Num, Den).to_ss()</cite>.</p>\n<p>The resulting state space model of the form</p>\n<pre class=\"math\">\n\\begin{eqnarray}\n    \\dot{x} &amp;= \\mathbf{A} x + \\mathbf{B} u \\\\\n           y &amp;= \\mathbf{C} x + \\mathbf{D} u\n\\end{eqnarray}\n</pre>\n<p>is handled the same as the 'StateSpace' block, where <cite>A</cite>, <cite>B</cite>, <cite>C</cite> and <cite>D</cite>\nare the state space matrices, <cite>x</cite> is the internal state, <cite>u</cite> the input and\n<cite>y</cite> the output vector.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>Num <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array_like</span></dt>\n<dd>numerator polynomial coefficients</dd>\n<dt>Den <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array_like</span></dt>\n<dd>denominator polynomial coefficients</dd>\n</dl>\n",
          "bases": [
            "StateSpace"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "signature": "(Num = [1], Den = [1, 1])",
              "parameters": [
                {
                  "name": "Num",
                  "type": null,
                  "default": "[1]",
                  "description": ""
                },
                {
                  "name": "Den",
                  "type": null,
                  "default": "[1, 1]",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "input_port_labels",
              "description": "",
              "type": null,
              "value": "{'in': 0}"
            },
            {
              "name": "output_port_labels",
              "description": "",
              "type": null,
              "value": "{'out': 0}"
            }
          ],
          "parameters": [
            {
              "name": "Num",
              "type": null,
              "default": "[1]",
              "description": "numerator polynomial coefficients"
            },
            {
              "name": "Den",
              "type": null,
              "default": "[1, 1]",
              "description": "denominator polynomial coefficients"
            }
          ]
        },
        {
          "name": "ODE",
          "description": "Ordinary differential equation (ODE) defined by its right hand side function.",
          "docstring_html": "<p>Ordinary differential equation (ODE) defined by its right hand side function.</p>\n<pre class=\"math\">\n\\begin{eqnarray}\n    \\dot{x}(t) =&amp; \\mathrm{func}(x(t), u(t), t) \\\\\n           y(t) =&amp; x(t)\n\\end{eqnarray}\n</pre>\n<p>with inhomogenity (input) <cite>u</cite> and state vector <cite>x</cite>. The function can be nonlinear\nand the ODE can be of arbitrary order. The block utilizes the integration engine\nto solve the ODE by integrating the <cite>func</cite>, which is the right hand side function.</p>\n<div class=\"section\" id=\"example\">\n<h4>Example</h4>\n<p>For example a linear 1st order ODE:</p>\n<pre class=\"code python literal-block\">\node = ODE(lambda x, u, t: -x)\n</pre>\n<p>Or something more complex like the <cite>Van der Pol</cite> system, where it makes sense to\nalso specify the jacobian, which improves convergence for implicit solvers but is\nnot needed in most cases:</p>\n<pre class=\"code python literal-block\">\nimport numpy as np\n\n#initial condition\nx0 = np.array([2, 0])\n\n#van der Pol parameter\nmu = 1000\n\ndef func(x, u, t):\n    return np.array([x[1], mu*(1 - x[0]**2)*x[1] - x[0]])\n\n#analytical jacobian (optional)\ndef jac(x, u, t):\n    return np.array(\n        [[0                , 1               ],\n         [-mu*2*x[0]*x[1]-1, mu*(1 - x[0]**2)]]\n         )\n\n#finally the block\nvdp = ODE(func, x0, jac)\n</pre>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>func <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">callable</span></dt>\n<dd>right hand side function of ODE</dd>\n<dt>initial_value <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array[float]</span></dt>\n<dd>initial state / initial condition</dd>\n<dt>jac <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">callable, None</span></dt>\n<dd>jacobian of 'func' or 'None'</dd>\n</dl>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>op_dyn <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">DynamicOperator</span></dt>\n<dd>internal dynamic operator for ODE right hand side 'func'</dd>\n</dl>\n</div>\n",
          "bases": [
            "Block"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "signature": "(func = lambda x, u, t: -x, initial_value = 0.0, jac = None)",
              "parameters": [
                {
                  "name": "func",
                  "type": null,
                  "default": "lambda x, u, t: -x",
                  "description": ""
                },
                {
                  "name": "initial_value",
                  "type": null,
                  "default": "0.0",
                  "description": ""
                },
                {
                  "name": "jac",
                  "type": null,
                  "default": "None",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "update",
              "description": "update system equation for fixed point loop,",
              "docstring_html": "<p>update system equation for fixed point loop,\nhere just setting the outputs</p>\n<div class=\"section\" id=\"note\">\n<h4>Note</h4>\n<p>the ODE block has no direct passthrough, so the\n'update' method is optimized for this case</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time</dd>\n</dl>\n</div>\n",
              "signature": "(t)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "solve",
              "description": "advance solution of implicit update equation of the solver",
              "docstring_html": "<p>advance solution of implicit update equation of the solver</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time</dd>\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>integration timestep</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>error <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>solver residual norm</dd>\n</dl>\n",
              "signature": "(t, dt)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time"
                },
                {
                  "name": "dt",
                  "type": null,
                  "default": null,
                  "description": "integration timestep"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "step",
              "description": "compute timestep update with integration engine",
              "docstring_html": "<p>compute timestep update with integration engine</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time</dd>\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>integration timestep</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>success <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>step was successful</dd>\n<dt>error <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>local truncation error from adaptive integrators</dd>\n<dt>scale <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>timestep rescale from adaptive integrators</dd>\n</dl>\n",
              "signature": "(t, dt)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time"
                },
                {
                  "name": "dt",
                  "type": null,
                  "default": null,
                  "description": "integration timestep"
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "func",
              "description": "",
              "type": null,
              "value": "func"
            },
            {
              "name": "initial_value",
              "description": "",
              "type": null,
              "value": "initial_value"
            },
            {
              "name": "jac",
              "description": "",
              "type": null,
              "value": "jac"
            },
            {
              "name": "op_dyn",
              "description": "",
              "type": null,
              "value": "DynamicOperator(func=func, jac_x=jac)"
            }
          ],
          "parameters": [
            {
              "name": "func",
              "type": null,
              "default": "lambda x, u, t: -x",
              "description": "right hand side function of ODE"
            },
            {
              "name": "initial_value",
              "type": null,
              "default": "0.0",
              "description": "initial state / initial condition"
            },
            {
              "name": "jac",
              "type": null,
              "default": "None",
              "description": "jacobian of 'func' or 'None'"
            }
          ]
        },
        {
          "name": "RandomNumberGenerator",
          "description": "Generates a random output value using `numpy.random.rand`.",
          "docstring_html": "<p>Generates a random output value using <cite>numpy.random.rand</cite>.</p>\n<p>If no <cite>sampling_period</cite> (None) is specified, every simulation timestep gets\na random value. Otherwise an internal <cite>Schedule</cite> event is used to periodically\nsample a random value and set the output like a zero-order-hold stage.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>sampling_period <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float, None</span></dt>\n<dd>time between random samples</dd>\n</dl>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>_sample <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>internal random number state in case that\nno <cite>sampling_period</cite> is provided</dd>\n<dt>Evt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">Schedule</span></dt>\n<dd>internal event that periodically samples a random\nvalue in case <cite>sampling_period</cite> is provided</dd>\n</dl>\n",
          "bases": [
            "Block"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "signature": "(sampling_period = None)",
              "parameters": [
                {
                  "name": "sampling_period",
                  "type": null,
                  "default": "None",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "update",
              "description": "Setting output with random sample in case",
              "docstring_html": "<p>Setting output with random sample in case\nof <cite>sampling_period==None</cite>, otherwise does nothing.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time</dd>\n</dl>\n",
              "signature": "(t)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "sample",
              "description": "Generating a new random sample at each timestep",
              "docstring_html": "<p>Generating a new random sample at each timestep\nin case of <cite>sampling_period==None</cite>, otherwise does nothing.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time</dd>\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>integration timestep</dd>\n</dl>\n",
              "signature": "(t, dt)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time"
                },
                {
                  "name": "dt",
                  "type": null,
                  "default": null,
                  "description": "integration timestep"
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "input_port_labels",
              "description": "",
              "type": null,
              "value": "{}"
            },
            {
              "name": "output_port_labels",
              "description": "",
              "type": null,
              "value": "{'out': 0}"
            },
            {
              "name": "sampling_period",
              "description": "",
              "type": null,
              "value": "sampling_period"
            },
            {
              "name": "Evt",
              "description": "",
              "type": null,
              "value": "Schedule(t_start=0, t_period=sampling_period, func_act=_set)"
            },
            {
              "name": "events",
              "description": "",
              "type": null,
              "value": "[self.Evt]"
            }
          ],
          "parameters": [
            {
              "name": "sampling_period",
              "type": null,
              "default": "None",
              "description": "time between random samples"
            }
          ]
        },
        {
          "name": "RNG",
          "description": "Alias for RandomNumberGenerator.",
          "docstring_html": "<p>Alias for RandomNumberGenerator.</p>\n",
          "bases": [
            "RandomNumberGenerator"
          ],
          "methods": [],
          "attributes": [],
          "parameters": []
        },
        {
          "name": "FIR",
          "description": "Models a discrete-time Finite-Impulse-Response (FIR) filter.",
          "docstring_html": "<p>Models a discrete-time Finite-Impulse-Response (FIR) filter.</p>\n<p>This block applies an FIR filter to an input signal sampled periodically.\nThe output at each sample time is a weighted sum of the current and a finite number\nof past input samples. The operation is triggered by a scheduled event.</p>\n<p>Functionality:</p>\n<pre class=\"math\">\ny[n] = b[0] x[n] + b[1] x[n-1] + \\dots + b[N] x[n-N]\n</pre>\n<p>where <cite>b</cite> are the filter coefficients and <cite>N</cite> is the filter order (number of\ncoefficients - 1).</p>\n<ol class=\"arabic simple\">\n<li>Samples the input <cite>inputs[0]</cite> at intervals of <cite>T</cite>, starting after delay <cite>tau</cite>.</li>\n<li>Stores the current and past <cite>len(coefficients) - 1</cite> input samples in an internal buffer.</li>\n<li>Computes the filter output using the dot product of the coefficients\nand the buffered input samples.</li>\n<li>Outputs the result on <cite>outputs[0]</cite>.</li>\n<li>Holds the output constant between updates.</li>\n</ol>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>coeffs <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array_like</span></dt>\n<dd>List or numpy array of FIR filter coefficients [b0, b1, ..., bN].\nThe number of coefficients determines the filter's order and memory.</dd>\n<dt>T <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float, optional</span></dt>\n<dd>Sampling period (time between input samples and output updates). Default is 1.</dd>\n<dt>tau <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float, optional</span></dt>\n<dd>Initial delay before the first sample is processed. Default is 0.</dd>\n</dl>\n<div class=\"section\" id=\"input-ports\">\n<h4>Input Ports</h4>\n<dl class=\"docutils\">\n<dt>inputs[0] <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>Input signal sample at the current time step.</dd>\n</dl>\n</div>\n<div class=\"section\" id=\"output-ports\">\n<h4>Output Ports</h4>\n<dl class=\"docutils\">\n<dt>outputs[0] <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>Filtered output signal sample.</dd>\n</dl>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>buffer <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">deque</span></dt>\n<dd>Internal buffer storing the most recent input samples.</dd>\n<dt>events <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">list[Schedule]</span></dt>\n<dd>Internal scheduled event triggering the filter calculation.</dd>\n</dl>\n</div>\n",
          "bases": [
            "Block"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "signature": "(coeffs = [1.0], T = 1, tau = 0)",
              "parameters": [
                {
                  "name": "coeffs",
                  "type": null,
                  "default": "[1.0]",
                  "description": ""
                },
                {
                  "name": "T",
                  "type": null,
                  "default": "1",
                  "description": ""
                },
                {
                  "name": "tau",
                  "type": null,
                  "default": "0",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "reset",
              "description": "Resets the filter state (buffer) and output.",
              "docstring_html": "<p>Resets the filter state (buffer) and output.</p>\n",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "input_port_labels",
              "description": "",
              "type": null,
              "value": "{'in': 0}"
            },
            {
              "name": "output_port_labels",
              "description": "",
              "type": null,
              "value": "{'out': 0}"
            },
            {
              "name": "coeffs",
              "description": "",
              "type": null,
              "value": "np.array(coeffs)"
            },
            {
              "name": "T",
              "description": "",
              "type": null,
              "value": "T"
            },
            {
              "name": "tau",
              "description": "",
              "type": null,
              "value": "tau"
            },
            {
              "name": "events",
              "description": "",
              "type": null,
              "value": "[Schedule(t_start=(self.tau), t_period=(self.T), func_act=_update_fir)]"
            }
          ],
          "parameters": [
            {
              "name": "coeffs",
              "type": null,
              "default": "[1.0]",
              "description": "List or numpy array of FIR filter coefficients [b0, b1, ..., bN]. The number of coefficients determines the filter's order and memory."
            },
            {
              "name": "T",
              "type": null,
              "default": "1",
              "description": "Sampling period (time between input samples and output updates). Default is 1."
            },
            {
              "name": "tau",
              "type": null,
              "default": "0",
              "description": "Initial delay before the first sample is processed. Default is 0."
            }
          ]
        },
        {
          "name": "FMUWrapper",
          "description": "Version-agnostic wrapper for FMI 2.0 and 3.0 FMUs.",
          "docstring_html": "<p>Version-agnostic wrapper for FMI 2.0 and 3.0 FMUs.</p>\n<p>This class provides a unified interface for working with FMUs regardless of\nFMI version (2.0 or 3.0) or interface type (Co-Simulation or Model Exchange).\nIt handles all version-specific API differences internally.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>fmu_path <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">str</span></dt>\n<dd>path to the FMU file (.fmu)</dd>\n<dt>instance_name <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">str, optional</span></dt>\n<dd>name for the FMU instance (default: 'fmu_instance')</dd>\n<dt>mode <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">str, optional</span></dt>\n<dd>FMU interface mode: 'cosimulation' or 'model_exchange' (default: 'cosimulation')</dd>\n</dl>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>fmu_path <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">str</span></dt>\n<dd>path to the FMU file</dd>\n<dt>instance_name <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">str</span></dt>\n<dd>name of the FMU instance</dd>\n<dt>mode <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">str</span></dt>\n<dd>interface mode ('cosimulation' or 'model_exchange')</dd>\n<dt>model_description <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">ModelDescription</span></dt>\n<dd>FMI model description from FMPy (use this for metadata access)</dd>\n<dt>fmu <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">FMU2Slave | FMU3Slave | FMU2Model | FMU3Model</span></dt>\n<dd>underlying FMPy FMU instance</dd>\n<dt>fmi_version <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">str</span></dt>\n<dd>detected FMI version ('2.0' or '3.0')</dd>\n<dt>n_states <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>number of continuous states (Model Exchange only)</dd>\n<dt>n_event_indicators <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>number of event indicators (Model Exchange only)</dd>\n<dt>input_refs <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">dict</span></dt>\n<dd>mapping from input variable names to value references</dd>\n<dt>output_refs <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">dict</span></dt>\n<dd>mapping from output variable names to value references</dd>\n</dl>\n",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "signature": "(fmu_path, instance_name = 'fmu_instance', mode = 'cosimulation')",
              "parameters": [
                {
                  "name": "fmu_path",
                  "type": null,
                  "default": null,
                  "description": ""
                },
                {
                  "name": "instance_name",
                  "type": null,
                  "default": "'fmu_instance'",
                  "description": ""
                },
                {
                  "name": "mode",
                  "type": null,
                  "default": "'cosimulation'",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "create_port_registers",
              "description": "Create input and output registers for block I/O.",
              "docstring_html": "<p>Create input and output registers for block I/O.</p>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>inputs <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">Register</span></dt>\n<dd>input register with FMU input variable names as labels</dd>\n<dt>outputs <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">Register</span></dt>\n<dd>output register with FMU output variable names as labels</dd>\n</dl>\n",
              "signature": "()",
              "parameters": [],
              "returns": "Tuple[Register, Register]",
              "method_type": "method"
            },
            {
              "name": "initialize",
              "description": "Complete FMU initialization sequence.",
              "docstring_html": "<p>Complete FMU initialization sequence.</p>\n<p>Performs: instantiate -&gt; setup_experiment -&gt; enter_initialization_mode\n-&gt; set start values -&gt; exit_initialization_mode</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>start_values <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">dict, optional</span></dt>\n<dd>dictionary of variable names and their initial values</dd>\n<dt>start_time <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float, optional</span></dt>\n<dd>simulation start time (default: 0.0)</dd>\n<dt>stop_time <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float, optional</span></dt>\n<dd>simulation stop time</dd>\n<dt>tolerance <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float, optional</span></dt>\n<dd>tolerance for integration/event detection</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>event_info <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">EventInfo or None</span></dt>\n<dd>event information for FMI 3.0 Model Exchange, None otherwise</dd>\n</dl>\n",
              "signature": "(start_values = None, start_time = 0.0, stop_time = None, tolerance = None)",
              "parameters": [
                {
                  "name": "start_values",
                  "type": null,
                  "default": "None",
                  "description": "dictionary of variable names and their initial values"
                },
                {
                  "name": "start_time",
                  "type": null,
                  "default": "0.0",
                  "description": "simulation start time (default: 0.0)"
                },
                {
                  "name": "stop_time",
                  "type": null,
                  "default": "None",
                  "description": "simulation stop time"
                },
                {
                  "name": "tolerance",
                  "type": null,
                  "default": "None",
                  "description": "tolerance for integration/event detection"
                }
              ],
              "returns": "Optional[EventInfo]",
              "method_type": "method"
            },
            {
              "name": "get_state_jacobian",
              "description": "Compute Jacobian of state derivatives w.r.t. states (Model Exchange only).",
              "docstring_html": "<p>Compute Jacobian of state derivatives w.r.t. states (Model Exchange only).</p>\n<p>Uses FMU's directional derivative capability to compute ∂ẋ/∂x.\nRequires the FMU to have providesDirectionalDerivative=true.</p>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>jacobian <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">np.ndarray</span></dt>\n<dd>n_states x n_states Jacobian matrix, or None if not supported</dd>\n</dl>\n",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "instantiate",
              "description": "Instantiate the FMU.",
              "docstring_html": "<p>Instantiate the FMU.</p>\n",
              "signature": "(visible = False, logging_on = False)",
              "parameters": [
                {
                  "name": "visible",
                  "type": null,
                  "default": "False",
                  "description": ""
                },
                {
                  "name": "logging_on",
                  "type": null,
                  "default": "False",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "setup_experiment",
              "description": "Setup experiment parameters.",
              "docstring_html": "<p>Setup experiment parameters.</p>\n",
              "signature": "(tolerance = None, start_time = 0.0, stop_time = None)",
              "parameters": [
                {
                  "name": "tolerance",
                  "type": null,
                  "default": "None",
                  "description": ""
                },
                {
                  "name": "start_time",
                  "type": null,
                  "default": "0.0",
                  "description": ""
                },
                {
                  "name": "stop_time",
                  "type": null,
                  "default": "None",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "enter_initialization_mode",
              "description": "Enter initialization mode.",
              "docstring_html": "<p>Enter initialization mode.</p>\n",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "exit_initialization_mode",
              "description": "Exit initialization mode and return event information.",
              "docstring_html": "<p>Exit initialization mode and return event information.</p>\n",
              "signature": "()",
              "parameters": [],
              "returns": "Optional[EventInfo]",
              "method_type": "method"
            },
            {
              "name": "reset",
              "description": "Reset FMU to initial state.",
              "docstring_html": "<p>Reset FMU to initial state.</p>\n",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "terminate",
              "description": "Terminate FMU.",
              "docstring_html": "<p>Terminate FMU.</p>\n",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "free_instance",
              "description": "Free FMU instance and resources.",
              "docstring_html": "<p>Free FMU instance and resources.</p>\n",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "set_real",
              "description": "Set real-valued variables by reference.",
              "docstring_html": "<p>Set real-valued variables by reference.</p>\n",
              "signature": "(refs, values)",
              "parameters": [
                {
                  "name": "refs",
                  "type": null,
                  "default": null,
                  "description": ""
                },
                {
                  "name": "values",
                  "type": null,
                  "default": null,
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "get_real",
              "description": "Get real-valued variables by reference.",
              "docstring_html": "<p>Get real-valued variables by reference.</p>\n",
              "signature": "(refs)",
              "parameters": [
                {
                  "name": "refs",
                  "type": null,
                  "default": null,
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "set_variable",
              "description": "Set a single variable by name (automatically detects type).",
              "docstring_html": "<p>Set a single variable by name (automatically detects type).</p>\n",
              "signature": "(name, value)",
              "parameters": [
                {
                  "name": "name",
                  "type": null,
                  "default": null,
                  "description": ""
                },
                {
                  "name": "value",
                  "type": null,
                  "default": null,
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "set_inputs_from_array",
              "description": "Set all FMU inputs from an array.",
              "docstring_html": "<p>Set all FMU inputs from an array.</p>\n",
              "signature": "(values)",
              "parameters": [
                {
                  "name": "values",
                  "type": null,
                  "default": null,
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "get_outputs_as_array",
              "description": "Get all FMU outputs as an array.",
              "docstring_html": "<p>Get all FMU outputs as an array.</p>\n",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "do_step",
              "description": "Perform a co-simulation step.",
              "docstring_html": "<p>Perform a co-simulation step.</p>\n",
              "signature": "(current_time, step_size)",
              "parameters": [
                {
                  "name": "current_time",
                  "type": null,
                  "default": null,
                  "description": ""
                },
                {
                  "name": "step_size",
                  "type": null,
                  "default": null,
                  "description": ""
                }
              ],
              "returns": "StepResult",
              "method_type": "method"
            },
            {
              "name": "set_time",
              "description": "Set current time (Model Exchange only).",
              "docstring_html": "<p>Set current time (Model Exchange only).</p>\n",
              "signature": "(time)",
              "parameters": [
                {
                  "name": "time",
                  "type": null,
                  "default": null,
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "set_continuous_states",
              "description": "Set continuous states (Model Exchange only).",
              "docstring_html": "<p>Set continuous states (Model Exchange only).</p>\n",
              "signature": "(states)",
              "parameters": [
                {
                  "name": "states",
                  "type": null,
                  "default": null,
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "get_continuous_states",
              "description": "Get continuous states (Model Exchange only).",
              "docstring_html": "<p>Get continuous states (Model Exchange only).</p>\n",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "get_derivatives",
              "description": "Get state derivatives (Model Exchange only).",
              "docstring_html": "<p>Get state derivatives (Model Exchange only).</p>\n",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "get_event_indicators",
              "description": "Get event indicators (Model Exchange only).",
              "docstring_html": "<p>Get event indicators (Model Exchange only).</p>\n",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "enter_event_mode",
              "description": "Enter event mode (Model Exchange only).",
              "docstring_html": "<p>Enter event mode (Model Exchange only).</p>\n",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "enter_continuous_time_mode",
              "description": "Enter continuous time mode (Model Exchange only).",
              "docstring_html": "<p>Enter continuous time mode (Model Exchange only).</p>\n",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "update_discrete_states",
              "description": "Update discrete states during event iteration (Model Exchange only).",
              "docstring_html": "<p>Update discrete states during event iteration (Model Exchange only).</p>\n",
              "signature": "()",
              "parameters": [],
              "returns": "EventInfo",
              "method_type": "method"
            },
            {
              "name": "completed_integrator_step",
              "description": "Notify FMU that integrator step completed (Model Exchange only).",
              "docstring_html": "<p>Notify FMU that integrator step completed (Model Exchange only).</p>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>enter_event_mode <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>whether FMU requests event mode</dd>\n<dt>terminate_simulation <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>whether FMU requests simulation termination</dd>\n</dl>\n",
              "signature": "()",
              "parameters": [],
              "returns": "Tuple[bool, bool]",
              "method_type": "method"
            },
            {
              "name": "__del__",
              "description": "Cleanup FMU resources on deletion.",
              "docstring_html": "<p>Cleanup FMU resources on deletion.</p>\n",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "fmu_path",
              "description": "",
              "type": null,
              "value": "fmu_path"
            },
            {
              "name": "instance_name",
              "description": "",
              "type": null,
              "value": "instance_name"
            },
            {
              "name": "mode",
              "description": "",
              "type": null,
              "value": "mode.lower()"
            },
            {
              "name": "model_description",
              "description": "",
              "type": null,
              "value": "read_model_description(fmu_path)"
            },
            {
              "name": "fmi_version",
              "description": "",
              "type": null,
              "value": "self.model_description.fmiVersion"
            },
            {
              "name": "unzipdir",
              "description": "",
              "type": null,
              "value": "extract(fmu_path)"
            },
            {
              "name": "n_states",
              "description": "",
              "type": null,
              "value": "self.model_description.numberOfContinuousStates"
            },
            {
              "name": "n_event_indicators",
              "description": "",
              "type": null,
              "value": "self.model_description.numberOfEventIndicators"
            },
            {
              "name": "fmu",
              "description": "",
              "type": null,
              "value": "self._create_fmu_instance(FMU2Slave, FMU2Model, FMU3Slave, FMU3Model)"
            },
            {
              "name": "default_step_size",
              "description": "Get default step size from FMU's default experiment, if defined.",
              "type": "Optional[float]",
              "value": null
            },
            {
              "name": "default_tolerance",
              "description": "Get default tolerance from FMU's default experiment, if defined.",
              "type": "Optional[float]",
              "value": null
            },
            {
              "name": "needs_completed_integrator_step",
              "description": "Check if FMU requires completedIntegratorStep notifications (Model Exchange only).",
              "type": "bool",
              "value": null
            },
            {
              "name": "provides_jacobian",
              "description": "Check if FMU provides directional derivatives for Jacobian computation.",
              "type": "bool",
              "value": null
            }
          ],
          "parameters": [
            {
              "name": "fmu_path",
              "type": null,
              "default": null,
              "description": "path to the FMU file (.fmu)"
            },
            {
              "name": "instance_name",
              "type": null,
              "default": "'fmu_instance'",
              "description": "name for the FMU instance (default: 'fmu_instance')"
            },
            {
              "name": "mode",
              "type": null,
              "default": "'cosimulation'",
              "description": "FMU interface mode: 'cosimulation' or 'model_exchange' (default: 'cosimulation')"
            }
          ]
        },
        {
          "name": "CoSimulationFMU",
          "description": "Co-Simulation FMU block using FMPy with support for FMI 2.0 and FMI 3.0.",
          "docstring_html": "<p>Co-Simulation FMU block using FMPy with support for FMI 2.0 and FMI 3.0.</p>\n<p>This block wraps an FMU (Functional Mock-up Unit) for co-simulation.\nThe FMU encapsulates a simulation model that can be executed independently\nand synchronized with the main simulation at discrete communication points.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>fmu_path <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">str</span></dt>\n<dd>path to the FMU file (.fmu)</dd>\n<dt>instance_name <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">str, optional</span></dt>\n<dd>name for the FMU instance (default: 'fmu_instance')</dd>\n<dt>start_values <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">dict, optional</span></dt>\n<dd>dictionary of variable names and their initial values</dd>\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float, optional</span></dt>\n<dd>communication step size for co-simulation. If None, uses the FMU's\ndefault experiment step size if available.</dd>\n</dl>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>fmu_wrapper <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">FMUWrapper</span></dt>\n<dd>version-agnostic FMU wrapper instance providing access to model_description,\nfmu, and other FMPy objects for advanced usage</dd>\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>communication step size</dd>\n</dl>\n",
          "bases": [
            "Block"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "signature": "(fmu_path, instance_name = 'fmu_instance', start_values = None, dt = None)",
              "parameters": [
                {
                  "name": "fmu_path",
                  "type": null,
                  "default": null,
                  "description": ""
                },
                {
                  "name": "instance_name",
                  "type": null,
                  "default": "'fmu_instance'",
                  "description": ""
                },
                {
                  "name": "start_values",
                  "type": null,
                  "default": "None",
                  "description": ""
                },
                {
                  "name": "dt",
                  "type": null,
                  "default": "None",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "reset",
              "description": "Reset the FMU instance.",
              "docstring_html": "<p>Reset the FMU instance.</p>\n",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "start_values",
              "description": "",
              "type": null,
              "value": "start_values"
            },
            {
              "name": "fmu_wrapper",
              "description": "",
              "type": null,
              "value": "FMUWrapper(fmu_path, instance_name, mode='cosimulation')"
            },
            {
              "name": "dt",
              "description": "",
              "type": null,
              "value": "dt if dt is not None else self.fmu_wrapper.default_step_size"
            },
            {
              "name": "events",
              "description": "",
              "type": null,
              "value": "[Schedule(t_start=0, t_period=(self.dt), func_act=(self._step_fmu))]"
            }
          ],
          "parameters": [
            {
              "name": "fmu_path",
              "type": null,
              "default": null,
              "description": "path to the FMU file (.fmu)"
            },
            {
              "name": "instance_name",
              "type": null,
              "default": "'fmu_instance'",
              "description": "name for the FMU instance (default: 'fmu_instance')"
            },
            {
              "name": "start_values",
              "type": null,
              "default": "None",
              "description": "dictionary of variable names and their initial values"
            },
            {
              "name": "dt",
              "type": null,
              "default": "None",
              "description": "communication step size for co-simulation. If None, uses the FMU's default experiment step size if available."
            }
          ]
        },
        {
          "name": "ModelExchangeFMU",
          "description": "Model Exchange FMU block using FMPy with support for FMI 2.0 and FMI 3.0.",
          "docstring_html": "<p>Model Exchange FMU block using FMPy with support for FMI 2.0 and FMI 3.0.</p>\n<p>This block wraps an FMU (Functional Mock-up Unit) for model exchange.\nThe FMU provides the right-hand side of an ODE system that is integrated\nby PathSim's numerical solvers. Internal FMU events (state events, time\nevents, and step completion events) are translated to PathSim events.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>fmu_path <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">str</span></dt>\n<dd>path to the FMU file (.fmu)</dd>\n<dt>instance_name <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">str, optional</span></dt>\n<dd>name for the FMU instance (default: 'fmu_instance')</dd>\n<dt>start_values <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">dict, optional</span></dt>\n<dd>dictionary of variable names and their initial values</dd>\n<dt>tolerance <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float, optional</span></dt>\n<dd>tolerance for event detection (default: 1e-10)</dd>\n<dt>verbose <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool, optional</span></dt>\n<dd>enable verbose output (default: False)</dd>\n</dl>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>fmu_wrapper <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">FMUWrapper</span></dt>\n<dd>version-agnostic FMU wrapper instance providing access to model_description,\nfmu, and other FMPy objects for advanced usage</dd>\n<dt>time_event <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">ScheduleList or None</span></dt>\n<dd>dynamic time event for FMU-scheduled events</dd>\n</dl>\n",
          "bases": [
            "DynamicalSystem"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "signature": "(fmu_path, instance_name = 'fmu_instance', start_values = None, tolerance = 1e-10, verbose = False)",
              "parameters": [
                {
                  "name": "fmu_path",
                  "type": null,
                  "default": null,
                  "description": ""
                },
                {
                  "name": "instance_name",
                  "type": null,
                  "default": "'fmu_instance'",
                  "description": ""
                },
                {
                  "name": "start_values",
                  "type": null,
                  "default": "None",
                  "description": ""
                },
                {
                  "name": "tolerance",
                  "type": null,
                  "default": "1e-10",
                  "description": ""
                },
                {
                  "name": "verbose",
                  "type": null,
                  "default": "False",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "sample",
              "description": "Sample block after successful timestep and handle FMU step completion events.",
              "docstring_html": "<p>Sample block after successful timestep and handle FMU step completion events.</p>\n",
              "signature": "(t, dt)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": ""
                },
                {
                  "name": "dt",
                  "type": null,
                  "default": null,
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "reset",
              "description": "Reset the FMU instance.",
              "docstring_html": "<p>Reset the FMU instance.</p>\n",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "tolerance",
              "description": "",
              "type": null,
              "value": "tolerance"
            },
            {
              "name": "verbose",
              "description": "",
              "type": null,
              "value": "verbose"
            },
            {
              "name": "start_values",
              "description": "",
              "type": null,
              "value": "start_values"
            },
            {
              "name": "fmu_wrapper",
              "description": "",
              "type": null,
              "value": "FMUWrapper(fmu_path, instance_name, mode='model_exchange')"
            },
            {
              "name": "time_event",
              "description": "",
              "type": null,
              "value": "None"
            }
          ],
          "parameters": [
            {
              "name": "fmu_path",
              "type": null,
              "default": null,
              "description": "path to the FMU file (.fmu)"
            },
            {
              "name": "instance_name",
              "type": null,
              "default": "'fmu_instance'",
              "description": "name for the FMU instance (default: 'fmu_instance')"
            },
            {
              "name": "start_values",
              "type": null,
              "default": "None",
              "description": "dictionary of variable names and their initial values"
            },
            {
              "name": "tolerance",
              "type": null,
              "default": "1e-10",
              "description": "tolerance for event detection (default: 1e-10)"
            },
            {
              "name": "verbose",
              "type": null,
              "default": "False",
              "description": "enable verbose output (default: False)"
            }
          ]
        },
        {
          "name": "RFNetwork",
          "description": "N-port RF network linear time invariant (LTI) multi input multi output (MIMO) state-space model.",
          "docstring_html": "<p>N-port RF network linear time invariant (LTI) multi input multi output (MIMO) state-space model.</p>\n<p>Uses Vector Fitting for rational approximation of the frequency response using poles and residues.\nThe resulting approximation has guaranteed stable poles that are real or come in complex conjugate pairs.</p>\n<p>Assumes N inputs and N outputs, where N is the number of ports of the RF network.</p>\n<div class=\"section\" id=\"note\">\n<h4>Note</h4>\n<p>This block requires scikit-rf <a class=\"citation-reference\" href=\"#skrf\" id=\"citation-reference-1\">[skrf]</a> to be installed. Its an optional dependency of pathsim,\nto install it:</p>\n<pre class=\"code literal-block\">\npip install scikit-rf\n</pre>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>ntwk <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">can be :py:class:`~skrf.network.Network`, str, Path, or file-object.</span></dt>\n<dd>scikit-rf <a class=\"citation-reference\" href=\"#skrf\" id=\"citation-reference-2\">[skrf]</a> RF Network object, or file to load information from.\nSupported formats are touchstone file V1 (.s?p) or V2 (.ts).</dd>\n</dl>\n<p><strong>References</strong></p>\n<table class=\"docutils citation\" frame=\"void\" id=\"skrf\" rules=\"none\">\n<colgroup><col class=\"label\" /><col /></colgroup>\n<tbody valign=\"top\">\n<tr><td class=\"label\">[skrf]</td><td><em>(<a class=\"fn-backref\" href=\"#citation-reference-1\">1</a>, <a class=\"fn-backref\" href=\"#citation-reference-2\">2</a>)</em> scikit-rf webpage <a class=\"reference external\" href=\"https://scikit-rf.org/\">https://scikit-rf.org/</a></td></tr>\n</tbody>\n</table>\n</div>\n",
          "bases": [
            "StateSpace"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "signature": "(ntwk: NetworkType | str | Path, auto_fit: bool = True, kwargs = {})",
              "parameters": [
                {
                  "name": "ntwk",
                  "type": "NetworkType | str | Path",
                  "default": null,
                  "description": ""
                },
                {
                  "name": "auto_fit",
                  "type": "bool",
                  "default": "True",
                  "description": ""
                },
                {
                  "name": "kwargs",
                  "type": null,
                  "default": "{}",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "s",
              "description": "S-matrix of the vector fitted N-port model calculated from its state-space representation.",
              "docstring_html": "<p>S-matrix of the vector fitted N-port model calculated from its state-space representation.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>freqs <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">:py:class:`~numpy.ndarray`</span></dt>\n<dd>Frequencies (in Hz) at which to calculate the S-matrices.</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>s <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">:py:class:`~numpy.ndarray`</span></dt>\n<dd>Complex-valued S-matrices (fxNxN) calculated at frequencies <cite>freqs</cite>.</dd>\n</dl>\n",
              "signature": "(freqs: np.ndarray)",
              "parameters": [
                {
                  "name": "freqs",
                  "type": "np.ndarray",
                  "default": null,
                  "description": "Frequencies (in Hz) at which to calculate the S-matrices."
                }
              ],
              "returns": "np.ndarray",
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "network",
              "description": "",
              "type": null,
              "value": "ntwk"
            },
            {
              "name": "vf",
              "description": "",
              "type": null,
              "value": "vf"
            }
          ],
          "parameters": [
            {
              "name": "ntwk",
              "type": "NetworkType | str | Path",
              "default": null,
              "description": "scikit-rf [skrf]_ RF Network object, or file to load information from. Supported formats are touchstone file V1 (.s?p) or V2 (.ts)."
            },
            {
              "name": "auto_fit",
              "type": "bool",
              "default": "True",
              "description": ""
            },
            {
              "name": "kwargs",
              "type": null,
              "default": "{}",
              "description": ""
            }
          ]
        }
      ],
      "functions": [
        {
          "name": "deprecated",
          "description": "Decorator to mark functions, methods, or classes as deprecated.",
          "docstring_html": "<p>Decorator to mark functions, methods, or classes as deprecated.</p>\n<p>Emits a DeprecationWarning when the decorated item is called/instantiated\nand adds RST-formatted deprecation notice to the docstring.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>version <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">str | None</span></dt>\n<dd>Version when the item will be removed (e.g., &quot;1.0.0&quot;)</dd>\n<dt>replacement <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">str | None</span></dt>\n<dd>Name of the replacement to use instead (e.g., &quot;new_function&quot;)</dd>\n<dt>reason <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">str | None</span></dt>\n<dd>Additional explanation for the deprecation</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>decorator <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">callable</span></dt>\n<dd>Decorator function</dd>\n</dl>\n<div class=\"section\" id=\"example\">\n<h4>Example</h4>\n<pre class=\"code python literal-block\">\n&#64;deprecated(version=&quot;1.0.0&quot;, replacement=&quot;new_function&quot;)\ndef old_function():\n    pass\n\n&#64;deprecated(version=&quot;2.0.0&quot;, reason=&quot;No longer needed&quot;)\nclass OldClass:\n    pass\n</pre>\n</div>\n",
          "signature": "(version = None, replacement = None, reason = None)",
          "parameters": [
            {
              "name": "version",
              "type": null,
              "default": "None",
              "description": "Version when the item will be removed (e.g., \"1.0.0\")"
            },
            {
              "name": "replacement",
              "type": null,
              "default": "None",
              "description": "Name of the replacement to use instead (e.g., \"new_function\")"
            },
            {
              "name": "reason",
              "type": null,
              "default": "None",
              "description": "Additional explanation for the deprecation"
            }
          ],
          "returns": null
        },
        {
          "name": "gilbert_realization",
          "description": "Build real valued statespace model from transfer function",
          "docstring_html": "<p>Build real valued statespace model from transfer function\nin pole residue form by Gilbert's method and an additional\nsimilarity transformation to get fully real valued matrices.</p>\n<p>pole residue form:</p>\n<pre class=\"math\">\n\\mathbf{H}(s) = \\mathmf{D} + \\sum_{n=1}^N \\frac{\\mathbf{R}_n}{s - p_n} )\n</pre>\n<p>statespace form:</p>\n<div>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\">\n  <mi>𝐇</mi>\n  <mo stretchy=\"false\">(</mo>\n  <mi>s</mi>\n  <mo stretchy=\"false\">)</mo>\n  <mo>=</mo>\n  <mi>𝐂</mi>\n  <mo stretchy=\"false\">(</mo>\n  <mi>s</mi>\n  <mi>𝐈</mi>\n  <mo>−</mo>\n  <mi>𝐀</mi>\n  <msup>\n    <mo stretchy=\"false\">)</mo>\n    <mrow>\n      <mo>−</mo>\n      <mn>1</mn>\n    </mrow>\n  </msup>\n  <mo>*</mo>\n  <mi>𝐁</mi>\n  <mo>+</mo>\n  <mi>𝐇</mi>\n</math>\n</div>\n<p><strong>Notes</strong></p>\n<p>The resulting system is identical to the so-called\n'Modal Form' and is a minimal realization.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>Poles <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array</span></dt>\n<dd>real and complex poles</dd>\n<dt>Residues <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array</span></dt>\n<dd>array of real and complex residue matrices</dd>\n<dt>Const <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array</span></dt>\n<dd>matrix for constant term</dd>\n<dt>tolerance <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>relative tolerance for checking real poles</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>A <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array</span></dt>\n<dd>state matrix</dd>\n<dt>B <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array</span></dt>\n<dd>input mapping matrix</dd>\n<dt>C <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array</span></dt>\n<dd>state to output projection matrix</dd>\n<dt>D <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array, float</span></dt>\n<dd>direct passthrough</dd>\n</dl>\n<div class=\"section\" id=\"note\">\n<h4>Note</h4>\n<p>If some poles are complex-valued, their conjugate-values are automatically\nadded if missing, to enforce the model realness and stability.</p>\n</div>\n",
          "signature": "(Poles = [], Residues = [], Const = 0.0, tolerance = 1e-09)",
          "parameters": [
            {
              "name": "Poles",
              "type": null,
              "default": "[]",
              "description": "real and complex poles"
            },
            {
              "name": "Residues",
              "type": null,
              "default": "[]",
              "description": "array of real and complex residue matrices"
            },
            {
              "name": "Const",
              "type": null,
              "default": "0.0",
              "description": "matrix for constant term"
            },
            {
              "name": "tolerance",
              "type": null,
              "default": "1e-09",
              "description": "relative tolerance for checking real poles"
            }
          ],
          "returns": null
        }
      ],
      "submodules": [
        "adder",
        "amplifier",
        "comparator",
        "converters",
        "counter",
        "ctrl",
        "delay",
        "differentiator",
        "dynsys",
        "filters",
        "fir",
        "fmu",
        "function",
        "integrator",
        "kalman",
        "lti",
        "math",
        "multiplier",
        "noise",
        "ode",
        "relay",
        "rf",
        "rng",
        "samplehold",
        "scope",
        "sources",
        "spectrum",
        "switch",
        "table",
        "wrapper"
      ]
    },
    "pathsim.solvers": {
      "name": "pathsim.solvers",
      "description": "",
      "docstring_html": "",
      "classes": [
        {
          "name": "ImplicitSolver",
          "description": "Base class for implicit solver definition.",
          "docstring_html": "<p>Base class for implicit solver definition.</p>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>x_0 <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">numeric, array[numeric]</span></dt>\n<dd>internal 'working' initial value</dd>\n<dt>x <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">numeric, array[numeric]</span></dt>\n<dd>internal 'working' state</dd>\n<dt>n <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>order of integration scheme</dd>\n<dt>s <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>number of internal intermediate stages</dd>\n<dt>stage <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>counter for current intermediate stage</dd>\n<dt>eval_stages <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">list[float]</span></dt>\n<dd>rations for evaluation times of intermediate stages</dd>\n<dt>opt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">NewtonAnderson, Anderson, etc.</span></dt>\n<dd>optimizer instance to solve the implicit update equation</dd>\n</dl>\n",
          "bases": [
            "Solver"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "signature": "(solver_args = (), solver_kwargs = {})",
              "parameters": [
                {
                  "name": "solver_args",
                  "type": null,
                  "default": "()",
                  "description": ""
                },
                {
                  "name": "solver_kwargs",
                  "type": null,
                  "default": "{}",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "buffer",
              "description": "Saves the current state to an internal state buffer which",
              "docstring_html": "<p>Saves the current state to an internal state buffer which\nis especially relevant for multistage and implicit solvers.</p>\n<p>Resets the stage counter and the optimizer of implicit methods.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>integration timestep</dd>\n</dl>\n",
              "signature": "(dt)",
              "parameters": [
                {
                  "name": "dt",
                  "type": null,
                  "default": null,
                  "description": "integration timestep"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "solve",
              "description": "Advances the solution of the implicit update equation of the solver",
              "docstring_html": "<p>Advances the solution of the implicit update equation of the solver\nwith the optimizer of the engine and tracks the evolution of the\nsolution by providing the residual norm of the fixed-point solution.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>f <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">numeric, array[numeric]</span></dt>\n<dd>evaluation of rhs function</dd>\n<dt>J <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array[numeric]</span></dt>\n<dd>evaluation of jacobian of rhs function</dd>\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>integration timestep</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>err <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>residual error of the fixed point update equation</dd>\n</dl>\n",
              "signature": "(j, J, dt)",
              "parameters": [
                {
                  "name": "j",
                  "type": null,
                  "default": null,
                  "description": ""
                },
                {
                  "name": "J",
                  "type": null,
                  "default": null,
                  "description": "evaluation of jacobian of rhs function"
                },
                {
                  "name": "dt",
                  "type": null,
                  "default": null,
                  "description": "integration timestep"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "integrate_singlestep",
              "description": "Directly integrate the function 'func' for a single timestep 'dt' with",
              "docstring_html": "<p>Directly integrate the function 'func' for a single timestep 'dt' with\nimplicit solvers. This method is primarily intended for testing purposes.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>func <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">callable</span></dt>\n<dd>function to integrate f(x, t)</dd>\n<dt>jac <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">callable</span></dt>\n<dd>jacobian of f w.r.t. x</dd>\n<dt>time_start <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>starting time for timestep</dd>\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>integration timestep</dd>\n<dt>tolerance_fpi <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>convergence criterion for implicit update equation</dd>\n<dt>max_iterations <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>maximum numer of iterations for optimizer to solve\nimplicit update equation</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>success <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>True if the timestep was successful</dd>\n<dt>error_norm <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>estimated error of the internal error controller\nor solver when not converged</dd>\n<dt>scale <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>estimated timestep rescale factor for error control</dd>\n</dl>\n",
              "signature": "(func, jac, time = 0.0, dt = SIM_TIMESTEP, tolerance_fpi = SOL_TOLERANCE_FPI, max_iterations = SOL_ITERATIONS_MAX)",
              "parameters": [
                {
                  "name": "func",
                  "type": null,
                  "default": null,
                  "description": "function to integrate f(x, t)"
                },
                {
                  "name": "jac",
                  "type": null,
                  "default": null,
                  "description": "jacobian of f w.r.t. x"
                },
                {
                  "name": "time",
                  "type": null,
                  "default": "0.0",
                  "description": ""
                },
                {
                  "name": "dt",
                  "type": null,
                  "default": "SIM_TIMESTEP",
                  "description": "integration timestep"
                },
                {
                  "name": "tolerance_fpi",
                  "type": null,
                  "default": "SOL_TOLERANCE_FPI",
                  "description": "convergence criterion for implicit update equation"
                },
                {
                  "name": "max_iterations",
                  "type": null,
                  "default": "SOL_ITERATIONS_MAX",
                  "description": "maximum numer of iterations for optimizer to solve implicit update equation"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "integrate",
              "description": "Directly integrate the function 'func' from 'time_start'",
              "docstring_html": "<p>Directly integrate the function 'func' from 'time_start'\nto 'time_end' with timestep 'dt' for implicit solvers.</p>\n<p>This method is primarily intended for testing purposes or\nfor use as a standalone numerical integrator.</p>\n<div class=\"section\" id=\"example\">\n<h4>Example</h4>\n<p>This is how to directly use the solver to integrate an ODE:</p>\n<pre class=\"code python literal-block\">\n#1st order linear ODE\ndef f(x, t):\n    return -x\n\n#initial condition\nx0 = 1\n\n#initialize ODE solver\nsol = Solver(x0)\n\n#integrate from 0 to 5 with timestep 0.1\nt, x = sol.integrate(f, time_end=5, dt=0.1)\n</pre>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>func <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">callable</span></dt>\n<dd>function to integrate f(x, t)</dd>\n<dt>jac <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">callable</span></dt>\n<dd>jacobian of f w.r.t. x</dd>\n<dt>time_start <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>starting time for integration</dd>\n<dt>time_end <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>end time for integration</dd>\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>timestep or initial timestep for adaptive solvers</dd>\n<dt>dt_min <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>lower bound for timestep, default '0.0'</dd>\n<dt>dt_max <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>upper bound for timestep, default 'None'</dd>\n<dt>adaptive <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>use adaptive timestepping if available</dd>\n<dt>tolerance_fpi <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>convergence criterion for implicit update equation</dd>\n<dt>max_iterations <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>maximum numer of iterations for optimizer to solve\nimplicit update equation</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>outout_times <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array[float]</span></dt>\n<dd>time points of the solution</dd>\n<dt>output_states <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array[numeric], array[array[numeric]]</span></dt>\n<dd>state values at solution time points</dd>\n</dl>\n</div>\n",
              "signature": "(func, jac, time_start = 0.0, time_end = 1.0, dt = SIM_TIMESTEP, dt_min = SIM_TIMESTEP_MIN, dt_max = SIM_TIMESTEP_MAX, adaptive = True, tolerance_fpi = SOL_TOLERANCE_FPI, max_iterations = SOL_ITERATIONS_MAX)",
              "parameters": [
                {
                  "name": "func",
                  "type": null,
                  "default": null,
                  "description": "function to integrate f(x, t)"
                },
                {
                  "name": "jac",
                  "type": null,
                  "default": null,
                  "description": "jacobian of f w.r.t. x"
                },
                {
                  "name": "time_start",
                  "type": null,
                  "default": "0.0",
                  "description": "starting time for integration"
                },
                {
                  "name": "time_end",
                  "type": null,
                  "default": "1.0",
                  "description": "end time for integration"
                },
                {
                  "name": "dt",
                  "type": null,
                  "default": "SIM_TIMESTEP",
                  "description": "timestep or initial timestep for adaptive solvers"
                },
                {
                  "name": "dt_min",
                  "type": null,
                  "default": "SIM_TIMESTEP_MIN",
                  "description": "lower bound for timestep, default '0.0'"
                },
                {
                  "name": "dt_max",
                  "type": null,
                  "default": "SIM_TIMESTEP_MAX",
                  "description": "upper bound for timestep, default 'None'"
                },
                {
                  "name": "adaptive",
                  "type": null,
                  "default": "True",
                  "description": "use adaptive timestepping if available"
                },
                {
                  "name": "tolerance_fpi",
                  "type": null,
                  "default": "SOL_TOLERANCE_FPI",
                  "description": "convergence criterion for implicit update equation"
                },
                {
                  "name": "max_iterations",
                  "type": null,
                  "default": "SOL_ITERATIONS_MAX",
                  "description": "maximum numer of iterations for optimizer to solve implicit update equation"
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "is_explicit",
              "description": "",
              "type": null,
              "value": "False"
            },
            {
              "name": "is_implicit",
              "description": "",
              "type": null,
              "value": "True"
            },
            {
              "name": "eval_stages",
              "description": "",
              "type": null,
              "value": "[1.0]"
            },
            {
              "name": "opt",
              "description": "",
              "type": null,
              "value": "NewtonAnderson()"
            }
          ],
          "parameters": [
            {
              "name": "solver_args",
              "type": null,
              "default": "()",
              "description": ""
            },
            {
              "name": "solver_kwargs",
              "type": null,
              "default": "{}",
              "description": ""
            }
          ]
        },
        {
          "name": "SteadyState",
          "description": "Pseudo-solver that finds the time-independent steady-state solution (DC operating point).",
          "docstring_html": "<p>Pseudo-solver that finds the time-independent steady-state solution (DC operating point).</p>\n<p>This works by modifying the fixed-point iteration target. Instead of solving\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\">\n  <msub>\n    <mi>x</mi>\n    <mrow>\n      <mi>n</mi>\n      <mo>+</mo>\n      <mn>1</mn>\n    </mrow>\n  </msub>\n  <mo>=</mo>\n  <mi>G</mi>\n  <mo stretchy=\"false\">(</mo>\n  <msub>\n    <mi>x</mi>\n    <mrow>\n      <mi>n</mi>\n      <mo>+</mo>\n      <mn>1</mn>\n    </mrow>\n  </msub>\n  <mo stretchy=\"false\">)</mo>\n</math> for an implicit step, it aims to solve the algebraic equation\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\">\n  <mi>f</mi>\n  <mo stretchy=\"false\">(</mo>\n  <mi>x</mi>\n  <mo>,</mo>\n  <mi>u</mi>\n  <mo>,</mo>\n  <msub>\n    <mi>t</mi>\n    <mrow>\n      <mi>s</mi>\n      <mi>t</mi>\n      <mi>e</mi>\n      <mi>a</mi>\n      <mi>d</mi>\n      <mi>y</mi>\n    </mrow>\n  </msub>\n  <mo stretchy=\"false\">)</mo>\n  <mo>=</mo>\n  <mn>0</mn>\n</math> by finding the fixed point of <math xmlns=\"http://www.w3.org/1998/Math/MathML\">\n  <mi>x</mi>\n  <mo>=</mo>\n  <mi>x</mi>\n  <mo>+</mo>\n  <mi>f</mi>\n  <mo stretchy=\"false\">(</mo>\n  <mi>x</mi>\n  <mo>,</mo>\n  <mi>u</mi>\n  <mo>,</mo>\n  <msub>\n    <mi>t</mi>\n    <mrow>\n      <mi>s</mi>\n      <mi>t</mi>\n      <mi>e</mi>\n      <mi>a</mi>\n      <mi>d</mi>\n      <mi>y</mi>\n    </mrow>\n  </msub>\n  <mo stretchy=\"false\">)</mo>\n</math>.\nIt uses the same internal optimizer (e.g., NewtonAnderson) as other implicit solvers.</p>\n<div class=\"section\" id=\"characteristics\">\n<h4>Characteristics</h4>\n<ul class=\"simple\">\n<li>Purpose: Find steady-state (<math xmlns=\"http://www.w3.org/1998/Math/MathML\">\n  <mi>d</mi>\n  <mi>x</mi>\n  <mo stretchy=\"false\">/</mo>\n  <mi>d</mi>\n  <mi>t</mi>\n  <mo>=</mo>\n  <mn>0</mn>\n</math>)</li>\n<li>Implicit (uses optimizer)</li>\n<li>Not a time-stepping method.</li>\n</ul>\n</div>\n",
          "bases": [
            "ImplicitSolver"
          ],
          "methods": [
            {
              "name": "solve",
              "description": "Solve for steady state by finding x where f(x,u,t) = 0",
              "docstring_html": "<p>Solve for steady state by finding x where f(x,u,t) = 0\nusing the fixed point equation x = x + f(x,u,t).</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>f <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array_like</span></dt>\n<dd>evaluation of function</dd>\n<dt>J <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array_like</span></dt>\n<dd>evaluation of jacobian of function</dd>\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>integration timestep</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>err <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>residual error of the fixed point update equation</dd>\n</dl>\n",
              "signature": "(f, J, dt)",
              "parameters": [
                {
                  "name": "f",
                  "type": null,
                  "default": null,
                  "description": "evaluation of function"
                },
                {
                  "name": "J",
                  "type": null,
                  "default": null,
                  "description": "evaluation of jacobian of function"
                },
                {
                  "name": "dt",
                  "type": null,
                  "default": null,
                  "description": "integration timestep"
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [],
          "parameters": []
        },
        {
          "name": "ExplicitSolver",
          "description": "Base class for explicit solver definition.",
          "docstring_html": "<p>Base class for explicit solver definition.</p>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>x_0 <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">numeric, array[numeric]</span></dt>\n<dd>internal 'working' initial value</dd>\n<dt>x <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">numeric, array[numeric]</span></dt>\n<dd>internal 'working' state</dd>\n<dt>n <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>order of integration scheme</dd>\n<dt>s <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>number of internal intermediate stages</dd>\n<dt>stage <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>counter for current intermediate stage</dd>\n<dt>eval_stages <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">list[float]</span></dt>\n<dd>rations for evaluation times of intermediate stages</dd>\n</dl>\n",
          "bases": [
            "Solver"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "signature": "(solver_args = (), solver_kwargs = {})",
              "parameters": [
                {
                  "name": "solver_args",
                  "type": null,
                  "default": "()",
                  "description": ""
                },
                {
                  "name": "solver_kwargs",
                  "type": null,
                  "default": "{}",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "integrate_singlestep",
              "description": "Directly integrate the function for a single timestep 'dt' with",
              "docstring_html": "<p>Directly integrate the function for a single timestep 'dt' with\nexplicit solvers. This method is primarily intended for testing purposes.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>func <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">callable</span></dt>\n<dd>function to integrate f(x, t)</dd>\n<dt>time <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>starting time for timestep</dd>\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>integration timestep</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>success <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>True if the timestep was successful</dd>\n<dt>error_norm <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>estimated error of the internal error controller</dd>\n<dt>scale <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>estimated timestep rescale factor for error control</dd>\n</dl>\n",
              "signature": "(func, time = 0.0, dt = SIM_TIMESTEP)",
              "parameters": [
                {
                  "name": "func",
                  "type": null,
                  "default": null,
                  "description": "function to integrate f(x, t)"
                },
                {
                  "name": "time",
                  "type": null,
                  "default": "0.0",
                  "description": "starting time for timestep"
                },
                {
                  "name": "dt",
                  "type": null,
                  "default": "SIM_TIMESTEP",
                  "description": "integration timestep"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "integrate",
              "description": "Directly integrate the function 'func' from 'time_start'",
              "docstring_html": "<p>Directly integrate the function 'func' from 'time_start'\nto 'time_end' with timestep 'dt' for explicit solvers.</p>\n<p>This method is primarily intended for testing purposes or\nfor use as a standalone numerical integrator.</p>\n<div class=\"section\" id=\"example\">\n<h4>Example</h4>\n<p>This is how to directly use the solver to integrate an ODE:</p>\n<pre class=\"code python literal-block\">\n#1st order linear ODE\ndef f(x, u, t):\n    return -x\n\n#initial condition\nx0 = 1\n\n#initialize ODE solver\nsol = Solver(x0)\n\n#integrate from 0 to 5 with timestep 0.1\nt, x = sol.integrate(f, time_end=5, dt=0.1)\n</pre>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>func <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">callable</span></dt>\n<dd>function to integrate f(x, t)</dd>\n<dt>time_start <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>starting time for integration</dd>\n<dt>time_end <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>end time for integration</dd>\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>timestep or initial timestep for adaptive solvers</dd>\n<dt>dt_min <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>lower bound for timestep, default '0.0'</dd>\n<dt>dt_max <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>upper bound for timestep, default 'None'</dd>\n<dt>adaptive <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>use adaptive timestepping if available</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>outout_times <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array[float]</span></dt>\n<dd>time points of the solution</dd>\n<dt>output_states <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array[numeric], array[array[numeric]]</span></dt>\n<dd>state values at solution time points</dd>\n</dl>\n</div>\n",
              "signature": "(func, time_start = 0.0, time_end = 1.0, dt = SIM_TIMESTEP, dt_min = SIM_TIMESTEP_MIN, dt_max = SIM_TIMESTEP_MAX, adaptive = True)",
              "parameters": [
                {
                  "name": "func",
                  "type": null,
                  "default": null,
                  "description": "function to integrate f(x, t)"
                },
                {
                  "name": "time_start",
                  "type": null,
                  "default": "0.0",
                  "description": "starting time for integration"
                },
                {
                  "name": "time_end",
                  "type": null,
                  "default": "1.0",
                  "description": "end time for integration"
                },
                {
                  "name": "dt",
                  "type": null,
                  "default": "SIM_TIMESTEP",
                  "description": "timestep or initial timestep for adaptive solvers"
                },
                {
                  "name": "dt_min",
                  "type": null,
                  "default": "SIM_TIMESTEP_MIN",
                  "description": "lower bound for timestep, default '0.0'"
                },
                {
                  "name": "dt_max",
                  "type": null,
                  "default": "SIM_TIMESTEP_MAX",
                  "description": "upper bound for timestep, default 'None'"
                },
                {
                  "name": "adaptive",
                  "type": null,
                  "default": "True",
                  "description": "use adaptive timestepping if available"
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "is_explicit",
              "description": "",
              "type": null,
              "value": "True"
            },
            {
              "name": "is_implicit",
              "description": "",
              "type": null,
              "value": "False"
            },
            {
              "name": "eval_stages",
              "description": "",
              "type": null,
              "value": "[0.0]"
            }
          ],
          "parameters": [
            {
              "name": "solver_args",
              "type": null,
              "default": "()",
              "description": ""
            },
            {
              "name": "solver_kwargs",
              "type": null,
              "default": "{}",
              "description": ""
            }
          ]
        },
        {
          "name": "EUF",
          "description": "Explicit Forward Euler (FE) integration method.",
          "docstring_html": "<p>Explicit Forward Euler (FE) integration method.</p>\n<p>This is the simplest explicit numerical integration method. It is first-order\naccurate (<math xmlns=\"http://www.w3.org/1998/Math/MathML\">\n  <mi>O</mi>\n  <mo stretchy=\"false\">(</mo>\n  <mi>h</mi>\n  <mo stretchy=\"false\">)</mo>\n</math>) and generally not suitable for stiff problems due to its\nlimited stability region.</p>\n<p>Method:</p>\n<div>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\">\n  <msub>\n    <mi>x</mi>\n    <mrow>\n      <mi>n</mi>\n      <mo>+</mo>\n      <mn>1</mn>\n    </mrow>\n  </msub>\n  <mo>=</mo>\n  <msub>\n    <mi>x</mi>\n    <mi>n</mi>\n  </msub>\n  <mo>+</mo>\n  <mi>d</mi>\n  <mi>t</mi>\n  <mo>⋅</mo>\n  <mi>f</mi>\n  <mo stretchy=\"false\">(</mo>\n  <msub>\n    <mi>x</mi>\n    <mi>n</mi>\n  </msub>\n  <mo>,</mo>\n  <msub>\n    <mi>t</mi>\n    <mi>n</mi>\n  </msub>\n  <mo stretchy=\"false\">)</mo>\n</math>\n</div>\n<div class=\"section\" id=\"characteristics\">\n<h4>Characteristics</h4>\n<ul class=\"simple\">\n<li>Order: 1</li>\n<li>Stages: 1</li>\n<li>Explicit</li>\n<li>Fixed timestep only</li>\n<li>Not A-stable</li>\n<li>Low accuracy and stability, but computationally very cheap.</li>\n</ul>\n</div>\n<div class=\"section\" id=\"when-to-use\">\n<h4>When to Use</h4>\n<ul class=\"simple\">\n<li><strong>Educational purposes</strong>: Ideal for teaching basic numerical integration concepts</li>\n<li><strong>Very smooth problems</strong>: When the function is extremely smooth and well-behaved</li>\n<li><strong>Rapid prototyping</strong>: Quick initial testing before applying more sophisticated methods</li>\n<li><strong>Resource-constrained scenarios</strong>: When computational cost must be minimized</li>\n</ul>\n<p><strong>Not recommended</strong> for production use, stiff problems, or when accuracy is important.</p>\n<p><strong>References</strong></p>\n<table class=\"docutils footnote\" frame=\"void\" id=\"footnote-1\" rules=\"none\">\n<colgroup><col class=\"label\" /><col /></colgroup>\n<tbody valign=\"top\">\n<tr><td class=\"label\">[1]</td><td>Euler, L. (1768). &quot;Institutionum calculi integralis&quot;. Impensis Academiae\nImperialis Scientiarum, Vol. 1.</td></tr>\n</tbody>\n</table>\n<table class=\"docutils footnote\" frame=\"void\" id=\"footnote-2\" rules=\"none\">\n<colgroup><col class=\"label\" /><col /></colgroup>\n<tbody valign=\"top\">\n<tr><td class=\"label\">[2]</td><td>Butcher, J. C. (2016). &quot;Numerical Methods for Ordinary Differential Equations&quot;.\nJohn Wiley &amp; Sons, 3rd Edition.</td></tr>\n</tbody>\n</table>\n<table class=\"docutils footnote\" frame=\"void\" id=\"footnote-3\" rules=\"none\">\n<colgroup><col class=\"label\" /><col /></colgroup>\n<tbody valign=\"top\">\n<tr><td class=\"label\">[3]</td><td>Hairer, E., Nørsett, S. P., &amp; Wanner, G. (1993). &quot;Solving Ordinary\nDifferential Equations I: Nonstiff Problems&quot;. Springer Series in Computational\nMathematics, Vol. 8.</td></tr>\n</tbody>\n</table>\n</div>\n",
          "bases": [
            "ExplicitSolver"
          ],
          "methods": [
            {
              "name": "step",
              "description": "performs the explicit forward timestep for (t+dt)",
              "docstring_html": "<p>performs the explicit forward timestep for (t+dt)\nbased on the state and input at (t)</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>f <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array_like</span></dt>\n<dd>evaluation of function</dd>\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>integration timestep</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>success <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>timestep was successful</dd>\n<dt>err <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>truncation error estimate</dd>\n<dt>scale <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>timestep rescale from error controller</dd>\n</dl>\n",
              "signature": "(f, dt)",
              "parameters": [
                {
                  "name": "f",
                  "type": null,
                  "default": null,
                  "description": "evaluation of function"
                },
                {
                  "name": "dt",
                  "type": null,
                  "default": null,
                  "description": "integration timestep"
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [],
          "parameters": []
        },
        {
          "name": "EUB",
          "description": "Implicit Backward Euler (BE) integration method.",
          "docstring_html": "<p>Implicit Backward Euler (BE) integration method.</p>\n<p>This is the simplest implicit numerical integration method. It is first-order\naccurate (<math xmlns=\"http://www.w3.org/1998/Math/MathML\">\n  <mi>O</mi>\n  <mo stretchy=\"false\">(</mo>\n  <mi>h</mi>\n  <mo stretchy=\"false\">)</mo>\n</math>) and is A-stable and L-stable, making it suitable for very\nstiff problems where stability is paramount, although its low order limits\naccuracy for non-stiff problems or when high precision is required.</p>\n<p>Method:</p>\n<div>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\">\n  <msub>\n    <mi>x</mi>\n    <mrow>\n      <mi>n</mi>\n      <mo>+</mo>\n      <mn>1</mn>\n    </mrow>\n  </msub>\n  <mo>=</mo>\n  <msub>\n    <mi>x</mi>\n    <mi>n</mi>\n  </msub>\n  <mo>+</mo>\n  <mi>d</mi>\n  <mi>t</mi>\n  <mo>⋅</mo>\n  <mi>f</mi>\n  <mo stretchy=\"false\">(</mo>\n  <msub>\n    <mi>x</mi>\n    <mrow>\n      <mi>n</mi>\n      <mo>+</mo>\n      <mn>1</mn>\n    </mrow>\n  </msub>\n  <mo>,</mo>\n  <msub>\n    <mi>t</mi>\n    <mrow>\n      <mi>n</mi>\n      <mo>+</mo>\n      <mn>1</mn>\n    </mrow>\n  </msub>\n  <mo stretchy=\"false\">)</mo>\n</math>\n</div>\n<p>This implicit equation is solved iteratively using the internal optimizer.</p>\n<div class=\"section\" id=\"characteristics\">\n<h4>Characteristics</h4>\n<ul class=\"simple\">\n<li>Order: 1</li>\n<li>Stages: 1 (Implicit)</li>\n<li>Implicit</li>\n<li>Fixed timestep only</li>\n<li>A-stable, L-stable</li>\n<li>Very stable, suitable for stiff problems, but low accuracy.</li>\n</ul>\n</div>\n<div class=\"section\" id=\"when-to-use\">\n<h4>When to Use</h4>\n<ul class=\"simple\">\n<li><strong>Highly stiff problems</strong>: Excellent stability for very stiff ODEs</li>\n<li><strong>Robustness over accuracy</strong>: When stability is more critical than precision</li>\n<li><strong>Long-time integration</strong>: For simulations over very long time periods where stability matters</li>\n<li><strong>Initial testing of stiff systems</strong>: Simple method to verify problem setup</li>\n</ul>\n<p><strong>Trade-off</strong>: Sacrifices accuracy for exceptional stability. For higher accuracy on\nstiff problems, consider BDF or ESDIRK methods.</p>\n<p><strong>References</strong></p>\n<table class=\"docutils footnote\" frame=\"void\" id=\"footnote-1\" rules=\"none\">\n<colgroup><col class=\"label\" /><col /></colgroup>\n<tbody valign=\"top\">\n<tr><td class=\"label\">[1]</td><td>Curtiss, C. F., &amp; Hirschfelder, J. O. (1952). &quot;Integration of stiff equations&quot;.\nProceedings of the National Academy of Sciences, 38(3), 235-243.</td></tr>\n</tbody>\n</table>\n<table class=\"docutils footnote\" frame=\"void\" id=\"footnote-2\" rules=\"none\">\n<colgroup><col class=\"label\" /><col /></colgroup>\n<tbody valign=\"top\">\n<tr><td class=\"label\">[2]</td><td>Hairer, E., &amp; Wanner, G. (1996). &quot;Solving Ordinary Differential Equations II:\nStiff and Differential-Algebraic Problems&quot;. Springer Series in Computational\nMathematics, Vol. 14.</td></tr>\n</tbody>\n</table>\n<table class=\"docutils footnote\" frame=\"void\" id=\"footnote-3\" rules=\"none\">\n<colgroup><col class=\"label\" /><col /></colgroup>\n<tbody valign=\"top\">\n<tr><td class=\"label\">[3]</td><td>Butcher, J. C. (2016). &quot;Numerical Methods for Ordinary Differential Equations&quot;.\nJohn Wiley &amp; Sons, 3rd Edition.</td></tr>\n</tbody>\n</table>\n</div>\n",
          "bases": [
            "ImplicitSolver"
          ],
          "methods": [
            {
              "name": "solve",
              "description": "Solves the implicit update equation",
              "docstring_html": "<p>Solves the implicit update equation\nusing the internal optimizer.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>f <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array_like</span></dt>\n<dd>evaluation of function</dd>\n<dt>J <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array_like</span></dt>\n<dd>evaluation of jacobian of function</dd>\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>integration timestep</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>err <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>residual error of the fixed point update equation</dd>\n</dl>\n",
              "signature": "(f, J, dt)",
              "parameters": [
                {
                  "name": "f",
                  "type": null,
                  "default": null,
                  "description": "evaluation of function"
                },
                {
                  "name": "J",
                  "type": null,
                  "default": null,
                  "description": "evaluation of jacobian of function"
                },
                {
                  "name": "dt",
                  "type": null,
                  "default": null,
                  "description": "integration timestep"
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [],
          "parameters": []
        },
        {
          "name": "DIRK3",
          "description": "Four-stage, 3rd order L-stable Diagonally Implicit Runge-Kutta (DIRK) method.",
          "docstring_html": "<p>Four-stage, 3rd order L-stable Diagonally Implicit Runge-Kutta (DIRK) method.</p>\n<p>L-stability (A-stability and stiffly accurate, i.e., <math xmlns=\"http://www.w3.org/1998/Math/MathML\">\n  <mo stretchy=\"false\">|</mo>\n  <mi>R</mi>\n  <mo stretchy=\"false\">(</mo>\n  <mi>∞</mi>\n  <mo stretchy=\"false\">)</mo>\n  <mo stretchy=\"false\">|</mo>\n  <mo>=</mo>\n  <mn>0</mn>\n</math>) makes\nthis method suitable for stiff problems where damping of high-frequency components\nis desired. The stiffly accurate property ensures good behavior for problems with\nsingular perturbations and differential-algebraic equations.</p>\n<div class=\"section\" id=\"characteristics\">\n<h4>Characteristics</h4>\n<ul class=\"simple\">\n<li>Order: 3</li>\n<li>Stages: 4 (Implicit)</li>\n<li>Implicit (DIRK)</li>\n<li>Fixed timestep only</li>\n<li>L-stable (and thus A-stable)</li>\n<li>Stiffly accurate</li>\n</ul>\n</div>\n<div class=\"section\" id=\"when-to-use\">\n<h4>When to Use</h4>\n<ul class=\"simple\">\n<li><strong>Stiff problems</strong>: Excellent stability for very stiff ODEs</li>\n<li><strong>Damping required</strong>: L-stability damps high-frequency oscillations</li>\n<li><strong>Differential-algebraic equations</strong>: Stiffly accurate property helps with DAEs</li>\n<li><strong>3rd order implicit</strong>: Moderate accuracy with strong stability</li>\n</ul>\n<p><strong>Recommended</strong> for stiff problems requiring 3rd order accuracy. For higher order,\nconsider ESDIRK54. For variable timestep, use adaptive ESDIRK methods.</p>\n<p><strong>References</strong></p>\n<table class=\"docutils footnote\" frame=\"void\" id=\"footnote-1\" rules=\"none\">\n<colgroup><col class=\"label\" /><col /></colgroup>\n<tbody valign=\"top\">\n<tr><td class=\"label\">[1]</td><td>Crouzeix, M. (1975). &quot;Sur l'approximation des équations différentielles\nopérationnelles linéaires par des méthodes de Runge-Kutta&quot;. PhD thesis,\nUniversité Paris VI.</td></tr>\n</tbody>\n</table>\n<table class=\"docutils footnote\" frame=\"void\" id=\"footnote-2\" rules=\"none\">\n<colgroup><col class=\"label\" /><col /></colgroup>\n<tbody valign=\"top\">\n<tr><td class=\"label\">[2]</td><td>Hairer, E., &amp; Wanner, G. (1996). &quot;Solving Ordinary Differential Equations II:\nStiff and Differential-Algebraic Problems&quot;. Springer Series in Computational\nMathematics, Vol. 14.</td></tr>\n</tbody>\n</table>\n<table class=\"docutils footnote\" frame=\"void\" id=\"footnote-3\" rules=\"none\">\n<colgroup><col class=\"label\" /><col /></colgroup>\n<tbody valign=\"top\">\n<tr><td class=\"label\">[3]</td><td>Alexander, R. (1977). &quot;Diagonally implicit Runge-Kutta methods for stiff O.D.E.'s&quot;.\nSIAM Journal on Numerical Analysis, 14(6), 1006-1021.</td></tr>\n</tbody>\n</table>\n</div>\n",
          "bases": [
            "DiagonallyImplicitRungeKutta"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "signature": "(solver_args = (), solver_kwargs = {})",
              "parameters": [
                {
                  "name": "solver_args",
                  "type": null,
                  "default": "()",
                  "description": ""
                },
                {
                  "name": "solver_kwargs",
                  "type": null,
                  "default": "{}",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "s",
              "description": "",
              "type": null,
              "value": "4"
            },
            {
              "name": "n",
              "description": "",
              "type": null,
              "value": "3"
            },
            {
              "name": "eval_stages",
              "description": "",
              "type": null,
              "value": "[1 / 2, 2 / 3, 1 / 2, 1.0]"
            },
            {
              "name": "BT",
              "description": "",
              "type": null,
              "value": "{0: [1 / 2], 1: [1 / 6, 1 / 2], 2: [-1 / 2, 1 / 2, 1 / 2], 3: [3 / 2, -3 / 2, 1 / 2, 1 / 2]}"
            }
          ],
          "parameters": [
            {
              "name": "solver_args",
              "type": null,
              "default": "()",
              "description": ""
            },
            {
              "name": "solver_kwargs",
              "type": null,
              "default": "{}",
              "description": ""
            }
          ]
        },
        {
          "name": "BDF",
          "description": "Base class for the backward differentiation formula (BDF) integrators.",
          "docstring_html": "<p>Base class for the backward differentiation formula (BDF) integrators.</p>\n<p><strong>Notes</strong></p>\n<p>This solver class is not intended to be used directly</p>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>x <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">numeric, array[numeric]</span></dt>\n<dd>internal 'working' state</dd>\n<dt>n <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>order of integration scheme</dd>\n<dt>s <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>number of internal intermediate stages</dd>\n<dt>stage <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>counter for current intermediate stage</dd>\n<dt>eval_stages <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">list[float]</span></dt>\n<dd>rations for evaluation times of intermediate stages</dd>\n<dt>opt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">NewtonAnderson, Anderson, etc.</span></dt>\n<dd>optimizer instance to solve the implicit update equation</dd>\n<dt>K <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">dict[int: list[float]]</span></dt>\n<dd>bdf coefficients for the state buffer for each order</dd>\n<dt>F <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">dict[int: float]</span></dt>\n<dd>bdf coefficients for the function 'func' for each order</dd>\n<dt>history <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">deque[numeric]</span></dt>\n<dd>internal history of past results</dd>\n<dt>startup <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">Solver</span></dt>\n<dd>internal solver instance for startup (building history)\nof multistep methods (using 'DIRK3' for 'BDF' methods)</dd>\n</dl>\n",
          "bases": [
            "ImplicitSolver"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "signature": "(solver_args = (), solver_kwargs = {})",
              "parameters": [
                {
                  "name": "solver_args",
                  "type": null,
                  "default": "()",
                  "description": ""
                },
                {
                  "name": "solver_kwargs",
                  "type": null,
                  "default": "{}",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "cast",
              "description": "cast to this solver needs special handling of startup method",
              "docstring_html": "<p>cast to this solver needs special handling of startup method</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>other <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">Solver</span></dt>\n<dd>solver instance to cast new instance of this class from</dd>\n<dt>parent <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">None | Solver</span></dt>\n<dd>solver instance to use as parent</dd>\n<dt>solver_kwargs <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">dict</span></dt>\n<dd>other args for the solver</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>engine <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">BDF</span></dt>\n<dd>instance of <cite>BDF</cite> solver with params and state from <cite>other</cite></dd>\n</dl>\n",
              "signature": "(cls, other, parent, solver_kwargs = {})",
              "parameters": [
                {
                  "name": "cls",
                  "type": null,
                  "default": null,
                  "description": ""
                },
                {
                  "name": "other",
                  "type": null,
                  "default": null,
                  "description": "solver instance to cast new instance of this class from"
                },
                {
                  "name": "parent",
                  "type": null,
                  "default": null,
                  "description": "solver instance to use as parent"
                },
                {
                  "name": "solver_kwargs",
                  "type": null,
                  "default": "{}",
                  "description": "other args for the solver"
                }
              ],
              "returns": null,
              "method_type": "classmethod"
            },
            {
              "name": "create",
              "description": "Create a new BDF solver, properly initializing the startup solver.",
              "docstring_html": "<p>Create a new BDF solver, properly initializing the startup solver.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>initial_value <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float, array</span></dt>\n<dd>initial condition / integration constant</dd>\n<dt>parent <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">None | Solver</span></dt>\n<dd>parent solver instance for stage synchronization</dd>\n<dt>from_engine <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">None | Solver</span></dt>\n<dd>existing solver to inherit state and settings from</dd>\n<dt>solver_kwargs <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">dict</span></dt>\n<dd>additional args for the solver</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>engine <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">BDF</span></dt>\n<dd>new BDF solver instance</dd>\n</dl>\n",
              "signature": "(cls, initial_value, parent = None, from_engine = None, solver_kwargs = {})",
              "parameters": [
                {
                  "name": "cls",
                  "type": null,
                  "default": null,
                  "description": ""
                },
                {
                  "name": "initial_value",
                  "type": null,
                  "default": null,
                  "description": "initial condition / integration constant"
                },
                {
                  "name": "parent",
                  "type": null,
                  "default": "None",
                  "description": "parent solver instance for stage synchronization"
                },
                {
                  "name": "from_engine",
                  "type": null,
                  "default": "None",
                  "description": "existing solver to inherit state and settings from"
                },
                {
                  "name": "solver_kwargs",
                  "type": null,
                  "default": "{}",
                  "description": "additional args for the solver"
                }
              ],
              "returns": null,
              "method_type": "classmethod"
            },
            {
              "name": "stages",
              "description": "Generator that yields the intermediate evaluation",
              "docstring_html": "<p>Generator that yields the intermediate evaluation\ntime during the timestep 't + ratio * dt'.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time</dd>\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>integration timestep</dd>\n</dl>\n",
              "signature": "(t, dt)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time"
                },
                {
                  "name": "dt",
                  "type": null,
                  "default": null,
                  "description": "integration timestep"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "reset",
              "description": "\"Resets integration engine to initial state.",
              "docstring_html": "<p>&quot;Resets integration engine to initial state.</p>\n",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "buffer",
              "description": "buffer the state for the multistep method",
              "docstring_html": "<p>buffer the state for the multistep method</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>integration timestep</dd>\n</dl>\n",
              "signature": "(dt)",
              "parameters": [
                {
                  "name": "dt",
                  "type": null,
                  "default": null,
                  "description": "integration timestep"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "solve",
              "description": "Solves the implicit update equation using the optimizer of the engine.",
              "docstring_html": "<p>Solves the implicit update equation using the optimizer of the engine.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>f <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array_like</span></dt>\n<dd>evaluation of function</dd>\n<dt>J <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array_like</span></dt>\n<dd>evaluation of jacobian of function</dd>\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>integration timestep</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>err <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>residual error of the fixed point update equation</dd>\n</dl>\n",
              "signature": "(f, J, dt)",
              "parameters": [
                {
                  "name": "f",
                  "type": null,
                  "default": null,
                  "description": "evaluation of function"
                },
                {
                  "name": "J",
                  "type": null,
                  "default": null,
                  "description": "evaluation of jacobian of function"
                },
                {
                  "name": "dt",
                  "type": null,
                  "default": null,
                  "description": "integration timestep"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "step",
              "description": "Performs the explicit timestep for (t+dt) based",
              "docstring_html": "<p>Performs the explicit timestep for (t+dt) based\non the state and input at (t).</p>\n<div class=\"section\" id=\"note\">\n<h4>Note</h4>\n<p>This is only required for the startup solver.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>f <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">numeric, array[numeric]</span></dt>\n<dd>evaluation of rhs function</dd>\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>integration timestep</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>success <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>True if the timestep was successful</dd>\n<dt>error <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>estimated error of the internal error controller</dd>\n<dt>scale <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>estimated timestep rescale factor for error control</dd>\n</dl>\n</div>\n",
              "signature": "(f, dt)",
              "parameters": [
                {
                  "name": "f",
                  "type": null,
                  "default": null,
                  "description": "evaluation of rhs function"
                },
                {
                  "name": "dt",
                  "type": null,
                  "default": null,
                  "description": "integration timestep"
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "n",
              "description": "",
              "type": null,
              "value": "None"
            },
            {
              "name": "K",
              "description": "",
              "type": null,
              "value": "{1: [1.0], 2: [4 / 3, -1 / 3], 3: [18 / 11, -9 / 11, 2 / 11], 4: [48 / 25, -36 / 25, 16 / 25, -3 / 25], 5: [300 / 137, -300 / 137, 200 / 137, -75 / 137, 12 / 137], 6: [360 / 147, -450 / 147, 400 / 147, -225 / 147, 72 / 147, -10 / 147]}"
            },
            {
              "name": "F",
              "description": "",
              "type": null,
              "value": "{1: 1.0, 2: 2 / 3, 3: 6 / 11, 4: 12 / 25, 5: 60 / 137, 6: 60 / 147}"
            },
            {
              "name": "startup",
              "description": "",
              "type": null,
              "value": "DIRK3.cast(self, self.parent)"
            }
          ],
          "parameters": [
            {
              "name": "solver_args",
              "type": null,
              "default": "()",
              "description": ""
            },
            {
              "name": "solver_kwargs",
              "type": null,
              "default": "{}",
              "description": ""
            }
          ]
        },
        {
          "name": "BDF2",
          "description": "Fixed-step 2nd order Backward Differentiation Formula (BDF).",
          "docstring_html": "<p>Fixed-step 2nd order Backward Differentiation Formula (BDF).</p>\n<p>Implicit linear multistep method using the previous two solution points. A-stable,\nmaking it excellent for stiff problems. Uses DIRK3 startup method for the first steps.</p>\n<div class=\"section\" id=\"characteristics\">\n<h4>Characteristics</h4>\n<ul class=\"simple\">\n<li>Order: 2</li>\n<li>Implicit Multistep</li>\n<li>Fixed timestep only</li>\n<li>A-stable</li>\n</ul>\n</div>\n<div class=\"section\" id=\"when-to-use\">\n<h4>When to Use</h4>\n<ul class=\"simple\">\n<li><strong>Stiff problems with fixed timestep</strong>: Classic choice for stiff ODEs</li>\n<li><strong>Long-time integration</strong>: Very stable for extended simulations</li>\n<li><strong>Known timestep</strong>: When timestep is predetermined</li>\n<li><strong>Efficient stiff solver</strong>: Lower overhead than higher-order BDFs</li>\n</ul>\n<p><strong>Recommended</strong> for fixed-timestep stiff problems. For adaptive stepping, use GEAR21\nor ESDIRK methods.</p>\n<p><strong>References</strong></p>\n<table class=\"docutils footnote\" frame=\"void\" id=\"footnote-1\" rules=\"none\">\n<colgroup><col class=\"label\" /><col /></colgroup>\n<tbody valign=\"top\">\n<tr><td class=\"label\">[1]</td><td>Gear, C. W. (1971). &quot;Numerical Initial Value Problems in Ordinary\nDifferential Equations&quot;. Prentice-Hall.</td></tr>\n</tbody>\n</table>\n<table class=\"docutils footnote\" frame=\"void\" id=\"footnote-2\" rules=\"none\">\n<colgroup><col class=\"label\" /><col /></colgroup>\n<tbody valign=\"top\">\n<tr><td class=\"label\">[2]</td><td>Hairer, E., &amp; Wanner, G. (1996). &quot;Solving Ordinary Differential Equations II:\nStiff and Differential-Algebraic Problems&quot;. Springer Series in Computational\nMathematics, Vol. 14.</td></tr>\n</tbody>\n</table>\n</div>\n",
          "bases": [
            "BDF"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "signature": "(solver_args = (), solver_kwargs = {})",
              "parameters": [
                {
                  "name": "solver_args",
                  "type": null,
                  "default": "()",
                  "description": ""
                },
                {
                  "name": "solver_kwargs",
                  "type": null,
                  "default": "{}",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "n",
              "description": "",
              "type": null,
              "value": "2"
            },
            {
              "name": "history",
              "description": "",
              "type": null,
              "value": "deque([], maxlen=2)"
            }
          ],
          "parameters": [
            {
              "name": "solver_args",
              "type": null,
              "default": "()",
              "description": ""
            },
            {
              "name": "solver_kwargs",
              "type": null,
              "default": "{}",
              "description": ""
            }
          ]
        },
        {
          "name": "BDF3",
          "description": "Fixed-step 3rd order Backward Differentiation Formula (BDF).",
          "docstring_html": "<p>Fixed-step 3rd order Backward Differentiation Formula (BDF).</p>\n<p>Implicit linear multistep method using the previous three solution points. A(alpha)-stable\nwith <math xmlns=\"http://www.w3.org/1998/Math/MathML\">\n  <mi>α</mi>\n  <mo>≈</mo>\n  <msup>\n    <mn>86</mn>\n    <mo>∘</mo>\n  </msup>\n</math>, providing excellent stability for stiff problems.\nUses DIRK3 startup method for initial steps.</p>\n<div class=\"section\" id=\"characteristics\">\n<h4>Characteristics</h4>\n<ul class=\"simple\">\n<li>Order: 3</li>\n<li>Implicit Multistep</li>\n<li>Fixed timestep only</li>\n<li>A(alpha)-stable (<math xmlns=\"http://www.w3.org/1998/Math/MathML\">\n  <mi>α</mi>\n  <mo>≈</mo>\n  <msup>\n    <mn>86</mn>\n    <mo>∘</mo>\n  </msup>\n</math>)</li>\n</ul>\n</div>\n<div class=\"section\" id=\"when-to-use\">\n<h4>When to Use</h4>\n<ul class=\"simple\">\n<li><strong>Stiff problems with higher accuracy</strong>: 3rd order for better accuracy than BDF2</li>\n<li><strong>Fixed-timestep applications</strong>: When timestep is predetermined</li>\n<li><strong>Good stability/accuracy balance</strong>: Better accuracy with still-excellent stability</li>\n<li><strong>Chemical kinetics</strong>: Common in reaction-diffusion problems</li>\n</ul>\n<p><strong>Trade-off</strong>: Slightly less stable than BDF2, but more accurate. For adaptive stepping,\nuse GEAR32 or ESDIRK43.</p>\n<p><strong>References</strong></p>\n<table class=\"docutils footnote\" frame=\"void\" id=\"footnote-1\" rules=\"none\">\n<colgroup><col class=\"label\" /><col /></colgroup>\n<tbody valign=\"top\">\n<tr><td class=\"label\">[1]</td><td>Gear, C. W. (1971). &quot;Numerical Initial Value Problems in Ordinary\nDifferential Equations&quot;. Prentice-Hall.</td></tr>\n</tbody>\n</table>\n<table class=\"docutils footnote\" frame=\"void\" id=\"footnote-2\" rules=\"none\">\n<colgroup><col class=\"label\" /><col /></colgroup>\n<tbody valign=\"top\">\n<tr><td class=\"label\">[2]</td><td>Hairer, E., &amp; Wanner, G. (1996). &quot;Solving Ordinary Differential Equations II:\nStiff and Differential-Algebraic Problems&quot;. Springer Series in Computational\nMathematics, Vol. 14.</td></tr>\n</tbody>\n</table>\n</div>\n",
          "bases": [
            "BDF"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "signature": "(solver_args = (), solver_kwargs = {})",
              "parameters": [
                {
                  "name": "solver_args",
                  "type": null,
                  "default": "()",
                  "description": ""
                },
                {
                  "name": "solver_kwargs",
                  "type": null,
                  "default": "{}",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "n",
              "description": "",
              "type": null,
              "value": "3"
            },
            {
              "name": "history",
              "description": "",
              "type": null,
              "value": "deque([], maxlen=3)"
            }
          ],
          "parameters": [
            {
              "name": "solver_args",
              "type": null,
              "default": "()",
              "description": ""
            },
            {
              "name": "solver_kwargs",
              "type": null,
              "default": "{}",
              "description": ""
            }
          ]
        },
        {
          "name": "BDF4",
          "description": "Fixed-step 4th order Backward Differentiation Formula (BDF).",
          "docstring_html": "<p>Fixed-step 4th order Backward Differentiation Formula (BDF).</p>\n<p>Implicit linear multistep method using the previous four solution points. A(alpha)-stable\nwith <math xmlns=\"http://www.w3.org/1998/Math/MathML\">\n  <mi>α</mi>\n  <mo>≈</mo>\n  <msup>\n    <mn>73</mn>\n    <mo>∘</mo>\n  </msup>\n</math>. Good for stiff problems requiring moderate-to-high\naccuracy. Uses DIRK3 startup method for initial steps.</p>\n<div class=\"section\" id=\"characteristics\">\n<h4>Characteristics</h4>\n<ul class=\"simple\">\n<li>Order: 4</li>\n<li>Implicit Multistep</li>\n<li>Fixed timestep only</li>\n<li>A(alpha)-stable (<math xmlns=\"http://www.w3.org/1998/Math/MathML\">\n  <mi>α</mi>\n  <mo>≈</mo>\n  <msup>\n    <mn>73</mn>\n    <mo>∘</mo>\n  </msup>\n</math>)</li>\n</ul>\n</div>\n<div class=\"section\" id=\"when-to-use\">\n<h4>When to Use</h4>\n<ul class=\"simple\">\n<li><strong>Moderate-to-high accuracy on stiff problems</strong>: 4th order with good stability</li>\n<li><strong>Fixed timestep</strong>: When timestep is predetermined</li>\n<li><strong>Accurate stiff solver</strong>: Higher accuracy than BDF3</li>\n<li><strong>Scientific computing</strong>: Common in engineering simulations</li>\n</ul>\n<p><strong>Note</strong>: Stability angle is smaller than BDF3. For very stiff problems, BDF2 or BDF3\nmay be more robust. For adaptive stepping, use GEAR43 or ESDIRK43.</p>\n<p><strong>References</strong></p>\n<table class=\"docutils footnote\" frame=\"void\" id=\"footnote-1\" rules=\"none\">\n<colgroup><col class=\"label\" /><col /></colgroup>\n<tbody valign=\"top\">\n<tr><td class=\"label\">[1]</td><td>Gear, C. W. (1971). &quot;Numerical Initial Value Problems in Ordinary\nDifferential Equations&quot;. Prentice-Hall.</td></tr>\n</tbody>\n</table>\n<table class=\"docutils footnote\" frame=\"void\" id=\"footnote-2\" rules=\"none\">\n<colgroup><col class=\"label\" /><col /></colgroup>\n<tbody valign=\"top\">\n<tr><td class=\"label\">[2]</td><td>Hairer, E., &amp; Wanner, G. (1996). &quot;Solving Ordinary Differential Equations II:\nStiff and Differential-Algebraic Problems&quot;. Springer Series in Computational\nMathematics, Vol. 14.</td></tr>\n</tbody>\n</table>\n</div>\n",
          "bases": [
            "BDF"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "signature": "(solver_args = (), solver_kwargs = {})",
              "parameters": [
                {
                  "name": "solver_args",
                  "type": null,
                  "default": "()",
                  "description": ""
                },
                {
                  "name": "solver_kwargs",
                  "type": null,
                  "default": "{}",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "n",
              "description": "",
              "type": null,
              "value": "4"
            },
            {
              "name": "history",
              "description": "",
              "type": null,
              "value": "deque([], maxlen=4)"
            }
          ],
          "parameters": [
            {
              "name": "solver_args",
              "type": null,
              "default": "()",
              "description": ""
            },
            {
              "name": "solver_kwargs",
              "type": null,
              "default": "{}",
              "description": ""
            }
          ]
        },
        {
          "name": "BDF5",
          "description": "Fixed-step 5th order Backward Differentiation Formula (BDF).",
          "docstring_html": "<p>Fixed-step 5th order Backward Differentiation Formula (BDF).</p>\n<p>Implicit linear multistep method using the previous five solution points. A(alpha)-stable\nwith <math xmlns=\"http://www.w3.org/1998/Math/MathML\">\n  <mi>α</mi>\n  <mo>≈</mo>\n  <msup>\n    <mn>51</mn>\n    <mo>∘</mo>\n  </msup>\n</math>. Suitable for stiff problems requiring high accuracy,\nbut with reduced stability angle. Uses DIRK3 startup method for initial steps.</p>\n<div class=\"section\" id=\"characteristics\">\n<h4>Characteristics</h4>\n<ul class=\"simple\">\n<li>Order: 5</li>\n<li>Implicit Multistep</li>\n<li>Fixed timestep only</li>\n<li>A(alpha)-stable (<math xmlns=\"http://www.w3.org/1998/Math/MathML\">\n  <mi>α</mi>\n  <mo>≈</mo>\n  <msup>\n    <mn>51</mn>\n    <mo>∘</mo>\n  </msup>\n</math>)</li>\n</ul>\n</div>\n<div class=\"section\" id=\"when-to-use\">\n<h4>When to Use</h4>\n<ul class=\"simple\">\n<li><strong>High accuracy on mildly stiff problems</strong>: 5th order when stability angle is sufficient</li>\n<li><strong>Fixed timestep applications</strong>: When timestep is predetermined</li>\n<li><strong>Smooth stiff problems</strong>: Problems without extreme stiffness</li>\n<li><strong>High-precision requirements</strong>: Better accuracy than BDF4</li>\n</ul>\n<p><strong>Warning</strong>: Reduced stability compared to lower-order BDFs. For very stiff problems,\nuse BDF2 or BDF3. For adaptive stepping, use GEAR54 or ESDIRK54.</p>\n<p><strong>References</strong></p>\n<table class=\"docutils footnote\" frame=\"void\" id=\"footnote-1\" rules=\"none\">\n<colgroup><col class=\"label\" /><col /></colgroup>\n<tbody valign=\"top\">\n<tr><td class=\"label\">[1]</td><td>Gear, C. W. (1971). &quot;Numerical Initial Value Problems in Ordinary\nDifferential Equations&quot;. Prentice-Hall.</td></tr>\n</tbody>\n</table>\n<table class=\"docutils footnote\" frame=\"void\" id=\"footnote-2\" rules=\"none\">\n<colgroup><col class=\"label\" /><col /></colgroup>\n<tbody valign=\"top\">\n<tr><td class=\"label\">[2]</td><td>Hairer, E., &amp; Wanner, G. (1996). &quot;Solving Ordinary Differential Equations II:\nStiff and Differential-Algebraic Problems&quot;. Springer Series in Computational\nMathematics, Vol. 14.</td></tr>\n</tbody>\n</table>\n</div>\n",
          "bases": [
            "BDF"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "signature": "(solver_args = (), solver_kwargs = {})",
              "parameters": [
                {
                  "name": "solver_args",
                  "type": null,
                  "default": "()",
                  "description": ""
                },
                {
                  "name": "solver_kwargs",
                  "type": null,
                  "default": "{}",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "n",
              "description": "",
              "type": null,
              "value": "5"
            },
            {
              "name": "history",
              "description": "",
              "type": null,
              "value": "deque([], maxlen=5)"
            }
          ],
          "parameters": [
            {
              "name": "solver_args",
              "type": null,
              "default": "()",
              "description": ""
            },
            {
              "name": "solver_kwargs",
              "type": null,
              "default": "{}",
              "description": ""
            }
          ]
        },
        {
          "name": "BDF6",
          "description": "Fixed-step 6th order Backward Differentiation Formula (BDF).",
          "docstring_html": "<p>Fixed-step 6th order Backward Differentiation Formula (BDF).</p>\n<p>Implicit linear multistep method using the previous six solution points. Not A-stable;\nstability region does not contain the entire left half-plane (stability angle only\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\">\n  <mo>≈</mo>\n  <msup>\n    <mn>18</mn>\n    <mo>∘</mo>\n  </msup>\n</math>), severely limiting its use for stiff problems. Uses DIRK3\nstartup method for initial steps.</p>\n<div class=\"section\" id=\"characteristics\">\n<h4>Characteristics</h4>\n<ul class=\"simple\">\n<li>Order: 6</li>\n<li>Implicit Multistep</li>\n<li>Fixed timestep only</li>\n<li>Not A-stable (stability angle approx <math xmlns=\"http://www.w3.org/1998/Math/MathML\">\n  <msup>\n    <mn>18</mn>\n    <mo>∘</mo>\n  </msup>\n</math>)</li>\n</ul>\n</div>\n<div class=\"section\" id=\"when-to-use\">\n<h4>When to Use</h4>\n<ul class=\"simple\">\n<li><strong>Very smooth, mildly stiff problems</strong>: Only when stiffness is minimal</li>\n<li><strong>High accuracy priority</strong>: When 6th order accuracy justifies poor stability</li>\n<li><strong>Specialized applications</strong>: Rarely used in practice</li>\n</ul>\n<p><strong>Warning</strong>: Very limited stability. Generally not recommended for stiff problems.\nFor most applications requiring 6th order accuracy, use explicit methods like RKV65\non non-stiff problems, or lower-order BDFs with smaller timesteps on stiff problems.</p>\n<p><strong>References</strong></p>\n<table class=\"docutils footnote\" frame=\"void\" id=\"footnote-1\" rules=\"none\">\n<colgroup><col class=\"label\" /><col /></colgroup>\n<tbody valign=\"top\">\n<tr><td class=\"label\">[1]</td><td>Gear, C. W. (1971). &quot;Numerical Initial Value Problems in Ordinary\nDifferential Equations&quot;. Prentice-Hall.</td></tr>\n</tbody>\n</table>\n<table class=\"docutils footnote\" frame=\"void\" id=\"footnote-2\" rules=\"none\">\n<colgroup><col class=\"label\" /><col /></colgroup>\n<tbody valign=\"top\">\n<tr><td class=\"label\">[2]</td><td>Hairer, E., &amp; Wanner, G. (1996). &quot;Solving Ordinary Differential Equations II:\nStiff and Differential-Algebraic Problems&quot;. Springer Series in Computational\nMathematics, Vol. 14.</td></tr>\n</tbody>\n</table>\n<table class=\"docutils footnote\" frame=\"void\" id=\"footnote-3\" rules=\"none\">\n<colgroup><col class=\"label\" /><col /></colgroup>\n<tbody valign=\"top\">\n<tr><td class=\"label\">[3]</td><td>Curtiss, C. F., &amp; Hirschfelder, J. O. (1952). &quot;Integration of stiff equations&quot;.\nProceedings of the National Academy of Sciences, 38(3), 235-243.</td></tr>\n</tbody>\n</table>\n</div>\n",
          "bases": [
            "BDF"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "signature": "(solver_args = (), solver_kwargs = {})",
              "parameters": [
                {
                  "name": "solver_args",
                  "type": null,
                  "default": "()",
                  "description": ""
                },
                {
                  "name": "solver_kwargs",
                  "type": null,
                  "default": "{}",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "n",
              "description": "",
              "type": null,
              "value": "6"
            },
            {
              "name": "history",
              "description": "",
              "type": null,
              "value": "deque([], maxlen=6)"
            }
          ],
          "parameters": [
            {
              "name": "solver_args",
              "type": null,
              "default": "()",
              "description": ""
            },
            {
              "name": "solver_kwargs",
              "type": null,
              "default": "{}",
              "description": ""
            }
          ]
        },
        {
          "name": "ESDIRK32",
          "description": "Four-stage, 3rd order Embedded Singly Diagonally Implicit Runge-Kutta (ESDIRK) method.",
          "docstring_html": "<p>Four-stage, 3rd order Embedded Singly Diagonally Implicit Runge-Kutta (ESDIRK) method.</p>\n<p>Features an embedded 2nd order method for adaptive step size control. The first stage\nis explicit, making the method suitable for problems with explicit first stages. Designed\nto be applicable to index-2 Differential Algebraic Equations (DAEs).</p>\n<div class=\"section\" id=\"characteristics\">\n<h4>Characteristics</h4>\n<ul class=\"simple\">\n<li>Order: 3</li>\n<li>Embedded Order: 2</li>\n<li>Stages: 4 (1 Explicit, 3 Implicit)</li>\n<li>Implicit (ESDIRK)</li>\n<li>Adaptive timestep</li>\n<li>A-stable</li>\n</ul>\n</div>\n<div class=\"section\" id=\"when-to-use\">\n<h4>When to Use</h4>\n<ul class=\"simple\">\n<li><strong>Moderately stiff problems with adaptivity</strong>: Good for stiff ODEs needing timestep control</li>\n<li><strong>Differential-algebraic equations</strong>: Suitable for DAEs of index up to 2</li>\n<li><strong>Entry-level adaptive implicit</strong>: Lower-order adaptive implicit method</li>\n<li><strong>Testing stiffness</strong>: Explore if a problem requires implicit methods</li>\n</ul>\n<p><strong>Trade-off</strong>: Lower accuracy than ESDIRK43 or ESDIRK54, but computationally cheaper.\nFor higher accuracy, use ESDIRK54.</p>\n<p><strong>References</strong></p>\n<table class=\"docutils footnote\" frame=\"void\" id=\"footnote-1\" rules=\"none\">\n<colgroup><col class=\"label\" /><col /></colgroup>\n<tbody valign=\"top\">\n<tr><td class=\"label\">[1]</td><td>Williams, D. M., Houzeaux, G., Aubry, R., Vázquez, M., &amp; Calmet, H. (2013).\n&quot;Efficiency of a matrix-free linearly implicit time integration strategy&quot;.\nComputers &amp; Fluids, 83, 77-89.</td></tr>\n</tbody>\n</table>\n<table class=\"docutils footnote\" frame=\"void\" id=\"footnote-2\" rules=\"none\">\n<colgroup><col class=\"label\" /><col /></colgroup>\n<tbody valign=\"top\">\n<tr><td class=\"label\">[2]</td><td>Kennedy, C. A., &amp; Carpenter, M. H. (2016). &quot;Diagonally implicit Runge-Kutta\nmethods for ordinary differential equations. A review&quot;. NASA Technical Report.</td></tr>\n</tbody>\n</table>\n<table class=\"docutils footnote\" frame=\"void\" id=\"footnote-3\" rules=\"none\">\n<colgroup><col class=\"label\" /><col /></colgroup>\n<tbody valign=\"top\">\n<tr><td class=\"label\">[3]</td><td>Hairer, E., &amp; Wanner, G. (1996). &quot;Solving Ordinary Differential Equations II:\nStiff and Differential-Algebraic Problems&quot;. Springer Series in Computational\nMathematics, Vol. 14.</td></tr>\n</tbody>\n</table>\n</div>\n",
          "bases": [
            "DiagonallyImplicitRungeKutta"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "signature": "(solver_args = (), solver_kwargs = {})",
              "parameters": [
                {
                  "name": "solver_args",
                  "type": null,
                  "default": "()",
                  "description": ""
                },
                {
                  "name": "solver_kwargs",
                  "type": null,
                  "default": "{}",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "s",
              "description": "",
              "type": null,
              "value": "4"
            },
            {
              "name": "n",
              "description": "",
              "type": null,
              "value": "3"
            },
            {
              "name": "m",
              "description": "",
              "type": null,
              "value": "2"
            },
            {
              "name": "is_adaptive",
              "description": "",
              "type": null,
              "value": "True"
            },
            {
              "name": "eval_stages",
              "description": "",
              "type": null,
              "value": "[0.0, 1.0, 3 / 2, 1.0]"
            },
            {
              "name": "BT",
              "description": "",
              "type": null,
              "value": "{0: None, 1: [1 / 2, 1 / 2], 2: [5 / 8, 3 / 8, 1 / 2], 3: [7 / 18, 1 / 3, -2 / 9, 1 / 2]}"
            },
            {
              "name": "TR",
              "description": "",
              "type": null,
              "value": "[-1 / 9, -1 / 6, -2 / 9, 1 / 2]"
            }
          ],
          "parameters": [
            {
              "name": "solver_args",
              "type": null,
              "default": "()",
              "description": ""
            },
            {
              "name": "solver_kwargs",
              "type": null,
              "default": "{}",
              "description": ""
            }
          ]
        },
        {
          "name": "GEAR",
          "description": "Base class for GEAR-type integrators that defines the universal methods.",
          "docstring_html": "<p>Base class for GEAR-type integrators that defines the universal methods.</p>\n<p>Numerical integration method based on BDFs (linear multistep methods).\nUses n-th order BDF for timestepping and (n-1)-th order BDF coefficients\nto estimate a lower ordersolutuin for error control.</p>\n<p>The adaptive timestep BDF coefficients are dynamically computed at the\nbeginning of each timestep from the buffered previous timsteps.</p>\n<p><strong>Notes</strong></p>\n<p>Not to be used directly!</p>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>x <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">numeric, array[numeric]</span></dt>\n<dd>internal 'working' state</dd>\n<dt>n <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>order of integration scheme</dd>\n<dt>s <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>number of internal intermediate stages</dd>\n<dt>stage <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>counter for current intermediate stage</dd>\n<dt>eval_stages <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">list[float]</span></dt>\n<dd>rations for evaluation times of intermediate stages</dd>\n<dt>opt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">NewtonAnderson, Anderson, etc.</span></dt>\n<dd>optimizer instance to solve the implicit update equation</dd>\n<dt>K <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">dict[int: list[float]]</span></dt>\n<dd>bdf coefficients for the state buffer for each order</dd>\n<dt>F <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">dict[int: float]</span></dt>\n<dd>bdf coefficients for the function 'func' for each order</dd>\n<dt>history <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">deque[numeric]</span></dt>\n<dd>internal history of past results</dd>\n<dt>history_dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">deque[numeric]</span></dt>\n<dd>internal history of past timesteps</dd>\n<dt>startup <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">Solver</span></dt>\n<dd>internal solver instance for startup (building history)\nof multistep methods (using 'ESDIRK32' for 'GEAR' methods)</dd>\n</dl>\n",
          "bases": [
            "ImplicitSolver"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "signature": "(solver_args = (), solver_kwargs = {})",
              "parameters": [
                {
                  "name": "solver_args",
                  "type": null,
                  "default": "()",
                  "description": ""
                },
                {
                  "name": "solver_kwargs",
                  "type": null,
                  "default": "{}",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "cast",
              "description": "cast to this solver needs special handling of startup method",
              "docstring_html": "<p>cast to this solver needs special handling of startup method</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>other <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">Solver</span></dt>\n<dd>solver instance to cast new instance of this class from</dd>\n<dt>parent <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">None | Solver</span></dt>\n<dd>solver instance to use as parent</dd>\n<dt>solver_kwargs <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">dict</span></dt>\n<dd>other args for the solver</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>engine <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">GEAR</span></dt>\n<dd>instance of <cite>GEAR</cite> solver with params and state from <cite>other</cite></dd>\n</dl>\n",
              "signature": "(cls, other, parent, solver_kwargs = {})",
              "parameters": [
                {
                  "name": "cls",
                  "type": null,
                  "default": null,
                  "description": ""
                },
                {
                  "name": "other",
                  "type": null,
                  "default": null,
                  "description": "solver instance to cast new instance of this class from"
                },
                {
                  "name": "parent",
                  "type": null,
                  "default": null,
                  "description": "solver instance to use as parent"
                },
                {
                  "name": "solver_kwargs",
                  "type": null,
                  "default": "{}",
                  "description": "other args for the solver"
                }
              ],
              "returns": null,
              "method_type": "classmethod"
            },
            {
              "name": "create",
              "description": "Create a new GEAR solver, properly initializing the startup solver.",
              "docstring_html": "<p>Create a new GEAR solver, properly initializing the startup solver.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>initial_value <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float, array</span></dt>\n<dd>initial condition / integration constant</dd>\n<dt>parent <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">None | Solver</span></dt>\n<dd>parent solver instance for stage synchronization</dd>\n<dt>from_engine <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">None | Solver</span></dt>\n<dd>existing solver to inherit state and settings from</dd>\n<dt>solver_kwargs <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">dict</span></dt>\n<dd>additional args for the solver</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>engine <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">GEAR</span></dt>\n<dd>new GEAR solver instance</dd>\n</dl>\n",
              "signature": "(cls, initial_value, parent = None, from_engine = None, solver_kwargs = {})",
              "parameters": [
                {
                  "name": "cls",
                  "type": null,
                  "default": null,
                  "description": ""
                },
                {
                  "name": "initial_value",
                  "type": null,
                  "default": null,
                  "description": "initial condition / integration constant"
                },
                {
                  "name": "parent",
                  "type": null,
                  "default": "None",
                  "description": "parent solver instance for stage synchronization"
                },
                {
                  "name": "from_engine",
                  "type": null,
                  "default": "None",
                  "description": "existing solver to inherit state and settings from"
                },
                {
                  "name": "solver_kwargs",
                  "type": null,
                  "default": "{}",
                  "description": "additional args for the solver"
                }
              ],
              "returns": null,
              "method_type": "classmethod"
            },
            {
              "name": "stages",
              "description": "Generator that yields the intermediate evaluation",
              "docstring_html": "<p>Generator that yields the intermediate evaluation\ntime during the timestep 't + ratio * dt'.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time</dd>\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>integration timestep</dd>\n</dl>\n",
              "signature": "(t, dt)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time"
                },
                {
                  "name": "dt",
                  "type": null,
                  "default": null,
                  "description": "integration timestep"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "reset",
              "description": "\"Resets integration engine to initial state.",
              "docstring_html": "<p>&quot;Resets integration engine to initial state.</p>\n",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "buffer",
              "description": "Buffer the state and timestep. Dynamically precompute",
              "docstring_html": "<p>Buffer the state and timestep. Dynamically precompute\nthe variable timestep BDF coefficients on the fly for the\ncurrent timestep.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>integration timestep</dd>\n</dl>\n",
              "signature": "(dt)",
              "parameters": [
                {
                  "name": "dt",
                  "type": null,
                  "default": null,
                  "description": "integration timestep"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "revert",
              "description": "Revert integration engine to previous timestep, this is only",
              "docstring_html": "<p>Revert integration engine to previous timestep, this is only\nrelevant for adaptive methods where the simulation timestep 'dt'\nis rescaled and the engine step is recomputed with the smaller\ntimestep.</p>\n",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "error_controller",
              "description": "Compute scaling factor for adaptive timestep based on absolute and",
              "docstring_html": "<p>Compute scaling factor for adaptive timestep based on absolute and\nrelative tolerances for local truncation error.</p>\n<p>Checks if the error tolerance is achieved and returns a success metric.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>tr <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array[float]</span></dt>\n<dd>truncation error estimate</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>success <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>True if the timestep was successful</dd>\n<dt>error <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>estimated error of the internal error controller</dd>\n<dt>scale <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>estimated timestep rescale factor for error control</dd>\n</dl>\n",
              "signature": "(tr)",
              "parameters": [
                {
                  "name": "tr",
                  "type": null,
                  "default": null,
                  "description": "truncation error estimate"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "solve",
              "description": "Solves the implicit update equation using the optimizer of the engine.",
              "docstring_html": "<p>Solves the implicit update equation using the optimizer of the engine.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>f <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array_like</span></dt>\n<dd>evaluation of function</dd>\n<dt>J <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array_like</span></dt>\n<dd>evaluation of jacobian of function</dd>\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>integration timestep</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>err <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>residual error of the fixed point update equation</dd>\n</dl>\n",
              "signature": "(f, J, dt)",
              "parameters": [
                {
                  "name": "f",
                  "type": null,
                  "default": null,
                  "description": "evaluation of function"
                },
                {
                  "name": "J",
                  "type": null,
                  "default": null,
                  "description": "evaluation of jacobian of function"
                },
                {
                  "name": "dt",
                  "type": null,
                  "default": null,
                  "description": "integration timestep"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "step",
              "description": "Finalizes the timestep by resetting the solver for the implicit",
              "docstring_html": "<p>Finalizes the timestep by resetting the solver for the implicit\nupdate equation and computing the lower order estimate of the\nsolution for error control.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>f <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array_like</span></dt>\n<dd>evaluation of function</dd>\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>integration timestep</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>success <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>True if the timestep was successful</dd>\n<dt>error <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>estimated error of the internal error controller</dd>\n<dt>scale <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>estimated timestep rescale factor for error control</dd>\n</dl>\n",
              "signature": "(f, dt)",
              "parameters": [
                {
                  "name": "f",
                  "type": null,
                  "default": null,
                  "description": "evaluation of function"
                },
                {
                  "name": "dt",
                  "type": null,
                  "default": null,
                  "description": "integration timestep"
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "n",
              "description": "",
              "type": null,
              "value": "None"
            },
            {
              "name": "m",
              "description": "",
              "type": null,
              "value": "None"
            },
            {
              "name": "beta",
              "description": "",
              "type": null,
              "value": "SOL_BETA"
            },
            {
              "name": "history_dt",
              "description": "",
              "type": null,
              "value": "deque([], maxlen=1)"
            },
            {
              "name": "is_adaptive",
              "description": "",
              "type": null,
              "value": "True"
            },
            {
              "name": "startup",
              "description": "",
              "type": null,
              "value": "ESDIRK32.cast(self, self.parent)"
            }
          ],
          "parameters": [
            {
              "name": "solver_args",
              "type": null,
              "default": "()",
              "description": ""
            },
            {
              "name": "solver_kwargs",
              "type": null,
              "default": "{}",
              "description": ""
            }
          ]
        },
        {
          "name": "GEAR21",
          "description": "Adaptive-step GEAR integrator using 2nd order BDF with variable timesteps.",
          "docstring_html": "<p>Adaptive-step GEAR integrator using 2nd order BDF with variable timesteps.</p>\n<p>Uses 2nd order BDF for timestepping and 1st order BDF (Backward Euler) for truncation\nerror estimation. Dynamically computes BDF coefficients for variable timesteps. Excellent\nfor moderately stiff problems where adaptive timestepping is beneficial. Uses ESDIRK32\nfor startup.</p>\n<div class=\"section\" id=\"characteristics\">\n<h4>Characteristics</h4>\n<ul class=\"simple\">\n<li>Stepping Order: 2 (max)</li>\n<li>Error Estimation Order: 1</li>\n<li>Implicit Variable-Step Multistep</li>\n<li>Adaptive timestep</li>\n<li>A-stable (based on BDF2)</li>\n</ul>\n</div>\n<div class=\"section\" id=\"when-to-use\">\n<h4>When to Use</h4>\n<ul class=\"simple\">\n<li><strong>Stiff problems with adaptive stepping</strong>: Classic adaptive stiff solver</li>\n<li><strong>Variable dynamics</strong>: When solution changes character over time</li>\n<li><strong>Efficient stiff integration</strong>: Good balance of stability and accuracy</li>\n<li><strong>Long-time simulations</strong>: Stable for extended integrations</li>\n</ul>\n</div>\n<div class=\"section\" id=\"note\">\n<h4>Note</h4>\n<p>Good choice as a default adaptive stiff solver. For higher accuracy, use GEAR32 or\nESDIRK43. For fixed timestep, use BDF2.</p>\n<p><strong>References</strong></p>\n<table class=\"docutils footnote\" frame=\"void\" id=\"footnote-1\" rules=\"none\">\n<colgroup><col class=\"label\" /><col /></colgroup>\n<tbody valign=\"top\">\n<tr><td class=\"label\">[1]</td><td>Gear, C. W. (1971). &quot;Numerical Initial Value Problems in Ordinary\nDifferential Equations&quot;. Prentice-Hall.</td></tr>\n</tbody>\n</table>\n<table class=\"docutils footnote\" frame=\"void\" id=\"footnote-2\" rules=\"none\">\n<colgroup><col class=\"label\" /><col /></colgroup>\n<tbody valign=\"top\">\n<tr><td class=\"label\">[2]</td><td>Hairer, E., &amp; Wanner, G. (1996). &quot;Solving Ordinary Differential Equations II:\nStiff and Differential-Algebraic Problems&quot;. Springer Series in Computational\nMathematics, Vol. 14.</td></tr>\n</tbody>\n</table>\n</div>\n",
          "bases": [
            "GEAR"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "signature": "(solver_args = (), solver_kwargs = {})",
              "parameters": [
                {
                  "name": "solver_args",
                  "type": null,
                  "default": "()",
                  "description": ""
                },
                {
                  "name": "solver_kwargs",
                  "type": null,
                  "default": "{}",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "n",
              "description": "",
              "type": null,
              "value": "2"
            },
            {
              "name": "m",
              "description": "",
              "type": null,
              "value": "1"
            },
            {
              "name": "history",
              "description": "",
              "type": null,
              "value": "deque([], maxlen=2)"
            },
            {
              "name": "history_dt",
              "description": "",
              "type": null,
              "value": "deque([], maxlen=2)"
            }
          ],
          "parameters": [
            {
              "name": "solver_args",
              "type": null,
              "default": "()",
              "description": ""
            },
            {
              "name": "solver_kwargs",
              "type": null,
              "default": "{}",
              "description": ""
            }
          ]
        },
        {
          "name": "GEAR32",
          "description": "Adaptive-step GEAR integrator using 3rd order BDF with variable timesteps.",
          "docstring_html": "<p>Adaptive-step GEAR integrator using 3rd order BDF with variable timesteps.</p>\n<p>Uses 3rd order BDF for timestepping and 2nd order BDF for truncation error estimation.\nDynamically computes BDF coefficients for variable timesteps. Suitable for stiff problems\nrequiring higher accuracy than GEAR21. Uses ESDIRK32 for startup.</p>\n<div class=\"section\" id=\"characteristics\">\n<h4>Characteristics</h4>\n<ul class=\"simple\">\n<li>Stepping Order: 3 (max)</li>\n<li>Error Estimation Order: 2</li>\n<li>Implicit Variable-Step Multistep</li>\n<li>Adaptive timestep</li>\n<li>A(alpha)-stable (based on BDF3)</li>\n</ul>\n</div>\n<div class=\"section\" id=\"when-to-use\">\n<h4>When to Use</h4>\n<ul class=\"simple\">\n<li><strong>Higher accuracy stiff problems</strong>: 3rd order with adaptive stepping</li>\n<li><strong>Good stability/accuracy balance</strong>: Better accuracy with excellent stability</li>\n<li><strong>Chemical reactions</strong>: Common in kinetics problems</li>\n<li><strong>Engineering simulations</strong>: Widely used in practice</li>\n</ul>\n</div>\n<div class=\"section\" id=\"note\">\n<h4>Note</h4>\n<p>Slightly less stable than GEAR21, but more accurate. For very high accuracy,\nuse GEAR43 or ESDIRK54.</p>\n<p><strong>References</strong></p>\n<table class=\"docutils footnote\" frame=\"void\" id=\"footnote-1\" rules=\"none\">\n<colgroup><col class=\"label\" /><col /></colgroup>\n<tbody valign=\"top\">\n<tr><td class=\"label\">[1]</td><td>Gear, C. W. (1971). &quot;Numerical Initial Value Problems in Ordinary\nDifferential Equations&quot;. Prentice-Hall.</td></tr>\n</tbody>\n</table>\n<table class=\"docutils footnote\" frame=\"void\" id=\"footnote-2\" rules=\"none\">\n<colgroup><col class=\"label\" /><col /></colgroup>\n<tbody valign=\"top\">\n<tr><td class=\"label\">[2]</td><td>Hairer, E., &amp; Wanner, G. (1996). &quot;Solving Ordinary Differential Equations II:\nStiff and Differential-Algebraic Problems&quot;. Springer Series in Computational\nMathematics, Vol. 14.</td></tr>\n</tbody>\n</table>\n</div>\n",
          "bases": [
            "GEAR"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "signature": "(solver_args = (), solver_kwargs = {})",
              "parameters": [
                {
                  "name": "solver_args",
                  "type": null,
                  "default": "()",
                  "description": ""
                },
                {
                  "name": "solver_kwargs",
                  "type": null,
                  "default": "{}",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "n",
              "description": "",
              "type": null,
              "value": "3"
            },
            {
              "name": "m",
              "description": "",
              "type": null,
              "value": "2"
            },
            {
              "name": "history",
              "description": "",
              "type": null,
              "value": "deque([], maxlen=3)"
            },
            {
              "name": "history_dt",
              "description": "",
              "type": null,
              "value": "deque([], maxlen=3)"
            }
          ],
          "parameters": [
            {
              "name": "solver_args",
              "type": null,
              "default": "()",
              "description": ""
            },
            {
              "name": "solver_kwargs",
              "type": null,
              "default": "{}",
              "description": ""
            }
          ]
        },
        {
          "name": "GEAR43",
          "description": "Adaptive-step GEAR integrator using 4th order BDF with variable timesteps.",
          "docstring_html": "<p>Adaptive-step GEAR integrator using 4th order BDF with variable timesteps.</p>\n<p>Uses 4th order BDF for timestepping and 3rd order BDF for truncation error estimation.\nDynamically computes BDF coefficients for variable timesteps. Suitable for stiff problems\nrequiring good accuracy. Uses ESDIRK32 for startup.</p>\n<div class=\"section\" id=\"characteristics\">\n<h4>Characteristics</h4>\n<ul class=\"simple\">\n<li>Stepping Order: 4 (max)</li>\n<li>Error Estimation Order: 3</li>\n<li>Implicit Variable-Step Multistep</li>\n<li>Adaptive timestep</li>\n<li>A(alpha)-stable (based on BDF4)</li>\n</ul>\n</div>\n<div class=\"section\" id=\"when-to-use\">\n<h4>When to Use</h4>\n<ul class=\"simple\">\n<li><strong>High-accuracy stiff problems</strong>: 4th order with adaptive stepping</li>\n<li><strong>Demanding applications</strong>: When higher accuracy is needed</li>\n<li><strong>Smooth stiff dynamics</strong>: Problems with smooth solutions</li>\n<li><strong>Scientific computing</strong>: Common in research applications</li>\n</ul>\n</div>\n<div class=\"section\" id=\"note\">\n<h4>Note</h4>\n<p>Smaller stability angle than GEAR32. For very stiff problems, GEAR21 or GEAR32\nmay be more robust. For very high accuracy, use GEAR54 or ESDIRK54.</p>\n<p><strong>References</strong></p>\n<table class=\"docutils footnote\" frame=\"void\" id=\"footnote-1\" rules=\"none\">\n<colgroup><col class=\"label\" /><col /></colgroup>\n<tbody valign=\"top\">\n<tr><td class=\"label\">[1]</td><td>Gear, C. W. (1971). &quot;Numerical Initial Value Problems in Ordinary\nDifferential Equations&quot;. Prentice-Hall.</td></tr>\n</tbody>\n</table>\n<table class=\"docutils footnote\" frame=\"void\" id=\"footnote-2\" rules=\"none\">\n<colgroup><col class=\"label\" /><col /></colgroup>\n<tbody valign=\"top\">\n<tr><td class=\"label\">[2]</td><td>Hairer, E., &amp; Wanner, G. (1996). &quot;Solving Ordinary Differential Equations II:\nStiff and Differential-Algebraic Problems&quot;. Springer Series in Computational\nMathematics, Vol. 14.</td></tr>\n</tbody>\n</table>\n</div>\n",
          "bases": [
            "GEAR"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "signature": "(solver_args = (), solver_kwargs = {})",
              "parameters": [
                {
                  "name": "solver_args",
                  "type": null,
                  "default": "()",
                  "description": ""
                },
                {
                  "name": "solver_kwargs",
                  "type": null,
                  "default": "{}",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "n",
              "description": "",
              "type": null,
              "value": "4"
            },
            {
              "name": "m",
              "description": "",
              "type": null,
              "value": "3"
            },
            {
              "name": "history",
              "description": "",
              "type": null,
              "value": "deque([], maxlen=4)"
            },
            {
              "name": "history_dt",
              "description": "",
              "type": null,
              "value": "deque([], maxlen=4)"
            }
          ],
          "parameters": [
            {
              "name": "solver_args",
              "type": null,
              "default": "()",
              "description": ""
            },
            {
              "name": "solver_kwargs",
              "type": null,
              "default": "{}",
              "description": ""
            }
          ]
        },
        {
          "name": "GEAR54",
          "description": "Adaptive-step GEAR integrator using 5th order BDF with variable timesteps.",
          "docstring_html": "<p>Adaptive-step GEAR integrator using 5th order BDF with variable timesteps.</p>\n<p>Uses 5th order BDF for timestepping and 4th order BDF for truncation error estimation.\nDynamically computes BDF coefficients for variable timesteps. Suitable for stiff problems\nrequiring high accuracy, but stability region is smaller than lower-order GEAR methods.\nUses ESDIRK32 for startup.</p>\n<div class=\"section\" id=\"characteristics\">\n<h4>Characteristics</h4>\n<ul class=\"simple\">\n<li>Stepping Order: 5 (max)</li>\n<li>Error Estimation Order: 4</li>\n<li>Implicit Variable-Step Multistep</li>\n<li>Adaptive timestep</li>\n<li>A(alpha)-stable (based on BDF5)</li>\n</ul>\n</div>\n<div class=\"section\" id=\"when-to-use\">\n<h4>When to Use</h4>\n<ul class=\"simple\">\n<li><strong>Very high accuracy on mildly stiff problems</strong>: 5th order when stability angle sufficient</li>\n<li><strong>Smooth stiff problems</strong>: Problems without extreme stiffness</li>\n<li><strong>High-precision requirements</strong>: Better accuracy than GEAR43</li>\n<li><strong>Research applications</strong>: Specialized high-accuracy needs</li>\n</ul>\n</div>\n<div class=\"section\" id=\"warn\">\n<h4>Warn</h4>\n<p>Reduced stability compared to lower-order GEAR methods. For very stiff problems,\nuse GEAR21 or GEAR32. Consider ESDIRK54 as an alternative high-accuracy stiff solver.</p>\n<p><strong>References</strong></p>\n<table class=\"docutils footnote\" frame=\"void\" id=\"footnote-1\" rules=\"none\">\n<colgroup><col class=\"label\" /><col /></colgroup>\n<tbody valign=\"top\">\n<tr><td class=\"label\">[1]</td><td>Gear, C. W. (1971). &quot;Numerical Initial Value Problems in Ordinary\nDifferential Equations&quot;. Prentice-Hall.</td></tr>\n</tbody>\n</table>\n<table class=\"docutils footnote\" frame=\"void\" id=\"footnote-2\" rules=\"none\">\n<colgroup><col class=\"label\" /><col /></colgroup>\n<tbody valign=\"top\">\n<tr><td class=\"label\">[2]</td><td>Hairer, E., &amp; Wanner, G. (1996). &quot;Solving Ordinary Differential Equations II:\nStiff and Differential-Algebraic Problems&quot;. Springer Series in Computational\nMathematics, Vol. 14.</td></tr>\n</tbody>\n</table>\n</div>\n",
          "bases": [
            "GEAR"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "signature": "(solver_args = (), solver_kwargs = {})",
              "parameters": [
                {
                  "name": "solver_args",
                  "type": null,
                  "default": "()",
                  "description": ""
                },
                {
                  "name": "solver_kwargs",
                  "type": null,
                  "default": "{}",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "n",
              "description": "",
              "type": null,
              "value": "5"
            },
            {
              "name": "m",
              "description": "",
              "type": null,
              "value": "4"
            },
            {
              "name": "history",
              "description": "",
              "type": null,
              "value": "deque([], maxlen=5)"
            },
            {
              "name": "history_dt",
              "description": "",
              "type": null,
              "value": "deque([], maxlen=5)"
            }
          ],
          "parameters": [
            {
              "name": "solver_args",
              "type": null,
              "default": "()",
              "description": ""
            },
            {
              "name": "solver_kwargs",
              "type": null,
              "default": "{}",
              "description": ""
            }
          ]
        },
        {
          "name": "GEAR52A",
          "description": "Adaptive-order, adaptive-stepsize GEAR integrator (Variable-Step Variable-Order BDF).",
          "docstring_html": "<p>Adaptive-order, adaptive-stepsize GEAR integrator (Variable-Step Variable-Order BDF).</p>\n<p>This method dynamically adjusts both timestep and BDF order (between 2 and 5) based on\nerror estimates from lower and higher order predictors. Optimizes step size by using\nhigher orders for smooth regions and lower, more stable orders for stiff or rapidly\nchanging regions. Dynamically computes BDF coefficients for variable timesteps and orders.\nUses ESDIRK32 for startup.</p>\n<p>Error estimation compares the current order solution with predictions from\norder n-1 and n+1 formulas to select the optimal order.</p>\n<div class=\"section\" id=\"characteristics\">\n<h4>Characteristics</h4>\n<ul class=\"simple\">\n<li>Stepping Order: Variable (2 to 5)</li>\n<li>Error Estimation Orders: n-1 and n+1 (relative to current n)</li>\n<li>Implicit Variable-Step, Variable-Order Multistep</li>\n<li>Adaptive timestep and order</li>\n<li>Stability varies with the currently selected order (A-stable or A(alpha)-stable)</li>\n</ul>\n</div>\n<div class=\"section\" id=\"when-to-use\">\n<h4>When to Use</h4>\n<ul class=\"simple\">\n<li><strong>Problems with varying character</strong>: Automatically adapts to changing dynamics</li>\n<li><strong>Black-box applications</strong>: Minimal tuning required</li>\n<li><strong>Efficiency priority</strong>: Optimizes order for efficiency</li>\n<li><strong>General-purpose adaptive stiff solver</strong>: Robust default choice</li>\n</ul>\n</div>\n<div class=\"section\" id=\"note\">\n<h4>Note</h4>\n<p>Recommended for problems where the optimal order is unknown. This is similar to\nMATLAB's ode15s. Can be more efficient than fixed-order methods for problems with\nvarying smoothness.</p>\n<p><strong>References</strong></p>\n<table class=\"docutils footnote\" frame=\"void\" id=\"footnote-1\" rules=\"none\">\n<colgroup><col class=\"label\" /><col /></colgroup>\n<tbody valign=\"top\">\n<tr><td class=\"label\">[1]</td><td>Gear, C. W. (1971). &quot;Numerical Initial Value Problems in Ordinary\nDifferential Equations&quot;. Prentice-Hall.</td></tr>\n</tbody>\n</table>\n<table class=\"docutils footnote\" frame=\"void\" id=\"footnote-2\" rules=\"none\">\n<colgroup><col class=\"label\" /><col /></colgroup>\n<tbody valign=\"top\">\n<tr><td class=\"label\">[2]</td><td>Shampine, L. F., &amp; Reichelt, M. W. (1997). &quot;The MATLAB ODE Suite&quot;.\nSIAM Journal on Scientific Computing, 18(1), 1-22.</td></tr>\n</tbody>\n</table>\n<table class=\"docutils footnote\" frame=\"void\" id=\"footnote-3\" rules=\"none\">\n<colgroup><col class=\"label\" /><col /></colgroup>\n<tbody valign=\"top\">\n<tr><td class=\"label\">[3]</td><td>Hairer, E., &amp; Wanner, G. (1996). &quot;Solving Ordinary Differential Equations II:\nStiff and Differential-Algebraic Problems&quot;. Springer Series in Computational\nMathematics, Vol. 14.</td></tr>\n</tbody>\n</table>\n</div>\n",
          "bases": [
            "GEAR"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "signature": "(solver_args = (), solver_kwargs = {})",
              "parameters": [
                {
                  "name": "solver_args",
                  "type": null,
                  "default": "()",
                  "description": ""
                },
                {
                  "name": "solver_kwargs",
                  "type": null,
                  "default": "{}",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "buffer",
              "description": "Buffer the state and timestep. Dynamically precompute",
              "docstring_html": "<p>Buffer the state and timestep. Dynamically precompute\nthe variable timestep BDF coefficients on the fly for the\ncurrent timestep.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>integration timestep</dd>\n</dl>\n",
              "signature": "(dt)",
              "parameters": [
                {
                  "name": "dt",
                  "type": null,
                  "default": null,
                  "description": "integration timestep"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "error_controller",
              "description": "Compute scaling factor for adaptive timestep based on absolute and",
              "docstring_html": "<p>Compute scaling factor for adaptive timestep based on absolute and\nrelative tolerances of the local truncation error estimate obtained from\nesimated lower and higher order solution.</p>\n<p>Checks if the error tolerance is achieved and returns a success metric.</p>\n<p>Adapts the stepping order such that the normalized error is minimized and\nlarger steps can be taken by the integrator.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>tr_m <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array[float]</span></dt>\n<dd>lower order truncation error estimate</dd>\n<dt>tr_p <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array[float]</span></dt>\n<dd>higher order truncation error estimate</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>success <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>True if the timestep was successful</dd>\n<dt>error <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>estimated error of the internal error controller</dd>\n<dt>scale <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>estimated timestep rescale factor for error control</dd>\n</dl>\n",
              "signature": "(tr_m, tr_p)",
              "parameters": [
                {
                  "name": "tr_m",
                  "type": null,
                  "default": null,
                  "description": "lower order truncation error estimate"
                },
                {
                  "name": "tr_p",
                  "type": null,
                  "default": null,
                  "description": "higher order truncation error estimate"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "solve",
              "description": "Solves the implicit update equation using the optimizer of the engine.",
              "docstring_html": "<p>Solves the implicit update equation using the optimizer of the engine.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>f <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array_like</span></dt>\n<dd>evaluation of function</dd>\n<dt>J <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array_like</span></dt>\n<dd>evaluation of jacobian of function</dd>\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>integration timestep</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>err <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>residual error of the fixed point update equation</dd>\n</dl>\n",
              "signature": "(f, J, dt)",
              "parameters": [
                {
                  "name": "f",
                  "type": null,
                  "default": null,
                  "description": "evaluation of function"
                },
                {
                  "name": "J",
                  "type": null,
                  "default": null,
                  "description": "evaluation of jacobian of function"
                },
                {
                  "name": "dt",
                  "type": null,
                  "default": null,
                  "description": "integration timestep"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "step",
              "description": "Finalizes the timestep by resetting the solver for the implicit",
              "docstring_html": "<p>Finalizes the timestep by resetting the solver for the implicit\nupdate equation and computing the lower and higher order estimate\nof the solution.</p>\n<p>Then calls the error controller.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>f <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array_like</span></dt>\n<dd>evaluation of function</dd>\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>integration timestep</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>success <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>True if the timestep was successful</dd>\n<dt>error <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>estimated error of the internal error controller</dd>\n<dt>scale <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>estimated timestep rescale factor for error control</dd>\n</dl>\n",
              "signature": "(f, dt)",
              "parameters": [
                {
                  "name": "f",
                  "type": null,
                  "default": null,
                  "description": "evaluation of function"
                },
                {
                  "name": "dt",
                  "type": null,
                  "default": null,
                  "description": "integration timestep"
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "n",
              "description": "",
              "type": null,
              "value": "2"
            },
            {
              "name": "history",
              "description": "",
              "type": null,
              "value": "deque([], maxlen=6)"
            },
            {
              "name": "history_dt",
              "description": "",
              "type": null,
              "value": "deque([], maxlen=6)"
            }
          ],
          "parameters": [
            {
              "name": "solver_args",
              "type": null,
              "default": "()",
              "description": ""
            },
            {
              "name": "solver_kwargs",
              "type": null,
              "default": "{}",
              "description": ""
            }
          ]
        },
        {
          "name": "DiagonallyImplicitRungeKutta",
          "description": "Base class for diagonally implicit Runge-Kutta (DIRK) integrators",
          "docstring_html": "<p>Base class for diagonally implicit Runge-Kutta (DIRK) integrators\nwhich implements the timestepping at intermediate stages, involving\nthe numerical solution of the implicit update equation and the\nerror control if the coefficients for the local truncation error\nestimate are defined.</p>\n<p>Extensions and checks to also handle explicit first stages (ESDIRK)\nand additional final evaluation coefficients (not stiffly accurate)</p>\n<div class=\"section\" id=\"note\">\n<h4>Note</h4>\n<p>This class is not intended to be used directly!!!</p>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>n <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>order of stepping integration scheme</dd>\n<dt>m <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>order of embedded integration scheme for error control</dd>\n<dt>s <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>numer of RK stages</dd>\n<dt>beta <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>safety factor for error control</dd>\n<dt>Ks <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">dict</span></dt>\n<dd>slopes at RK stages</dd>\n<dt>BT <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">dict[int: None, list[float]], None</span></dt>\n<dd>butcher table</dd>\n<dt>A <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">list[float], None</span></dt>\n<dd>coefficients for final solution evaluation</dd>\n<dt>TR <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">list[float]</span></dt>\n<dd>coefficients for truncation error estimate</dd>\n</dl>\n</div>\n",
          "bases": [
            "ImplicitSolver"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "signature": "(solver_args = (), solver_kwargs = {})",
              "parameters": [
                {
                  "name": "solver_args",
                  "type": null,
                  "default": "()",
                  "description": ""
                },
                {
                  "name": "solver_kwargs",
                  "type": null,
                  "default": "{}",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "error_controller",
              "description": "Compute scaling factor for adaptive timestep based on",
              "docstring_html": "<p>Compute scaling factor for adaptive timestep based on\nabsolute and relative local truncation error estimate,\nalso checks if the error tolerance is achieved and returns\na success metric.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>integration timestep</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>success <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>timestep was successful</dd>\n<dt>err <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>truncation error estimate</dd>\n<dt>scale <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>timestep rescale from error controller</dd>\n</dl>\n",
              "signature": "(dt)",
              "parameters": [
                {
                  "name": "dt",
                  "type": null,
                  "default": null,
                  "description": "integration timestep"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "solve",
              "description": "Solves the implicit update equation using the optimizer of the engine.",
              "docstring_html": "<p>Solves the implicit update equation using the optimizer of the engine.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>f <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array_like</span></dt>\n<dd>evaluation of function</dd>\n<dt>J <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array_like</span></dt>\n<dd>evaluation of jacobian of function</dd>\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>integration timestep</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>err <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>residual error of the fixed point update equation</dd>\n</dl>\n",
              "signature": "(f, J, dt)",
              "parameters": [
                {
                  "name": "f",
                  "type": null,
                  "default": null,
                  "description": "evaluation of function"
                },
                {
                  "name": "J",
                  "type": null,
                  "default": null,
                  "description": "evaluation of jacobian of function"
                },
                {
                  "name": "dt",
                  "type": null,
                  "default": null,
                  "description": "integration timestep"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "step",
              "description": "performs the (explicit) timestep at the intermediate RK stages",
              "docstring_html": "<p>performs the (explicit) timestep at the intermediate RK stages\nfor (t+dt) based on the state and input at (t)</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>f <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array_like</span></dt>\n<dd>evaluation of function</dd>\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>integration timestep</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>success <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>timestep was successful</dd>\n<dt>err <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>truncation error estimate</dd>\n<dt>scale <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>timestep rescale from error controller</dd>\n</dl>\n",
              "signature": "(f, dt)",
              "parameters": [
                {
                  "name": "f",
                  "type": null,
                  "default": null,
                  "description": "evaluation of function"
                },
                {
                  "name": "dt",
                  "type": null,
                  "default": null,
                  "description": "integration timestep"
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "n",
              "description": "",
              "type": null,
              "value": "0"
            },
            {
              "name": "m",
              "description": "",
              "type": null,
              "value": "0"
            },
            {
              "name": "s",
              "description": "",
              "type": null,
              "value": "0"
            },
            {
              "name": "beta",
              "description": "",
              "type": null,
              "value": "SOL_BETA"
            },
            {
              "name": "Ks",
              "description": "",
              "type": null,
              "value": "{}"
            },
            {
              "name": "BT",
              "description": "",
              "type": null,
              "value": "None"
            },
            {
              "name": "A",
              "description": "",
              "type": null,
              "value": "None"
            },
            {
              "name": "TR",
              "description": "",
              "type": null,
              "value": "None"
            }
          ],
          "parameters": [
            {
              "name": "solver_args",
              "type": null,
              "default": "()",
              "description": ""
            },
            {
              "name": "solver_kwargs",
              "type": null,
              "default": "{}",
              "description": ""
            }
          ]
        },
        {
          "name": "DIRK2",
          "description": "Two-stage, 2nd order Diagonally Implicit Runge-Kutta (DIRK) method.",
          "docstring_html": "<p>Two-stage, 2nd order Diagonally Implicit Runge-Kutta (DIRK) method.</p>\n<p>This specific method is SSP-optimal (largest radius of absolute monotonicity\nfor a 2-stage, 2nd order DIRK), symplectic, and A-stable. It's a robust choice\nfor moderately stiff problems where second-order accuracy is sufficient.</p>\n<div class=\"section\" id=\"characteristics\">\n<h4>Characteristics</h4>\n<ul class=\"simple\">\n<li>Order: 2</li>\n<li>Stages: 2 (Implicit)</li>\n<li>Implicit (DIRK)</li>\n<li>Fixed timestep only</li>\n<li>A-stable, SSP-optimal, Symplectic</li>\n</ul>\n</div>\n<div class=\"section\" id=\"when-to-use\">\n<h4>When to Use</h4>\n<ul class=\"simple\">\n<li><strong>Moderately stiff problems</strong>: Good entry-level implicit method for stiff ODEs</li>\n<li><strong>SSP requirements with stiffness</strong>: Combines strong stability preservation with A-stability</li>\n<li><strong>Symplectic integration</strong>: Preserves geometric structure in Hamiltonian systems</li>\n<li><strong>Low-order implicit needs</strong>: When 2nd order implicit accuracy is sufficient</li>\n</ul>\n<p><strong>Trade-off</strong>: Lower order than ESDIRK or BDF methods but has SSP and symplectic\nproperties. For higher accuracy on stiff problems, consider ESDIRK43 or BDF methods.</p>\n<p><strong>References</strong></p>\n<table class=\"docutils footnote\" frame=\"void\" id=\"footnote-1\" rules=\"none\">\n<colgroup><col class=\"label\" /><col /></colgroup>\n<tbody valign=\"top\">\n<tr><td class=\"label\">[1]</td><td>Ferracina, L., &amp; Spijker, M. N. (2008). &quot;Strong stability of singly-diagonally-\nimplicit Runge-Kutta methods&quot;. Applied Numerical Mathematics, 58(11), 1675-1686.</td></tr>\n</tbody>\n</table>\n<table class=\"docutils footnote\" frame=\"void\" id=\"footnote-2\" rules=\"none\">\n<colgroup><col class=\"label\" /><col /></colgroup>\n<tbody valign=\"top\">\n<tr><td class=\"label\">[2]</td><td>Hairer, E., &amp; Wanner, G. (1996). &quot;Solving Ordinary Differential Equations II:\nStiff and Differential-Algebraic Problems&quot;. Springer Series in Computational\nMathematics, Vol. 14.</td></tr>\n</tbody>\n</table>\n</div>\n",
          "bases": [
            "DiagonallyImplicitRungeKutta"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "signature": "(solver_args = (), solver_kwargs = {})",
              "parameters": [
                {
                  "name": "solver_args",
                  "type": null,
                  "default": "()",
                  "description": ""
                },
                {
                  "name": "solver_kwargs",
                  "type": null,
                  "default": "{}",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "s",
              "description": "",
              "type": null,
              "value": "2"
            },
            {
              "name": "n",
              "description": "",
              "type": null,
              "value": "2"
            },
            {
              "name": "eval_stages",
              "description": "",
              "type": null,
              "value": "[1 / 4, 3 / 4]"
            },
            {
              "name": "BT",
              "description": "",
              "type": null,
              "value": "{0: [1 / 4], 1: [1 / 2, 1 / 4]}"
            },
            {
              "name": "A",
              "description": "",
              "type": null,
              "value": "[1 / 2, 1 / 2]"
            }
          ],
          "parameters": [
            {
              "name": "solver_args",
              "type": null,
              "default": "()",
              "description": ""
            },
            {
              "name": "solver_kwargs",
              "type": null,
              "default": "{}",
              "description": ""
            }
          ]
        },
        {
          "name": "ESDIRK4",
          "description": "Six-stage, 4th order Singly Diagonally Implicit Runge-Kutta (ESDIRK) method.",
          "docstring_html": "<p>Six-stage, 4th order Singly Diagonally Implicit Runge-Kutta (ESDIRK) method.</p>\n<p>Features an explicit first stage (making it ESDIRK). This specific tableau is designed\nfor handling stiff problems and potentially Differential Algebraic Equations (DAEs) of\nindex up to two or three. Does not have an embedded method for error estimation in this\nimplementation (fixed step only).</p>\n<div class=\"section\" id=\"characteristics\">\n<h4>Characteristics</h4>\n<ul class=\"simple\">\n<li>Order: 4</li>\n<li>Stages: 6 (1 Explicit, 5 Implicit)</li>\n<li>Implicit (ESDIRK)</li>\n<li>Fixed timestep only</li>\n<li>A-stable</li>\n</ul>\n</div>\n<div class=\"section\" id=\"when-to-use\">\n<h4>When to Use</h4>\n<ul class=\"simple\">\n<li><strong>Stiff problems with fixed timestep</strong>: 4th order accuracy for stiff ODEs</li>\n<li><strong>Differential-algebraic equations</strong>: Suitable for DAEs of index 2-3</li>\n<li><strong>Moderate-to-high accuracy on stiff problems</strong>: Better than 3rd order methods</li>\n<li><strong>Known stable timestep</strong>: When adaptive stepping is not needed</li>\n</ul>\n<p><strong>Note</strong>: For adaptive timestepping on stiff problems, use ESDIRK43 or ESDIRK54 instead.</p>\n<p><strong>References</strong></p>\n<table class=\"docutils footnote\" frame=\"void\" id=\"footnote-1\" rules=\"none\">\n<colgroup><col class=\"label\" /><col /></colgroup>\n<tbody valign=\"top\">\n<tr><td class=\"label\">[1]</td><td>Kennedy, C. A., &amp; Carpenter, M. H. (2016). &quot;Diagonally implicit Runge-Kutta\nmethods for ordinary differential equations. A review&quot;. NASA Technical Report.</td></tr>\n</tbody>\n</table>\n<table class=\"docutils footnote\" frame=\"void\" id=\"footnote-2\" rules=\"none\">\n<colgroup><col class=\"label\" /><col /></colgroup>\n<tbody valign=\"top\">\n<tr><td class=\"label\">[2]</td><td>Hairer, E., &amp; Wanner, G. (1996). &quot;Solving Ordinary Differential Equations II:\nStiff and Differential-Algebraic Problems&quot;. Springer Series in Computational\nMathematics, Vol. 14.</td></tr>\n</tbody>\n</table>\n</div>\n",
          "bases": [
            "DiagonallyImplicitRungeKutta"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "signature": "(solver_args = (), solver_kwargs = {})",
              "parameters": [
                {
                  "name": "solver_args",
                  "type": null,
                  "default": "()",
                  "description": ""
                },
                {
                  "name": "solver_kwargs",
                  "type": null,
                  "default": "{}",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "s",
              "description": "",
              "type": null,
              "value": "6"
            },
            {
              "name": "n",
              "description": "",
              "type": null,
              "value": "4"
            },
            {
              "name": "eval_stages",
              "description": "",
              "type": null,
              "value": "[0.0, 1 / 2, 1 / 6, 37 / 40, 1 / 2, 1.0]"
            },
            {
              "name": "BT",
              "description": "",
              "type": null,
              "value": "{0: None, 1: [1 / 4, 1 / 4], 2: [-1 / 36, -1 / 18, 1 / 4], 3: [-21283 / 32000, -5143 / 64000, 90909 / 64000, 1 / 4], 4: [46010759 / 749250000, -737693 / 40500000, 10931269 / 45500000, -1140071 / 34090875, 1 / 4], 5: [89 / 444, 89 / 804756, -27 / 364, -20000 / 171717, 843750 / 1140071, 1 / 4]}"
            }
          ],
          "parameters": [
            {
              "name": "solver_args",
              "type": null,
              "default": "()",
              "description": ""
            },
            {
              "name": "solver_kwargs",
              "type": null,
              "default": "{}",
              "description": ""
            }
          ]
        },
        {
          "name": "ESDIRK43",
          "description": "Six-stage, 4th order Embedded Singly Diagonally Implicit Runge-Kutta (ESDIRK) method.",
          "docstring_html": "<p>Six-stage, 4th order Embedded Singly Diagonally Implicit Runge-Kutta (ESDIRK) method.</p>\n<p>Features an embedded 3rd order method for adaptive step size control. The first stage is\nexplicit. L-stable and stiffly accurate, making it excellent for stiff problems requiring\nmoderate-to-high accuracy with adaptive timestepping.</p>\n<div class=\"section\" id=\"characteristics\">\n<h4>Characteristics</h4>\n<ul class=\"simple\">\n<li>Order: 4</li>\n<li>Embedded Order: 3</li>\n<li>Stages: 6 (1 Explicit, 5 Implicit)</li>\n<li>Implicit (ESDIRK)</li>\n<li>Adaptive timestep</li>\n<li>L-stable</li>\n<li>Stiffly accurate</li>\n</ul>\n</div>\n<div class=\"section\" id=\"when-to-use\">\n<h4>When to Use</h4>\n<ul class=\"simple\">\n<li><strong>Stiff problems with adaptive stepping</strong>: Excellent default for stiff ODEs</li>\n<li><strong>Moderate-to-high accuracy</strong>: 4th order with good error control</li>\n<li><strong>Damping high frequencies</strong>: L-stability damps spurious oscillations</li>\n<li><strong>General-purpose stiff solver</strong>: Reliable choice for most stiff applications</li>\n</ul>\n<p><strong>Recommended</strong> as a default adaptive stiff solver. For very high accuracy, use ESDIRK54.\nFor non-stiff problems, RKDP54 is more efficient.</p>\n<p><strong>References</strong></p>\n<table class=\"docutils footnote\" frame=\"void\" id=\"footnote-1\" rules=\"none\">\n<colgroup><col class=\"label\" /><col /></colgroup>\n<tbody valign=\"top\">\n<tr><td class=\"label\">[1]</td><td>Kennedy, C. A., &amp; Carpenter, M. H. (2019). &quot;Diagonally implicit Runge-Kutta\nmethods for stiff ODEs&quot;. Applied Numerical Mathematics, 146, 221-244.</td></tr>\n</tbody>\n</table>\n<table class=\"docutils footnote\" frame=\"void\" id=\"footnote-2\" rules=\"none\">\n<colgroup><col class=\"label\" /><col /></colgroup>\n<tbody valign=\"top\">\n<tr><td class=\"label\">[2]</td><td>Hairer, E., &amp; Wanner, G. (1996). &quot;Solving Ordinary Differential Equations II:\nStiff and Differential-Algebraic Problems&quot;. Springer Series in Computational\nMathematics, Vol. 14.</td></tr>\n</tbody>\n</table>\n</div>\n",
          "bases": [
            "DiagonallyImplicitRungeKutta"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "signature": "(solver_args = (), solver_kwargs = {})",
              "parameters": [
                {
                  "name": "solver_args",
                  "type": null,
                  "default": "()",
                  "description": ""
                },
                {
                  "name": "solver_kwargs",
                  "type": null,
                  "default": "{}",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "s",
              "description": "",
              "type": null,
              "value": "6"
            },
            {
              "name": "n",
              "description": "",
              "type": null,
              "value": "4"
            },
            {
              "name": "m",
              "description": "",
              "type": null,
              "value": "3"
            },
            {
              "name": "is_adaptive",
              "description": "",
              "type": null,
              "value": "True"
            },
            {
              "name": "eval_stages",
              "description": "",
              "type": null,
              "value": "[0.0, 1 / 2, (2 - np.sqrt(2)) / 4, 2012122486997 / 3467029789466, 1.0, 1.0]"
            },
            {
              "name": "BT",
              "description": "",
              "type": null,
              "value": "{0: None, 1: [1 / 4, 1 / 4], 2: [-1356991263433 / 26208533697614, -1356991263433 / 26208533697614, 1 / 4], 3: [-1778551891173 / 14697912885533, -1778551891173 / 14697912885533, 7325038566068 / 12797657924939, 1 / 4], 4: [-24076725932807 / 39344244018142, -24076725932807 / 39344244018142, 9344023789330 / 6876721947151, 11302510524611 / 18374767399840, 1 / 4], 5: [657241292721 / 9909463049845, 657241292721 / 9909463049845, 1290772910128 / 5804808736437, 1103522341516 / 2197678446715, -3 / 28, 1 / 4]}"
            },
            {
              "name": "TR",
              "description": "",
              "type": null,
              "value": "[(a1 - a2) for a1, a2 in (zip(_A1, _A2))]"
            }
          ],
          "parameters": [
            {
              "name": "solver_args",
              "type": null,
              "default": "()",
              "description": ""
            },
            {
              "name": "solver_kwargs",
              "type": null,
              "default": "{}",
              "description": ""
            }
          ]
        },
        {
          "name": "ESDIRK54",
          "description": "Seven-stage, 5th order L-stable Embedded Singly Diagonally Implicit Runge-Kutta method.",
          "docstring_html": "<p>Seven-stage, 5th order L-stable Embedded Singly Diagonally Implicit Runge-Kutta method.</p>\n<p>Features an embedded 4th order method for adaptive step size control. The first stage is\nexplicit. L-stable and stiffly accurate, making it excellent for stiff problems requiring\nhigh accuracy with adaptive timestepping. This is the ESDIRK5(4)7L[2]SA2 method.</p>\n<div class=\"section\" id=\"characteristics\">\n<h4>Characteristics</h4>\n<ul class=\"simple\">\n<li>Order: 5</li>\n<li>Embedded Order: 4</li>\n<li>Stages: 7 (1 Explicit, 6 Implicit)</li>\n<li>Implicit (ESDIRK)</li>\n<li>Adaptive timestep</li>\n<li>L-stable, Stiffly accurate</li>\n</ul>\n</div>\n<div class=\"section\" id=\"when-to-use\">\n<h4>When to Use</h4>\n<ul class=\"simple\">\n<li><strong>High-accuracy stiff problems</strong>: When 5th order is needed for stiff ODEs</li>\n<li><strong>Demanding stiff applications</strong>: Chemical kinetics, combustion, atmospheric chemistry</li>\n<li><strong>Tight error tolerances</strong>: Better accuracy than 4th order methods</li>\n<li><strong>Production stiff solver</strong>: High-quality method for serious applications</li>\n</ul>\n<p><strong>Recommended</strong> for high-accuracy stiff problems. This is a state-of-the-art adaptive\nimplicit method. For very stiff problems with less stringent accuracy, ESDIRK43 may be\nmore efficient.</p>\n<p><strong>References</strong></p>\n<table class=\"docutils footnote\" frame=\"void\" id=\"footnote-1\" rules=\"none\">\n<colgroup><col class=\"label\" /><col /></colgroup>\n<tbody valign=\"top\">\n<tr><td class=\"label\">[1]</td><td>Kennedy, C. A., &amp; Carpenter, M. H. (2019). &quot;Diagonally implicit Runge-Kutta\nmethods for stiff ODEs&quot;. Applied Numerical Mathematics, 146, 221-244.</td></tr>\n</tbody>\n</table>\n<table class=\"docutils footnote\" frame=\"void\" id=\"footnote-2\" rules=\"none\">\n<colgroup><col class=\"label\" /><col /></colgroup>\n<tbody valign=\"top\">\n<tr><td class=\"label\">[2]</td><td>Hairer, E., &amp; Wanner, G. (1996). &quot;Solving Ordinary Differential Equations II:\nStiff and Differential-Algebraic Problems&quot;. Springer Series in Computational\nMathematics, Vol. 14.</td></tr>\n</tbody>\n</table>\n</div>\n",
          "bases": [
            "DiagonallyImplicitRungeKutta"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "signature": "(solver_args = (), solver_kwargs = {})",
              "parameters": [
                {
                  "name": "solver_args",
                  "type": null,
                  "default": "()",
                  "description": ""
                },
                {
                  "name": "solver_kwargs",
                  "type": null,
                  "default": "{}",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "s",
              "description": "",
              "type": null,
              "value": "7"
            },
            {
              "name": "n",
              "description": "",
              "type": null,
              "value": "5"
            },
            {
              "name": "m",
              "description": "",
              "type": null,
              "value": "4"
            },
            {
              "name": "is_adaptive",
              "description": "",
              "type": null,
              "value": "True"
            },
            {
              "name": "eval_stages",
              "description": "",
              "type": null,
              "value": "[0.0, 46 / 125, 7121331996143 / 11335814405378, 49 / 353, 3706679970760 / 5295570149437, 347 / 382, 1.0]"
            },
            {
              "name": "BT",
              "description": "",
              "type": null,
              "value": "{0: None, 1: [23 / 125, 23 / 125], 2: [791020047304 / 3561426431547, 791020047304 / 3561426431547, 23 / 125], 3: [-158159076358 / 11257294102345, -158159076358 / 11257294102345, -85517644447 / 5003708988389, 23 / 125], 4: [-1653327111580 / 4048416487981, -1653327111580 / 4048416487981, 1514767744496 / 9099671765375, 14283835447591 / 12247432691556, 23 / 125], 5: [-4540011970825 / 8418487046959, -4540011970825 / 8418487046959, -1790937573418 / 7393406387169, 10819093665085 / 7266595846747, 4109463131231 / 7386972500302, 23 / 125], 6: [-188593204321 / 4778616380481, -188593204321 / 4778616380481, 2809310203510 / 10304234040467, 1021729336898 / 2364210264653, 870612361811 / 2470410392208, -1307970675534 / 8059683598661, 23 / 125]}"
            },
            {
              "name": "TR",
              "description": "",
              "type": null,
              "value": "[(_a1 - _a2) for _a1, _a2 in (zip(_A1, _A2))]"
            }
          ],
          "parameters": [
            {
              "name": "solver_args",
              "type": null,
              "default": "()",
              "description": ""
            },
            {
              "name": "solver_kwargs",
              "type": null,
              "default": "{}",
              "description": ""
            }
          ]
        },
        {
          "name": "ESDIRK85",
          "description": "Sixteen-stage, 8th order L-stable Embedded Singly Diagonally Implicit Runge-Kutta method.",
          "docstring_html": "<p>Sixteen-stage, 8th order L-stable Embedded Singly Diagonally Implicit Runge-Kutta method.</p>\n<p>Features an embedded 5th order method for adaptive step size control. The first stage is\nexplicit. Designed for very stiff problems requiring very high accuracy. Computationally\nexpensive due to 16 stages, but can take very large timesteps with tight tolerances.\nThis is the ESDIRK(16,8)[2]SAL-[(16,5)] method.</p>\n<div class=\"section\" id=\"characteristics\">\n<h4>Characteristics</h4>\n<ul class=\"simple\">\n<li>Order: 8</li>\n<li>Embedded Order: 5</li>\n<li>Stages: 16 (1 Explicit, 15 Implicit)</li>\n<li>Implicit (ESDIRK)</li>\n<li>Adaptive timestep</li>\n<li>L-stable, Stiffly accurate</li>\n</ul>\n</div>\n<div class=\"section\" id=\"when-to-use\">\n<h4>When to Use</h4>\n<ul class=\"simple\">\n<li><strong>Extremely high accuracy on stiff problems</strong>: When very tight tolerances are essential</li>\n<li><strong>Expensive right-hand sides</strong>: When large timesteps justify the 16 stages</li>\n<li><strong>Benchmark computations</strong>: Reference solutions for stiff problems</li>\n<li><strong>Specialized applications</strong>: Only when 8th order accuracy is truly needed</li>\n</ul>\n<p><strong>Warning</strong>: Very expensive (16 implicit stages). Only use when extremely high accuracy\nis essential and large timesteps are possible. For most applications, ESDIRK54 is more\npractical.</p>\n<p><strong>References</strong></p>\n<table class=\"docutils footnote\" frame=\"void\" id=\"footnote-1\" rules=\"none\">\n<colgroup><col class=\"label\" /><col /></colgroup>\n<tbody valign=\"top\">\n<tr><td class=\"label\">[1]</td><td>Alamri, Y., &amp; Ketcheson, D. I. (2019). &quot;Very high-order A-stable stiffly accurate\ndiagonally implicit Runge-Kutta methods with error estimators&quot;. arXiv preprint\narXiv:1905.11370.</td></tr>\n</tbody>\n</table>\n<table class=\"docutils footnote\" frame=\"void\" id=\"footnote-2\" rules=\"none\">\n<colgroup><col class=\"label\" /><col /></colgroup>\n<tbody valign=\"top\">\n<tr><td class=\"label\">[2]</td><td>Kennedy, C. A., &amp; Carpenter, M. H. (2019). &quot;Diagonally implicit Runge-Kutta\nmethods for stiff ODEs&quot;. Applied Numerical Mathematics, 146, 221-244.</td></tr>\n</tbody>\n</table>\n<table class=\"docutils footnote\" frame=\"void\" id=\"footnote-3\" rules=\"none\">\n<colgroup><col class=\"label\" /><col /></colgroup>\n<tbody valign=\"top\">\n<tr><td class=\"label\">[3]</td><td>Hairer, E., &amp; Wanner, G. (1996). &quot;Solving Ordinary Differential Equations II:\nStiff and Differential-Algebraic Problems&quot;. Springer Series in Computational\nMathematics, Vol. 14.</td></tr>\n</tbody>\n</table>\n</div>\n",
          "bases": [
            "DiagonallyImplicitRungeKutta"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "signature": "(solver_args = (), solver_kwargs = {})",
              "parameters": [
                {
                  "name": "solver_args",
                  "type": null,
                  "default": "()",
                  "description": ""
                },
                {
                  "name": "solver_kwargs",
                  "type": null,
                  "default": "{}",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "s",
              "description": "",
              "type": null,
              "value": "16"
            },
            {
              "name": "n",
              "description": "",
              "type": null,
              "value": "8"
            },
            {
              "name": "m",
              "description": "",
              "type": null,
              "value": "5"
            },
            {
              "name": "is_adaptive",
              "description": "",
              "type": null,
              "value": "True"
            },
            {
              "name": "eval_stages",
              "description": "",
              "type": null,
              "value": "[0.0, 0.234637638717043, 0.558545926594724, 0.562667638694992, 0.697898381329126, 0.956146958839776, 0.812903043340468, 0.148256733818785, 0.944650387704291, 0.428471803715736, 0.984131639774509, 0.320412672954752, 0.974077670791771, 0.852850433853921, 0.823320301074444, 1.0]"
            },
            {
              "name": "BT",
              "description": "",
              "type": null,
              "value": "{0: None, 1: [0.117318819358521, 0.117318819358521], 2: [0.0557014605974616, 0.385525646638742, 0.117318819358521], 3: [0.063493276428895, 0.373556126263681, 0.0082994166438953, 0.117318819358521], 4: [0.0961351856230088, 0.335558324517178, 0.207077765910132, -0.0581917140797146, 0.117318819358521], 5: [0.0497669214238319, 0.384288616546039, 0.0821728117583936, 0.120337007107103, 0.202262782645888, 0.117318819358521], 6: [0.00626710666809847, 0.496491452640725, -0.111303249827358, 0.170478821683603, 0.166517073971103, -0.0328669811542241, 0.117318819358521], 7: [0.0463439767281591, 0.00306724391019652, -0.00816305222386205, -0.0353302599538294, 0.0139313601702569, -0.00992014507967429, 0.0210087909090165, 0.117318819358521], 8: [0.111574049232048, 0.467639166482209, 0.237773114804619, 0.0798895699267508, 0.109580615914593, 0.0307353103825936, -0.0404391509541147, -0.16942110744293, 0.117318819358521], 9: [-0.0107072484863877, -0.231376703354252, 0.017541113036611, 0.144871527682418, -0.041855459769806, 0.0841832168332261, -0.0850020937282192, 0.486170343825899, -0.0526717116822739, 0.117318819358521], 10: [-0.0142238262314935, 0.14752923682514, 0.238235830732566, 0.037950291904103, 0.252075123381518, 0.0474266904224567, -0.00363139069342027, 0.274081442388563, -0.0599166970745255, -0.0527138812389185, 0.117318819358521], 11: [-0.11837020183211, -0.635712481821264, 0.239738832602538, 0.330058936651707, -0.325784087988237, -0.0506514314589253, -0.281914404487009, 0.852596345144291, 0.651444614298805, -0.103476387303591, -0.354835880209975, 0.117318819358521], 12: [-0.00458164025442349, 0.296219694015248, 0.322146049419995, 0.15917778285238, 0.284864871688843, 0.185509526463076, -0.0784621067883274, 0.166312223692047, -0.284152486083397, -0.357125104338944, 0.078437074055306, 0.0884129667114481, 0.117318819358521], 13: [-0.0545561913848106, 0.675785423442753, 0.423066443201941, -0.000165300126841193, 0.104252994793763, -0.105763019303021, -0.15988308809318, 0.0515050001032011, 0.56013979290924, -0.45781539708603, -0.255870699752664, 0.026960254296416, -0.0721245985053681, 0.117318819358521], 14: [0.0649253995775223, -0.0216056457922249, -0.073738139377975, 0.0931033310077225, -0.0194339577299149, -0.0879623837313009, 0.057125517179467, 0.205120850488097, 0.132576503537441, 0.489416890627328, -0.1106765720501, -0.081038793996096, 0.0606031613503788, -0.00241467937442272, 0.117318819358521], 15: [0.0459979286336779, 0.0780075394482806, 0.015021874148058, 0.195180277284195, -0.00246643310153235, 0.0473977117068314, -0.0682773558610363, 0.19568019123878, -0.0876765449323747, 0.177874852409192, -0.337519251582222, -0.0123255553640736, 0.311573291192553, 0.0458604327754991, 0.278352222645651, 0.117318819358521]}"
            },
            {
              "name": "TR",
              "description": "",
              "type": null,
              "value": "[(_a1 - _a2) for _a1, _a2 in (zip(_A1, _A2))]"
            }
          ],
          "parameters": [
            {
              "name": "solver_args",
              "type": null,
              "default": "()",
              "description": ""
            },
            {
              "name": "solver_kwargs",
              "type": null,
              "default": "{}",
              "description": ""
            }
          ]
        },
        {
          "name": "ExplicitRungeKutta",
          "description": "Base class for explicit Runge-Kutta integrators which implements",
          "docstring_html": "<p>Base class for explicit Runge-Kutta integrators which implements\nthe timestepping at intermediate stages and the error control if\nthe coefficients for the local truncation error estimate are defined.</p>\n<div class=\"section\" id=\"note\">\n<h4>Note</h4>\n<p>This class is not intended to be used directly!!!</p>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>n <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>order of stepping integration scheme</dd>\n<dt>m <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>order of embedded integration scheme for error control</dd>\n<dt>s <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>numer of RK stages</dd>\n<dt>history <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">deque[numeric]</span></dt>\n<dd>internal history of past results</dd>\n<dt>beta <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>safety factor for error control</dd>\n<dt>Ks <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">dict</span></dt>\n<dd>slopes at RK stages</dd>\n<dt>BT <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">dict[int: None, list[float]], None</span></dt>\n<dd>butcher table</dd>\n<dt>TR <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">list[float]</span></dt>\n<dd>coefficients for truncation error estimate</dd>\n</dl>\n</div>\n",
          "bases": [
            "ExplicitSolver"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "signature": "(solver_args = (), solver_kwargs = {})",
              "parameters": [
                {
                  "name": "solver_args",
                  "type": null,
                  "default": "()",
                  "description": ""
                },
                {
                  "name": "solver_kwargs",
                  "type": null,
                  "default": "{}",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "error_controller",
              "description": "Compute scaling factor for adaptive timestep based on",
              "docstring_html": "<p>Compute scaling factor for adaptive timestep based on\nabsolute and relative local truncation error estimate,\nalso checks if the error tolerance is achieved and returns\na success metric.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>integration timestep</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>success <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>timestep was successful</dd>\n<dt>err <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>truncation error estimate</dd>\n<dt>scale <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>timestep rescale from error controller</dd>\n</dl>\n",
              "signature": "(dt)",
              "parameters": [
                {
                  "name": "dt",
                  "type": null,
                  "default": null,
                  "description": "integration timestep"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "step",
              "description": "Performs the (explicit) timestep at the intermediate RK stages",
              "docstring_html": "<p>Performs the (explicit) timestep at the intermediate RK stages\nfor (t+dt) based on the state and input at (t)</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>f <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">numeric, array[numeric]</span></dt>\n<dd>evaluation of function</dd>\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>integration timestep</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>success <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>timestep was successful</dd>\n<dt>err <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>truncation error estimate</dd>\n<dt>scale <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>timestep rescale from error controller</dd>\n</dl>\n",
              "signature": "(f, dt)",
              "parameters": [
                {
                  "name": "f",
                  "type": null,
                  "default": null,
                  "description": "evaluation of function"
                },
                {
                  "name": "dt",
                  "type": null,
                  "default": null,
                  "description": "integration timestep"
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "n",
              "description": "",
              "type": null,
              "value": "0"
            },
            {
              "name": "m",
              "description": "",
              "type": null,
              "value": "0"
            },
            {
              "name": "s",
              "description": "",
              "type": null,
              "value": "0"
            },
            {
              "name": "beta",
              "description": "",
              "type": null,
              "value": "SOL_BETA"
            },
            {
              "name": "Ks",
              "description": "",
              "type": null,
              "value": "{}"
            },
            {
              "name": "BT",
              "description": "",
              "type": null,
              "value": "None"
            },
            {
              "name": "TR",
              "description": "",
              "type": null,
              "value": "None"
            }
          ],
          "parameters": [
            {
              "name": "solver_args",
              "type": null,
              "default": "()",
              "description": ""
            },
            {
              "name": "solver_kwargs",
              "type": null,
              "default": "{}",
              "description": ""
            }
          ]
        },
        {
          "name": "SSPRK22",
          "description": "Two-stage, 2nd order Strong Stability Preserving (SSP) explicit Runge-Kutta method.",
          "docstring_html": "<p>Two-stage, 2nd order Strong Stability Preserving (SSP) explicit Runge-Kutta method.</p>\n<p>Also known as Heun's method or the explicit midpoint method. SSP methods are designed\nto preserve stability properties (like total variation diminishing - TVD) when solving\nhyperbolic PDEs with spatial discretizations that have strong stability properties.\nAlso effective as a general-purpose low-order explicit method.</p>\n<div class=\"section\" id=\"characteristics\">\n<h4>Characteristics</h4>\n<ul class=\"simple\">\n<li>Order: 2</li>\n<li>Stages: 2</li>\n<li>Explicit (SSP)</li>\n<li>Fixed timestep only</li>\n<li>SSP coefficient: <math xmlns=\"http://www.w3.org/1998/Math/MathML\">\n  <mi>C</mi>\n  <mo>=</mo>\n  <mn>1</mn>\n</math></li>\n<li>Good balance of simplicity, cost, and stability</li>\n</ul>\n</div>\n<div class=\"section\" id=\"when-to-use\">\n<h4>When to Use</h4>\n<ul class=\"simple\">\n<li><strong>Hyperbolic PDEs</strong>: Ideal for shock-capturing schemes and conservation laws</li>\n<li><strong>TVD/SSP requirements</strong>: When preserving monotonicity or boundedness is critical</li>\n<li><strong>Discontinuous solutions</strong>: Shocks, contact discontinuities, rarefactions</li>\n<li><strong>Method of lines</strong>: Time integration of spatially discretized PDEs</li>\n</ul>\n</div>\n<div class=\"section\" id=\"note\">\n<h4>Note</h4>\n<p>Computational fluid dynamics, shallow water equations, traffic flow,\nBurgers' equation, Euler equations.</p>\n<p><strong>References</strong></p>\n<table class=\"docutils footnote\" frame=\"void\" id=\"footnote-1\" rules=\"none\">\n<colgroup><col class=\"label\" /><col /></colgroup>\n<tbody valign=\"top\">\n<tr><td class=\"label\">[1]</td><td>Shu, C. W., &amp; Osher, S. (1988). &quot;Efficient implementation of essentially\nnon-oscillatory shock-capturing schemes&quot;. Journal of Computational Physics,\n77(2), 439-471.</td></tr>\n</tbody>\n</table>\n<table class=\"docutils footnote\" frame=\"void\" id=\"footnote-2\" rules=\"none\">\n<colgroup><col class=\"label\" /><col /></colgroup>\n<tbody valign=\"top\">\n<tr><td class=\"label\">[2]</td><td>Gottlieb, S., Shu, C. W., &amp; Tadmor, E. (2001). &quot;Strong stability-preserving\nhigh-order time discretization methods&quot;. SIAM Review, 43(1), 89-112.</td></tr>\n</tbody>\n</table>\n<table class=\"docutils footnote\" frame=\"void\" id=\"footnote-3\" rules=\"none\">\n<colgroup><col class=\"label\" /><col /></colgroup>\n<tbody valign=\"top\">\n<tr><td class=\"label\">[3]</td><td>Ketcheson, D. I. (2008). &quot;Highly efficient strong stability-preserving\nRunge-Kutta methods with low-storage implementations&quot;. SIAM Journal on\nScientific Computing, 30(4), 2113-2136.</td></tr>\n</tbody>\n</table>\n</div>\n",
          "bases": [
            "ExplicitRungeKutta"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "signature": "(solver_args = (), solver_kwargs = {})",
              "parameters": [
                {
                  "name": "solver_args",
                  "type": null,
                  "default": "()",
                  "description": ""
                },
                {
                  "name": "solver_kwargs",
                  "type": null,
                  "default": "{}",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "interpolate",
              "description": "",
              "docstring_html": "",
              "signature": "(r, dt)",
              "parameters": [
                {
                  "name": "r",
                  "type": null,
                  "default": null,
                  "description": ""
                },
                {
                  "name": "dt",
                  "type": null,
                  "default": null,
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "s",
              "description": "",
              "type": null,
              "value": "2"
            },
            {
              "name": "n",
              "description": "",
              "type": null,
              "value": "2"
            },
            {
              "name": "eval_stages",
              "description": "",
              "type": null,
              "value": "[0.0, 1.0]"
            },
            {
              "name": "BT",
              "description": "",
              "type": null,
              "value": "{0: [1.0], 1: [1 / 2, 1 / 2]}"
            }
          ],
          "parameters": [
            {
              "name": "solver_args",
              "type": null,
              "default": "()",
              "description": ""
            },
            {
              "name": "solver_kwargs",
              "type": null,
              "default": "{}",
              "description": ""
            }
          ]
        },
        {
          "name": "SSPRK33",
          "description": "Three-stage, 3rd order Strong Stability Preserving (SSP) explicit Runge-Kutta method.",
          "docstring_html": "<p>Three-stage, 3rd order Strong Stability Preserving (SSP) explicit Runge-Kutta method.</p>\n<p>Offers higher accuracy than SSPRK22 while maintaining the SSP property. This is the\noptimal 3-stage 3rd order SSP method. A popular choice for problems where TVD\nproperties are important or when a simple, stable 3rd order explicit method is needed.</p>\n<dl class=\"docutils\">\n<dt>Characteristics:</dt>\n<dd><ul class=\"first last simple\">\n<li>Order: 3</li>\n<li>Stages: 3</li>\n<li>Explicit (SSP)</li>\n<li>Fixed timestep only</li>\n<li>SSP coefficient: <math xmlns=\"http://www.w3.org/1998/Math/MathML\">\n  <mi>C</mi>\n  <mo>=</mo>\n  <mn>1</mn>\n</math></li>\n<li>Optimal 3-stage SSP method</li>\n<li>Good stability properties for an explicit 3rd order method</li>\n</ul>\n</dd>\n</dl>\n<div class=\"section\" id=\"when-to-use\">\n<h4>When to Use</h4>\n<ul class=\"simple\">\n<li><strong>Hyperbolic conservation laws</strong>: Standard choice for higher-order TVD schemes</li>\n<li><strong>Higher accuracy than SSPRK22</strong>: When 3rd order accuracy is needed with SSP</li>\n<li><strong>WENO schemes</strong>: Common pairing with weighted essentially non-oscillatory methods</li>\n<li><strong>Compressible flow</strong>: Euler and Navier-Stokes equations with shocks</li>\n</ul>\n<p><strong>Recommended</strong> as the standard SSP method for most applications requiring 3rd order\naccuracy. For enhanced stability, consider SSPRK34 (4 stages).</p>\n<p><strong>References</strong></p>\n<table class=\"docutils footnote\" frame=\"void\" id=\"footnote-1\" rules=\"none\">\n<colgroup><col class=\"label\" /><col /></colgroup>\n<tbody valign=\"top\">\n<tr><td class=\"label\">[1]</td><td>Shu, C. W., &amp; Osher, S. (1988). &quot;Efficient implementation of essentially\nnon-oscillatory shock-capturing schemes&quot;. Journal of Computational Physics,\n77(2), 439-471.</td></tr>\n</tbody>\n</table>\n<table class=\"docutils footnote\" frame=\"void\" id=\"footnote-2\" rules=\"none\">\n<colgroup><col class=\"label\" /><col /></colgroup>\n<tbody valign=\"top\">\n<tr><td class=\"label\">[2]</td><td>Gottlieb, S., Shu, C. W., &amp; Tadmor, E. (2001). &quot;Strong stability-preserving\nhigh-order time discretization methods&quot;. SIAM Review, 43(1), 89-112.</td></tr>\n</tbody>\n</table>\n<table class=\"docutils footnote\" frame=\"void\" id=\"footnote-3\" rules=\"none\">\n<colgroup><col class=\"label\" /><col /></colgroup>\n<tbody valign=\"top\">\n<tr><td class=\"label\">[3]</td><td>Gottlieb, S., Ketcheson, D. I., &amp; Shu, C. W. (2011). &quot;Strong Stability\nPreserving Runge-Kutta and Multistep Time Discretizations&quot;. World Scientific.</td></tr>\n</tbody>\n</table>\n</div>\n",
          "bases": [
            "ExplicitRungeKutta"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "signature": "(solver_args = (), solver_kwargs = {})",
              "parameters": [
                {
                  "name": "solver_args",
                  "type": null,
                  "default": "()",
                  "description": ""
                },
                {
                  "name": "solver_kwargs",
                  "type": null,
                  "default": "{}",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "interpolate",
              "description": "",
              "docstring_html": "",
              "signature": "(r, dt)",
              "parameters": [
                {
                  "name": "r",
                  "type": null,
                  "default": null,
                  "description": ""
                },
                {
                  "name": "dt",
                  "type": null,
                  "default": null,
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "s",
              "description": "",
              "type": null,
              "value": "3"
            },
            {
              "name": "n",
              "description": "",
              "type": null,
              "value": "3"
            },
            {
              "name": "eval_stages",
              "description": "",
              "type": null,
              "value": "[0.0, 1.0, 0.5]"
            },
            {
              "name": "BT",
              "description": "",
              "type": null,
              "value": "{0: [1.0], 1: [1 / 4, 1 / 4], 2: [1 / 6, 1 / 6, 2 / 3]}"
            }
          ],
          "parameters": [
            {
              "name": "solver_args",
              "type": null,
              "default": "()",
              "description": ""
            },
            {
              "name": "solver_kwargs",
              "type": null,
              "default": "{}",
              "description": ""
            }
          ]
        },
        {
          "name": "SSPRK34",
          "description": "Four-stage, 3rd order Strong Stability Preserving (SSP) explicit Runge-Kutta method.",
          "docstring_html": "<p>Four-stage, 3rd order Strong Stability Preserving (SSP) explicit Runge-Kutta method.</p>\n<p>Provides a larger stability region and higher SSP coefficient compared to SSPRK33,\nparticularly along the negative real axis, at the cost of an additional stage. Useful\nwhen stability is more critical than computational cost for a 3rd order explicit method.</p>\n<div class=\"section\" id=\"characteristics\">\n<h4>Characteristics</h4>\n<ul class=\"simple\">\n<li>Order: 3</li>\n<li>Stages: 4</li>\n<li>Explicit (SSP)</li>\n<li>Fixed timestep only</li>\n<li>SSP coefficient: <math xmlns=\"http://www.w3.org/1998/Math/MathML\">\n  <mi>C</mi>\n  <mo>=</mo>\n  <mn>2</mn>\n</math></li>\n<li>Enhanced stability compared to SSPRK33</li>\n</ul>\n</div>\n<div class=\"section\" id=\"when-to-use\">\n<h4>When to Use</h4>\n<ul class=\"simple\">\n<li><strong>Larger timesteps</strong>: SSP coefficient of 2 allows larger stable timesteps</li>\n<li><strong>Difficult hyperbolic problems</strong>: More robust than SSPRK33 for challenging cases</li>\n<li><strong>Extra stability needed</strong>: When SSPRK33 exhibits instabilities</li>\n<li><strong>Worth extra stage</strong>: When the improved stability justifies 4 stages vs 3</li>\n</ul>\n<p><strong>Trade-off</strong>: More expensive than SSPRK33 but allows larger timesteps and better\nstability. Use when stability is critical.</p>\n<p><strong>References</strong></p>\n<table class=\"docutils footnote\" frame=\"void\" id=\"footnote-1\" rules=\"none\">\n<colgroup><col class=\"label\" /><col /></colgroup>\n<tbody valign=\"top\">\n<tr><td class=\"label\">[1]</td><td>Spiteri, R. J., &amp; Ruuth, S. J. (2002). &quot;A new class of optimal high-order\nstrong-stability-preserving time discretization methods&quot;. SIAM Journal on\nNumerical Analysis, 40(2), 469-491.</td></tr>\n</tbody>\n</table>\n<table class=\"docutils footnote\" frame=\"void\" id=\"footnote-2\" rules=\"none\">\n<colgroup><col class=\"label\" /><col /></colgroup>\n<tbody valign=\"top\">\n<tr><td class=\"label\">[2]</td><td>Gottlieb, S., Shu, C. W., &amp; Tadmor, E. (2001). &quot;Strong stability-preserving\nhigh-order time discretization methods&quot;. SIAM Review, 43(1), 89-112.</td></tr>\n</tbody>\n</table>\n<table class=\"docutils footnote\" frame=\"void\" id=\"footnote-3\" rules=\"none\">\n<colgroup><col class=\"label\" /><col /></colgroup>\n<tbody valign=\"top\">\n<tr><td class=\"label\">[3]</td><td>Gottlieb, S., Ketcheson, D. I., &amp; Shu, C. W. (2011). &quot;Strong Stability\nPreserving Runge-Kutta and Multistep Time Discretizations&quot;. World Scientific.</td></tr>\n</tbody>\n</table>\n</div>\n",
          "bases": [
            "ExplicitRungeKutta"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "signature": "(solver_args = (), solver_kwargs = {})",
              "parameters": [
                {
                  "name": "solver_args",
                  "type": null,
                  "default": "()",
                  "description": ""
                },
                {
                  "name": "solver_kwargs",
                  "type": null,
                  "default": "{}",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "s",
              "description": "",
              "type": null,
              "value": "4"
            },
            {
              "name": "n",
              "description": "",
              "type": null,
              "value": "3"
            },
            {
              "name": "eval_stages",
              "description": "",
              "type": null,
              "value": "[0.0, 1 / 2, 1, 1 / 2]"
            },
            {
              "name": "BT",
              "description": "",
              "type": null,
              "value": "{0: [1 / 2], 1: [1 / 2, 1 / 2], 2: [1 / 6, 1 / 6, 1 / 6], 3: [1 / 6, 1 / 6, 1 / 6, 1 / 2]}"
            }
          ],
          "parameters": [
            {
              "name": "solver_args",
              "type": null,
              "default": "()",
              "description": ""
            },
            {
              "name": "solver_kwargs",
              "type": null,
              "default": "{}",
              "description": ""
            }
          ]
        },
        {
          "name": "RK4",
          "description": "Classical four-stage, 4th order explicit Runge-Kutta method.",
          "docstring_html": "<p>Classical four-stage, 4th order explicit Runge-Kutta method.</p>\n<p>The most well-known Runge-Kutta method. It provides a good balance\nbetween accuracy and computational cost for non-stiff problems. This is\nthe standard textbook Runge-Kutta method, often simply called &quot;RK4&quot; or\n&quot;the Runge-Kutta method.&quot;</p>\n<div class=\"section\" id=\"characteristics\">\n<h4>Characteristics</h4>\n<ul class=\"simple\">\n<li>Order: 4</li>\n<li>Stages: 4</li>\n<li>Explicit</li>\n<li>Fixed timestep only</li>\n<li>Not SSP</li>\n<li>Widely used, good general-purpose explicit solver</li>\n</ul>\n</div>\n<div class=\"section\" id=\"when-to-use\">\n<h4>When to Use</h4>\n<ul class=\"simple\">\n<li><strong>General-purpose integration</strong>: Excellent default choice for smooth, non-stiff problems</li>\n<li><strong>Fixed timestep applications</strong>: When adaptive stepping is not required</li>\n<li><strong>Moderate accuracy needs</strong>: Good balance of accuracy and computational cost</li>\n<li><strong>Educational/reference</strong>: Standard method for comparison and teaching</li>\n</ul>\n</div>\n<div class=\"section\" id=\"note\">\n<h4>Note</h4>\n<p>Not suitable for stiff problems. For adaptive timestepping, consider\nRKDP54 or RKF45. For problems requiring TVD/SSP properties, use SSPRK methods.</p>\n<p><strong>References</strong></p>\n<table class=\"docutils footnote\" frame=\"void\" id=\"footnote-1\" rules=\"none\">\n<colgroup><col class=\"label\" /><col /></colgroup>\n<tbody valign=\"top\">\n<tr><td class=\"label\">[1]</td><td>Kutta, W. (1901). &quot;Beitrag zur näherungsweisen Integration totaler\nDifferentialgleichungen&quot;. Zeitschrift für Mathematik und Physik, 46, 435-453.</td></tr>\n</tbody>\n</table>\n<table class=\"docutils footnote\" frame=\"void\" id=\"footnote-2\" rules=\"none\">\n<colgroup><col class=\"label\" /><col /></colgroup>\n<tbody valign=\"top\">\n<tr><td class=\"label\">[2]</td><td>Butcher, J. C. (2016). &quot;Numerical Methods for Ordinary Differential Equations&quot;.\nJohn Wiley &amp; Sons, 3rd Edition.</td></tr>\n</tbody>\n</table>\n<table class=\"docutils footnote\" frame=\"void\" id=\"footnote-3\" rules=\"none\">\n<colgroup><col class=\"label\" /><col /></colgroup>\n<tbody valign=\"top\">\n<tr><td class=\"label\">[3]</td><td>Hairer, E., Nørsett, S. P., &amp; Wanner, G. (1993). &quot;Solving Ordinary\nDifferential Equations I: Nonstiff Problems&quot;. Springer Series in Computational\nMathematics, Vol. 8.</td></tr>\n</tbody>\n</table>\n</div>\n",
          "bases": [
            "ExplicitRungeKutta"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "signature": "(solver_args = (), solver_kwargs = {})",
              "parameters": [
                {
                  "name": "solver_args",
                  "type": null,
                  "default": "()",
                  "description": ""
                },
                {
                  "name": "solver_kwargs",
                  "type": null,
                  "default": "{}",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "interpolate",
              "description": "",
              "docstring_html": "",
              "signature": "(r, dt)",
              "parameters": [
                {
                  "name": "r",
                  "type": null,
                  "default": null,
                  "description": ""
                },
                {
                  "name": "dt",
                  "type": null,
                  "default": null,
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "s",
              "description": "",
              "type": null,
              "value": "4"
            },
            {
              "name": "n",
              "description": "",
              "type": null,
              "value": "4"
            },
            {
              "name": "eval_stages",
              "description": "",
              "type": null,
              "value": "[0.0, 0.5, 0.5, 1.0]"
            },
            {
              "name": "BT",
              "description": "",
              "type": null,
              "value": "{0: [1 / 2], 1: [0.0, 1 / 2], 2: [0.0, 0.0, 1.0], 3: [1 / 6, 2 / 6, 2 / 6, 1 / 6]}"
            }
          ],
          "parameters": [
            {
              "name": "solver_args",
              "type": null,
              "default": "()",
              "description": ""
            },
            {
              "name": "solver_kwargs",
              "type": null,
              "default": "{}",
              "description": ""
            }
          ]
        },
        {
          "name": "RKF21",
          "description": "Three-stage, 2nd order embedded Runge-Kutta-Fehlberg method.",
          "docstring_html": "<p>Three-stage, 2nd order embedded Runge-Kutta-Fehlberg method.</p>\n<p>Features an embedded 1st order method for adaptive step size control. This is a\nclassic low-order adaptive method. The three stages make it computationally cheap,\nbut the low order limits accuracy. The error estimate is also less accurate than\nhigher-order methods.</p>\n<div class=\"section\" id=\"characteristics\">\n<h4>Characteristics</h4>\n<ul class=\"simple\">\n<li>Order: 2 (Propagating solution)</li>\n<li>Embedded Order: 1 (Error estimation)</li>\n<li>Stages: 3</li>\n<li>Explicit</li>\n<li>Adaptive timestep</li>\n<li>Efficient but low accuracy</li>\n</ul>\n</div>\n<div class=\"section\" id=\"when-to-use\">\n<h4>When to Use</h4>\n<ul class=\"simple\">\n<li><strong>Computationally cheap adaptive stepping</strong>: When you need some adaptive control but minimal cost</li>\n<li><strong>Coarse integration</strong>: Problems where high accuracy is not required</li>\n<li><strong>Event detection</strong>: When timestep is limited by events rather than truncation error</li>\n<li><strong>Initial exploration</strong>: Quick preliminary runs before using higher-order methods</li>\n</ul>\n</div>\n<div class=\"section\" id=\"note\">\n<h4>Note</h4>\n<p>Low accuracy. For most applications requiring adaptive stepping, RKBS32 or RKDP54 are\nbetter choices.</p>\n<p><strong>References</strong></p>\n<table class=\"docutils footnote\" frame=\"void\" id=\"footnote-1\" rules=\"none\">\n<colgroup><col class=\"label\" /><col /></colgroup>\n<tbody valign=\"top\">\n<tr><td class=\"label\">[1]</td><td>Fehlberg, E. (1969). &quot;Low-order classical Runge-Kutta formulas with stepsize\ncontrol and their application to some heat transfer problems&quot;. NASA Technical\nReport TR R-315.</td></tr>\n</tbody>\n</table>\n<table class=\"docutils footnote\" frame=\"void\" id=\"footnote-2\" rules=\"none\">\n<colgroup><col class=\"label\" /><col /></colgroup>\n<tbody valign=\"top\">\n<tr><td class=\"label\">[2]</td><td>Hairer, E., Nørsett, S. P., &amp; Wanner, G. (1993). &quot;Solving Ordinary\nDifferential Equations I: Nonstiff Problems&quot;. Springer Series in Computational\nMathematics, Vol. 8.</td></tr>\n</tbody>\n</table>\n</div>\n",
          "bases": [
            "ExplicitRungeKutta"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "signature": "(solver_args = (), solver_kwargs = {})",
              "parameters": [
                {
                  "name": "solver_args",
                  "type": null,
                  "default": "()",
                  "description": ""
                },
                {
                  "name": "solver_kwargs",
                  "type": null,
                  "default": "{}",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "s",
              "description": "",
              "type": null,
              "value": "3"
            },
            {
              "name": "n",
              "description": "",
              "type": null,
              "value": "2"
            },
            {
              "name": "m",
              "description": "",
              "type": null,
              "value": "1"
            },
            {
              "name": "is_adaptive",
              "description": "",
              "type": null,
              "value": "True"
            },
            {
              "name": "eval_stages",
              "description": "",
              "type": null,
              "value": "[0.0, 1 / 2, 1]"
            },
            {
              "name": "BT",
              "description": "",
              "type": null,
              "value": "{0: [1 / 2], 1: [1 / 256, 255 / 256], 2: [1 / 512, 255 / 256, 1 / 512]}"
            },
            {
              "name": "TR",
              "description": "",
              "type": null,
              "value": "[1 / 512, 0, -1 / 512]"
            }
          ],
          "parameters": [
            {
              "name": "solver_args",
              "type": null,
              "default": "()",
              "description": ""
            },
            {
              "name": "solver_kwargs",
              "type": null,
              "default": "{}",
              "description": ""
            }
          ]
        },
        {
          "name": "RKBS32",
          "description": "Four-stage, 3rd order explicit Runge-Kutta method by Bogacki and Shampine.",
          "docstring_html": "<p>Four-stage, 3rd order explicit Runge-Kutta method by Bogacki and Shampine.</p>\n<p>Features an embedded 2nd order method for adaptive step size control with FSAL\n(First Same As Last) property. The 3rd order result is used for propagation.\nCommonly used in software packages (e.g., MATLAB's ode23). Good for problems\nrequiring low to moderate accuracy with efficiency.</p>\n<div class=\"section\" id=\"characteristics\">\n<h4>Characteristics</h4>\n<ul class=\"simple\">\n<li>Order: 3 (Propagating solution)</li>\n<li>Embedded Order: 2 (Error estimation)</li>\n<li>Stages: 4 (3 effective due to FSAL)</li>\n<li>Explicit</li>\n<li>Adaptive timestep</li>\n<li>Efficient low-to-moderate accuracy solver</li>\n</ul>\n</div>\n<div class=\"section\" id=\"when-to-use\">\n<h4>When to Use</h4>\n<ul class=\"simple\">\n<li><strong>Low-to-moderate accuracy needs</strong>: When stringent accuracy is not required</li>\n<li><strong>Efficiency-focused applications</strong>: Cheaper than 5th order methods</li>\n<li><strong>Smooth non-stiff problems</strong>: Well-suited for mildly nonlinear problems</li>\n<li><strong>Default low-order adaptive solver</strong>: Good general-purpose choice for less demanding problems</li>\n</ul>\n</div>\n<div class=\"section\" id=\"note\">\n<h4>Note</h4>\n<p>More efficient than 5th order methods but less accurate. For higher\naccuracy requirements, use RKDP54 or RKCK54. Nonetheless a good default\nexplicit adaptive timestep solver.</p>\n<p><strong>References</strong></p>\n<table class=\"docutils footnote\" frame=\"void\" id=\"footnote-1\" rules=\"none\">\n<colgroup><col class=\"label\" /><col /></colgroup>\n<tbody valign=\"top\">\n<tr><td class=\"label\">[1]</td><td>Bogacki, P., &amp; Shampine, L. F. (1989). &quot;A 3(2) pair of Runge-Kutta formulas&quot;.\nApplied Mathematics Letters, 2(4), 321-325.</td></tr>\n</tbody>\n</table>\n<table class=\"docutils footnote\" frame=\"void\" id=\"footnote-2\" rules=\"none\">\n<colgroup><col class=\"label\" /><col /></colgroup>\n<tbody valign=\"top\">\n<tr><td class=\"label\">[2]</td><td>Shampine, L. F., &amp; Reichelt, M. W. (1997). &quot;The MATLAB ODE Suite&quot;.\nSIAM Journal on Scientific Computing, 18(1), 1-22.</td></tr>\n</tbody>\n</table>\n<table class=\"docutils footnote\" frame=\"void\" id=\"footnote-3\" rules=\"none\">\n<colgroup><col class=\"label\" /><col /></colgroup>\n<tbody valign=\"top\">\n<tr><td class=\"label\">[3]</td><td>Hairer, E., Nørsett, S. P., &amp; Wanner, G. (1993). &quot;Solving Ordinary\nDifferential Equations I: Nonstiff Problems&quot;. Springer Series in Computational\nMathematics, Vol. 8.</td></tr>\n</tbody>\n</table>\n</div>\n",
          "bases": [
            "ExplicitRungeKutta"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "signature": "(solver_args = (), solver_kwargs = {})",
              "parameters": [
                {
                  "name": "solver_args",
                  "type": null,
                  "default": "()",
                  "description": ""
                },
                {
                  "name": "solver_kwargs",
                  "type": null,
                  "default": "{}",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "s",
              "description": "",
              "type": null,
              "value": "4"
            },
            {
              "name": "n",
              "description": "",
              "type": null,
              "value": "3"
            },
            {
              "name": "m",
              "description": "",
              "type": null,
              "value": "2"
            },
            {
              "name": "is_adaptive",
              "description": "",
              "type": null,
              "value": "True"
            },
            {
              "name": "eval_stages",
              "description": "",
              "type": null,
              "value": "[0.0, 1 / 2, 3 / 4, 1.0]"
            },
            {
              "name": "BT",
              "description": "",
              "type": null,
              "value": "{0: [1 / 2], 1: [0.0, 3 / 4], 2: [2 / 9, 1 / 3, 4 / 9], 3: [2 / 9, 1 / 3, 4 / 9]}"
            },
            {
              "name": "TR",
              "description": "",
              "type": null,
              "value": "[-5 / 72, 1 / 12, 1 / 9, -1 / 8]"
            }
          ],
          "parameters": [
            {
              "name": "solver_args",
              "type": null,
              "default": "()",
              "description": ""
            },
            {
              "name": "solver_kwargs",
              "type": null,
              "default": "{}",
              "description": ""
            }
          ]
        },
        {
          "name": "RKF45",
          "description": "Six-stage, 4th order explicit Runge-Kutta-Fehlberg method.",
          "docstring_html": "<p>Six-stage, 4th order explicit Runge-Kutta-Fehlberg method.</p>\n<p>Features an embedded 5th order method. The difference between the 5th and 4th order\nresults provides a 5th order error estimate. Typically, the 4th order solution is\npropagated (local extrapolation available). A classic adaptive step size method,\nthough often superseded in efficiency by Dormand-Prince methods.</p>\n<div class=\"section\" id=\"characteristics\">\n<h4>Characteristics</h4>\n<ul class=\"simple\">\n<li>Order: 4 (Propagating solution)</li>\n<li>Embedded Order: 5 (Error estimation)</li>\n<li>Stages: 6</li>\n<li>Explicit</li>\n<li>Adaptive timestep</li>\n<li>Classic adaptive method, good for moderate accuracy</li>\n</ul>\n</div>\n<div class=\"section\" id=\"when-to-use\">\n<h4>When to Use</h4>\n<ul class=\"simple\">\n<li><strong>Moderate accuracy requirements</strong>: Good balance for many engineering applications</li>\n<li><strong>Well-established benchmarks</strong>: When comparing against historical results</li>\n<li><strong>Non-stiff smooth problems</strong>: Standard choice for a wide range of ODEs</li>\n</ul>\n</div>\n<div class=\"section\" id=\"note\">\n<h4>Note</h4>\n<p>While this is a classic method, RKDP54 or RKCK54 generally offer better efficiency\nfor the same computational cost. Consider RKDP54 or RKCK54 for new applications unless\nspecific properties of RKF45 are required.</p>\n<p><strong>References</strong></p>\n<table class=\"docutils footnote\" frame=\"void\" id=\"footnote-1\" rules=\"none\">\n<colgroup><col class=\"label\" /><col /></colgroup>\n<tbody valign=\"top\">\n<tr><td class=\"label\">[1]</td><td>Fehlberg, E. (1969). &quot;Low-order classical Runge-Kutta formulas with stepsize\ncontrol and their application to some heat transfer problems&quot;. NASA Technical\nReport TR R-315.</td></tr>\n</tbody>\n</table>\n<table class=\"docutils footnote\" frame=\"void\" id=\"footnote-2\" rules=\"none\">\n<colgroup><col class=\"label\" /><col /></colgroup>\n<tbody valign=\"top\">\n<tr><td class=\"label\">[2]</td><td>Fehlberg, E. (1970). &quot;Klassische Runge-Kutta-Formeln vierter und niedrigerer\nOrdnung mit Schrittweiten-Kontrolle und ihre Anwendung auf Wärmeleitungsprobleme&quot;.\nComputing, 6(1-2), 61-71.</td></tr>\n</tbody>\n</table>\n<table class=\"docutils footnote\" frame=\"void\" id=\"footnote-3\" rules=\"none\">\n<colgroup><col class=\"label\" /><col /></colgroup>\n<tbody valign=\"top\">\n<tr><td class=\"label\">[3]</td><td>Hairer, E., Nørsett, S. P., &amp; Wanner, G. (1993). &quot;Solving Ordinary\nDifferential Equations I: Nonstiff Problems&quot;. Springer Series in Computational\nMathematics, Vol. 8.</td></tr>\n</tbody>\n</table>\n</div>\n",
          "bases": [
            "ExplicitRungeKutta"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "signature": "(solver_args = (), solver_kwargs = {})",
              "parameters": [
                {
                  "name": "solver_args",
                  "type": null,
                  "default": "()",
                  "description": ""
                },
                {
                  "name": "solver_kwargs",
                  "type": null,
                  "default": "{}",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "s",
              "description": "",
              "type": null,
              "value": "6"
            },
            {
              "name": "n",
              "description": "",
              "type": null,
              "value": "5"
            },
            {
              "name": "m",
              "description": "",
              "type": null,
              "value": "4"
            },
            {
              "name": "is_adaptive",
              "description": "",
              "type": null,
              "value": "True"
            },
            {
              "name": "eval_stages",
              "description": "",
              "type": null,
              "value": "[0.0, 1 / 4, 3 / 8, 12 / 13, 1, 1 / 2]"
            },
            {
              "name": "BT",
              "description": "",
              "type": null,
              "value": "{0: [1 / 4], 1: [3 / 32, 9 / 32], 2: [1932 / 2197, -7200 / 2197, 7296 / 2197], 3: [439 / 216, -8, 3680 / 513, -845 / 4104], 4: [-8 / 27, 2, -3554 / 2565, 1859 / 4104, -11 / 40], 5: [25 / 216, 0, 1408 / 2565, 2197 / 4104, -1 / 5, 0]}"
            },
            {
              "name": "TR",
              "description": "",
              "type": null,
              "value": "[1 / 360, 0, -128 / 4275, -2197 / 75240, 1 / 50, 2 / 55]"
            }
          ],
          "parameters": [
            {
              "name": "solver_args",
              "type": null,
              "default": "()",
              "description": ""
            },
            {
              "name": "solver_kwargs",
              "type": null,
              "default": "{}",
              "description": ""
            }
          ]
        },
        {
          "name": "RKCK54",
          "description": "Six-stage, 5th order explicit Runge-Kutta method by Cash and Karp.",
          "docstring_html": "<p>Six-stage, 5th order explicit Runge-Kutta method by Cash and Karp.</p>\n<p>Features an embedded 4th order method. The difference between the 5th and 4th order\nresults provides a 5th order error estimate, typically used to control the step size\nwhile propagating the 5th order solution (local extrapolation). Known for better\nstability properties compared to RKF45.</p>\n<div class=\"section\" id=\"characteristics\">\n<h4>Characteristics</h4>\n<ul class=\"simple\">\n<li>Order: 5 (Propagating solution)</li>\n<li>Embedded Order: 4</li>\n<li>Stages: 6</li>\n<li>Explicit</li>\n<li>Adaptive timestep</li>\n<li>Good stability, suitable for moderate-to-high accuracy requirements</li>\n</ul>\n</div>\n<div class=\"section\" id=\"when-to-use\">\n<h4>When to Use</h4>\n<ul class=\"simple\">\n<li><strong>Improved stability over RKF45</strong>: When RKF45 exhibits stability issues</li>\n<li><strong>Moderate-to-high accuracy needs</strong>: 5th order for better accuracy than 3rd order methods</li>\n<li><strong>Non-stiff problems</strong>: Excellent for smooth, non-stiff ODEs</li>\n<li><strong>Alternative to RKDP54</strong>: Similar performance, sometimes better for specific problems</li>\n</ul>\n</div>\n<div class=\"section\" id=\"note\">\n<h4>Note</h4>\n<p>RKDP54 is generally more efficient when first-same-as-last (FSAL) property is implemented\n(which it currently is not!), but RKCK54 can have better stability for certain problems.\nBoth are excellent 5th order adaptive methods.</p>\n<p><strong>References</strong></p>\n<table class=\"docutils footnote\" frame=\"void\" id=\"footnote-1\" rules=\"none\">\n<colgroup><col class=\"label\" /><col /></colgroup>\n<tbody valign=\"top\">\n<tr><td class=\"label\">[1]</td><td>Cash, J. R., &amp; Karp, A. H. (1990). &quot;A variable order Runge-Kutta method for\ninitial value problems with rapidly varying right-hand sides&quot;. ACM Transactions\non Mathematical Software, 16(3), 201-222.</td></tr>\n</tbody>\n</table>\n<table class=\"docutils footnote\" frame=\"void\" id=\"footnote-2\" rules=\"none\">\n<colgroup><col class=\"label\" /><col /></colgroup>\n<tbody valign=\"top\">\n<tr><td class=\"label\">[2]</td><td>Press, W. H., Teukolsky, S. A., Vetterling, W. T., &amp; Flannery, B. P. (2007).\n&quot;Numerical Recipes: The Art of Scientific Computing&quot; (3rd ed.). Cambridge\nUniversity Press.</td></tr>\n</tbody>\n</table>\n<table class=\"docutils footnote\" frame=\"void\" id=\"footnote-3\" rules=\"none\">\n<colgroup><col class=\"label\" /><col /></colgroup>\n<tbody valign=\"top\">\n<tr><td class=\"label\">[3]</td><td>Hairer, E., Nørsett, S. P., &amp; Wanner, G. (1993). &quot;Solving Ordinary\nDifferential Equations I: Nonstiff Problems&quot;. Springer Series in Computational\nMathematics, Vol. 8.</td></tr>\n</tbody>\n</table>\n</div>\n",
          "bases": [
            "ExplicitRungeKutta"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "signature": "(solver_args = (), solver_kwargs = {})",
              "parameters": [
                {
                  "name": "solver_args",
                  "type": null,
                  "default": "()",
                  "description": ""
                },
                {
                  "name": "solver_kwargs",
                  "type": null,
                  "default": "{}",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "s",
              "description": "",
              "type": null,
              "value": "6"
            },
            {
              "name": "n",
              "description": "",
              "type": null,
              "value": "5"
            },
            {
              "name": "m",
              "description": "",
              "type": null,
              "value": "4"
            },
            {
              "name": "is_adaptive",
              "description": "",
              "type": null,
              "value": "True"
            },
            {
              "name": "eval_stages",
              "description": "",
              "type": null,
              "value": "[0.0, 1 / 5, 3 / 10, 3 / 5, 1, 7 / 8]"
            },
            {
              "name": "BT",
              "description": "",
              "type": null,
              "value": "{0: [1 / 5], 1: [3 / 40, 9 / 40], 2: [3 / 10, -9 / 10, 6 / 5], 3: [-11 / 54, 5 / 2, -70 / 27, 35 / 27], 4: [1631 / 55296, 175 / 512, 575 / 13824, 44275 / 110592, 253 / 4096], 5: [37 / 378, 0, 250 / 621, 125 / 594, 0, 512 / 1771]}"
            },
            {
              "name": "TR",
              "description": "",
              "type": null,
              "value": "[-277 / 64512, 0, 6925 / 370944, -6925 / 202752, -277 / 14336, 277 / 7084]"
            }
          ],
          "parameters": [
            {
              "name": "solver_args",
              "type": null,
              "default": "()",
              "description": ""
            },
            {
              "name": "solver_kwargs",
              "type": null,
              "default": "{}",
              "description": ""
            }
          ]
        },
        {
          "name": "RKDP54",
          "description": "Seven-stage, 5th order explicit Runge-Kutta method by Dormand and Prince (DOPRI5).",
          "docstring_html": "<p>Seven-stage, 5th order explicit Runge-Kutta method by Dormand and Prince (DOPRI5).</p>\n<p>Features an embedded 4th order method. Widely considered one of the most efficient\ngeneral-purpose adaptive step size solvers for non-stiff problems requiring moderate\nto high accuracy. The 5th order result is used for propagation. Used as the basis for\nMATLAB's ode45. FSAL property (not available in this implementation).</p>\n<div class=\"section\" id=\"characteristics\">\n<h4>Characteristics</h4>\n<ul class=\"simple\">\n<li>Order: 5 (Propagating solution)</li>\n<li>Embedded Order: 4</li>\n<li>Stages: 7 (6 effective due to FSAL, not here though)</li>\n<li>Explicit</li>\n<li>Adaptive timestep</li>\n<li>Industry-standard adaptive solver</li>\n</ul>\n</div>\n<div class=\"section\" id=\"when-to-use\">\n<h4>When to Use</h4>\n<ul class=\"simple\">\n<li><strong>Default adaptive solver</strong>: Excellent first choice for most non-stiff problems</li>\n<li><strong>Moderate-to-high accuracy</strong>: 5th order provides good accuracy efficiently</li>\n<li><strong>General-purpose integration</strong>: Reliable for a wide variety of ODE systems</li>\n<li><strong>Industry standard</strong>: Well-tested and widely used in production software</li>\n</ul>\n</div>\n<div class=\"section\" id=\"note\">\n<h4>Note</h4>\n<p>Recommended as the primary adaptive solver for non-stiff problems. For stiff\nproblems, use BDF or ESDIRK methods. For very high accuracy, consider RKV65 or RKDP87.</p>\n<p><strong>References</strong></p>\n<table class=\"docutils footnote\" frame=\"void\" id=\"footnote-1\" rules=\"none\">\n<colgroup><col class=\"label\" /><col /></colgroup>\n<tbody valign=\"top\">\n<tr><td class=\"label\">[1]</td><td>Dormand, J. R., &amp; Prince, P. J. (1980). &quot;A family of embedded Runge-Kutta\nformulae&quot;. Journal of Computational and Applied Mathematics, 6(1), 19-26.</td></tr>\n</tbody>\n</table>\n<table class=\"docutils footnote\" frame=\"void\" id=\"footnote-2\" rules=\"none\">\n<colgroup><col class=\"label\" /><col /></colgroup>\n<tbody valign=\"top\">\n<tr><td class=\"label\">[2]</td><td>Shampine, L. F., &amp; Reichelt, M. W. (1997). &quot;The MATLAB ODE Suite&quot;.\nSIAM Journal on Scientific Computing, 18(1), 1-22.</td></tr>\n</tbody>\n</table>\n<table class=\"docutils footnote\" frame=\"void\" id=\"footnote-3\" rules=\"none\">\n<colgroup><col class=\"label\" /><col /></colgroup>\n<tbody valign=\"top\">\n<tr><td class=\"label\">[3]</td><td>Hairer, E., Nørsett, S. P., &amp; Wanner, G. (1993). &quot;Solving Ordinary\nDifferential Equations I: Nonstiff Problems&quot;. Springer Series in Computational\nMathematics, Vol. 8.</td></tr>\n</tbody>\n</table>\n</div>\n",
          "bases": [
            "ExplicitRungeKutta"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "signature": "(solver_args = (), solver_kwargs = {})",
              "parameters": [
                {
                  "name": "solver_args",
                  "type": null,
                  "default": "()",
                  "description": ""
                },
                {
                  "name": "solver_kwargs",
                  "type": null,
                  "default": "{}",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "s",
              "description": "",
              "type": null,
              "value": "7"
            },
            {
              "name": "n",
              "description": "",
              "type": null,
              "value": "5"
            },
            {
              "name": "m",
              "description": "",
              "type": null,
              "value": "4"
            },
            {
              "name": "is_adaptive",
              "description": "",
              "type": null,
              "value": "True"
            },
            {
              "name": "eval_stages",
              "description": "",
              "type": null,
              "value": "[0.0, 1 / 5, 3 / 10, 4 / 5, 8 / 9, 1.0, 1.0]"
            },
            {
              "name": "BT",
              "description": "",
              "type": null,
              "value": "{0: [1 / 5], 1: [3 / 40, 9 / 40], 2: [44 / 45, -56 / 15, 32 / 9], 3: [19372 / 6561, -25360 / 2187, 64448 / 6561, -212 / 729], 4: [9017 / 3168, -355 / 33, 46732 / 5247, 49 / 176, -5103 / 18656], 5: [35 / 384, 0, 500 / 1113, 125 / 192, -2187 / 6784, 11 / 84], 6: [35 / 384, 0, 500 / 1113, 125 / 192, -2187 / 6784, 11 / 84]}"
            },
            {
              "name": "TR",
              "description": "",
              "type": null,
              "value": "[71 / 57600, 0, -71 / 16695, 71 / 1920, -17253 / 339200, 22 / 525, -1 / 40]"
            }
          ],
          "parameters": [
            {
              "name": "solver_args",
              "type": null,
              "default": "()",
              "description": ""
            },
            {
              "name": "solver_kwargs",
              "type": null,
              "default": "{}",
              "description": ""
            }
          ]
        },
        {
          "name": "RKV65",
          "description": "Nine-stage, 6th order explicit Runge-Kutta method by Verner.",
          "docstring_html": "<p>Nine-stage, 6th order explicit Runge-Kutta method by Verner.</p>\n<p>Features an embedded 5th order method for adaptive step size control. This is the\n'most robust' 9-stage 6(5) pair from Jim Verner's collection, designed for efficient\nhigh-accuracy integration of non-stiff problems. Offers better accuracy than 5th\norder methods while being more efficient than 8th order methods.</p>\n<div class=\"section\" id=\"characteristics\">\n<h4>Characteristics</h4>\n<ul class=\"simple\">\n<li>Order: 6 (Propagating solution)</li>\n<li>Embedded Order: 5</li>\n<li>Stages: 9</li>\n<li>Explicit</li>\n<li>Adaptive timestep</li>\n<li>Efficient high-order method for non-stiff problems</li>\n</ul>\n</div>\n<div class=\"section\" id=\"when-to-use\">\n<h4>When to Use</h4>\n<ul class=\"simple\">\n<li><strong>High-accuracy requirements</strong>: When 5th order is insufficient but 8th order is overkill</li>\n<li><strong>Smooth non-stiff problems</strong>: Excellent for problems with smooth solutions</li>\n<li><strong>Stringent error tolerances</strong>: When tight tolerances are needed efficiently</li>\n<li><strong>Scientific computing</strong>: Common in astronomical and molecular dynamics simulations</li>\n</ul>\n</div>\n<div class=\"section\" id=\"note\">\n<h4>Note</h4>\n<p>More expensive per step than 5th order methods, but can take larger steps for the same\naccuracy. For very high accuracy, consider RKF78 or RKDP87.</p>\n<p><strong>References</strong></p>\n<table class=\"docutils footnote\" frame=\"void\" id=\"footnote-1\" rules=\"none\">\n<colgroup><col class=\"label\" /><col /></colgroup>\n<tbody valign=\"top\">\n<tr><td class=\"label\">[1]</td><td>Verner, J. H. (2010). &quot;Numerically optimal Runge-Kutta pairs with interpolants&quot;.\nNumerical Algorithms, 53(2-3), 383-396.</td></tr>\n</tbody>\n</table>\n<table class=\"docutils footnote\" frame=\"void\" id=\"footnote-2\" rules=\"none\">\n<colgroup><col class=\"label\" /><col /></colgroup>\n<tbody valign=\"top\">\n<tr><td class=\"label\">[2]</td><td>Verner's Refuge for Runge-Kutta Pairs: <a class=\"reference external\" href=\"https://www.sfu.ca/~jverner/\">https://www.sfu.ca/~jverner/</a></td></tr>\n</tbody>\n</table>\n<table class=\"docutils footnote\" frame=\"void\" id=\"footnote-3\" rules=\"none\">\n<colgroup><col class=\"label\" /><col /></colgroup>\n<tbody valign=\"top\">\n<tr><td class=\"label\">[3]</td><td>Hairer, E., Nørsett, S. P., &amp; Wanner, G. (1993). &quot;Solving Ordinary\nDifferential Equations I: Nonstiff Problems&quot;. Springer Series in Computational\nMathematics, Vol. 8.</td></tr>\n</tbody>\n</table>\n</div>\n",
          "bases": [
            "ExplicitRungeKutta"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "signature": "(solver_args = (), solver_kwargs = {})",
              "parameters": [
                {
                  "name": "solver_args",
                  "type": null,
                  "default": "()",
                  "description": ""
                },
                {
                  "name": "solver_kwargs",
                  "type": null,
                  "default": "{}",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "s",
              "description": "",
              "type": null,
              "value": "9"
            },
            {
              "name": "n",
              "description": "",
              "type": null,
              "value": "6"
            },
            {
              "name": "m",
              "description": "",
              "type": null,
              "value": "5"
            },
            {
              "name": "is_adaptive",
              "description": "",
              "type": null,
              "value": "True"
            },
            {
              "name": "eval_stages",
              "description": "",
              "type": null,
              "value": "[0.0, 9 / 50, 1 / 6, 1 / 4, 53 / 100, 3 / 5, 4 / 5, 1.0, 1.0]"
            },
            {
              "name": "BT",
              "description": "",
              "type": null,
              "value": "{0: [9 / 50], 1: [29 / 324, 25 / 324], 2: [1 / 16, 0, 3 / 16], 3: [79129 / 250000, 0, -261237 / 250000, 19663 / 15625], 4: [1336883 / 4909125, 0, -25476 / 30875, 194159 / 185250, 8225 / 78546], 5: [-2459386 / 14727375, 0, 19504 / 30875, 2377474 / 13615875, -6157250 / 5773131, 902 / 735], 6: [2699 / 7410, 0, -252 / 1235, -1393253 / 3993990, 236875 / 72618, -135 / 49, 15 / 22], 7: [11 / 144, 0, 0, 256 / 693, 0, 125 / 504, 125 / 528, 5 / 72], 8: [11 / 144, 0, 0, 256 / 693, 0, 125 / 504, 125 / 528, 5 / 72]}"
            },
            {
              "name": "TR",
              "description": "",
              "type": null,
              "value": "[(a - b) for a, b in (zip(_A1, _A2))]"
            }
          ],
          "parameters": [
            {
              "name": "solver_args",
              "type": null,
              "default": "()",
              "description": ""
            },
            {
              "name": "solver_kwargs",
              "type": null,
              "default": "{}",
              "description": ""
            }
          ]
        },
        {
          "name": "RKF78",
          "description": "Thirteen-stage, 7th order explicit Runge-Kutta-Fehlberg method.",
          "docstring_html": "<p>Thirteen-stage, 7th order explicit Runge-Kutta-Fehlberg method.</p>\n<p>Features an embedded 8th order method for error estimation. The difference provides\nan 8th order error estimate. The 7th order solution is typically propagated. Designed\nfor very high accuracy requirements and long-time integration where precision is critical.</p>\n<div class=\"section\" id=\"characteristics\">\n<h4>Characteristics</h4>\n<ul class=\"simple\">\n<li>Order: 7 (Propagating solution)</li>\n<li>Embedded Order: 8 (Error estimation)</li>\n<li>Stages: 13</li>\n<li>Explicit</li>\n<li>Adaptive timestep</li>\n<li>Very high accuracy, nearly symplectic properties</li>\n</ul>\n</div>\n<div class=\"section\" id=\"when-to-use\">\n<h4>When to Use</h4>\n<ul class=\"simple\">\n<li><strong>Very high accuracy needs</strong>: When stringent error tolerances are essential</li>\n<li><strong>Long-time integration</strong>: Problems requiring stable, accurate integration over long periods</li>\n<li><strong>Smooth dynamics</strong>: Highly smooth problems where high order is efficient</li>\n<li><strong>Scientific precision</strong>: Astronomical calculations, molecular dynamics, precision engineering</li>\n</ul>\n</div>\n<div class=\"section\" id=\"note\">\n<h4>Note</h4>\n<p>Expensive per step (13 stages), but can take very large steps with tight tolerances.\nNot suitable for non-smooth problems or when function evaluations are expensive.</p>\n<p><strong>References</strong></p>\n<table class=\"docutils footnote\" frame=\"void\" id=\"footnote-1\" rules=\"none\">\n<colgroup><col class=\"label\" /><col /></colgroup>\n<tbody valign=\"top\">\n<tr><td class=\"label\">[1]</td><td>Fehlberg, E. (1968). &quot;Classical fifth-, sixth-, seventh-, and eighth-order\nRunge-Kutta formulas with stepsize control&quot;. NASA Technical Report TR R-287.</td></tr>\n</tbody>\n</table>\n<table class=\"docutils footnote\" frame=\"void\" id=\"footnote-2\" rules=\"none\">\n<colgroup><col class=\"label\" /><col /></colgroup>\n<tbody valign=\"top\">\n<tr><td class=\"label\">[2]</td><td>Hairer, E., Nørsett, S. P., &amp; Wanner, G. (1993). &quot;Solving Ordinary\nDifferential Equations I: Nonstiff Problems&quot;. Springer Series in Computational\nMathematics, Vol. 8.</td></tr>\n</tbody>\n</table>\n<table class=\"docutils footnote\" frame=\"void\" id=\"footnote-3\" rules=\"none\">\n<colgroup><col class=\"label\" /><col /></colgroup>\n<tbody valign=\"top\">\n<tr><td class=\"label\">[3]</td><td>Prince, P. J., &amp; Dormand, J. R. (1981). &quot;High order embedded Runge-Kutta\nformulae&quot;. Journal of Computational and Applied Mathematics, 7(1), 67-75.</td></tr>\n</tbody>\n</table>\n</div>\n",
          "bases": [
            "ExplicitRungeKutta"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "signature": "(solver_args = (), solver_kwargs = {})",
              "parameters": [
                {
                  "name": "solver_args",
                  "type": null,
                  "default": "()",
                  "description": ""
                },
                {
                  "name": "solver_kwargs",
                  "type": null,
                  "default": "{}",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "s",
              "description": "",
              "type": null,
              "value": "13"
            },
            {
              "name": "n",
              "description": "",
              "type": null,
              "value": "7"
            },
            {
              "name": "m",
              "description": "",
              "type": null,
              "value": "8"
            },
            {
              "name": "is_adaptive",
              "description": "",
              "type": null,
              "value": "True"
            },
            {
              "name": "eval_stages",
              "description": "",
              "type": null,
              "value": "[0, 2 / 27, 1 / 9, 1 / 6, 5 / 12, 1 / 2, 5 / 6, 1 / 6, 2 / 3, 1 / 3, 1, 0, 1]"
            },
            {
              "name": "BT",
              "description": "",
              "type": null,
              "value": "{0: [2 / 27], 1: [1 / 36, 1 / 12], 2: [1 / 24, 0, 1 / 8], 3: [5 / 12, 0, -25 / 16, 25 / 16], 4: [1 / 20, 0, 0, 1 / 4, 1 / 5], 5: [-25 / 108, 0, 0, 125 / 108, -65 / 27, 125 / 54], 6: [31 / 300, 0, 0, 0, 61 / 225, -2 / 9, 13 / 900], 7: [2, 0, 0, -53 / 6, 704 / 45, -107 / 9, 67 / 90, 3], 8: [-91 / 108, 0, 0, 23 / 108, -976 / 135, 311 / 54, -19 / 60, 17 / 6, -1 / 12], 9: [2383 / 4100, 0, 0, -341 / 164, 4496 / 1025, -301 / 82, 2133 / 4100, 45 / 82, 45 / 164, 18 / 41], 10: [3 / 205, 0, 0, 0, 0, -6 / 41, -3 / 205, -3 / 41, 3 / 41, 6 / 41], 11: [-1777 / 4100, 0, 0, -341 / 164, 4496 / 1025, -289 / 82, 2193 / 4100, 51 / 82, 33 / 164, 12 / 41, 0, 1], 12: [41 / 840, 0, 0, 0, 0, 34 / 105, 9 / 35, 9 / 35, 9 / 280, 9 / 280, 41 / 840]}"
            },
            {
              "name": "TR",
              "description": "",
              "type": null,
              "value": "[41 / 840, 0, 0, 0, 0, 0, 0, 0, 0, 0, 41 / 840, -41 / 840, -41 / 840]"
            }
          ],
          "parameters": [
            {
              "name": "solver_args",
              "type": null,
              "default": "()",
              "description": ""
            },
            {
              "name": "solver_kwargs",
              "type": null,
              "default": "{}",
              "description": ""
            }
          ]
        },
        {
          "name": "RKDP87",
          "description": "Thirteen-stage, 8th order explicit Runge-Kutta method by Dormand and Prince (DOP853).",
          "docstring_html": "<p>Thirteen-stage, 8th order explicit Runge-Kutta method by Dormand and Prince (DOP853).</p>\n<p>Features an embedded 7th order method for adaptive step size control. Designed for\nproblems requiring very high accuracy with excellent error estimation. This is one\nof the most efficient 8th order methods available. FSAL property (not available in\nthis implementation).</p>\n<div class=\"section\" id=\"characteristics\">\n<h4>Characteristics</h4>\n<ul class=\"simple\">\n<li>Order: 8 (Propagating solution)</li>\n<li>Embedded Order: 7</li>\n<li>Stages: 13 (12 effective due to FSAL)</li>\n<li>Explicit</li>\n<li>Adaptive timestep</li>\n<li>State-of-the-art very high-order solver</li>\n</ul>\n</div>\n<div class=\"section\" id=\"when-to-use\">\n<h4>When to Use</h4>\n<ul class=\"simple\">\n<li><strong>Extremely high accuracy</strong>: When very tight error tolerances are required</li>\n<li><strong>Smooth high-dimensional problems</strong>: Excellent for smooth ODEs in many dimensions</li>\n<li><strong>Long-time precision integration</strong>: Orbital mechanics, celestial mechanics</li>\n<li><strong>Benchmark computations</strong>: Reference solutions for method comparison</li>\n</ul>\n</div>\n<div class=\"section\" id=\"note\">\n<h4>Note</h4>\n<p>Generally recommended as the highest-order general-purpose explicit method. More\nefficient than RKF78 for the same accuracy level. Only use when very high accuracy\njustifies the 13-stage computational cost.</p>\n<p><strong>References</strong></p>\n<table class=\"docutils footnote\" frame=\"void\" id=\"footnote-1\" rules=\"none\">\n<colgroup><col class=\"label\" /><col /></colgroup>\n<tbody valign=\"top\">\n<tr><td class=\"label\">[1]</td><td>Dormand, J. R., &amp; Prince, P. J. (1981). &quot;High order embedded Runge-Kutta\nformulae&quot;. Journal of Computational and Applied Mathematics, 7(1), 67-75.</td></tr>\n</tbody>\n</table>\n<table class=\"docutils footnote\" frame=\"void\" id=\"footnote-2\" rules=\"none\">\n<colgroup><col class=\"label\" /><col /></colgroup>\n<tbody valign=\"top\">\n<tr><td class=\"label\">[2]</td><td>Hairer, E., Nørsett, S. P., &amp; Wanner, G. (1993). &quot;Solving Ordinary\nDifferential Equations I: Nonstiff Problems&quot;. Springer Series in Computational\nMathematics, Vol. 8.</td></tr>\n</tbody>\n</table>\n<table class=\"docutils footnote\" frame=\"void\" id=\"footnote-3\" rules=\"none\">\n<colgroup><col class=\"label\" /><col /></colgroup>\n<tbody valign=\"top\">\n<tr><td class=\"label\">[3]</td><td>Prince, P. J., &amp; Dormand, J. R. (1981). &quot;High order embedded Runge-Kutta\nformulae&quot;. Journal of Computational and Applied Mathematics, 7(1), 67-75.</td></tr>\n</tbody>\n</table>\n</div>\n",
          "bases": [
            "ExplicitRungeKutta"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "signature": "(solver_args = (), solver_kwargs = {})",
              "parameters": [
                {
                  "name": "solver_args",
                  "type": null,
                  "default": "()",
                  "description": ""
                },
                {
                  "name": "solver_kwargs",
                  "type": null,
                  "default": "{}",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "s",
              "description": "",
              "type": null,
              "value": "13"
            },
            {
              "name": "n",
              "description": "",
              "type": null,
              "value": "8"
            },
            {
              "name": "m",
              "description": "",
              "type": null,
              "value": "7"
            },
            {
              "name": "is_adaptive",
              "description": "",
              "type": null,
              "value": "True"
            },
            {
              "name": "eval_stages",
              "description": "",
              "type": null,
              "value": "[0.0, 1 / 18, 1 / 12, 1 / 8, 5 / 16, 3 / 8, 59 / 400, 93 / 200, 5490023248 / 9719169821, 13 / 20, 1201146811 / 1299019798, 1.0, 1.0]"
            },
            {
              "name": "BT",
              "description": "",
              "type": null,
              "value": "{0: [1 / 18], 1: [1 / 48, 1 / 16], 2: [1 / 32, 0, 3 / 32], 3: [5 / 16, 0, -75 / 64, 75 / 64], 4: [3 / 80, 0, 0, 3 / 16, 3 / 20], 5: [29443841 / 614563906, 0, 0, 77736538 / 692538347, -28693883 / 1125000000, 23124283 / 1800000000], 6: [16016141 / 946692911, 0, 0, 61564180 / 158732637, 22789713 / 633445777, 545815736 / 2771057229, -180193667 / 1043307555], 7: [39632708 / 573591083, 0, 0, -433636366 / 683701615, -421739975 / 2616292301, 100302831 / 723423059, 790204164 / 839813087, 800635310 / 3783071287], 8: [246121993 / 1340847787, 0, 0, -37695042795 / 15268766246, -309121744 / 1061227803, -12992083 / 490766935, 6005943493 / 2108947869, 393006217 / 1396673457, 123872331 / 1001029789], 9: [-1028468189 / 846180014, 0, 0, 8478235783 / 508512852, 1311729495 / 1432422823, -10304129995 / 1701304382, -48777925059 / 3047939560, 15336726248 / 1032824649, -45442868181 / 3398467696, 3065993473 / 597172653], 10: [185892177 / 718116043, 0, 0, -3185094517 / 667107341, -477755414 / 1098053517, -703635378 / 230739211, 5731566787 / 1027545527, 5232866602 / 850066563, -4093664535 / 808688257, 3962137247 / 1805957418, 65686358 / 487910083], 11: [403863854 / 491063109, 0, 0, -5068492393 / 434740067, -411421997 / 543043805, 652783627 / 914296604, 11173962825 / 925320556, -13158990841 / 6184727034, 3936647629 / 1978049680, -160528059 / 685178525, 248638103 / 1413531060, 0], 12: [14005451 / 335480064, 0, 0, 0, 0, -59238493 / 1068277825, 181606767 / 758867731, 561292985 / 797845732, -1041891430 / 1371343529, 760417239 / 1151165299, 118820643 / 751138087, -528747749 / 2220607170, 1 / 4]}"
            },
            {
              "name": "TR",
              "description": "",
              "type": null,
              "value": "[(a - b) for a, b in (zip(self.BT[12], bh))]"
            }
          ],
          "parameters": [
            {
              "name": "solver_args",
              "type": null,
              "default": "()",
              "description": ""
            },
            {
              "name": "solver_kwargs",
              "type": null,
              "default": "{}",
              "description": ""
            }
          ]
        }
      ],
      "functions": [
        {
          "name": "compute_bdf_coefficients",
          "description": "Computes the coefficients for backward differentiation formulas for a given order.",
          "docstring_html": "<p>Computes the coefficients for backward differentiation formulas for a given order.\nThe timesteps can be specified for variable timestep BDF methods.</p>\n<dl class=\"docutils\">\n<dt>For m-th order BDF we have for the n-th timestep:</dt>\n<dd>sum(alpha_i * x_i; i=n-m,...,n) = h_n * f_n(x_n, t_n)</dd>\n<dt>or</dt>\n<dd>x_n = beta * h_n * f_n(x_n, t_n) - sum(alpha_j * x_{n-1-j}; j=0,...,order-1)</dd>\n</dl>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>order <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>order of the integration scheme</dd>\n<dt>timesteps <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array[float]</span></dt>\n<dd>timestep buffer (h_{n-j}; j=0,...,order-1)</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>beta <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>weight for function</dd>\n<dt>alpha <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array[float]</span></dt>\n<dd>weights for previous solutions</dd>\n</dl>\n",
          "signature": "(order, timesteps)",
          "parameters": [
            {
              "name": "order",
              "type": null,
              "default": null,
              "description": "order of the integration scheme"
            },
            {
              "name": "timesteps",
              "type": null,
              "default": null,
              "description": "timestep buffer (h_{n-j}; j=0,...,order-1)"
            }
          ],
          "returns": null
        }
      ],
      "submodules": [
        "bdf",
        "dirk2",
        "dirk3",
        "esdirk32",
        "esdirk4",
        "esdirk43",
        "esdirk54",
        "esdirk85",
        "euler",
        "gear",
        "rk4",
        "rkbs32",
        "rkck54",
        "rkdp54",
        "rkdp87",
        "rkf21",
        "rkf45",
        "rkf78",
        "rkv65",
        "ssprk22",
        "ssprk33",
        "ssprk34",
        "steadystate"
      ]
    },
    "pathsim.events": {
      "name": "pathsim.events",
      "description": "",
      "docstring_html": "",
      "classes": [
        {
          "name": "Event",
          "description": "This is the base class of the event handling system.",
          "docstring_html": "<p>This is the base class of the event handling system.</p>\n<p>Monitors system state by evaluating an event function (func_evt) with scalar output.</p>\n<pre class=\"code literal-block\">\nfunc_evt(time) -&gt; event?\n</pre>\n<p>If an event is detected, some action (func_act) is performed on the states of the blocks.</p>\n<pre class=\"code literal-block\">\nfunc_evt(time) == True -&gt; event -&gt; func_act(time)\n</pre>\n<p>The methods are structured such that event detection can be separated from event\nresolution. This is required for adaptive timestep solvers to approach the event\nand only resolve it when the event tolerance ('tolerance') is satisfied.</p>\n<p>If no action function (func_act) is specified, the event will only be detected but other\nthan that, no action will be triggered. For general state monitoring.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>func_evt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">callable</span></dt>\n<dd>event function, where zeros are events</dd>\n<dt>func_act <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">callable</span></dt>\n<dd>action function for event resolution</dd>\n<dt>tolerance <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>tolerance to check if detection is close to actual event</dd>\n</dl>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>_history <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">tuple[None, float], tuple[float, float], tuple[bool, float]</span></dt>\n<dd>history of event function evaluation after buffering</dd>\n<dt>_times <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">list[float]</span></dt>\n<dd>tracking the event times</dd>\n<dt>_active <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>flag that sets event active or inactive</dd>\n</dl>\n",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "signature": "(func_evt = None, func_act = None, tolerance = EVT_TOLERANCE)",
              "parameters": [
                {
                  "name": "func_evt",
                  "type": null,
                  "default": "None",
                  "description": ""
                },
                {
                  "name": "func_act",
                  "type": null,
                  "default": "None",
                  "description": ""
                },
                {
                  "name": "tolerance",
                  "type": null,
                  "default": "EVT_TOLERANCE",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "on",
              "description": "",
              "docstring_html": "",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "off",
              "description": "",
              "docstring_html": "",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "reset",
              "description": "Reset the recorded event times. Resetting the history is not",
              "docstring_html": "<p>Reset the recorded event times. Resetting the history is not\nrequired because of the 'buffer' method. Reactivates event tracking.</p>\n",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "buffer",
              "description": "Buffer the event function evaluation before the timestep is",
              "docstring_html": "<p>Buffer the event function evaluation before the timestep is\ntaken and the evaluation time.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time for buffering history</dd>\n</dl>\n",
              "signature": "(t)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time for buffering history"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "estimate",
              "description": "Estimate the time of the next event, based on history or internal schedule.",
              "docstring_html": "<p>Estimate the time of the next event, based on history or internal schedule.</p>\n<p>This improves simulation performance by estimating events before the simulation\nstep such that fewer steps have to be rejected for event location.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time for estimation</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>float | None</dt>\n<dd>estimated time until next event</dd>\n</dl>\n",
              "signature": "(t)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time for estimation"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "detect",
              "description": "Evaluate the event function and decide if an event has occured.",
              "docstring_html": "<p>Evaluate the event function and decide if an event has occured.\nCan also use the history of the event function evaluation from\nbefore the timestep.</p>\n<p><strong>Notes</strong></p>\n<p>This does nothing and needs to be implemented for specific events!!!</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time for detection</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>detected <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>was an event detected?</dd>\n<dt>close <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>are we close to the event?</dd>\n<dt>ratio <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>interpolated event location as ratio of timestep</dd>\n</dl>\n",
              "signature": "(t)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time for detection"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "resolve",
              "description": "Resolve the event and record the time (t) at which it occurs.",
              "docstring_html": "<p>Resolve the event and record the time (t) at which it occurs.</p>\n<p>Resolves event using the action function (func_act) if it is defined.</p>\n<p>Otherwise this just marks the location of the event in time.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time for event resolution</dd>\n</dl>\n",
              "signature": "(t)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time for event resolution"
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "func_evt",
              "description": "",
              "type": null,
              "value": "func_evt"
            },
            {
              "name": "func_act",
              "description": "",
              "type": null,
              "value": "func_act"
            },
            {
              "name": "tolerance",
              "description": "",
              "type": null,
              "value": "tolerance"
            }
          ],
          "parameters": [
            {
              "name": "func_evt",
              "type": null,
              "default": "None",
              "description": "event function, where zeros are events"
            },
            {
              "name": "func_act",
              "type": null,
              "default": "None",
              "description": "action function for event resolution"
            },
            {
              "name": "tolerance",
              "type": null,
              "default": "EVT_TOLERANCE",
              "description": "tolerance to check if detection is close to actual event"
            }
          ]
        },
        {
          "name": "ZeroCrossing",
          "description": "Subclass of base 'Event' that triggers if the event function crosses zero.",
          "docstring_html": "<p>Subclass of base 'Event' that triggers if the event function crosses zero.\nThis is a bidirectional zero-crossing detector.</p>\n<p>Monitors system state by evaluating an event function (func_evt) with scalar output and\ntesting for zero crossings (sign changes).</p>\n<pre class=\"code literal-block\">\nfunc_evt(time) -&gt; event?\n</pre>\n<p>If an event is detected, some action (func_act) is performed on the system state.</p>\n<pre class=\"code literal-block\">\nfunc_evt(time) == 0 -&gt; event -&gt; func_act(time)\n</pre>\n<div class=\"section\" id=\"example\">\n<h4>Example</h4>\n<p>Initialize a zero-crossing event handler like this:</p>\n<pre class=\"code python literal-block\">\n# define the event function\ndef evt(t):\n    # here we have a zero-crossing at 't==10'\n    return t - 10\n\n# define the action function (callback)\ndef act(t):\n    # do something at event resolution\n    pass\n\n# initialize the event manager\nE = ZeroCrossing(\n    func_evt=evt,  # the event function\n    func_act=act   # the action function\n    )\n</pre>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>func_evt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">callable</span></dt>\n<dd>event function, where zeros are events</dd>\n<dt>func_act <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">callable</span></dt>\n<dd>action function for event resolution</dd>\n<dt>tolerance <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>tolerance to check if detection is close to actual event</dd>\n</dl>\n</div>\n",
          "bases": [
            "Event"
          ],
          "methods": [
            {
              "name": "detect",
              "description": "Evaluate the event function and check for zero-crossings",
              "docstring_html": "<p>Evaluate the event function and check for zero-crossings</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time for detection</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>detected <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>was an event detected?</dd>\n<dt>close <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>are we close to the event?</dd>\n<dt>ratio <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>interpolated event location as ratio of timestep</dd>\n</dl>\n",
              "signature": "(t)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time for detection"
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [],
          "parameters": []
        },
        {
          "name": "ZeroCrossingUp",
          "description": "Modification of standard 'ZeroCrossing' event where events are only triggered",
          "docstring_html": "<p>Modification of standard 'ZeroCrossing' event where events are only triggered\nif the event function changes sign from negative to positive (up). Also called\nunidirectional zero-crossing.</p>\n",
          "bases": [
            "Event"
          ],
          "methods": [
            {
              "name": "detect",
              "description": "Evaluate the event function and check for zero-crossings",
              "docstring_html": "<p>Evaluate the event function and check for zero-crossings</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time for detection</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>detected <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>was an event detected?</dd>\n<dt>close <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>are we close to the event?</dd>\n<dt>ratio <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>interpolated event location as ratio of timestep</dd>\n</dl>\n",
              "signature": "(t)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time for detection"
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [],
          "parameters": []
        },
        {
          "name": "ZeroCrossingDown",
          "description": "Modification of standard 'ZeroCrossing' event where events are only triggered",
          "docstring_html": "<p>Modification of standard 'ZeroCrossing' event where events are only triggered\nif the event function changes sign from positive to negative (down). Also called\nunidirectional zero-crossing.</p>\n",
          "bases": [
            "Event"
          ],
          "methods": [
            {
              "name": "detect",
              "description": "Evaluate the event function and check for zero-crossings",
              "docstring_html": "<p>Evaluate the event function and check for zero-crossings</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time for detection</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>detected <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>was an event detected?</dd>\n<dt>close <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>are we close to the event?</dd>\n<dt>ratio <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>interpolated event location as ratio of timestep</dd>\n</dl>\n",
              "signature": "(t)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time for detection"
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [],
          "parameters": []
        },
        {
          "name": "Condition",
          "description": "Subclass of base 'Event' that triggers if the event function evaluates to 'True',",
          "docstring_html": "<p>Subclass of base 'Event' that triggers if the event function evaluates to 'True',\ni.e. the condition is satisfied.</p>\n<p>Monitors system state by evaluating an event function (func_evt) with boolean output.\nThe event is considered detected when the event function evaluates to 'True' for the\nfirst time. Subsequent evaluations to 'True' are not considered unless the event is reset.</p>\n<pre class=\"code literal-block\">\nfunc_evt(time) -&gt; event?\n</pre>\n<p>If an event is detected, some action (func_act) is performed on the system state.</p>\n<pre class=\"code literal-block\">\nfunc_evt(time) == True -&gt; event -&gt; func_act(time)\n</pre>\n<div class=\"section\" id=\"note\">\n<h4>Note</h4>\n<p>Condition event functions evaluate to boolean and are therefore not smooth.\nTherefore uses bisection method for event location instead of secant method.</p>\n</div>\n<div class=\"section\" id=\"example\">\n<h4>Example</h4>\n<p>Initialize a conditional event handler like this:</p>\n<pre class=\"code python literal-block\">\n#define the event function\ndef evt(t):\n    return t &gt; 10\n\n#define the action function (callback)\ndef act(t):\n    #do something at event resolution\n    pass\n\n#initialize the event manager\nE = Condition(\n    func_evt=evt,  #the event function\n    func_act=act   #the action function\n    )\n</pre>\n</div>\n",
          "bases": [
            "Event"
          ],
          "methods": [
            {
              "name": "detect",
              "description": "Evaluate the event function and check if condition is satisfied.",
              "docstring_html": "<p>Evaluate the event function and check if condition is satisfied.</p>\n<p>The event function is not differentiable, so we use bisection to\nnarrow down its location to some tolerance.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time for detection</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>detected <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>was an event detected?</dd>\n<dt>close <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>are we close to the event?</dd>\n<dt>ratio <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>adjust timestep to locate event</dd>\n</dl>\n",
              "signature": "(t)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time for detection"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "resolve",
              "description": "Resolve the event and record the time (t) at which it occurs.",
              "docstring_html": "<p>Resolve the event and record the time (t) at which it occurs.\nResolves event using the action function (func_act) if it is defined.</p>\n<p>Deactivates the event tracking upon first resolution.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time for event resolution</dd>\n</dl>\n",
              "signature": "(t)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time for event resolution"
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [],
          "parameters": []
        },
        {
          "name": "Schedule",
          "description": "Subclass of base 'Event' that triggers dependent on the evaluation time.",
          "docstring_html": "<p>Subclass of base 'Event' that triggers dependent on the evaluation time.</p>\n<p>Monitors time in every timestep and triggers periodically (period). This event\ndoes not have an event function as the event condition only depends on time.</p>\n<pre class=\"code literal-block\">\ntime == next_schedule_time -&gt; event\n</pre>\n<div class=\"section\" id=\"example\">\n<h4>Example</h4>\n<p>Initialize a scheduled event handler like this:</p>\n<pre class=\"code python literal-block\">\n#define the action function (callback)\ndef act(t):\n    #do something at event resolution\n    pass\n\n#initialize the event manager\nE = Schedule(\n    t_start=0,    #starting at t=0\n    t_end=None,   #never ending\n    t_period=3,   #triggering every 3 time units\n    func_act=act  #resulting in a callback\n    )\n</pre>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t_start <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>starting time for schedule</dd>\n<dt>t_end <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>termination time for schedule</dd>\n<dt>t_period <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>time period of schedule, when events are triggered</dd>\n<dt>func_act <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">callable</span></dt>\n<dd>action function for event resolution</dd>\n<dt>tolerance <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>tolerance to check if detection is close to actual event</dd>\n</dl>\n</div>\n",
          "bases": [
            "Event"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "signature": "(t_start = 0, t_end = None, t_period = 1, func_act = None, tolerance = TOLERANCE)",
              "parameters": [
                {
                  "name": "t_start",
                  "type": null,
                  "default": "0",
                  "description": ""
                },
                {
                  "name": "t_end",
                  "type": null,
                  "default": "None",
                  "description": ""
                },
                {
                  "name": "t_period",
                  "type": null,
                  "default": "1",
                  "description": ""
                },
                {
                  "name": "func_act",
                  "type": null,
                  "default": "None",
                  "description": ""
                },
                {
                  "name": "tolerance",
                  "type": null,
                  "default": "TOLERANCE",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "estimate",
              "description": "Estimate the time until the next scheduled event.",
              "docstring_html": "<p>Estimate the time until the next scheduled event.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time for estimation</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>float</dt>\n<dd>estimated time until next event</dd>\n</dl>\n",
              "signature": "(t)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time for estimation"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "buffer",
              "description": "Buffer the current time to history",
              "docstring_html": "<p>Buffer the current time to history</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>buffer time</dd>\n</dl>\n",
              "signature": "(t)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "buffer time"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "detect",
              "description": "Check if the event condition is satisfied, i.e. if the",
              "docstring_html": "<p>Check if the event condition is satisfied, i.e. if the\ntime period switch is within the current timestep.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time for detection</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>detected <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>was an event detected?</dd>\n<dt>close <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>are we close to the event?</dd>\n<dt>ratio <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>interpolated event location ratio in timestep</dd>\n</dl>\n",
              "signature": "(t)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time for detection"
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "t_start",
              "description": "",
              "type": null,
              "value": "t_start"
            },
            {
              "name": "t_period",
              "description": "",
              "type": null,
              "value": "t_period"
            },
            {
              "name": "t_end",
              "description": "",
              "type": null,
              "value": "t_end"
            }
          ],
          "parameters": [
            {
              "name": "t_start",
              "type": null,
              "default": "0",
              "description": "starting time for schedule"
            },
            {
              "name": "t_end",
              "type": null,
              "default": "None",
              "description": "termination time for schedule"
            },
            {
              "name": "t_period",
              "type": null,
              "default": "1",
              "description": "time period of schedule, when events are triggered"
            },
            {
              "name": "func_act",
              "type": null,
              "default": "None",
              "description": "action function for event resolution"
            },
            {
              "name": "tolerance",
              "type": null,
              "default": "TOLERANCE",
              "description": "tolerance to check if detection is close to actual event"
            }
          ]
        },
        {
          "name": "ScheduleList",
          "description": "Subclass of base 'Schedule' that triggers dependent on the evaluation time.",
          "docstring_html": "<p>Subclass of base 'Schedule' that triggers dependent on the evaluation time.</p>\n<p>Monitors time in every timestep and triggers at the next event time from the\ntime list. This event does not have an event function as the event condition\nonly depends on time.</p>\n<pre class=\"code literal-block\">\ntime == next_scheduled_time -&gt; event\n</pre>\n<div class=\"section\" id=\"example\">\n<h4>Example</h4>\n<p>Initialize a scheduled event handler like this:</p>\n<pre class=\"code python literal-block\">\n#define the action function (callback)\ndef act(t):\n    #do something at event resolution\n    pass\n\n#initialize the event manager\nE = ScheduleList(\n    times_evt=[1, 5, 12, 300],  #event times where to trigger\n    func_act=act                #resulting in a callback\n    )\n</pre>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>times_evt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">list[float]</span></dt>\n<dd>list of event times in ascending order</dd>\n<dt>func_act <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">callable</span></dt>\n<dd>action function for event resolution</dd>\n<dt>tolerance <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>tolerance to check if detection is close to actual event</dd>\n</dl>\n</div>\n",
          "bases": [
            "Schedule"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "signature": "(times_evt, func_act = None, tolerance = TOLERANCE)",
              "parameters": [
                {
                  "name": "times_evt",
                  "type": null,
                  "default": null,
                  "description": ""
                },
                {
                  "name": "func_act",
                  "type": null,
                  "default": "None",
                  "description": ""
                },
                {
                  "name": "tolerance",
                  "type": null,
                  "default": "TOLERANCE",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "detect",
              "description": "Check if the event condition is satisfied, i.e. if the",
              "docstring_html": "<p>Check if the event condition is satisfied, i.e. if the\ntime period switch is within the current timestep.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time for detection</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>detected <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>was an event detected?</dd>\n<dt>close <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>are we close to the event?</dd>\n<dt>ratio <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>interpolated event location ratio in timestep</dd>\n</dl>\n",
              "signature": "(t)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time for detection"
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "times_evt",
              "description": "",
              "type": null,
              "value": "times_evt"
            }
          ],
          "parameters": [
            {
              "name": "times_evt",
              "type": null,
              "default": null,
              "description": "list of event times in ascending order"
            },
            {
              "name": "func_act",
              "type": null,
              "default": "None",
              "description": "action function for event resolution"
            },
            {
              "name": "tolerance",
              "type": null,
              "default": "TOLERANCE",
              "description": "tolerance to check if detection is close to actual event"
            }
          ]
        }
      ],
      "functions": [],
      "submodules": [
        "condition",
        "schedule",
        "zerocrossing"
      ]
    },
    "pathsim.optim": {
      "name": "pathsim.optim",
      "description": "",
      "docstring_html": "",
      "classes": [
        {
          "name": "Operator",
          "description": "Operator class for function evaluation and linearization.",
          "docstring_html": "<p>Operator class for function evaluation and linearization.</p>\n<p>This class wraps a function to provide both direct evaluation and linear approximation\ncapabilities. When linearized around a point x0, subsequent calls use the first-order\nTaylor approximation</p>\n<div>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\">\n  <mi>f</mi>\n  <mo stretchy=\"false\">(</mo>\n  <mi>x</mi>\n  <mo stretchy=\"false\">)</mo>\n  <mo>≈</mo>\n  <mi>f</mi>\n  <mo stretchy=\"false\">(</mo>\n  <msub>\n    <mi>x</mi>\n    <mn>0</mn>\n  </msub>\n  <mo stretchy=\"false\">)</mo>\n  <mo>+</mo>\n  <mi>𝐉</mi>\n  <mo stretchy=\"false\">(</mo>\n  <msub>\n    <mi>x</mi>\n    <mn>0</mn>\n  </msub>\n  <mo stretchy=\"false\">)</mo>\n  <mo stretchy=\"false\">(</mo>\n  <mi>x</mi>\n  <mo>−</mo>\n  <msub>\n    <mi>x</mi>\n    <mn>0</mn>\n  </msub>\n  <mo stretchy=\"false\">)</mo>\n</math>\n</div>\n<p>instead of evaluating the function.</p>\n<p>The class supports multiple methods for Jacobian computation: user-provided analytical\nJacobians, automatic differentiation via the Value class, and numerical differentiation\nas a fallback.</p>\n<div class=\"section\" id=\"example\">\n<h4>Example</h4>\n<p>Basic usage with automatic differentiation:</p>\n<pre class=\"code python literal-block\">\ndef f(x):\n    return x**2 + np.sin(x)\n\nop = Operator(f)\n\n# Direct function evaluation\ny1 = op(2.0)\n\n# Linearize at current point\nop.linearize(2.0)\n\n# Use linear approximation\ny2 = op(2.1)  # Returns f(2.0) + J(2.0) (2.1-2.0)\n</pre>\n<p>With user-provided Jacobian:</p>\n<pre class=\"code python literal-block\">\ndef f(x):\n    return x**2 + np.sin(x)\n\ndef df_dx(x):\n    return 2*x + np.cos(x)\n\nop = Operator(f, jac=df_dx)\n\nop.linearize(2.0)  # Uses df_dx for Jacobian\n</pre>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>func <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">callable</span></dt>\n<dd>The function to wrap</dd>\n<dt>jac <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">callable, optional</span></dt>\n<dd>Optional analytical Jacobian of func. If None, automatic or numerical\ndifferentiation will be used.</dd>\n</dl>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>f0 <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array_like</span></dt>\n<dd>function evaluation at operating point</dd>\n<dt>x0 <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array_like</span></dt>\n<dd>operating point</dd>\n<dt>J <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array_like</span></dt>\n<dd>jacobian matrix at operating point</dd>\n</dl>\n</div>\n",
          "bases": [
            "object"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "signature": "(func, jac = None)",
              "parameters": [
                {
                  "name": "func",
                  "type": null,
                  "default": null,
                  "description": ""
                },
                {
                  "name": "jac",
                  "type": null,
                  "default": "None",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "jac",
              "description": "Compute the Jacobian matrix at point x.",
              "docstring_html": "<p>Compute the Jacobian matrix at point x.</p>\n<p>Uses the following methods in order of preference:\n1. User-provided analytical Jacobian if available\n2. Automatic differentiation via Value class\n3. Numerical differentiation as fallback</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>x <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array_like</span></dt>\n<dd>Point at which to evaluate the Jacobian</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>jacobian <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">ndarray</span></dt>\n<dd>Jacobian matrix at x</dd>\n</dl>\n",
              "signature": "(x)",
              "parameters": [
                {
                  "name": "x",
                  "type": null,
                  "default": null,
                  "description": "Point at which to evaluate the Jacobian Returns -------"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "linearize",
              "description": "Linearize the function at point x.",
              "docstring_html": "<p>Linearize the function at point x.</p>\n<p>Computes and stores both the function value and its Jacobian at x.\nAfter linearization, calls to the operator will use the linear\napproximation until reset() is called.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>x <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array_like</span></dt>\n<dd>Point at which to linearize the function</dd>\n</dl>\n",
              "signature": "(x)",
              "parameters": [
                {
                  "name": "x",
                  "type": null,
                  "default": null,
                  "description": "Point at which to linearize the function"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "reset",
              "description": "Reset the linearization.",
              "docstring_html": "<p>Reset the linearization.</p>\n<p>Clears the stored linearization point and Jacobian, causing the\noperator to evaluate the function directly on subsequent calls.</p>\n",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "f0",
              "description": "",
              "type": null,
              "value": "None"
            },
            {
              "name": "x0",
              "description": "",
              "type": null,
              "value": "None"
            },
            {
              "name": "J",
              "description": "",
              "type": null,
              "value": "None"
            }
          ],
          "parameters": [
            {
              "name": "func",
              "type": null,
              "default": null,
              "description": "The function to wrap"
            },
            {
              "name": "jac",
              "type": null,
              "default": "None",
              "description": "Optional analytical Jacobian of func. If None, automatic or numerical differentiation will be used."
            }
          ]
        }
      ],
      "functions": [],
      "submodules": [
        "anderson",
        "booster",
        "numerical",
        "operator"
      ]
    },
    "pathsim.utils": {
      "name": "pathsim.utils",
      "description": "",
      "docstring_html": "",
      "classes": [],
      "functions": [
        {
          "name": "deprecated",
          "description": "Decorator to mark functions, methods, or classes as deprecated.",
          "docstring_html": "<p>Decorator to mark functions, methods, or classes as deprecated.</p>\n<p>Emits a DeprecationWarning when the decorated item is called/instantiated\nand adds RST-formatted deprecation notice to the docstring.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>version <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">str | None</span></dt>\n<dd>Version when the item will be removed (e.g., &quot;1.0.0&quot;)</dd>\n<dt>replacement <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">str | None</span></dt>\n<dd>Name of the replacement to use instead (e.g., &quot;new_function&quot;)</dd>\n<dt>reason <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">str | None</span></dt>\n<dd>Additional explanation for the deprecation</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>decorator <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">callable</span></dt>\n<dd>Decorator function</dd>\n</dl>\n<div class=\"section\" id=\"example\">\n<h4>Example</h4>\n<pre class=\"code python literal-block\">\n&#64;deprecated(version=&quot;1.0.0&quot;, replacement=&quot;new_function&quot;)\ndef old_function():\n    pass\n\n&#64;deprecated(version=&quot;2.0.0&quot;, reason=&quot;No longer needed&quot;)\nclass OldClass:\n    pass\n</pre>\n</div>\n",
          "signature": "(version = None, replacement = None, reason = None)",
          "parameters": [
            {
              "name": "version",
              "type": null,
              "default": "None",
              "description": "Version when the item will be removed (e.g., \"1.0.0\")"
            },
            {
              "name": "replacement",
              "type": null,
              "default": "None",
              "description": "Name of the replacement to use instead (e.g., \"new_function\")"
            },
            {
              "name": "reason",
              "type": null,
              "default": "None",
              "description": "Additional explanation for the deprecation"
            }
          ],
          "returns": null
        }
      ],
      "submodules": [
        "adaptivebuffer",
        "analysis",
        "deprecation",
        "fmuwrapper",
        "gilbert",
        "graph",
        "logger",
        "portreference",
        "progresstracker",
        "realtimeplotter",
        "register"
      ]
    }
  }
}