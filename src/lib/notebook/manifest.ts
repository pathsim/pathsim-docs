/**
 * Types for notebook manifest files.
 * Generated by scripts/prepare-notebooks.py
 */

export interface NotebookMeta {
	/** URL-friendly identifier */
	slug: string;
	/** Display title (from first H1) */
	title: string;
	/** Short description (from first paragraph) */
	description: string;
	/** Category ID for grouping */
	category: string;
	/** Filename (e.g., "pendulum.ipynb") */
	file: string;
	/** Tags for filtering/search */
	tags: string[];
	/** Whether notebook can run in Pyodide */
	executable: boolean;
}

export interface Category {
	/** Unique identifier */
	id: string;
	/** Display title */
	title: string;
	/** Sort order */
	order: number;
}

export interface NotebookManifest {
	/** Package identifier */
	package: string;
	/** All notebooks in this package */
	notebooks: NotebookMeta[];
	/** Category definitions */
	categories: Category[];
}

/**
 * Load manifest for a package.
 */
export async function loadManifest(packageId: string): Promise<NotebookManifest> {
	const response = await fetch(`/notebooks/${packageId}/manifest.json`);
	if (!response.ok) {
		throw new Error(`Failed to load manifest for ${packageId}: ${response.status}`);
	}
	return response.json();
}

/**
 * Load a notebook JSON file.
 */
export async function loadNotebook(packageId: string, filename: string): Promise<unknown> {
	const response = await fetch(`/notebooks/${packageId}/${filename}`);
	if (!response.ok) {
		throw new Error(`Failed to load notebook ${filename}: ${response.status}`);
	}
	return response.json();
}

/**
 * Group notebooks by category.
 */
export function groupByCategory(
	notebooks: NotebookMeta[],
	categories: Category[]
): Map<Category, NotebookMeta[]> {
	const categoryMap = new Map<string, Category>();
	for (const cat of categories) {
		categoryMap.set(cat.id, cat);
	}

	const groups = new Map<Category, NotebookMeta[]>();

	for (const notebook of notebooks) {
		const category = categoryMap.get(notebook.category);
		if (category) {
			const existing = groups.get(category) || [];
			existing.push(notebook);
			groups.set(category, existing);
		}
	}

	// Sort by category order
	const sorted = new Map(
		[...groups.entries()].sort((a, b) => a[0].order - b[0].order)
	);

	return sorted;
}
