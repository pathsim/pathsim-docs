{
  "package": "pathsim",
  "modules": {
    "pathsim.connection": {
      "name": "pathsim.connection",
      "description": "",
      "docstring_html": "",
      "classes": [
        {
          "name": "Connection",
          "description": "Class to handle input-output relations of blocks by connecting them (directed graph)",
          "docstring_html": "<p>Class to handle input-output relations of blocks by connecting them (directed graph)\nand transfering data from the output port of the source block to the input port of\nthe target block.</p>\n<p>The default ports for connection are (0) -&gt; (0), since these are the default inputs\nthat are used in the SISO blocks.</p>\n<p><strong>Examples</strong></p>\n<p>Lets assume we have some generic blocks</p>\n<pre class=\"code python literal-block\">\n<span class=\"kn\">from</span><span class=\"w\"> </span><span class=\"nn\">pathsim.blocks._block</span><span class=\"w\"> </span><span class=\"kn\">import</span> <span class=\"n\">Block</span><span class=\"w\">\n\n</span><span class=\"n\">B1</span> <span class=\"o\">=</span> <span class=\"n\">Block</span><span class=\"p\">()</span><span class=\"w\">\n</span><span class=\"n\">B2</span> <span class=\"o\">=</span> <span class=\"n\">Block</span><span class=\"p\">()</span><span class=\"w\">\n</span><span class=\"n\">B3</span> <span class=\"o\">=</span> <span class=\"n\">Block</span><span class=\"p\">()</span>\n</pre>\n<p>that we want to connect. We initialize a 'Connection' with the blocks directly\nas the arguments if we want to connect the default ports (0) -&gt; (0)</p>\n<pre class=\"code python literal-block\">\n<span class=\"kn\">from</span><span class=\"w\"> </span><span class=\"nn\">pathsim</span><span class=\"w\"> </span><span class=\"kn\">import</span> <span class=\"n\">Connection</span><span class=\"w\">\n\n</span><span class=\"n\">C</span> <span class=\"o\">=</span> <span class=\"n\">Connection</span><span class=\"p\">(</span><span class=\"n\">B1</span><span class=\"p\">,</span> <span class=\"n\">B2</span><span class=\"p\">)</span>\n</pre>\n<p>which is a connection from block 'B1' to 'B2'. If we want to explicitly declare\nthe input and output ports we can do that by utilizing the '__getitem__' method\nof the blocks</p>\n<pre class=\"code python literal-block\">\n<span class=\"n\">C</span> <span class=\"o\">=</span> <span class=\"n\">Connection</span><span class=\"p\">(</span><span class=\"n\">B1</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">],</span> <span class=\"n\">B2</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">])</span>\n</pre>\n<p>which is exactly the default port setup. Connecting output port (1) of 'B1' to\nthe default input port (0) of 'B2' do</p>\n<pre class=\"code python literal-block\">\n<span class=\"n\">C</span> <span class=\"o\">=</span> <span class=\"n\">Connection</span><span class=\"p\">(</span><span class=\"n\">B1</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">],</span> <span class=\"n\">B2</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">])</span>\n</pre>\n<p>or just</p>\n<pre class=\"code python literal-block\">\n<span class=\"n\">C</span> <span class=\"o\">=</span> <span class=\"n\">Connection</span><span class=\"p\">(</span><span class=\"n\">B1</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">],</span> <span class=\"n\">B2</span><span class=\"p\">)</span><span class=\"o\">.</span>\n</pre>\n<p>The 'Connection' class also supports multiple targets for a single source.\nThis is specified by just adding more blocks with their respective ports into\nthe constructor like this:</p>\n<pre class=\"code python literal-block\">\n<span class=\"n\">C</span> <span class=\"o\">=</span> <span class=\"n\">Connection</span><span class=\"p\">(</span><span class=\"n\">B1</span><span class=\"p\">,</span> <span class=\"n\">B2</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">],</span> <span class=\"n\">B2</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">],</span> <span class=\"n\">B3</span><span class=\"p\">)</span>\n</pre>\n<p>The port definitions follow the same structure as for single target connections.</p>\n<p>'self'-connections also work without a problem. This is useful for modeling direct\nfeedback of a block to itself.</p>\n<p>Port definitions support slicing. This enables direct MIMO connections. For example\nconnecting ports 0, 1, 2 of 'B1' to ports 1, 2, 3 of 'B2' works like this:</p>\n<pre class=\"code python literal-block\">\n<span class=\"n\">C</span> <span class=\"o\">=</span> <span class=\"n\">Connection</span><span class=\"p\">(</span><span class=\"n\">B1</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">:</span><span class=\"mi\">2</span><span class=\"p\">],</span> <span class=\"n\">B2</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">:</span><span class=\"mi\">3</span><span class=\"p\">])</span>\n</pre>\n<p>Port definitions also support lists and tuples of 'int'. For example the slice\nabove is identical to this:</p>\n<pre class=\"code python literal-block\">\n<span class=\"n\">C</span> <span class=\"o\">=</span> <span class=\"n\">Connection</span><span class=\"p\">(</span><span class=\"n\">B1</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">],</span> <span class=\"n\">B2</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">])</span>\n</pre>\n<p>Or to be more programmatic about it, like this:</p>\n<pre class=\"code python literal-block\">\n<span class=\"n\">prts_1</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">]</span><span class=\"w\">\n</span><span class=\"n\">prts_2</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">]</span><span class=\"w\">\n\n</span><span class=\"n\">C</span> <span class=\"o\">=</span> <span class=\"n\">Connection</span><span class=\"p\">(</span><span class=\"n\">B1</span><span class=\"p\">[</span><span class=\"n\">prts_1</span><span class=\"p\">],</span> <span class=\"n\">B2</span><span class=\"p\">[</span><span class=\"n\">prts_2</span><span class=\"p\">])</span>\n</pre>\n<p>Another way to define the ports is by using strings. Some blocks have internal\naliases for the ports that can be used instead of the integer port indices to\ndefine the connections (or access the port data):</p>\n<pre class=\"code python literal-block\">\n<span class=\"n\">C</span> <span class=\"o\">=</span> <span class=\"n\">Connection</span><span class=\"p\">(</span><span class=\"n\">B1</span><span class=\"p\">[</span><span class=\"s2\">&quot;out&quot;</span><span class=\"p\">],</span> <span class=\"n\">B2</span><span class=\"p\">[</span><span class=\"s2\">&quot;in&quot;</span><span class=\"p\">])</span>\n</pre>\n<p>Or mixed with integer port indices:</p>\n<pre class=\"code python literal-block\">\n<span class=\"n\">C</span> <span class=\"o\">=</span> <span class=\"n\">Connection</span><span class=\"p\">(</span><span class=\"n\">B1</span><span class=\"p\">[</span><span class=\"s2\">&quot;out&quot;</span><span class=\"p\">],</span> <span class=\"n\">B2</span><span class=\"p\">[</span><span class=\"s2\">&quot;in&quot;</span><span class=\"p\">])</span>\n</pre>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>source <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">PortReference, Block</span></dt>\n<dd>source block and optional source output port</dd>\n<dt>targets <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">tuple[PortReference], tuple[Block]</span></dt>\n<dd>target blocks and optional target input ports</dd>\n</dl>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>_active <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>flag to set 'Connection' as active or inactive</dd>\n<dt>values <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array</span></dt>\n<dd>values to transmit, relevant for fixed-point accelerator</dd>\n<dt>accelerator <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">None, Anderson</span></dt>\n<dd>internal fixed-point accelerator for algebraic loops</dd>\n</dl>\n",
          "source": "class Connection:\n    \"\"\"Class to handle input-output relations of blocks by connecting them (directed graph) \n    and transfering data from the output port of the source block to the input port of \n    the target block.\n\n    The default ports for connection are (0) -> (0), since these are the default inputs \n    that are used in the SISO blocks.\n\n    Examples\n    --------\n    Lets assume we have some generic blocks \n\n    .. code-block:: python\n\n        from pathsim.blocks._block import Block\n\n        B1 = Block()\n        B2 = Block()\n        B3 = Block()\n\n\n    that we want to connect. We initialize a 'Connection' with the blocks directly \n    as the arguments if we want to connect the default ports (0) -> (0) \n\n    .. code-block:: python\n\n        from pathsim import Connection\n\n        C = Connection(B1, B2)\n\n\n    which is a connection from block 'B1' to 'B2'. If we want to explicitly declare \n    the input and output ports we can do that by utilizing the '__getitem__' method\n    of the blocks\n\n    .. code-block:: python\n\n        C = Connection(B1[0], B2[0])\n\n\n    which is exactly the default port setup. Connecting output port (1) of 'B1' to \n    the default input port (0) of 'B2' do\n\n    .. code-block:: python\n\n        C = Connection(B1[1], B2[0])\n\n\n    or just\n\n    .. code-block:: python\n\n        C = Connection(B1[1], B2).\n\n\n    The 'Connection' class also supports multiple targets for a single source. \n    This is specified by just adding more blocks with their respective ports into \n    the constructor like this:\n\n    .. code-block:: python\n\n        C = Connection(B1, B2[0], B2[1], B3)\n\n\n    The port definitions follow the same structure as for single target connections.\n\n    'self'-connections also work without a problem. This is useful for modeling direct \n    feedback of a block to itself.\n\n    Port definitions support slicing. This enables direct MIMO connections. For example \n    connecting ports 0, 1, 2 of 'B1' to ports 1, 2, 3 of 'B2' works like this:\n\n    .. code-block:: python\n\n        C = Connection(B1[0:2], B2[1:3])\n\n\n    Port definitions also support lists and tuples of 'int'. For example the slice \n    above is identical to this:\n\n    .. code-block:: python\n\n        C = Connection(B1[0, 1], B2[1, 2])\n\n\n    Or to be more programmatic about it, like this:\n\n    .. code-block:: python\n\n        prts_1 = [0, 1]\n        prts_2 = [1, 2]\n\n        C = Connection(B1[prts_1], B2[prts_2])\n\n\n    Another way to define the ports is by using strings. Some blocks have internal \n    aliases for the ports that can be used instead of the integer port indices to \n    define the connections (or access the port data):\n\n    .. code-block:: python\n\n        C = Connection(B1[\"out\"], B2[\"in\"])\n\n\n    Or mixed with integer port indices:\n\n    .. code-block:: python\n\n        C = Connection(B1[\"out\"], B2[\"in\"])\n\n\n    Parameters\n    ----------\n    source : PortReference, Block\n        source block and optional source output port\n    targets : tuple[PortReference], tuple[Block]\n        target blocks and optional target input ports\n\n\n    Attributes\n    ----------\n    _active : bool\n        flag to set 'Connection' as active or inactive\n    values : array\n        values to transmit, relevant for fixed-point accelerator\n    accelerator : None, Anderson\n        internal fixed-point accelerator for algebraic loops\n    \"\"\"\n\n    __slots__ = [\"source\", \"targets\", \"_active\", \"values\", \"accelerator\"]\n\n\n    def __init__(self, source, *targets):\n\n        #assign source block and port\n        self.source = source if isinstance(source, PortReference) else PortReference(source)\n\n        #assign target blocks and ports\n        self.targets = [trg if isinstance(trg, PortReference) else PortReference(trg) for trg in targets]\n\n        #flag to set connection active\n        self._active = True\n\n        #values to transmit as history\n        self.values = None\n\n        #internal fixed-point accelerator\n        self.accelerator = None\n\n        #validate port aliases\n        self._validate_ports()\n\n        #validate port dimensions at connection creation\n        self._validate_dimensions()\n\n\n    def __str__(self):\n        \"\"\"String representation of the connection using the \n        'to_dict' method with readable json formatting\n        \"\"\"\n        return json.dumps(self.to_dict(), indent=2, sort_keys=False)\n\n\n    def __bool__(self):\n        return self._active\n\n\n    def __contains__(self, other):\n        \"\"\"Check if block is part of connection\n\n        Paramters\n        ---------\n        other : Block\n            block to check if its part of the connection\n\n        Returns\n        -------\n        bool\n            is other part of connecion?\n        \"\"\"\n        if isinstance(other, Block): \n            return other in self.get_blocks()\n        return False\n\n\n    def _validate_dimensions(self):\n        \"\"\"Check the dimensions of the source and target ports, \n        if they dont match, raises an exception.\n        \"\"\"\n        n_src = len(self.source)\n        for trg in self.targets:\n            if len(trg) != n_src:\n                raise ValueError(f\"Source and target have different number of ports!\")\n\n\n    def _validate_ports(self):\n        \"\"\"Check the existance of the input and output ports of \n        the defined source and target blocks. \n\n        Utilizes the `PortReference._validate_output_ports` and \n        `PortReference._validate_input_ports` methods.\n        \"\"\"\n        self.source._validate_output_ports()\n        for trg in self.targets:\n            trg._validate_input_ports()\n\n\n    def get_blocks(self):\n        \"\"\"Returns all the unique internal source and target blocks \n        of the connection instance\n\n        Returns\n        -------\n        list[Block]\n            internal unique blocks of the connection\n        \"\"\"\n        blocks = [self.source.block]\n        for trg in self.targets:\n            if trg.block not in blocks:\n                blocks.append(trg.block)\n        return blocks\n\n\n    def on(self):\n        self._active = True\n\n\n    def off(self):\n        self._active = False\n\n\n    def overwrites(self, other):\n        \"\"\"Check if the connection 'self' overwrites the target port of \n        connection 'other' and return 'True' if so.\n\n        Parameters\n        ----------\n        other : Connection\n            other connection to check \n\n        Returns\n        -------\n        overwrites : bool\n            True if port is overwritten, False otherwise\n\n        \"\"\"\n\n        #catch self checking\n        if self == other:\n            return False\n\n        #iterate all target permutations\n        for trg in self.targets:\n            for otrg in other.targets:\n\n                #check if same target block\n                if trg.block is otrg.block:\n\n                    #check if there is port overlap\n                    for prt in trg.ports:\n                        if prt in otrg.ports: \n                            return True\n\n        return False \n\n\n    def to_dict(self):\n        \"\"\"Convert connection to dictionary representation for serialization\"\"\"\n        return {\n            \"id\": id(self),\n            \"source\": self.source.to_dict(),\n            \"targets\": [trg.to_dict() for trg in self.targets]\n        }\n\n\n    def update(self):\n        \"\"\"Transfers data from the source block output port \n        to the target block input port.\n        \"\"\"\n        for trg in self.targets:\n            self.source.to(trg)\n\n\n    def step(self):\n        \"\"\"Step the internal fixed-point accelerator forward by one iteration.\n\n        If no previous values are available (prev_values is None), falls back to \n        the 'update' method, which is essentially equivalent to a standard \n        fixed-point update. \n\n        Returns\n        -------\n        res : float\n            fixed point residual for convergence control\n        \"\"\"\n\n        #get source values and previous values\n        self.values, prev_values = self.source.get_outputs(), self.values\n\n        #initialize fixed point accelerator if not already available\n        if not self.accelerator:\n            self.accelerator = Anderson()\n\n        #no previous value -> fallback to update method\n        if prev_values is None:\n            self.update()\n            return 1.0\n\n        #update fixed-point accelerator\n        self.values, res = self.accelerator.step(prev_values, self.values)\n\n        #transmit new values to all targets\n        for trg in self.targets:\n            trg.set_inputs(self.values)\n\n        #return the fixed-point residual\n        return res\n\n\n    def reset(self):\n        \"\"\"Reset the internal fixed point accelerator which is used \n        to resolve algebraic loops and the internal values\"\"\"\n        self.values = None\n        if self.accelerator: \n            self.accelerator.reset()",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, source, *targets):\n\n    #assign source block and port\n    self.source = source if isinstance(source, PortReference) else PortReference(source)\n\n    #assign target blocks and ports\n    self.targets = [trg if isinstance(trg, PortReference) else PortReference(trg) for trg in targets]\n\n    #flag to set connection active\n    self._active = True\n\n    #values to transmit as history\n    self.values = None\n\n    #internal fixed-point accelerator\n    self.accelerator = None\n\n    #validate port aliases\n    self._validate_ports()\n\n    #validate port dimensions at connection creation\n    self._validate_dimensions()",
              "signature": "(source, targets = ())",
              "parameters": [
                {
                  "name": "source",
                  "type": null,
                  "default": null,
                  "description": ""
                },
                {
                  "name": "targets",
                  "type": null,
                  "default": "()",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "_validate_dimensions",
              "description": "Check the dimensions of the source and target ports,",
              "docstring_html": "<p>Check the dimensions of the source and target ports,\nif they dont match, raises an exception.</p>\n",
              "source": "def _validate_dimensions(self):\n    \"\"\"Check the dimensions of the source and target ports, \n    if they dont match, raises an exception.\n    \"\"\"\n    n_src = len(self.source)\n    for trg in self.targets:\n        if len(trg) != n_src:\n            raise ValueError(f\"Source and target have different number of ports!\")",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "_validate_ports",
              "description": "Check the existance of the input and output ports of",
              "docstring_html": "<p>Check the existance of the input and output ports of\nthe defined source and target blocks.</p>\n<p>Utilizes the <cite>PortReference._validate_output_ports</cite> and\n<cite>PortReference._validate_input_ports</cite> methods.</p>\n",
              "source": "def _validate_ports(self):\n    \"\"\"Check the existance of the input and output ports of \n    the defined source and target blocks. \n\n    Utilizes the `PortReference._validate_output_ports` and \n    `PortReference._validate_input_ports` methods.\n    \"\"\"\n    self.source._validate_output_ports()\n    for trg in self.targets:\n        trg._validate_input_ports()",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "get_blocks",
              "description": "Returns all the unique internal source and target blocks",
              "docstring_html": "<p>Returns all the unique internal source and target blocks\nof the connection instance</p>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>list[Block]</dt>\n<dd>internal unique blocks of the connection</dd>\n</dl>\n",
              "source": "def get_blocks(self):\n    \"\"\"Returns all the unique internal source and target blocks \n    of the connection instance\n\n    Returns\n    -------\n    list[Block]\n        internal unique blocks of the connection\n    \"\"\"\n    blocks = [self.source.block]\n    for trg in self.targets:\n        if trg.block not in blocks:\n            blocks.append(trg.block)\n    return blocks",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "on",
              "description": "",
              "docstring_html": "",
              "source": "def on(self):\n    self._active = True",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "off",
              "description": "",
              "docstring_html": "",
              "source": "def off(self):\n    self._active = False",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "overwrites",
              "description": "Check if the connection 'self' overwrites the target port of",
              "docstring_html": "<p>Check if the connection 'self' overwrites the target port of\nconnection 'other' and return 'True' if so.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>other <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">Connection</span></dt>\n<dd>other connection to check</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>overwrites <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>True if port is overwritten, False otherwise</dd>\n</dl>\n",
              "source": "def overwrites(self, other):\n    \"\"\"Check if the connection 'self' overwrites the target port of \n    connection 'other' and return 'True' if so.\n\n    Parameters\n    ----------\n    other : Connection\n        other connection to check \n\n    Returns\n    -------\n    overwrites : bool\n        True if port is overwritten, False otherwise\n\n    \"\"\"\n\n    #catch self checking\n    if self == other:\n        return False\n\n    #iterate all target permutations\n    for trg in self.targets:\n        for otrg in other.targets:\n\n            #check if same target block\n            if trg.block is otrg.block:\n\n                #check if there is port overlap\n                for prt in trg.ports:\n                    if prt in otrg.ports: \n                        return True\n\n    return False",
              "signature": "(other)",
              "parameters": [
                {
                  "name": "other",
                  "type": null,
                  "default": null,
                  "description": "other connection to check"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "to_dict",
              "description": "Convert connection to dictionary representation for serialization",
              "docstring_html": "<p>Convert connection to dictionary representation for serialization</p>\n",
              "source": "def to_dict(self):\n    \"\"\"Convert connection to dictionary representation for serialization\"\"\"\n    return {\n        \"id\": id(self),\n        \"source\": self.source.to_dict(),\n        \"targets\": [trg.to_dict() for trg in self.targets]\n    }",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "update",
              "description": "Transfers data from the source block output port",
              "docstring_html": "<p>Transfers data from the source block output port\nto the target block input port.</p>\n",
              "source": "def update(self):\n    \"\"\"Transfers data from the source block output port \n    to the target block input port.\n    \"\"\"\n    for trg in self.targets:\n        self.source.to(trg)",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "step",
              "description": "Step the internal fixed-point accelerator forward by one iteration.",
              "docstring_html": "<p>Step the internal fixed-point accelerator forward by one iteration.</p>\n<p>If no previous values are available (prev_values is None), falls back to\nthe 'update' method, which is essentially equivalent to a standard\nfixed-point update.</p>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>res <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>fixed point residual for convergence control</dd>\n</dl>\n",
              "source": "def step(self):\n    \"\"\"Step the internal fixed-point accelerator forward by one iteration.\n\n    If no previous values are available (prev_values is None), falls back to \n    the 'update' method, which is essentially equivalent to a standard \n    fixed-point update. \n\n    Returns\n    -------\n    res : float\n        fixed point residual for convergence control\n    \"\"\"\n\n    #get source values and previous values\n    self.values, prev_values = self.source.get_outputs(), self.values\n\n    #initialize fixed point accelerator if not already available\n    if not self.accelerator:\n        self.accelerator = Anderson()\n\n    #no previous value -> fallback to update method\n    if prev_values is None:\n        self.update()\n        return 1.0\n\n    #update fixed-point accelerator\n    self.values, res = self.accelerator.step(prev_values, self.values)\n\n    #transmit new values to all targets\n    for trg in self.targets:\n        trg.set_inputs(self.values)\n\n    #return the fixed-point residual\n    return res",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "reset",
              "description": "Reset the internal fixed point accelerator which is used",
              "docstring_html": "<p>Reset the internal fixed point accelerator which is used\nto resolve algebraic loops and the internal values</p>\n",
              "source": "def reset(self):\n    \"\"\"Reset the internal fixed point accelerator which is used \n    to resolve algebraic loops and the internal values\"\"\"\n    self.values = None\n    if self.accelerator: \n        self.accelerator.reset()",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "source",
              "description": "",
              "type": null,
              "value": "source if isinstance(source, PortReference) else PortReference(source)"
            },
            {
              "name": "targets",
              "description": "",
              "type": null,
              "value": "[(trg if isinstance(trg, PortReference) else PortReference(trg)) for trg in targets]"
            },
            {
              "name": "_active",
              "description": "",
              "type": null,
              "value": "True"
            },
            {
              "name": "values",
              "description": "",
              "type": null,
              "value": "None"
            },
            {
              "name": "accelerator",
              "description": "",
              "type": null,
              "value": "None"
            }
          ],
          "parameters": [
            {
              "name": "source",
              "type": null,
              "default": null,
              "description": "source block and optional source output port"
            },
            {
              "name": "targets",
              "type": null,
              "default": "()",
              "description": "target blocks and optional target input ports"
            }
          ]
        },
        {
          "name": "Duplex",
          "description": "Extension of the 'Connection' class, that defines bidirectional",
          "docstring_html": "<p>Extension of the 'Connection' class, that defines bidirectional\nconnections between two blocks by grouping together the inputs and\noutputs of the blocks into an IO-pair.</p>\n",
          "source": "class Duplex(Connection):\n    \"\"\"Extension of the 'Connection' class, that defines bidirectional \n    connections between two blocks by grouping together the inputs and \n    outputs of the blocks into an IO-pair.\n    \"\"\"\n\n    __slots__ = [\"source\", \"target\", \"targets\", \"_active\"]\n\n\n    def __init__(self, source, target):\n\n        self.source = source if isinstance(source, PortReference) else PortReference(source)\n        self.target = target if isinstance(target, PortReference) else PortReference(target)\n\n        #this is required for path length estimation\n        self.targets = [self.target, self.source]\n\n        #flag to set connection active\n        self._active = True\n\n\n    def to_dict(self):\n        \"\"\"Convert duplex to dictionary representation for serialization\"\"\"\n        return {\n            \"id\": id(self),\n            \"source\": self.source.to_dict(),\n            \"target\": self.target.to_dict()\n        }\n\n\n    def update(self):\n        \"\"\"Transfers data between the two target blocks \n        and ports bidirectionally.\n        \"\"\"\n\n        #bidirectional data transfer\n        self.target.to(self.source)\n        self.source.to(self.target)",
          "bases": [
            "pathsim.connection.Connection"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, source, target):\n\n    self.source = source if isinstance(source, PortReference) else PortReference(source)\n    self.target = target if isinstance(target, PortReference) else PortReference(target)\n\n    #this is required for path length estimation\n    self.targets = [self.target, self.source]\n\n    #flag to set connection active\n    self._active = True",
              "signature": "(source, target)",
              "parameters": [
                {
                  "name": "source",
                  "type": null,
                  "default": null,
                  "description": ""
                },
                {
                  "name": "target",
                  "type": null,
                  "default": null,
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "to_dict",
              "description": "Convert duplex to dictionary representation for serialization",
              "docstring_html": "<p>Convert duplex to dictionary representation for serialization</p>\n",
              "source": "def to_dict(self):\n    \"\"\"Convert duplex to dictionary representation for serialization\"\"\"\n    return {\n        \"id\": id(self),\n        \"source\": self.source.to_dict(),\n        \"target\": self.target.to_dict()\n    }",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "update",
              "description": "Transfers data between the two target blocks",
              "docstring_html": "<p>Transfers data between the two target blocks\nand ports bidirectionally.</p>\n",
              "source": "def update(self):\n    \"\"\"Transfers data between the two target blocks \n    and ports bidirectionally.\n    \"\"\"\n\n    #bidirectional data transfer\n    self.target.to(self.source)\n    self.source.to(self.target)",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "source",
              "description": "",
              "type": null,
              "value": "source if isinstance(source, PortReference) else PortReference(source)"
            },
            {
              "name": "target",
              "description": "",
              "type": null,
              "value": "target if isinstance(target, PortReference) else PortReference(target)"
            },
            {
              "name": "targets",
              "description": "",
              "type": null,
              "value": "[self.target, self.source]"
            },
            {
              "name": "_active",
              "description": "",
              "type": null,
              "value": "True"
            }
          ],
          "parameters": [
            {
              "name": "source",
              "type": null,
              "default": null,
              "description": ""
            },
            {
              "name": "target",
              "type": null,
              "default": null,
              "description": ""
            }
          ]
        }
      ],
      "functions": []
    },
    "pathsim.simulation": {
      "name": "pathsim.simulation",
      "description": "",
      "docstring_html": "",
      "classes": [
        {
          "name": "Simulation",
          "description": "Class that performs transient analysis of the dynamical system, defined by the",
          "docstring_html": "<p>Class that performs transient analysis of the dynamical system, defined by the\nblocks and connecions. It manages all the blocks and connections and the timestep update.</p>\n<p>The global system equation is evaluated by fixed point iteration, so the information from\neach timestep gets distributed within the entire system and is available for all blocks at\nall times.</p>\n<p>The minimum number of fixed-point iterations 'iterations_min' is set to 'None' by default\nand then the length of the longest internal signal path (with passthrough) is used as the\nestimate for minimum number of iterations needed for the information to reach all instant\ntime blocks in each timestep. Dont change this unless you know that the actual path is\nshorter or something similar that prohibits instant time information flow.</p>\n<p>Convergence check for the fixed-point iteration loop with 'tolerance_fpi' is based on\nmax absolute error (max-norm) to previous iteration and should not be touched.</p>\n<p>Multiple numerical integrators are implemented in the 'pathsim.solvers' module.\nThe default solver is a fixed timestep 2nd order Strong Stability Preserving Runge Kutta\n(SSPRK22) method which is quite fast and has ok accuracy, especially if you are forced to\ntake small steps to cover the behaviour of forcing functions. Adaptive timestepping and\nimplicit integrators are also available.</p>\n<p>Manages an event handling system based on zero crossing detection. Uses 'Event' objects\nto monitor solver states of stateful blocks and applys transformations on the state in\ncase an event is detected.</p>\n<div class=\"section\" id=\"example\">\n<h4>Example</h4>\n<p>This is how to setup a simple system simulation using the 'Simulation' class:</p>\n<pre class=\"code python literal-block\">\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"nn\">numpy</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"nn\">np</span><span class=\"w\">\n\n</span><span class=\"kn\">from</span><span class=\"w\"> </span><span class=\"nn\">pathsim</span><span class=\"w\"> </span><span class=\"kn\">import</span> <span class=\"n\">Simulation</span><span class=\"p\">,</span> <span class=\"n\">Connection</span><span class=\"w\">\n</span><span class=\"kn\">from</span><span class=\"w\"> </span><span class=\"nn\">pathsim.blocks</span><span class=\"w\"> </span><span class=\"kn\">import</span> <span class=\"n\">Source</span><span class=\"p\">,</span> <span class=\"n\">Integrator</span><span class=\"p\">,</span> <span class=\"n\">Scope</span><span class=\"w\">\n\n</span><span class=\"n\">src</span> <span class=\"o\">=</span> <span class=\"n\">Source</span><span class=\"p\">(</span><span class=\"k\">lambda</span> <span class=\"n\">t</span><span class=\"p\">:</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">cos</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"o\">*</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">pi</span><span class=\"o\">*</span><span class=\"n\">t</span><span class=\"p\">))</span><span class=\"w\">\n</span><span class=\"n\">itg</span> <span class=\"o\">=</span> <span class=\"n\">Integrator</span><span class=\"p\">()</span><span class=\"w\">\n</span><span class=\"n\">sco</span> <span class=\"o\">=</span> <span class=\"n\">Scope</span><span class=\"p\">(</span><span class=\"n\">labels</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"s2\">&quot;source&quot;</span><span class=\"p\">,</span> <span class=\"s2\">&quot;integrator&quot;</span><span class=\"p\">])</span><span class=\"w\">\n\n</span><span class=\"n\">sim</span> <span class=\"o\">=</span> <span class=\"n\">Simulation</span><span class=\"p\">(</span><span class=\"w\">\n</span>    <span class=\"n\">blocks</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"n\">src</span><span class=\"p\">,</span> <span class=\"n\">itg</span><span class=\"p\">,</span> <span class=\"n\">sco</span><span class=\"p\">],</span><span class=\"w\">\n</span>    <span class=\"n\">connections</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"w\">\n</span>        <span class=\"n\">Connection</span><span class=\"p\">(</span><span class=\"n\">src</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">],</span> <span class=\"n\">itg</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">],</span> <span class=\"n\">sco</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]),</span><span class=\"w\">\n</span>        <span class=\"n\">Connection</span><span class=\"p\">(</span><span class=\"n\">itg</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">],</span> <span class=\"n\">sco</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">])</span><span class=\"w\">\n</span>        <span class=\"p\">],</span><span class=\"w\">\n</span>    <span class=\"n\">dt</span><span class=\"o\">=</span><span class=\"mf\">0.01</span><span class=\"w\">\n</span>    <span class=\"p\">)</span><span class=\"w\">\n\n</span><span class=\"n\">sim</span><span class=\"o\">.</span><span class=\"n\">run</span><span class=\"p\">(</span><span class=\"mi\">4</span><span class=\"p\">)</span><span class=\"w\">\n</span><span class=\"n\">sim</span><span class=\"o\">.</span><span class=\"n\">plot</span><span class=\"p\">()</span>\n</pre>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>blocks <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">list[Block]</span></dt>\n<dd>blocks that define the system</dd>\n<dt>connections <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">list[Connection]</span></dt>\n<dd>connections that connect the blocks</dd>\n<dt>events <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">list[Event]</span></dt>\n<dd>list of event trackers (zero crossing detection, schedule, etc.)</dd>\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>transient simulation timestep in time units,\ndefault see ´SIM_TIMESTEP´ in ´_constants.py´</dd>\n<dt>dt_min <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>lower bound for transient simulation timestep,\ndefault see ´SIM_TIMESTEP_MIN´ in ´_constants.py´</dd>\n<dt>dt_max <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>upper bound for transient simulation timestep,\ndefault see ´SIM_TIMESTEP_MAX´ in ´_constants.py´</dd>\n<dt>Solver <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">Solver</span></dt>\n<dd>ODE solver class for numerical integration from ´pathsim.solvers´,\ndefault is ´pathsim.solvers.ssprk22.SSPRK22´ (2nd order expl. Runge Kutta)</dd>\n<dt>tolerance_fpi <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>absolute tolerance for convergence of algebraic loops\nand internal optimizers of implicit ODE solvers,\ndefault see ´SIM_TOLERANCE_FPI´ in ´_constants.py´</dd>\n<dt>iterations_max <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>maximum allowed number of iterations for implicit ODE\nsolver optimizers and algebraic loop solver,\ndefault see ´SIM_ITERATIONS_MAX´ in ´_constants.py´</dd>\n<dt>log <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool | string</span></dt>\n<dd>flag to enable logging, default see ´LOG_ENABLE´ in ´_constants.py´\n(alternatively a path to a log file can be specified)</dd>\n<dt>solver_kwargs <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">dict</span></dt>\n<dd>additional parameters for numerical solvers such as absolute\n(´tolerance_lte_abs´) and relative (´tolerance_lte_rel´) tolerance,\ndefaults are defined in ´_constants.py´</dd>\n</dl>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>time <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>global simulation time, starting at ´0.0´</dd>\n<dt>graph <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">Graph</span></dt>\n<dd>internal graph representation for fast system funcion\nevluations using DAG with algebraic depths</dd>\n<dt>engine <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">Solver</span></dt>\n<dd>global integrator (ODE solver) instance serving as a dummy to\nget attributes and access to intermediate evaluation stages</dd>\n<dt>logger <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">logging.Logger</span></dt>\n<dd>global simulation logger</dd>\n<dt>_needs_buffering <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>flag for buffering system state</dd>\n<dt>_blocks_dyn <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">list[Block]</span></dt>\n<dd>list of blocks with internal ´Solver´ instances (stateful)</dd>\n</dl>\n</div>\n",
          "source": "class Simulation:\n    \"\"\"Class that performs transient analysis of the dynamical system, defined by the \n    blocks and connecions. It manages all the blocks and connections and the timestep update.\n\n    The global system equation is evaluated by fixed point iteration, so the information from \n    each timestep gets distributed within the entire system and is available for all blocks at \n    all times.\n\n    The minimum number of fixed-point iterations 'iterations_min' is set to 'None' by default \n    and then the length of the longest internal signal path (with passthrough) is used as the \n    estimate for minimum number of iterations needed for the information to reach all instant \n    time blocks in each timestep. Dont change this unless you know that the actual path is \n    shorter or something similar that prohibits instant time information flow. \n\n    Convergence check for the fixed-point iteration loop with 'tolerance_fpi' is based on \n    max absolute error (max-norm) to previous iteration and should not be touched.\n\n    Multiple numerical integrators are implemented in the 'pathsim.solvers' module. \n    The default solver is a fixed timestep 2nd order Strong Stability Preserving Runge Kutta \n    (SSPRK22) method which is quite fast and has ok accuracy, especially if you are forced to \n    take small steps to cover the behaviour of forcing functions. Adaptive timestepping and \n    implicit integrators are also available.\n\n    Manages an event handling system based on zero crossing detection. Uses 'Event' objects \n    to monitor solver states of stateful blocks and applys transformations on the state in \n    case an event is detected. \n\n    Example\n    -------\n\n    This is how to setup a simple system simulation using the 'Simulation' class:\n\n    .. code-block:: python\n\n        import numpy as np\n\n        from pathsim import Simulation, Connection\n        from pathsim.blocks import Source, Integrator, Scope\n\n        src = Source(lambda t: np.cos(2*np.pi*t))\n        itg = Integrator()\n        sco = Scope(labels=[\"source\", \"integrator\"])\n\n        sim = Simulation(\n            blocks=[src, itg, sco],\n            connections=[\n                Connection(src[0], itg[0], sco[0]),\n                Connection(itg[0], sco[1])    \n                ],\n            dt=0.01\n            )\n\n        sim.run(4)\n        sim.plot()\n\n    Parameters\n    ----------\n    blocks : list[Block] \n        blocks that define the system\n    connections : list[Connection] \n        connections that connect the blocks\n    events : list[Event]\n        list of event trackers (zero crossing detection, schedule, etc.)\n    dt : float\n        transient simulation timestep in time units, \n        default see ´SIM_TIMESTEP´ in ´_constants.py´\n    dt_min : float\n        lower bound for transient simulation timestep, \n        default see ´SIM_TIMESTEP_MIN´ in ´_constants.py´\n    dt_max : float\n        upper bound for transient simulation timestep, \n        default see ´SIM_TIMESTEP_MAX´ in ´_constants.py´\n    Solver : Solver \n        ODE solver class for numerical integration from ´pathsim.solvers´,\n        default is ´pathsim.solvers.ssprk22.SSPRK22´ (2nd order expl. Runge Kutta)\n    tolerance_fpi : float\n        absolute tolerance for convergence of algebraic loops \n        and internal optimizers of implicit ODE solvers, \n        default see ´SIM_TOLERANCE_FPI´ in ´_constants.py´\n    iterations_max : int\n        maximum allowed number of iterations for implicit ODE \n        solver optimizers and algebraic loop solver, \n        default see ´SIM_ITERATIONS_MAX´ in ´_constants.py´\n    log : bool | string\n        flag to enable logging, default see ´LOG_ENABLE´ in ´_constants.py´\n        (alternatively a path to a log file can be specified)\n    solver_kwargs : dict\n        additional parameters for numerical solvers such as absolute \n        (´tolerance_lte_abs´) and relative (´tolerance_lte_rel´) tolerance, \n        defaults are defined in ´_constants.py´\n\n    Attributes\n    ----------\n    time : float\n        global simulation time, starting at ´0.0´\n    graph : Graph\n        internal graph representation for fast system funcion \n        evluations using DAG with algebraic depths\n    engine : Solver\n        global integrator (ODE solver) instance serving as a dummy to \n        get attributes and access to intermediate evaluation stages\n    logger : logging.Logger\n        global simulation logger\n    _needs_buffering : bool\n        flag for buffering system state\n    _blocks_dyn : list[Block]\n        list of blocks with internal ´Solver´ instances (stateful) \n    \"\"\"\n\n    def __init__(\n        self, \n        blocks=None, \n        connections=None, \n        events=None,\n        dt=SIM_TIMESTEP, \n        dt_min=SIM_TIMESTEP_MIN, \n        dt_max=SIM_TIMESTEP_MAX, \n        Solver=SSPRK22, \n        tolerance_fpi=SIM_TOLERANCE_FPI, \n        iterations_max=SIM_ITERATIONS_MAX, \n        log=LOG_ENABLE,\n        **solver_kwargs\n        ):\n\n        #system definition\n        self.blocks      = []\n        self.connections = []\n        self.events      = []\n\n        #simulation timestep and bounds\n        self.dt     = dt\n        self.dt_min = dt_min\n        self.dt_max = dt_max\n\n        #numerical integrator to be used (class definition)\n        self.Solver = Solver\n\n        #numerical integrator instance\n        self.engine = Solver()\n\n        #internal system graph -> initialized later\n        self.graph = None\n\n        #error tolerance for fixed point loop and implicit solver\n        self.tolerance_fpi = tolerance_fpi\n\n        #additional solver parameters\n        self.solver_kwargs = solver_kwargs\n\n        #iterations for fixed-point loop\n        self.iterations_max = iterations_max\n\n        #enable logging flag\n        self.log = log\n\n        #initial simulation time\n        self.time = 0.0\n\n        #flag for state buffering (transient)\n        self._needs_buffering = True\n\n        #collection of blocks with internal ODE solvers\n        self._blocks_dyn = []\n\n        #initialize logging for logging mode\n        self._initialize_logger()\n\n        #prepare and add blocks (including internal events)\n        if blocks is not None:\n            for block in blocks:\n                self.add_block(block)\n\n        #check and add connections\n        if connections is not None:\n            for connection in connections:\n                self.add_connection(connection)\n\n        #check and add events\n        if events is not None:\n            for event in events:\n                self.add_event(event)\n\n        #check if blocks from connections are in simulation\n        self._check_blocks_are_managed()\n\n        #assemble the system graph for simulation\n        self._assemble_graph()\n\n\n    def __str__(self):\n        \"\"\"String representation of the simulation using the \n        dict model format and readable json formatting\n        \"\"\"\n        return json.dumps(self.to_dict(), indent=2, sort_keys=False)\n\n\n    def __contains__(self, other):\n        \"\"\"Check if blocks, connections or events are \n        already part of the simulation \n\n        Paramters\n        ---------\n        other : obj\n            object to check if its part of simulation\n\n        Returns\n        -------\n        bool\n        \"\"\"\n        return (\n            other in self.blocks or \n            other in self.connections or \n            other in self.events\n            )\n\n\n    # methods for access to metadata ----------------------------------------------\n\n    def size(self):\n        \"\"\"Get size information of the simulation, such as total number \n        of blocks and dynamic states, with recursive retrieval from subsystems\n\n        Returns\n        -------\n        sizes : tuple[int]\n            size of block (default 1) and number \n            of internal states (from internal engine)\n        \"\"\"\n        total_n, total_nx = 0, 0\n        for block in self.blocks:\n            n, nx = block.size()\n            total_n += n\n            total_nx += nx\n        return total_n, total_nx\n\n\n    # logger methods --------------------------------------------------------------\n\n    def _initialize_logger(self):\n        \"\"\"\n        setup and configure logging\n        \"\"\"\n\n        #initialize the logger\n        self.logger = logging.Logger(\"PathSim_Simulation_Logger\")\n\n        #capture warnings from the 'warnings' module\n        logging.captureWarnings(True)\n\n        #check if logging is enabled\n        if self.log:    \n\n            #if a filename for logging is specified\n            if isinstance(self.log, str):\n                handler = logging.FileHandler(self.log) \n            else:\n                handler = logging.StreamHandler()\n\n            #logging format\n            handler.setFormatter(\n                logging.Formatter(\"%(asctime)s - %(levelname)s - %(message)s\")   \n                )\n\n            self.logger.addHandler(handler)\n            self.logger.setLevel(logging.INFO)\n\n            self._logger_info(f\"LOGGING (log: {self.log})\")\n\n\n    def _logger_info(self, message):\n        if self.log: self.logger.info(message)\n\n\n    def _logger_error(self, message, Error=None):\n        if self.log: self.logger.error(message)\n        if Error is not None: raise Error(message)\n\n\n    def _logger_warning(self, message):\n        if self.log: self.logger.warning(message)\n\n\n    # visualization ---------------------------------------------------------------\n\n    def plot(self, *args, **kwargs):\n        \"\"\"Plot the simulation results by calling all the blocks \n        that have visualization capabilities such as the 'Scope' \n        and 'Spectrum'.\n\n        This is a quality of life method. Blocks can be visualized \n        individually due to the object oriented nature, but it might \n        be nice to just call the plot metho globally and look at all \n        the results at once. Also works for models loaded from an \n        external file.\n\n        Parameters\n        ----------\n        args : tuple\n            args for the plot methods\n        kwargs : dict\n            kwargs for the plot method\n        \"\"\"\n        for block in self.blocks:\n            if block: block.plot(*args, **kwargs)\n\n\n    # serialization/deserialization -----------------------------------------------\n\n    def save(self, path=\"\", **metadata):\n        \"\"\"Save the dictionary representation of the simulation instance \n        to an external file\n\n        Parameters\n        ----------\n        path : str\n            filepath to save data to\n        metadata : dict\n            metadata for the simulation model\n        \"\"\"\n\n        #add current pathsim version\n        metadata[\"version\"] = __version__\n\n        #add current timestamp\n        metadata[\"timestamp\"] = datetime.datetime.now().isoformat()\n\n        with open(path, \"w\", encoding=\"utf-8\") as file:\n            json.dump(self.to_dict(**metadata), file, indent=2, ensure_ascii=False)\n\n\n    @classmethod\n    def load(cls, path=\"\", **kwargs):\n        \"\"\"Load and instantiate a Simulation from an external file \n        in json format\n\n        Parameters\n        ----------\n        path : str\n            filepath to load data from\n        kwargs : dict\n            additional args for the simulation, overwriting metadata\n\n        Returns\n        -------\n        out : Simulation\n            reconstructed object from dict representation\n        \"\"\"\n        with open(path, \"r\", encoding=\"utf-8\") as file:\n            return cls.from_dict(json.load(file), **kwargs)\n        return None\n\n\n    def to_dict(self, **metadata):\n        \"\"\"Convert simulation to a complete model representation as a dict\n        with additional metadata.\n\n        Parameters\n        ----------\n        metadata : dict\n            metadata for the simulation model\n\n        Returns\n        -------\n        data : dict\n            dict that describes the simulation model\n        \"\"\"\n\n        #serialize system components\n        blocks = [block.to_dict() for block in self.blocks]\n        events = [event.to_dict() for event in self.events]\n        connections = [conn.to_dict() for conn in self.connections]\n\n        #create the full model\n        return {\n            \"type\": \"Simulation\",\n            \"metadata\": metadata,\n            \"structure\": {\n                \"blocks\": blocks,\n                \"events\": events,\n                \"connections\": connections\n                },\n            \"params\": {\n                \"dt\": self.dt,\n                \"dt_min\": self.dt_min,\n                \"dt_max\": self.dt_max,\n                \"Solver\": self.Solver.__name__,\n                \"tolerance_fpi\": self.tolerance_fpi,\n                \"iterations_max\": self.iterations_max,\n                **self.solver_kwargs\n                }\n            }\n\n\n    @classmethod\n    def from_dict(cls, data, **kwargs):\n        \"\"\"Create simulation from model data dict\n\n        Parameters\n        ----------\n        data : dict\n            model definition in json format\n        kwargs : dict\n            additional args for the simulation, overwriting metadata\n\n        Returns\n        -------\n        simulation : Simulation\n            instance of the Simulation class with mode definition\n        \"\"\"\n        from . import solvers\n\n        #get system structure\n        structure = data.get(\"structure\", {})\n\n        #deserialize blocks and create block ID mapping\n        blocks, id_to_block = [], {}\n        for block_data in structure.get(\"blocks\", []):\n            block = Block.from_dict(block_data)\n            blocks.append(block)\n            id_to_block[block_data[\"id\"]] = block\n\n        #deserialize connections\n        connections = []\n        for conn_data in structure.get(\"connections\", []):\n\n            #get source block and port\n            source_block = id_to_block[conn_data[\"source\"][\"block\"]]\n            source_ports = conn_data[\"source\"][\"ports\"]\n            source = PortReference(source_block, source_ports)\n\n            #get targets\n            targets = []\n            for trg in conn_data[\"targets\"]:\n                target_block = id_to_block[trg[\"block\"]]\n                target_ports = trg[\"ports\"]\n                targets.append(\n                    PortReference(target_block, target_ports)\n                    )\n\n            #create connection\n            connections.append(\n                Connection(source, *targets)\n                )\n\n        #deserialize events\n        events = []\n        for event_data in structure.get(\"events\", []):\n            events.append(Event.from_dict(event_data))\n\n        #get simulation parameters\n        params = data.get(\"params\", {})\n\n        #get solver class\n        solver_name = params.get(\"Solver\", \"SSPRK22\")\n        params[\"Solver\"] = getattr(solvers, solver_name)\n\n        #update with additional kwargs\n        for name, val in kwargs.items():\n            params[name] = val\n\n        #create simulation\n        return cls(\n            blocks=blocks,\n            connections=connections,\n            events=events,\n            **params\n            )\n\n\n    # adding system components ----------------------------------------------------\n\n    def add_block(self, block):\n        \"\"\"Adds a new block to the simulation, initializes its local solver \n        instance and collects internal events of the new block. \n\n        This works dynamically for running simulations.\n\n        Parameters\n        ----------\n        block : Block \n            block to add to the simulation\n        \"\"\"\n\n        #check if block already in block list\n        if block in self.blocks:\n            _msg = f\"block {block} already part of simulation\"\n            self._logger_error(_msg, ValueError)\n\n        #initialize numerical integrator of block\n        block.set_solver(self.Solver, **self.solver_kwargs)\n\n        #add to dynamic list if solver was initialized\n        if block.engine and block not in self._blocks_dyn:\n            self._blocks_dyn.append(block)\n\n        #add block to global blocklist\n        self.blocks.append(block)\n\n        #add events of block to global event list\n        for event in block.get_events():\n            self.add_event(event)\n\n        #if graph already exists, it needs to be rebuilt\n        if self.graph:\n            self._assemble_graph()\n\n\n    def add_connection(self, connection):\n        \"\"\"Adds a new connection to the simulaiton and checks if \n        the new connection overwrites any existing connections.\n\n        This works dynamically for running simulations.\n\n        Parameters\n        ----------\n        connection : Connection\n            connection to add to the simulation\n        \"\"\"\n\n        #check if connection already in connection list\n        if connection in self.connections:\n            _msg = f\"{connection} already part of simulation\"\n            self._logger_error(_msg, ValueError)\n\n        #check if connection overwrites existing connections\n        for conn in self.connections:\n            if connection.overwrites(conn):\n                _msg = f\"{connection} overwrites {conn}\"\n                self._logger_error(_msg, ValueError)\n\n        #add connection to global connection list\n        self.connections.append(connection)\n\n        #if graph already exists, it needs to be rebuilt\n        if self.graph:\n            self._assemble_graph()\n\n\n    def add_event(self, event):\n        \"\"\"Checks and adds a new event to the simulation.\n\n        This works dynamically for running simulations.\n\n        Parameters\n        ----------\n        event : Event\n            event to add to the simulation\n        \"\"\"\n\n        #check if event already in event list\n        if event in self.events:\n            _msg = f\"{event} already part of simulation\"\n            self._logger_error(_msg, ValueError)\n\n        #add event to global event list\n        self.events.append(event)\n\n\n    # system assembly -------------------------------------------------------------\n\n    def _assemble_graph(self):\n        \"\"\"Build the internal graph representation for fast system function \n        evaluation and algebraic loop resolution.\n        \"\"\"\n\n        #time the graph construction\n        with Timer(verbose=False) as T:\n            self.graph = Graph(self.blocks, self.connections)\n\n        self._logger_info(\n            \"GRAPH (size: {}, alg. depth: {}, loop depth: {}, runtime: {})\".format(\n                len(self.graph), *self.graph.depth(), T\n                )\n            )\n\n\n    # topological checks ----------------------------------------------------------\n\n    def _check_blocks_are_managed(self):\n        \"\"\"Check whether the blocks that are part of the connections are \n        in the simulation block list ('self.blocks') and therefore managed \n        by the simulation.\n\n        If not, there will be a warning in the logging.            \n        \"\"\"\n        #collect blocks from connections\n        conn_blocks = []\n        for conn in self.connections:\n            conn_blocks.extend(conn.get_blocks())\n\n        #iterate set of blocks from connections (unique)\n        for blk in set(conn_blocks):\n            if blk not in self.blocks:\n                self._logger_warning(\n                    f\"{blk} in 'connections' but not in 'blocks'!\"\n                    )\n\n\n    # solver management -----------------------------------------------------------\n\n    def _set_solver(self, Solver=None, **solver_kwargs):\n        \"\"\"Initialize all blocks with solver for numerical integration\n        and tolerance for local truncation error ´tolerance_lte´.\n\n        If blocks already have solvers, change the numerical integrator\n        to the ´Solver´ class.\n\n        Parameters\n        ----------\n        Solver : Solver\n            numerical solver definition from ´pathsim.solvers´\n        solver_kwargs : dict\n            additional parameters for numerical solvers\n        \"\"\"\n\n        #update global solver class\n        if Solver is not None:\n            self.Solver = Solver\n\n        #update solver parmeters\n        for k, v in solver_kwargs.items():\n            self.solver_kwargs[k] = v\n\n        #initialize dummy engine to get solver attributes\n        self.engine = self.Solver()\n\n        #iterate all blocks and set integration engines with tolerances\n        self._blocks_dyn = []\n        for block in self.blocks:\n            block.set_solver(self.Solver, **self.solver_kwargs)\n\n            #add dynamic blocks to list\n            if block.engine:\n                self._blocks_dyn.append(block)\n\n        #logging message\n        self._logger_info(\n            \"SOLVER (dyn. blocks: {}) -> {} (adaptive: {}, explicit: {})\".format(\n                len(self._blocks_dyn),\n                self.engine,\n                self.engine.is_adaptive, \n                self.engine.is_explicit\n                )\n            )\n\n\n    # resetting -------------------------------------------------------------------\n\n    def reset(self, time=0.0):\n        \"\"\"Reset the blocks to their initial state and the global time of \n        the simulation. \n\n        For recording blocks such as 'Scope', their recorded \n        data is also reset. \n\n        Resets linearization automatically, since resetting the blocks \n        resets their internal operators.\n\n        Afterwards the system function is evaluated with '_update' to update\n        the block inputs and outputs.\n\n        Parameters\n        ----------\n        time : float\n            simulation time for reset\n        \"\"\"\n\n        self._logger_info(f\"RESET (time: {time})\")\n\n        #reset simulation time\n        self.time = time\n\n        #reset all blocks to initial state\n        for block in self.blocks:\n            block.reset()\n\n        #reset all event managers\n        for event in self.events:\n            event.reset()\n\n        #evaluate system function\n        self._update(self.time)\n\n\n    # linearization ---------------------------------------------------------------\n\n    def linearize(self):\n        \"\"\"Linearize the full system in the current simulation state \n        at the current simulation time.\n\n        This is achieved by linearizing algebraic and dynamic operators \n        of the internal blocks. See definition of the 'Block' class.\n\n        Before linearization, the global system function is evaluated \n        to get the blocks into the current simulation state. \n        This is only really relevant if no solving attempt has been \n        happened before.\n        \"\"\"\n        #evaluate system function at current time\n        self._update(self.time)\n\n        #linearize all internal blocks and time it\n        with Timer(verbose=False) as T:\n            for block in self.blocks:\n                block.linearize(self.time)\n\n        self._logger_info(f\"LINEARIZED (runtime: {T})\")\n\n\n    def delinearize(self):\n        \"\"\"Revert the linearization of the full system.\"\"\"\n        for block in self.blocks: \n            block.delinearize()\n\n        self._logger_info(\"DELINEARIZED\")\n\n\n    # event system helpers --------------------------------------------------------\n\n    def _estimate_events(self, t):\n        \"\"\"Estimate the time until the next.\n\n        Parameters\n        ----------\n        t : float \n            evaluation time for event estimation\n\n        Returns\n        -------\n        float | None\n            esimated time until next event (delta)\n        \"\"\"\n\n        dt_evt_min = None\n        for event in self.events:\n\n            #skip inactive events\n            if not event: continue\n\n            #get the estimate\n            dt_evt = event.estimate(self.time)\n\n            #check if estimate available and smaller than min\n            if dt_evt_min is None or (dt_evt is not None and dt_evt < dt_evt_min):\n                dt_evt_min = dt_evt\n\n        #return time until next event or None\n        return dt_evt_min\n\n\n    def _buffer_events(self, t):\n        \"\"\"Buffer states for event monitoring before the timestep \n        is taken. \n\n        This is required to set reference for event monitoring and \n        backtracking for root finding.\n\n        Parameters\n        ----------\n        t : float \n            evaluation time for buffering\n        \"\"\"\n\n        #buffer states for event detection (with timestamp)\n        for event in self.events:\n            if event: event.buffer(t)\n\n\n    def _detected_events(self, t):\n        \"\"\"Check for possible (active) events and return them chronologically, \n        sorted by their timestep ratios (closest to the initial point in time).\n\n        Parameters\n        ----------\n        t : float\n            evaluation time for event function\n\n        Returns\n        -------\n        detected : list[Event]\n            list of detected events within timestep\n        \"\"\"\n\n        #iterate all event managers\n        detected_events = []\n        for event in self.events:\n\n            #skip inactive events\n            if not event: continue\n\n            #check if an event is detected\n            detected, close, ratio = event.detect(t)\n\n            #event was detected during the timestep \n            if detected:\n                detected_events.append([event, close, ratio])\n\n        #return detected events sorted by ratio\n        return sorted(detected_events, key=lambda e: e[-1])\n\n\n    # solving system equations ----------------------------------------------------\n\n\n    def _update(self, t):        \n        \"\"\"Distribute information within the system by evaluating the directed acyclic graph \n        (DAG) formed by the algebraic passthroughs of the blocks and resolving algebraic loops \n        through accelerated fixed-point iterations.\n\n        Effectively evaluates the right hand side function of the global \n        system ODE/DAE\n\n        .. math:: \n\n            \\\\begin{equnarray}\n                \\\\dot{x} &= f(x, t) \\\\\\\\\n                       0 &= g(x, t) \n            \\\\end{equnarray}\n\n        by converging the whole system (´f´ and ´g´) to a fixed-point at a given point \n        in time ´t´.\n\n        If no algebraic loops are present in the system, convergence is \n        guaranteed after the first stage (evaluation of the DAG in '_dag'). \n\n        Otherwise, accelerated fixed-point iterations ('_loops') are performed as a second \n        stage on the DAGs (broken cycles) of blocks that are part of or tainted by upstream \n        algebraic loops. \n\n        Parameters\n        ----------\n        t : float\n            evaluation time for system function\n        \"\"\"\n\n        #evaluate DAG\n        self._dag(t)\n\n        #algebraic loops -> solve them\n        if self.graph.has_loops:   \n            self._loops(t)\n\n\n    def _dag(self, t):\n        \"\"\"Update the directed acyclic graph components of the system.\n\n        Parameters\n        ----------\n        t : float\n            evaluation time for system function\n        \"\"\"\n\n        #perform gauss-seidel iterations without error checking\n        for _, blocks_dag, connections_dag in self.graph.dag():\n\n            #update blocks at algebraic depth (no error control)\n            for block in blocks_dag:\n                if block: block.update(t)\n\n            #update connenctions at algebraic depth (data transfer)\n            for connection in connections_dag:\n                if connection: connection.update()\n\n\n    def _loops(self, t):\n        \"\"\"Perform the algebraic loop solve of the system using accelerated \n        fixed-point iterations on the broken loop directed graph.\n\n        Parameters\n        ----------\n        t : float\n            evaluation time for system function\n        \"\"\"\n\n        #perform solver iterations on algebraic loops\n        for iteration in range(1, self.iterations_max):\n\n            #iterate DAG depths of broken loops\n            max_error = 0.0\n            for depth, blocks_loop, connections_loop in self.graph.loop():\n\n                #update blocks at algebraic depth\n                for block in blocks_loop:\n                    if block: block.update(t)\n\n                #step accelerated connenctions at algebraic depth (data transfer)\n                for connection in connections_loop:\n\n                    #skip inactive connections\n                    if not connection: \n                        continue\n\n                    #connections at first depth\n                    if depth == 0:\n\n                        #reset solver at first iteration\n                        if iteration == 1: \n                            connection.reset()\n\n                        #step fixed-point solver (for alg. loops)\n                        err = connection.step() \n                        if err > max_error:\n                            max_error = err\n\n                    else:\n\n                        #connections at lower depths\n                        connection.update()\n\n            #check convergence\n            if max_error <= self.tolerance_fpi:\n                return\n\n        #not converged -> error\n        self._logger_error(\n            \"fixed-point loop in '_update' not converged (iters: {}, err: {})\".format(\n                self.iterations_max, max_error), \n            RuntimeError\n            )\n\n\n    def _solve(self, t, dt):\n        \"\"\"For implicit solvers, this method implements the solving step \n        of the implicit update equation.\n\n        It already involves the evaluation of the system equation with \n        the '_update' method within the loop.\n\n        This also tracks the evolution of the solution as an estimate \n        for the convergence via the max residual norm of the fixed point \n        equation of the previous solution.\n\n        Parameters\n        ----------\n        t : float\n            evaluation time for system function\n        dt : float\n            timestep\n\n        Returns\n        -------\n        success : bool\n            indicator if the timestep was successful\n        total_evals : int\n            total number of system evaluations\n        total_solver_its : int\n            total number of implicit solver iterations\n        \"\"\"\n\n        #total evaluations of system equation\n        total_evals = 0\n\n        #perform fixed-point iterations to solve implicit update equation\n        for it in range(self.iterations_max):\n\n            #evaluate system equation (this is a fixed point loop)\n            self._update(t)\n            total_evals += 1            \n\n            #advance solution of implicit solver\n            max_error = 0.0\n            for block in self._blocks_dyn:\n\n                #skip inactive blocks\n                if not block: \n                    continue\n\n                #advance solution (internal optimizer)\n                error = block.solve(t, dt)\n                if error > max_error:\n                    max_error = error\n\n            #check for convergence (only error)\n            if max_error <= self.tolerance_fpi:\n                return True, total_evals, it+1\n\n        #not converged in 'self.iterations_max' steps\n        return False, total_evals, self.iterations_max\n\n\n    def steadystate(self, reset=False): \n        \"\"\"Find steady state solution (DC operating point) of the system \n        by switching all blocks to steady state solver, solving the \n        fixed point equations, then switching back.\n\n        The steady state solver forces all the temporal derivatives, i.e.\n        the right hand side equation (including external inputs) of the \n        engines of dynamic blocks to zero.\n\n        Parameters\n        ----------\n        reset : bool\n            reset the simulation before solving for steady state (default False)\n        \"\"\"\n\n        #reset the simulation before solving\n        if reset:\n            self.reset()\n\n        #current solver class\n        _solver = self.Solver\n\n        #switch to steady state solver\n        self._set_solver(SteadyState)\n\n        #log message begin of steady state solver\n        self._logger_info(f\"STEADYSTATE -> STARTING (reset: {reset})\")\n\n        #solve for steady state at current time\n        with Timer(verbose=False) as T:\n            success, evals, iters = self._solve(self.time, self.dt)\n\n        #catch non convergence\n        if not success:\n            self._logger_error(\n                \"STEADYSTATE -> FINISHED (success: {}, evals: {}, iters: {}, runtime: {})\".format(\n                    success, evals, iters, T), \n                RuntimeError\n                )\n\n        #sample result\n        self._sample(self.time)\n\n        #log message \n        self._logger_info(\n            \"STEADYSTATE -> FINISHED (success: {}, evals: {}, iters: {}, runtime: {})\".format(\n                success, evals, iters, T)\n            )\n\n        #switch back to original solver\n        self._set_solver(_solver)\n\n\n    # timestepping helpers --------------------------------------------------------\n\n    def _revert(self):\n        \"\"\"Revert simulation state to previous timestep for adaptive solvers \n        when local truncation error is too large and timestep has to be \n        retaken with smaller timestep. \n        \"\"\"\n\n        #revert dummy engine (for history)\n        self.engine.revert()\n\n        #revert block states\n        for block in self._blocks_dyn:\n            if block: block.revert()\n\n\n    def _sample(self, t):\n        \"\"\"Sample data from blocks that implement the 'sample' method such \n        as 'Scope', 'Delay' and the blocks that sample from a random \n        distribution at a given time 't'.\n\n        Parameters\n        ----------\n        t : float\n            time where to sample\n        \"\"\"\n        for block in self.blocks:\n            if block: block.sample(t)\n\n\n    def _buffer_blocks(self, dt):\n        \"\"\"Buffer internal states of blocks before the timestep is taken. \n\n        This is required for runge-kutta integrators but also for the \n        zero crossing detection of the event handling system.\n\n        The timesteps are also buffered because some integrators such as \n        GEAR-type methods need a history of the timesteps.\n\n        Parameters\n        ----------\n        dt : float\n            timestep\n        \"\"\"\n        #buffer the dummy engine\n        self.engine.buffer(dt)\n\n        #buffer internal states of stateful blocks\n        for block in self._blocks_dyn:\n            if block: block.buffer(dt)\n\n\n    def _step(self, t, dt):\n        \"\"\"Performs the 'step' method for dynamical blocks with internal \n        states that have a numerical integration engine. \n\n        Collects the local truncation error estimates and the timestep \n        rescale factor from the error controllers of the internal \n        intergation engines if they provide an error estimate \n        (for example embedded Runge-Kutta methods).\n\n        Notes\n        -----\n        Not to be confused with the global 'step' method, the '_step' \n        method executes the intermediate timesteps in multistage solvers \n        such as Runge-Kutta methods.\n\n        Parameters\n        ----------\n        t : float\n            evaluation time of dynamical timestepping\n        dt : float\n            timestep\n\n        Returns\n        -------\n        success : bool \n            indicator if the timestep was successful\n        max_error : float \n            maximum local truncation error from integration\n        scale : float\n            rescale factor for timestep\n        \"\"\"\n\n        #initial timestep rescale and error estimate\n        success, max_error_norm, relevant_scales = True, 0.0, []\n\n        #step blocks and get error estimates if available\n        for block in self._blocks_dyn:\n\n            #skip inactive blocks\n            if not block: continue\n\n            #step the block\n            suc, err_norm, scl = block.step(t, dt)\n\n            #check solver stepping success\n            if not suc: \n                success = False\n\n            #update error tracking\n            if err_norm > max_error_norm: \n                max_error_norm = err_norm\n\n            #update timestep rescale if relevant\n            if scl != 1.0 and scl > 0.0: \n                relevant_scales.append(scl)\n\n        #no relevant timestep rescale -> quit early\n        if not relevant_scales: \n            return success, max_error_norm, 1.0\n\n        #compute real timestep rescale\n        return success, max_error_norm, min(relevant_scales)\n\n\n    # timestepping ----------------------------------------------------------------\n\n    def timestep_fixed_explicit(self, dt=None):\n        \"\"\"Advances the simulation by one timestep 'dt' for explicit \n        fixed step solvers.\n\n        If discrete events are detected, they are resolved immediately \n        within the timestep.\n\n        Parameters\n        ----------\n        dt : float\n            timestep\n\n        Returns\n        -------\n        success : bool\n            indicator if the timestep was successful\n        max_error : float\n            maximum local truncation error from integration\n        scale : float\n            rescale factor for timestep\n        total_evals : int\n            total number of system evaluations\n        total_solver_its : int\n            total number of implicit solver iterations\n        \"\"\"\n\n        #default global timestep as local timestep\n        if dt is None: \n            dt = self.dt\n\n        #buffer states for event system\n        self._buffer_events(self.time)\n\n        #buffer internal states for solvers\n        self._buffer_blocks(dt)\n\n        #total function evaluations \n        total_evals = 0\n\n        #iterate explicit solver stages with evaluation time (generator)\n        for time_stage in self.engine.stages(self.time, dt):\n\n            #evaluate system equation by fixed-point iteration\n            self._update(time_stage) \n            total_evals += 1\n\n            #timestep for dynamical blocks (with internal states)\n            _1, error_norm, _3 = self._step(time_stage, dt)\n\n        #system time after timestep\n        time_dt = self.time + dt\n\n        #evaluate system equation before sampling and event check (+dt)\n        self._update(time_dt) \n        total_evals += 1\n\n        #handle events chronologically after timestep (+dt)\n        for event, _, ratio in self._detected_events(time_dt):\n\n            #fixed timestep -> resolve event directly\n            event.resolve(self.time + ratio * dt)  \n\n            #after resolve, evaluate system equation again -> propagate event\n            self._update(time_dt)  \n            total_evals += 1\n\n        #sample data after successful timestep (+dt)\n        self._sample(time_dt)\n\n        #increment global time and continue simulation\n        self.time = time_dt \n\n        #max local truncation error, timestep rescale, successful step\n        return True, error_norm, 1.0, total_evals, 0\n\n\n    def timestep_fixed_implicit(self, dt=None): \n        \"\"\"Advances the simulation by one timestep 'dt' for implicit \n        fixed step solvers.\n\n        If discrete events are detected, they are resolved immediately \n        within the timestep.\n\n        Parameters\n        ----------\n        dt : float\n            timestep\n\n        Returns\n        -------\n        success : bool\n            indicator if the timestep was successful\n        max_error : float\n            maximum local truncation error from integration\n        scale : float\n            rescale factor for timestep\n        total_evals : int\n            total number of system evaluations\n        total_solver_its : int\n            total number of implicit solver iterations\n        \"\"\"\n\n        #successful by default\n        success = True\n\n        #default global timestep as local timestep\n        if dt is None: \n            dt = self.dt\n\n        #buffer states for event system\n        self._buffer_events(self.time)\n\n        #buffer internal states for solvers\n        self._buffer_blocks(dt)\n\n        #total function evaluations and implicit solver iterations\n        total_evals, total_solver_its = 0, 0\n\n        #iterate explicit solver stages with evaluation time (generator)\n        for time_stage in self.engine.stages(self.time, dt):\n\n            #solve implicit update equation and get iteration count\n            success, evals, solver_its = self._solve(time_stage, dt)\n\n            #warning if implicit solver didnt converge in timestep\n            if not success:\n                self._logger_warning(\n                    f\"implicit solver not converged in {solver_its} iterations!\"\n                    )\n\n            #count solver iterations and function evaluations\n            total_solver_its += solver_its\n            total_evals += evals\n\n            #timestep for dynamical blocks (with internal states)\n            _1, error_norm, _3 = self._step(time_stage, dt)\n\n        #system time after timestep\n        time_dt = self.time + dt\n\n        #evaluate system equation before sampling and event check (+dt)\n        self._update(time_dt) \n        total_evals += 1\n\n        #handle events chronologically after timestep (+dt)\n        for event, _, ratio in self._detected_events(time_dt):\n\n            #fixed timestep -> resolve event directly\n            event.resolve(self.time + ratio * dt)  \n\n            #after resolve, evaluate system equation again -> propagate event\n            self._update(time_dt)  \n            total_evals += 1    \n\n        #sample data after successful timestep (+dt)\n        self._sample(time_dt)\n\n        #increment global time and continue simulation\n        self.time = time_dt \n\n        #max local truncation error, timestep rescale, successful step\n        return success, error_norm, 1.0, total_evals, total_solver_its\n\n\n    def timestep_adaptive_explicit(self, dt=None): \n        \"\"\"Advances the simulation by one timestep 'dt' for explicit \n        adaptive solvers.\n\n        If the local truncation error of the solver exceeds the tolerances \n        set in the 'solver_kwargs', the simulation state is reverted to the \n        state that was buffered (`_buffer(time, dt)`) at the beginning of \n        the timestep.\n\n        If discrete events are detected, the chronologically first event is \n        handled only. The event location (in time) is approached adaptively \n        by reverting the step and adjusting the stepsize (this is equivalent \n        to the secant method for finding zeros of the event function) until \n        the tolerance of the event is satisfied (close==True).\n\n        Parameters\n        ----------\n        dt : float\n            timestep\n\n        Returns\n        -------\n        success : bool\n            indicator if the timestep was successful\n        max_error : float\n            maximum local truncation error from integration\n        scale : float\n            rescale factor for timestep\n        total_evals : int\n            total number of system evaluations\n        total_solver_its : int\n            total number of implicit solver iterations\n        \"\"\"\n\n        #default global timestep as local timestep\n        if dt is None: \n            dt = self.dt\n\n        #buffer states for event system\n        self._buffer_events(self.time)\n\n        #buffer internal states for solvers\n        self._buffer_blocks(dt)\n\n        #total function evaluations and implicit solver iterations\n        total_evals = 0\n\n        #iterate explicit solver stages with evaluation time (generator)\n        for time_stage in self.engine.stages(self.time, dt):\n\n            #evaluate system equation by fixed-point iteration\n            self._update(time_stage) \n            total_evals += 1\n\n            #timestep for dynamical blocks (with internal states)\n            success, error_norm, scale = self._step(time_stage, dt)\n\n        #if step not successful -> roll back timestep\n        if not success:\n            self._revert()\n            self._update(self.time) \n            total_evals += 1\n            return False, error_norm, scale, total_evals, 0\n\n        #system time after timestep\n        time_dt = self.time + dt\n\n        #evaluate system equation before sampling and event check (+dt)\n        self._update(time_dt) \n        total_evals += 1\n\n        #handle detected events chronologically after timestep (+dt)\n        for event, close, ratio in self._detected_events(time_dt):\n\n            #close enough to event (ratio approx 1.0) -> resolve it\n            if close:\n                event.resolve(time_dt)\n\n                #after resolve, evaluate system equation again -> propagate event\n                self._update(time_dt) \n                total_evals += 1\n\n            #not close enough -> roll back timestep (secant step)\n            else:\n                self._revert()\n                self._update(self.time) \n                total_evals += 1\n                return False, error_norm, ratio, total_evals, 0\n\n        #sample data after successful timestep (+dt)\n        self._sample(time_dt)\n\n        #increment global time and continue simulation\n        self.time = time_dt    \n\n        #max local truncation error, timestep rescale, successful step\n        return success, error_norm, scale, total_evals, 0\n\n\n    def timestep_adaptive_implicit(self, dt=None): \n        \"\"\"Advances the simulation by one timestep 'dt' for implicit \n        adaptive solvers.\n\n        If the local truncation error of the solver exceeds the tolerances \n        set in the 'solver_kwargs', the simulation state is reverted to the \n        state that was buffered (`_buffer(time, dt)`) at the beginning of \n        the timestep.\n\n        If the solution of the implicit update equation in 'solve' doesnt \n        converge, the timestep is also considered unsuccessful. Then it is \n        reverted and the timestep is halfed.\n\n        If discrete events are detected, the chronologically first event is \n        handled only. The event location (in time) is approached adaptively \n        by reverting the step and adjusting the stepsize (this is equivalent \n        to the secant method for finding zeros of the event function) until \n        the tolerance of the event is satisfied (close==True).\n\n        Parameters\n        ----------\n        dt : float\n            timestep\n\n        Returns\n        -------\n        success : bool\n            indicator if the timestep was successful\n        max_error : float\n            maximum local truncation error from integration\n        scale : float\n            rescale factor for timestep\n        total_evals : int\n            total number of system evaluations\n        total_solver_its : int\n            total number of implicit solver iterations\n        \"\"\"\n\n        #default global timestep as local timestep\n        if dt is None: \n            dt = self.dt\n\n        #buffer states for event system\n        self._buffer_events(self.time)\n\n        #buffer internal states for solvers\n        self._buffer_blocks(dt)\n\n        #total function evaluations and implicit solver iterations\n        total_evals, total_solver_its = 0, 0\n\n        #iterate explicit solver stages with evaluation time (generator)\n        for time_stage in self.engine.stages(self.time, dt):\n\n            #solve implicit update equation and get iteration count\n            success, evals, solver_its = self._solve(time_stage, dt)\n\n            #count solver iterations and function evaluations\n            total_solver_its += solver_its\n            total_evals += evals\n\n            #if solver did not converge -> quit early (adaptive only)\n            if not success:\n                self._revert()\n                self._update(self.time) \n                return False, 0.0, 0.5, total_evals+1, total_solver_its  \n\n            #timestep for dynamical blocks (with internal states)\n            success, error_norm, scale = self._step(time_stage, dt)\n\n        #if step not successful -> roll back timestep\n        if not success:\n            self._revert()\n            self._update(self.time) \n            return False, error_norm, scale, total_evals+1, total_solver_its\n\n        #system time after timestep\n        time_dt = self.time + dt\n\n        #evaluate system equation before sampling and event check (+dt)\n        self._update(time_dt) \n        total_evals += 1\n\n        #handle detected events chronologically after timestep (+dt)\n        for event, close, ratio in self._detected_events(time_dt):\n\n            #close enough to event (ratio approx 1) -> resolve it\n            if close:\n                event.resolve(time_dt)\n\n                #after resolve, evaluate system equation again -> propagate event\n                self._update(time_dt) \n                total_evals += 1\n\n            #not close enough -> roll back timestep (secant step)\n            else:\n                self._revert()\n                self._update(self.time) \n                total_evals += 1\n                return False, error_norm, ratio, total_evals, total_solver_its\n\n        #sample data after successful timestep (+dt)\n        self._sample(time_dt)\n\n        #increment global time and continue simulation\n        self.time = time_dt    \n\n        #max local truncation error, timestep rescale, successful step\n        return success, error_norm, scale, total_evals, total_solver_its\n\n\n    def timestep(self, dt=None, adaptive=True):\n        \"\"\"Advances the transient simulation by one timestep 'dt'. \n\n        Automatic stepping method selection based on \n        selected `Solver`.\n\n        Parameters\n        ----------\n        dt : float\n            timestep size for transient simulation\n        adaptive : bool\n            explicitly select the addaptive timestepping branch\n\n        Returns\n        -------\n        success : bool\n            indicator if the timestep was successful\n        max_error : float\n            maximum local truncation error from integration\n        scale : float\n            rescale factor for timestep\n        total_evals : int\n            total number of system evaluations\n        total_solver_its : int\n            total number of implicit solver iterations            \n        \"\"\"\n        if adaptive and self.engine.is_adaptive:\n            if self.engine.is_explicit:\n                return self.timestep_adaptive_explicit(dt)\n            else:                \n                return self.timestep_adaptive_implicit(dt)\n        else:\n            if self.engine.is_explicit:\n                return self.timestep_fixed_explicit(dt)\n            else:                \n                return self.timestep_fixed_implicit(dt)\n\n\n    def step(self, dt=None, adaptive=True):\n        \"\"\"Wraps 'Simulation.timestep' for backward compatibility\"\"\"\n        self._logger_warning(\n            \"'Simulation.step' method will be deprecated in next release, use 'Simulation.timestep' instead!\"\n            )\n        return self.timestep(dt, adaptive)\n\n\n    # simulation execution --------------------------------------------------------\n\n    def run(self, duration=10, reset=False, adaptive=True):\n        \"\"\"Perform multiple simulation timesteps for a given 'duration'.\n\n        Tracks the total number of block evaluations (proxy for function \n        calls, although larger, since one function call of the system equation \n        consists of many block evaluations) and the total number of solver\n        iterations for implicit solvers.\n\n        Additionally the progress of the simulation is tracked by a custom\n        'ProgressTracker' class that is a dynamic generator and interfaces \n        the logging system.\n\n        Parameters\n        ----------\n        duration : float\n            simulation time (in time units)\n        reset : bool\n            reset the simulation before running (default False)\n        adaptive : bool\n            use adaptive timesteps if solver is adaptive (default True)\n\n        Returns\n        -------\n        stats : dict\n            stats of simulation run tracked by the ´ProgressTracker´ \n        \"\"\"\n\n        #reset the simulation before running it\n        if reset:\n            self.reset()\n\n        #make an adaptive run?\n        _adaptive = adaptive and self.engine.is_adaptive\n\n        #simulation start and end time\n        start_time, end_time = self.time, self.time + duration\n\n        #effective timestep for duration\n        _dt = self.dt\n\n        #initial system function evaluation \n        self._update(self.time)\n        initial_evals = 1\n\n        #catch and resolve initial events\n        for event, *_ in self._detected_events(self.time):\n\n            #resolve events directly\n            event.resolve(self.time)\n\n            #evaluate system function again -> propagate event\n            self._update(self.time) \n            initial_evals += 1\n\n        #sampling states and inputs at 'self.time == starting_time' \n        self._sample(self.time)\n\n        #initialize progress tracker\n        tracker = ProgressTracker(\n            total_duration=duration, \n            description=\"TRANSIENT\", \n            logger=self.logger,\n            log=self.log\n            )\n\n        #enter tracker context\n        with tracker:\n\n            #iterate progress tracker generator until 'progress >= 1.0' is reached\n            for _ in tracker:\n\n                #advance the simulation by one (effective) timestep '_dt'\n                success, error_norm, scale, *_ = self.timestep(\n                    dt=_dt, \n                    adaptive=_adaptive\n                    )\n\n                #perform adaptive rescale\n                if _adaptive:            \n\n                    #if no error estimate and rescale -> back to default timestep\n                    if not error_norm and scale == 1:\n                        _dt = self.dt\n\n                    #rescale due to error control\n                    _dt = scale * _dt\n\n                    #estimate time until next event and adjust timestep\n                    _dt_evt = self._estimate_events(self.time)\n                    if _dt_evt is not None and _dt_evt < _dt:\n                        _dt = _dt_evt\n\n                    #rescale if in danger of overshooting 'end_time' at next step\n                    if self.time + _dt > end_time:\n                        _dt = end_time - self.time\n\n                    #apply bounds to timestep after rescale\n                    _dt = np.clip(_dt, self.dt_min, self.dt_max)\n\n                #compute simulation progress\n                progress = np.clip((self.time - start_time)/duration, 0.0, 1.0)\n\n                #update the tracker\n                tracker.update(progress, success=success)\n\n        return tracker.stats",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(\n    self, \n    blocks=None, \n    connections=None, \n    events=None,\n    dt=SIM_TIMESTEP, \n    dt_min=SIM_TIMESTEP_MIN, \n    dt_max=SIM_TIMESTEP_MAX, \n    Solver=SSPRK22, \n    tolerance_fpi=SIM_TOLERANCE_FPI, \n    iterations_max=SIM_ITERATIONS_MAX, \n    log=LOG_ENABLE,\n    **solver_kwargs\n    ):\n\n    #system definition\n    self.blocks      = []\n    self.connections = []\n    self.events      = []\n\n    #simulation timestep and bounds\n    self.dt     = dt\n    self.dt_min = dt_min\n    self.dt_max = dt_max\n\n    #numerical integrator to be used (class definition)\n    self.Solver = Solver\n\n    #numerical integrator instance\n    self.engine = Solver()\n\n    #internal system graph -> initialized later\n    self.graph = None\n\n    #error tolerance for fixed point loop and implicit solver\n    self.tolerance_fpi = tolerance_fpi\n\n    #additional solver parameters\n    self.solver_kwargs = solver_kwargs\n\n    #iterations for fixed-point loop\n    self.iterations_max = iterations_max\n\n    #enable logging flag\n    self.log = log\n\n    #initial simulation time\n    self.time = 0.0\n\n    #flag for state buffering (transient)\n    self._needs_buffering = True\n\n    #collection of blocks with internal ODE solvers\n    self._blocks_dyn = []\n\n    #initialize logging for logging mode\n    self._initialize_logger()\n\n    #prepare and add blocks (including internal events)\n    if blocks is not None:\n        for block in blocks:\n            self.add_block(block)\n\n    #check and add connections\n    if connections is not None:\n        for connection in connections:\n            self.add_connection(connection)\n\n    #check and add events\n    if events is not None:\n        for event in events:\n            self.add_event(event)\n\n    #check if blocks from connections are in simulation\n    self._check_blocks_are_managed()\n\n    #assemble the system graph for simulation\n    self._assemble_graph()",
              "signature": "(blocks = None, connections = None, events = None, dt = SIM_TIMESTEP, dt_min = SIM_TIMESTEP_MIN, dt_max = SIM_TIMESTEP_MAX, Solver = SSPRK22, tolerance_fpi = SIM_TOLERANCE_FPI, iterations_max = SIM_ITERATIONS_MAX, log = LOG_ENABLE, solver_kwargs = {})",
              "parameters": [
                {
                  "name": "blocks",
                  "type": null,
                  "default": "None",
                  "description": ""
                },
                {
                  "name": "connections",
                  "type": null,
                  "default": "None",
                  "description": ""
                },
                {
                  "name": "events",
                  "type": null,
                  "default": "None",
                  "description": ""
                },
                {
                  "name": "dt",
                  "type": null,
                  "default": "SIM_TIMESTEP",
                  "description": ""
                },
                {
                  "name": "dt_min",
                  "type": null,
                  "default": "SIM_TIMESTEP_MIN",
                  "description": ""
                },
                {
                  "name": "dt_max",
                  "type": null,
                  "default": "SIM_TIMESTEP_MAX",
                  "description": ""
                },
                {
                  "name": "Solver",
                  "type": null,
                  "default": "SSPRK22",
                  "description": ""
                },
                {
                  "name": "tolerance_fpi",
                  "type": null,
                  "default": "SIM_TOLERANCE_FPI",
                  "description": ""
                },
                {
                  "name": "iterations_max",
                  "type": null,
                  "default": "SIM_ITERATIONS_MAX",
                  "description": ""
                },
                {
                  "name": "log",
                  "type": null,
                  "default": "LOG_ENABLE",
                  "description": ""
                },
                {
                  "name": "solver_kwargs",
                  "type": null,
                  "default": "{}",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "size",
              "description": "Get size information of the simulation, such as total number",
              "docstring_html": "<p>Get size information of the simulation, such as total number\nof blocks and dynamic states, with recursive retrieval from subsystems</p>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>sizes <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">tuple[int]</span></dt>\n<dd>size of block (default 1) and number\nof internal states (from internal engine)</dd>\n</dl>\n",
              "source": "def size(self):\n    \"\"\"Get size information of the simulation, such as total number \n    of blocks and dynamic states, with recursive retrieval from subsystems\n\n    Returns\n    -------\n    sizes : tuple[int]\n        size of block (default 1) and number \n        of internal states (from internal engine)\n    \"\"\"\n    total_n, total_nx = 0, 0\n    for block in self.blocks:\n        n, nx = block.size()\n        total_n += n\n        total_nx += nx\n    return total_n, total_nx",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "_initialize_logger",
              "description": "setup and configure logging",
              "docstring_html": "<p>setup and configure logging</p>\n",
              "source": "def _initialize_logger(self):\n    \"\"\"\n    setup and configure logging\n    \"\"\"\n\n    #initialize the logger\n    self.logger = logging.Logger(\"PathSim_Simulation_Logger\")\n\n    #capture warnings from the 'warnings' module\n    logging.captureWarnings(True)\n\n    #check if logging is enabled\n    if self.log:    \n\n        #if a filename for logging is specified\n        if isinstance(self.log, str):\n            handler = logging.FileHandler(self.log) \n        else:\n            handler = logging.StreamHandler()\n\n        #logging format\n        handler.setFormatter(\n            logging.Formatter(\"%(asctime)s - %(levelname)s - %(message)s\")   \n            )\n\n        self.logger.addHandler(handler)\n        self.logger.setLevel(logging.INFO)\n\n        self._logger_info(f\"LOGGING (log: {self.log})\")",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "_logger_info",
              "description": "",
              "docstring_html": "",
              "source": "def _logger_info(self, message):\n    if self.log: self.logger.info(message)",
              "signature": "(message)",
              "parameters": [
                {
                  "name": "message",
                  "type": null,
                  "default": null,
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "_logger_error",
              "description": "",
              "docstring_html": "",
              "source": "def _logger_error(self, message, Error=None):\n    if self.log: self.logger.error(message)\n    if Error is not None: raise Error(message)",
              "signature": "(message, Error = None)",
              "parameters": [
                {
                  "name": "message",
                  "type": null,
                  "default": null,
                  "description": ""
                },
                {
                  "name": "Error",
                  "type": null,
                  "default": "None",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "_logger_warning",
              "description": "",
              "docstring_html": "",
              "source": "def _logger_warning(self, message):\n    if self.log: self.logger.warning(message)",
              "signature": "(message)",
              "parameters": [
                {
                  "name": "message",
                  "type": null,
                  "default": null,
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "plot",
              "description": "Plot the simulation results by calling all the blocks",
              "docstring_html": "<p>Plot the simulation results by calling all the blocks\nthat have visualization capabilities such as the 'Scope'\nand 'Spectrum'.</p>\n<p>This is a quality of life method. Blocks can be visualized\nindividually due to the object oriented nature, but it might\nbe nice to just call the plot metho globally and look at all\nthe results at once. Also works for models loaded from an\nexternal file.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>args <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">tuple</span></dt>\n<dd>args for the plot methods</dd>\n<dt>kwargs <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">dict</span></dt>\n<dd>kwargs for the plot method</dd>\n</dl>\n",
              "source": "def plot(self, *args, **kwargs):\n    \"\"\"Plot the simulation results by calling all the blocks \n    that have visualization capabilities such as the 'Scope' \n    and 'Spectrum'.\n\n    This is a quality of life method. Blocks can be visualized \n    individually due to the object oriented nature, but it might \n    be nice to just call the plot metho globally and look at all \n    the results at once. Also works for models loaded from an \n    external file.\n\n    Parameters\n    ----------\n    args : tuple\n        args for the plot methods\n    kwargs : dict\n        kwargs for the plot method\n    \"\"\"\n    for block in self.blocks:\n        if block: block.plot(*args, **kwargs)",
              "signature": "(args = (), kwargs = {})",
              "parameters": [
                {
                  "name": "args",
                  "type": null,
                  "default": "()",
                  "description": "args for the plot methods"
                },
                {
                  "name": "kwargs",
                  "type": null,
                  "default": "{}",
                  "description": "kwargs for the plot method"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "save",
              "description": "Save the dictionary representation of the simulation instance",
              "docstring_html": "<p>Save the dictionary representation of the simulation instance\nto an external file</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>path <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">str</span></dt>\n<dd>filepath to save data to</dd>\n<dt>metadata <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">dict</span></dt>\n<dd>metadata for the simulation model</dd>\n</dl>\n",
              "source": "def save(self, path=\"\", **metadata):\n    \"\"\"Save the dictionary representation of the simulation instance \n    to an external file\n\n    Parameters\n    ----------\n    path : str\n        filepath to save data to\n    metadata : dict\n        metadata for the simulation model\n    \"\"\"\n\n    #add current pathsim version\n    metadata[\"version\"] = __version__\n\n    #add current timestamp\n    metadata[\"timestamp\"] = datetime.datetime.now().isoformat()\n\n    with open(path, \"w\", encoding=\"utf-8\") as file:\n        json.dump(self.to_dict(**metadata), file, indent=2, ensure_ascii=False)",
              "signature": "(path = '', metadata = {})",
              "parameters": [
                {
                  "name": "path",
                  "type": null,
                  "default": "''",
                  "description": "filepath to save data to"
                },
                {
                  "name": "metadata",
                  "type": null,
                  "default": "{}",
                  "description": "metadata for the simulation model"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "load",
              "description": "Load and instantiate a Simulation from an external file",
              "docstring_html": "<p>Load and instantiate a Simulation from an external file\nin json format</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>path <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">str</span></dt>\n<dd>filepath to load data from</dd>\n<dt>kwargs <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">dict</span></dt>\n<dd>additional args for the simulation, overwriting metadata</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>out <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">Simulation</span></dt>\n<dd>reconstructed object from dict representation</dd>\n</dl>\n",
              "source": "@classmethod\ndef load(cls, path=\"\", **kwargs):\n    \"\"\"Load and instantiate a Simulation from an external file \n    in json format\n\n    Parameters\n    ----------\n    path : str\n        filepath to load data from\n    kwargs : dict\n        additional args for the simulation, overwriting metadata\n\n    Returns\n    -------\n    out : Simulation\n        reconstructed object from dict representation\n    \"\"\"\n    with open(path, \"r\", encoding=\"utf-8\") as file:\n        return cls.from_dict(json.load(file), **kwargs)\n    return None",
              "signature": "(cls, path = '', kwargs = {})",
              "parameters": [
                {
                  "name": "cls",
                  "type": null,
                  "default": null,
                  "description": ""
                },
                {
                  "name": "path",
                  "type": null,
                  "default": "''",
                  "description": "filepath to load data from"
                },
                {
                  "name": "kwargs",
                  "type": null,
                  "default": "{}",
                  "description": "additional args for the simulation, overwriting metadata"
                }
              ],
              "returns": null,
              "method_type": "classmethod"
            },
            {
              "name": "to_dict",
              "description": "Convert simulation to a complete model representation as a dict",
              "docstring_html": "<p>Convert simulation to a complete model representation as a dict\nwith additional metadata.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>metadata <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">dict</span></dt>\n<dd>metadata for the simulation model</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>data <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">dict</span></dt>\n<dd>dict that describes the simulation model</dd>\n</dl>\n",
              "source": "def to_dict(self, **metadata):\n    \"\"\"Convert simulation to a complete model representation as a dict\n    with additional metadata.\n\n    Parameters\n    ----------\n    metadata : dict\n        metadata for the simulation model\n\n    Returns\n    -------\n    data : dict\n        dict that describes the simulation model\n    \"\"\"\n\n    #serialize system components\n    blocks = [block.to_dict() for block in self.blocks]\n    events = [event.to_dict() for event in self.events]\n    connections = [conn.to_dict() for conn in self.connections]\n\n    #create the full model\n    return {\n        \"type\": \"Simulation\",\n        \"metadata\": metadata,\n        \"structure\": {\n            \"blocks\": blocks,\n            \"events\": events,\n            \"connections\": connections\n            },\n        \"params\": {\n            \"dt\": self.dt,\n            \"dt_min\": self.dt_min,\n            \"dt_max\": self.dt_max,\n            \"Solver\": self.Solver.__name__,\n            \"tolerance_fpi\": self.tolerance_fpi,\n            \"iterations_max\": self.iterations_max,\n            **self.solver_kwargs\n            }\n        }",
              "signature": "(metadata = {})",
              "parameters": [
                {
                  "name": "metadata",
                  "type": null,
                  "default": "{}",
                  "description": "metadata for the simulation model"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "from_dict",
              "description": "Create simulation from model data dict",
              "docstring_html": "<p>Create simulation from model data dict</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>data <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">dict</span></dt>\n<dd>model definition in json format</dd>\n<dt>kwargs <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">dict</span></dt>\n<dd>additional args for the simulation, overwriting metadata</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>simulation <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">Simulation</span></dt>\n<dd>instance of the Simulation class with mode definition</dd>\n</dl>\n",
              "source": "@classmethod\ndef from_dict(cls, data, **kwargs):\n    \"\"\"Create simulation from model data dict\n\n    Parameters\n    ----------\n    data : dict\n        model definition in json format\n    kwargs : dict\n        additional args for the simulation, overwriting metadata\n\n    Returns\n    -------\n    simulation : Simulation\n        instance of the Simulation class with mode definition\n    \"\"\"\n    from . import solvers\n\n    #get system structure\n    structure = data.get(\"structure\", {})\n\n    #deserialize blocks and create block ID mapping\n    blocks, id_to_block = [], {}\n    for block_data in structure.get(\"blocks\", []):\n        block = Block.from_dict(block_data)\n        blocks.append(block)\n        id_to_block[block_data[\"id\"]] = block\n\n    #deserialize connections\n    connections = []\n    for conn_data in structure.get(\"connections\", []):\n\n        #get source block and port\n        source_block = id_to_block[conn_data[\"source\"][\"block\"]]\n        source_ports = conn_data[\"source\"][\"ports\"]\n        source = PortReference(source_block, source_ports)\n\n        #get targets\n        targets = []\n        for trg in conn_data[\"targets\"]:\n            target_block = id_to_block[trg[\"block\"]]\n            target_ports = trg[\"ports\"]\n            targets.append(\n                PortReference(target_block, target_ports)\n                )\n\n        #create connection\n        connections.append(\n            Connection(source, *targets)\n            )\n\n    #deserialize events\n    events = []\n    for event_data in structure.get(\"events\", []):\n        events.append(Event.from_dict(event_data))\n\n    #get simulation parameters\n    params = data.get(\"params\", {})\n\n    #get solver class\n    solver_name = params.get(\"Solver\", \"SSPRK22\")\n    params[\"Solver\"] = getattr(solvers, solver_name)\n\n    #update with additional kwargs\n    for name, val in kwargs.items():\n        params[name] = val\n\n    #create simulation\n    return cls(\n        blocks=blocks,\n        connections=connections,\n        events=events,\n        **params\n        )",
              "signature": "(cls, data, kwargs = {})",
              "parameters": [
                {
                  "name": "cls",
                  "type": null,
                  "default": null,
                  "description": ""
                },
                {
                  "name": "data",
                  "type": null,
                  "default": null,
                  "description": "model definition in json format"
                },
                {
                  "name": "kwargs",
                  "type": null,
                  "default": "{}",
                  "description": "additional args for the simulation, overwriting metadata"
                }
              ],
              "returns": null,
              "method_type": "classmethod"
            },
            {
              "name": "add_block",
              "description": "Adds a new block to the simulation, initializes its local solver",
              "docstring_html": "<p>Adds a new block to the simulation, initializes its local solver\ninstance and collects internal events of the new block.</p>\n<p>This works dynamically for running simulations.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>block <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">Block</span></dt>\n<dd>block to add to the simulation</dd>\n</dl>\n",
              "source": "def add_block(self, block):\n    \"\"\"Adds a new block to the simulation, initializes its local solver \n    instance and collects internal events of the new block. \n\n    This works dynamically for running simulations.\n\n    Parameters\n    ----------\n    block : Block \n        block to add to the simulation\n    \"\"\"\n\n    #check if block already in block list\n    if block in self.blocks:\n        _msg = f\"block {block} already part of simulation\"\n        self._logger_error(_msg, ValueError)\n\n    #initialize numerical integrator of block\n    block.set_solver(self.Solver, **self.solver_kwargs)\n\n    #add to dynamic list if solver was initialized\n    if block.engine and block not in self._blocks_dyn:\n        self._blocks_dyn.append(block)\n\n    #add block to global blocklist\n    self.blocks.append(block)\n\n    #add events of block to global event list\n    for event in block.get_events():\n        self.add_event(event)\n\n    #if graph already exists, it needs to be rebuilt\n    if self.graph:\n        self._assemble_graph()",
              "signature": "(block)",
              "parameters": [
                {
                  "name": "block",
                  "type": null,
                  "default": null,
                  "description": "block to add to the simulation"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "add_connection",
              "description": "Adds a new connection to the simulaiton and checks if",
              "docstring_html": "<p>Adds a new connection to the simulaiton and checks if\nthe new connection overwrites any existing connections.</p>\n<p>This works dynamically for running simulations.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>connection <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">Connection</span></dt>\n<dd>connection to add to the simulation</dd>\n</dl>\n",
              "source": "def add_connection(self, connection):\n    \"\"\"Adds a new connection to the simulaiton and checks if \n    the new connection overwrites any existing connections.\n\n    This works dynamically for running simulations.\n\n    Parameters\n    ----------\n    connection : Connection\n        connection to add to the simulation\n    \"\"\"\n\n    #check if connection already in connection list\n    if connection in self.connections:\n        _msg = f\"{connection} already part of simulation\"\n        self._logger_error(_msg, ValueError)\n\n    #check if connection overwrites existing connections\n    for conn in self.connections:\n        if connection.overwrites(conn):\n            _msg = f\"{connection} overwrites {conn}\"\n            self._logger_error(_msg, ValueError)\n\n    #add connection to global connection list\n    self.connections.append(connection)\n\n    #if graph already exists, it needs to be rebuilt\n    if self.graph:\n        self._assemble_graph()",
              "signature": "(connection)",
              "parameters": [
                {
                  "name": "connection",
                  "type": null,
                  "default": null,
                  "description": "connection to add to the simulation"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "add_event",
              "description": "Checks and adds a new event to the simulation.",
              "docstring_html": "<p>Checks and adds a new event to the simulation.</p>\n<p>This works dynamically for running simulations.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>event <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">Event</span></dt>\n<dd>event to add to the simulation</dd>\n</dl>\n",
              "source": "def add_event(self, event):\n    \"\"\"Checks and adds a new event to the simulation.\n\n    This works dynamically for running simulations.\n\n    Parameters\n    ----------\n    event : Event\n        event to add to the simulation\n    \"\"\"\n\n    #check if event already in event list\n    if event in self.events:\n        _msg = f\"{event} already part of simulation\"\n        self._logger_error(_msg, ValueError)\n\n    #add event to global event list\n    self.events.append(event)",
              "signature": "(event)",
              "parameters": [
                {
                  "name": "event",
                  "type": null,
                  "default": null,
                  "description": "event to add to the simulation"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "_assemble_graph",
              "description": "Build the internal graph representation for fast system function",
              "docstring_html": "<p>Build the internal graph representation for fast system function\nevaluation and algebraic loop resolution.</p>\n",
              "source": "def _assemble_graph(self):\n    \"\"\"Build the internal graph representation for fast system function \n    evaluation and algebraic loop resolution.\n    \"\"\"\n\n    #time the graph construction\n    with Timer(verbose=False) as T:\n        self.graph = Graph(self.blocks, self.connections)\n\n    self._logger_info(\n        \"GRAPH (size: {}, alg. depth: {}, loop depth: {}, runtime: {})\".format(\n            len(self.graph), *self.graph.depth(), T\n            )\n        )",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "_check_blocks_are_managed",
              "description": "Check whether the blocks that are part of the connections are",
              "docstring_html": "<p>Check whether the blocks that are part of the connections are\nin the simulation block list ('self.blocks') and therefore managed\nby the simulation.</p>\n<p>If not, there will be a warning in the logging.</p>\n",
              "source": "def _check_blocks_are_managed(self):\n    \"\"\"Check whether the blocks that are part of the connections are \n    in the simulation block list ('self.blocks') and therefore managed \n    by the simulation.\n\n    If not, there will be a warning in the logging.            \n    \"\"\"\n    #collect blocks from connections\n    conn_blocks = []\n    for conn in self.connections:\n        conn_blocks.extend(conn.get_blocks())\n\n    #iterate set of blocks from connections (unique)\n    for blk in set(conn_blocks):\n        if blk not in self.blocks:\n            self._logger_warning(\n                f\"{blk} in 'connections' but not in 'blocks'!\"\n                )",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "_set_solver",
              "description": "Initialize all blocks with solver for numerical integration",
              "docstring_html": "<p>Initialize all blocks with solver for numerical integration\nand tolerance for local truncation error ´tolerance_lte´.</p>\n<p>If blocks already have solvers, change the numerical integrator\nto the ´Solver´ class.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>Solver <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">Solver</span></dt>\n<dd>numerical solver definition from ´pathsim.solvers´</dd>\n<dt>solver_kwargs <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">dict</span></dt>\n<dd>additional parameters for numerical solvers</dd>\n</dl>\n",
              "source": "def _set_solver(self, Solver=None, **solver_kwargs):\n    \"\"\"Initialize all blocks with solver for numerical integration\n    and tolerance for local truncation error ´tolerance_lte´.\n\n    If blocks already have solvers, change the numerical integrator\n    to the ´Solver´ class.\n\n    Parameters\n    ----------\n    Solver : Solver\n        numerical solver definition from ´pathsim.solvers´\n    solver_kwargs : dict\n        additional parameters for numerical solvers\n    \"\"\"\n\n    #update global solver class\n    if Solver is not None:\n        self.Solver = Solver\n\n    #update solver parmeters\n    for k, v in solver_kwargs.items():\n        self.solver_kwargs[k] = v\n\n    #initialize dummy engine to get solver attributes\n    self.engine = self.Solver()\n\n    #iterate all blocks and set integration engines with tolerances\n    self._blocks_dyn = []\n    for block in self.blocks:\n        block.set_solver(self.Solver, **self.solver_kwargs)\n\n        #add dynamic blocks to list\n        if block.engine:\n            self._blocks_dyn.append(block)\n\n    #logging message\n    self._logger_info(\n        \"SOLVER (dyn. blocks: {}) -> {} (adaptive: {}, explicit: {})\".format(\n            len(self._blocks_dyn),\n            self.engine,\n            self.engine.is_adaptive, \n            self.engine.is_explicit\n            )\n        )",
              "signature": "(Solver = None, solver_kwargs = {})",
              "parameters": [
                {
                  "name": "Solver",
                  "type": null,
                  "default": "None",
                  "description": "numerical solver definition from ´pathsim.solvers´"
                },
                {
                  "name": "solver_kwargs",
                  "type": null,
                  "default": "{}",
                  "description": "additional parameters for numerical solvers"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "reset",
              "description": "Reset the blocks to their initial state and the global time of",
              "docstring_html": "<p>Reset the blocks to their initial state and the global time of\nthe simulation.</p>\n<p>For recording blocks such as 'Scope', their recorded\ndata is also reset.</p>\n<p>Resets linearization automatically, since resetting the blocks\nresets their internal operators.</p>\n<p>Afterwards the system function is evaluated with '_update' to update\nthe block inputs and outputs.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>time <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>simulation time for reset</dd>\n</dl>\n",
              "source": "def reset(self, time=0.0):\n    \"\"\"Reset the blocks to their initial state and the global time of \n    the simulation. \n\n    For recording blocks such as 'Scope', their recorded \n    data is also reset. \n\n    Resets linearization automatically, since resetting the blocks \n    resets their internal operators.\n\n    Afterwards the system function is evaluated with '_update' to update\n    the block inputs and outputs.\n\n    Parameters\n    ----------\n    time : float\n        simulation time for reset\n    \"\"\"\n\n    self._logger_info(f\"RESET (time: {time})\")\n\n    #reset simulation time\n    self.time = time\n\n    #reset all blocks to initial state\n    for block in self.blocks:\n        block.reset()\n\n    #reset all event managers\n    for event in self.events:\n        event.reset()\n\n    #evaluate system function\n    self._update(self.time)",
              "signature": "(time = 0.0)",
              "parameters": [
                {
                  "name": "time",
                  "type": null,
                  "default": "0.0",
                  "description": "simulation time for reset"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "linearize",
              "description": "Linearize the full system in the current simulation state",
              "docstring_html": "<p>Linearize the full system in the current simulation state\nat the current simulation time.</p>\n<p>This is achieved by linearizing algebraic and dynamic operators\nof the internal blocks. See definition of the 'Block' class.</p>\n<p>Before linearization, the global system function is evaluated\nto get the blocks into the current simulation state.\nThis is only really relevant if no solving attempt has been\nhappened before.</p>\n",
              "source": "def linearize(self):\n    \"\"\"Linearize the full system in the current simulation state \n    at the current simulation time.\n\n    This is achieved by linearizing algebraic and dynamic operators \n    of the internal blocks. See definition of the 'Block' class.\n\n    Before linearization, the global system function is evaluated \n    to get the blocks into the current simulation state. \n    This is only really relevant if no solving attempt has been \n    happened before.\n    \"\"\"\n    #evaluate system function at current time\n    self._update(self.time)\n\n    #linearize all internal blocks and time it\n    with Timer(verbose=False) as T:\n        for block in self.blocks:\n            block.linearize(self.time)\n\n    self._logger_info(f\"LINEARIZED (runtime: {T})\")",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "delinearize",
              "description": "Revert the linearization of the full system.",
              "docstring_html": "<p>Revert the linearization of the full system.</p>\n",
              "source": "def delinearize(self):\n    \"\"\"Revert the linearization of the full system.\"\"\"\n    for block in self.blocks: \n        block.delinearize()\n\n    self._logger_info(\"DELINEARIZED\")",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "_estimate_events",
              "description": "Estimate the time until the next.",
              "docstring_html": "<p>Estimate the time until the next.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time for event estimation</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>float | None</dt>\n<dd>esimated time until next event (delta)</dd>\n</dl>\n",
              "source": "def _estimate_events(self, t):\n    \"\"\"Estimate the time until the next.\n\n    Parameters\n    ----------\n    t : float \n        evaluation time for event estimation\n\n    Returns\n    -------\n    float | None\n        esimated time until next event (delta)\n    \"\"\"\n\n    dt_evt_min = None\n    for event in self.events:\n\n        #skip inactive events\n        if not event: continue\n\n        #get the estimate\n        dt_evt = event.estimate(self.time)\n\n        #check if estimate available and smaller than min\n        if dt_evt_min is None or (dt_evt is not None and dt_evt < dt_evt_min):\n            dt_evt_min = dt_evt\n\n    #return time until next event or None\n    return dt_evt_min",
              "signature": "(t)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time for event estimation"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "_buffer_events",
              "description": "Buffer states for event monitoring before the timestep",
              "docstring_html": "<p>Buffer states for event monitoring before the timestep\nis taken.</p>\n<p>This is required to set reference for event monitoring and\nbacktracking for root finding.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time for buffering</dd>\n</dl>\n",
              "source": "def _buffer_events(self, t):\n    \"\"\"Buffer states for event monitoring before the timestep \n    is taken. \n\n    This is required to set reference for event monitoring and \n    backtracking for root finding.\n\n    Parameters\n    ----------\n    t : float \n        evaluation time for buffering\n    \"\"\"\n\n    #buffer states for event detection (with timestamp)\n    for event in self.events:\n        if event: event.buffer(t)",
              "signature": "(t)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time for buffering"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "_detected_events",
              "description": "Check for possible (active) events and return them chronologically,",
              "docstring_html": "<p>Check for possible (active) events and return them chronologically,\nsorted by their timestep ratios (closest to the initial point in time).</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time for event function</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>detected <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">list[Event]</span></dt>\n<dd>list of detected events within timestep</dd>\n</dl>\n",
              "source": "def _detected_events(self, t):\n    \"\"\"Check for possible (active) events and return them chronologically, \n    sorted by their timestep ratios (closest to the initial point in time).\n\n    Parameters\n    ----------\n    t : float\n        evaluation time for event function\n\n    Returns\n    -------\n    detected : list[Event]\n        list of detected events within timestep\n    \"\"\"\n\n    #iterate all event managers\n    detected_events = []\n    for event in self.events:\n\n        #skip inactive events\n        if not event: continue\n\n        #check if an event is detected\n        detected, close, ratio = event.detect(t)\n\n        #event was detected during the timestep \n        if detected:\n            detected_events.append([event, close, ratio])\n\n    #return detected events sorted by ratio\n    return sorted(detected_events, key=lambda e: e[-1])",
              "signature": "(t)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time for event function"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "_update",
              "description": "Distribute information within the system by evaluating the directed acyclic graph",
              "docstring_html": "<p>Distribute information within the system by evaluating the directed acyclic graph\n(DAG) formed by the algebraic passthroughs of the blocks and resolving algebraic loops\nthrough accelerated fixed-point iterations.</p>\n<p>Effectively evaluates the right hand side function of the global\nsystem ODE/DAE</p>\n<div class=\"math\">\n\\begin{equation*}\n\\begin{equnarray}\n    \\dot{x} &amp;= f(x, t) \\\\\n           0 &amp;= g(x, t)\n\\end{equnarray}\n\\end{equation*}\n</div>\n<p>by converging the whole system (´f´ and ´g´) to a fixed-point at a given point\nin time ´t´.</p>\n<p>If no algebraic loops are present in the system, convergence is\nguaranteed after the first stage (evaluation of the DAG in '_dag').</p>\n<p>Otherwise, accelerated fixed-point iterations ('_loops') are performed as a second\nstage on the DAGs (broken cycles) of blocks that are part of or tainted by upstream\nalgebraic loops.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time for system function</dd>\n</dl>\n",
              "source": "def _update(self, t):        \n    \"\"\"Distribute information within the system by evaluating the directed acyclic graph \n    (DAG) formed by the algebraic passthroughs of the blocks and resolving algebraic loops \n    through accelerated fixed-point iterations.\n\n    Effectively evaluates the right hand side function of the global \n    system ODE/DAE\n\n    .. math:: \n\n        \\\\begin{equnarray}\n            \\\\dot{x} &= f(x, t) \\\\\\\\\n                   0 &= g(x, t) \n        \\\\end{equnarray}\n\n    by converging the whole system (´f´ and ´g´) to a fixed-point at a given point \n    in time ´t´.\n\n    If no algebraic loops are present in the system, convergence is \n    guaranteed after the first stage (evaluation of the DAG in '_dag'). \n\n    Otherwise, accelerated fixed-point iterations ('_loops') are performed as a second \n    stage on the DAGs (broken cycles) of blocks that are part of or tainted by upstream \n    algebraic loops. \n\n    Parameters\n    ----------\n    t : float\n        evaluation time for system function\n    \"\"\"\n\n    #evaluate DAG\n    self._dag(t)\n\n    #algebraic loops -> solve them\n    if self.graph.has_loops:   \n        self._loops(t)",
              "signature": "(t)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time for system function"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "_dag",
              "description": "Update the directed acyclic graph components of the system.",
              "docstring_html": "<p>Update the directed acyclic graph components of the system.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time for system function</dd>\n</dl>\n",
              "source": "def _dag(self, t):\n    \"\"\"Update the directed acyclic graph components of the system.\n\n    Parameters\n    ----------\n    t : float\n        evaluation time for system function\n    \"\"\"\n\n    #perform gauss-seidel iterations without error checking\n    for _, blocks_dag, connections_dag in self.graph.dag():\n\n        #update blocks at algebraic depth (no error control)\n        for block in blocks_dag:\n            if block: block.update(t)\n\n        #update connenctions at algebraic depth (data transfer)\n        for connection in connections_dag:\n            if connection: connection.update()",
              "signature": "(t)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time for system function"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "_loops",
              "description": "Perform the algebraic loop solve of the system using accelerated",
              "docstring_html": "<p>Perform the algebraic loop solve of the system using accelerated\nfixed-point iterations on the broken loop directed graph.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time for system function</dd>\n</dl>\n",
              "source": "def _loops(self, t):\n    \"\"\"Perform the algebraic loop solve of the system using accelerated \n    fixed-point iterations on the broken loop directed graph.\n\n    Parameters\n    ----------\n    t : float\n        evaluation time for system function\n    \"\"\"\n\n    #perform solver iterations on algebraic loops\n    for iteration in range(1, self.iterations_max):\n\n        #iterate DAG depths of broken loops\n        max_error = 0.0\n        for depth, blocks_loop, connections_loop in self.graph.loop():\n\n            #update blocks at algebraic depth\n            for block in blocks_loop:\n                if block: block.update(t)\n\n            #step accelerated connenctions at algebraic depth (data transfer)\n            for connection in connections_loop:\n\n                #skip inactive connections\n                if not connection: \n                    continue\n\n                #connections at first depth\n                if depth == 0:\n\n                    #reset solver at first iteration\n                    if iteration == 1: \n                        connection.reset()\n\n                    #step fixed-point solver (for alg. loops)\n                    err = connection.step() \n                    if err > max_error:\n                        max_error = err\n\n                else:\n\n                    #connections at lower depths\n                    connection.update()\n\n        #check convergence\n        if max_error <= self.tolerance_fpi:\n            return\n\n    #not converged -> error\n    self._logger_error(\n        \"fixed-point loop in '_update' not converged (iters: {}, err: {})\".format(\n            self.iterations_max, max_error), \n        RuntimeError\n        )",
              "signature": "(t)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time for system function"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "_solve",
              "description": "For implicit solvers, this method implements the solving step",
              "docstring_html": "<p>For implicit solvers, this method implements the solving step\nof the implicit update equation.</p>\n<p>It already involves the evaluation of the system equation with\nthe '_update' method within the loop.</p>\n<p>This also tracks the evolution of the solution as an estimate\nfor the convergence via the max residual norm of the fixed point\nequation of the previous solution.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time for system function</dd>\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>timestep</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>success <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>indicator if the timestep was successful</dd>\n<dt>total_evals <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>total number of system evaluations</dd>\n<dt>total_solver_its <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>total number of implicit solver iterations</dd>\n</dl>\n",
              "source": "def _solve(self, t, dt):\n    \"\"\"For implicit solvers, this method implements the solving step \n    of the implicit update equation.\n\n    It already involves the evaluation of the system equation with \n    the '_update' method within the loop.\n\n    This also tracks the evolution of the solution as an estimate \n    for the convergence via the max residual norm of the fixed point \n    equation of the previous solution.\n\n    Parameters\n    ----------\n    t : float\n        evaluation time for system function\n    dt : float\n        timestep\n\n    Returns\n    -------\n    success : bool\n        indicator if the timestep was successful\n    total_evals : int\n        total number of system evaluations\n    total_solver_its : int\n        total number of implicit solver iterations\n    \"\"\"\n\n    #total evaluations of system equation\n    total_evals = 0\n\n    #perform fixed-point iterations to solve implicit update equation\n    for it in range(self.iterations_max):\n\n        #evaluate system equation (this is a fixed point loop)\n        self._update(t)\n        total_evals += 1            \n\n        #advance solution of implicit solver\n        max_error = 0.0\n        for block in self._blocks_dyn:\n\n            #skip inactive blocks\n            if not block: \n                continue\n\n            #advance solution (internal optimizer)\n            error = block.solve(t, dt)\n            if error > max_error:\n                max_error = error\n\n        #check for convergence (only error)\n        if max_error <= self.tolerance_fpi:\n            return True, total_evals, it+1\n\n    #not converged in 'self.iterations_max' steps\n    return False, total_evals, self.iterations_max",
              "signature": "(t, dt)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time for system function"
                },
                {
                  "name": "dt",
                  "type": null,
                  "default": null,
                  "description": "timestep"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "steadystate",
              "description": "Find steady state solution (DC operating point) of the system",
              "docstring_html": "<p>Find steady state solution (DC operating point) of the system\nby switching all blocks to steady state solver, solving the\nfixed point equations, then switching back.</p>\n<p>The steady state solver forces all the temporal derivatives, i.e.\nthe right hand side equation (including external inputs) of the\nengines of dynamic blocks to zero.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>reset <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>reset the simulation before solving for steady state (default False)</dd>\n</dl>\n",
              "source": "def steadystate(self, reset=False): \n    \"\"\"Find steady state solution (DC operating point) of the system \n    by switching all blocks to steady state solver, solving the \n    fixed point equations, then switching back.\n\n    The steady state solver forces all the temporal derivatives, i.e.\n    the right hand side equation (including external inputs) of the \n    engines of dynamic blocks to zero.\n\n    Parameters\n    ----------\n    reset : bool\n        reset the simulation before solving for steady state (default False)\n    \"\"\"\n\n    #reset the simulation before solving\n    if reset:\n        self.reset()\n\n    #current solver class\n    _solver = self.Solver\n\n    #switch to steady state solver\n    self._set_solver(SteadyState)\n\n    #log message begin of steady state solver\n    self._logger_info(f\"STEADYSTATE -> STARTING (reset: {reset})\")\n\n    #solve for steady state at current time\n    with Timer(verbose=False) as T:\n        success, evals, iters = self._solve(self.time, self.dt)\n\n    #catch non convergence\n    if not success:\n        self._logger_error(\n            \"STEADYSTATE -> FINISHED (success: {}, evals: {}, iters: {}, runtime: {})\".format(\n                success, evals, iters, T), \n            RuntimeError\n            )\n\n    #sample result\n    self._sample(self.time)\n\n    #log message \n    self._logger_info(\n        \"STEADYSTATE -> FINISHED (success: {}, evals: {}, iters: {}, runtime: {})\".format(\n            success, evals, iters, T)\n        )\n\n    #switch back to original solver\n    self._set_solver(_solver)",
              "signature": "(reset = False)",
              "parameters": [
                {
                  "name": "reset",
                  "type": null,
                  "default": "False",
                  "description": "reset the simulation before solving for steady state (default False)"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "_revert",
              "description": "Revert simulation state to previous timestep for adaptive solvers",
              "docstring_html": "<p>Revert simulation state to previous timestep for adaptive solvers\nwhen local truncation error is too large and timestep has to be\nretaken with smaller timestep.</p>\n",
              "source": "def _revert(self):\n    \"\"\"Revert simulation state to previous timestep for adaptive solvers \n    when local truncation error is too large and timestep has to be \n    retaken with smaller timestep. \n    \"\"\"\n\n    #revert dummy engine (for history)\n    self.engine.revert()\n\n    #revert block states\n    for block in self._blocks_dyn:\n        if block: block.revert()",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "_sample",
              "description": "Sample data from blocks that implement the 'sample' method such",
              "docstring_html": "<p>Sample data from blocks that implement the 'sample' method such\nas 'Scope', 'Delay' and the blocks that sample from a random\ndistribution at a given time 't'.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>time where to sample</dd>\n</dl>\n",
              "source": "def _sample(self, t):\n    \"\"\"Sample data from blocks that implement the 'sample' method such \n    as 'Scope', 'Delay' and the blocks that sample from a random \n    distribution at a given time 't'.\n\n    Parameters\n    ----------\n    t : float\n        time where to sample\n    \"\"\"\n    for block in self.blocks:\n        if block: block.sample(t)",
              "signature": "(t)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "time where to sample"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "_buffer_blocks",
              "description": "Buffer internal states of blocks before the timestep is taken.",
              "docstring_html": "<p>Buffer internal states of blocks before the timestep is taken.</p>\n<p>This is required for runge-kutta integrators but also for the\nzero crossing detection of the event handling system.</p>\n<p>The timesteps are also buffered because some integrators such as\nGEAR-type methods need a history of the timesteps.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>timestep</dd>\n</dl>\n",
              "source": "def _buffer_blocks(self, dt):\n    \"\"\"Buffer internal states of blocks before the timestep is taken. \n\n    This is required for runge-kutta integrators but also for the \n    zero crossing detection of the event handling system.\n\n    The timesteps are also buffered because some integrators such as \n    GEAR-type methods need a history of the timesteps.\n\n    Parameters\n    ----------\n    dt : float\n        timestep\n    \"\"\"\n    #buffer the dummy engine\n    self.engine.buffer(dt)\n\n    #buffer internal states of stateful blocks\n    for block in self._blocks_dyn:\n        if block: block.buffer(dt)",
              "signature": "(dt)",
              "parameters": [
                {
                  "name": "dt",
                  "type": null,
                  "default": null,
                  "description": "timestep"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "_step",
              "description": "Performs the 'step' method for dynamical blocks with internal",
              "docstring_html": "<p>Performs the 'step' method for dynamical blocks with internal\nstates that have a numerical integration engine.</p>\n<p>Collects the local truncation error estimates and the timestep\nrescale factor from the error controllers of the internal\nintergation engines if they provide an error estimate\n(for example embedded Runge-Kutta methods).</p>\n<p><strong>Notes</strong></p>\n<p>Not to be confused with the global 'step' method, the '_step'\nmethod executes the intermediate timesteps in multistage solvers\nsuch as Runge-Kutta methods.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time of dynamical timestepping</dd>\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>timestep</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>success <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>indicator if the timestep was successful</dd>\n<dt>max_error <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>maximum local truncation error from integration</dd>\n<dt>scale <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>rescale factor for timestep</dd>\n</dl>\n",
              "source": "def _step(self, t, dt):\n    \"\"\"Performs the 'step' method for dynamical blocks with internal \n    states that have a numerical integration engine. \n\n    Collects the local truncation error estimates and the timestep \n    rescale factor from the error controllers of the internal \n    intergation engines if they provide an error estimate \n    (for example embedded Runge-Kutta methods).\n\n    Notes\n    -----\n    Not to be confused with the global 'step' method, the '_step' \n    method executes the intermediate timesteps in multistage solvers \n    such as Runge-Kutta methods.\n\n    Parameters\n    ----------\n    t : float\n        evaluation time of dynamical timestepping\n    dt : float\n        timestep\n\n    Returns\n    -------\n    success : bool \n        indicator if the timestep was successful\n    max_error : float \n        maximum local truncation error from integration\n    scale : float\n        rescale factor for timestep\n    \"\"\"\n\n    #initial timestep rescale and error estimate\n    success, max_error_norm, relevant_scales = True, 0.0, []\n\n    #step blocks and get error estimates if available\n    for block in self._blocks_dyn:\n\n        #skip inactive blocks\n        if not block: continue\n\n        #step the block\n        suc, err_norm, scl = block.step(t, dt)\n\n        #check solver stepping success\n        if not suc: \n            success = False\n\n        #update error tracking\n        if err_norm > max_error_norm: \n            max_error_norm = err_norm\n\n        #update timestep rescale if relevant\n        if scl != 1.0 and scl > 0.0: \n            relevant_scales.append(scl)\n\n    #no relevant timestep rescale -> quit early\n    if not relevant_scales: \n        return success, max_error_norm, 1.0\n\n    #compute real timestep rescale\n    return success, max_error_norm, min(relevant_scales)",
              "signature": "(t, dt)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time of dynamical timestepping"
                },
                {
                  "name": "dt",
                  "type": null,
                  "default": null,
                  "description": "timestep"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "timestep_fixed_explicit",
              "description": "Advances the simulation by one timestep 'dt' for explicit",
              "docstring_html": "<p>Advances the simulation by one timestep 'dt' for explicit\nfixed step solvers.</p>\n<p>If discrete events are detected, they are resolved immediately\nwithin the timestep.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>timestep</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>success <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>indicator if the timestep was successful</dd>\n<dt>max_error <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>maximum local truncation error from integration</dd>\n<dt>scale <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>rescale factor for timestep</dd>\n<dt>total_evals <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>total number of system evaluations</dd>\n<dt>total_solver_its <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>total number of implicit solver iterations</dd>\n</dl>\n",
              "source": "def timestep_fixed_explicit(self, dt=None):\n    \"\"\"Advances the simulation by one timestep 'dt' for explicit \n    fixed step solvers.\n\n    If discrete events are detected, they are resolved immediately \n    within the timestep.\n\n    Parameters\n    ----------\n    dt : float\n        timestep\n\n    Returns\n    -------\n    success : bool\n        indicator if the timestep was successful\n    max_error : float\n        maximum local truncation error from integration\n    scale : float\n        rescale factor for timestep\n    total_evals : int\n        total number of system evaluations\n    total_solver_its : int\n        total number of implicit solver iterations\n    \"\"\"\n\n    #default global timestep as local timestep\n    if dt is None: \n        dt = self.dt\n\n    #buffer states for event system\n    self._buffer_events(self.time)\n\n    #buffer internal states for solvers\n    self._buffer_blocks(dt)\n\n    #total function evaluations \n    total_evals = 0\n\n    #iterate explicit solver stages with evaluation time (generator)\n    for time_stage in self.engine.stages(self.time, dt):\n\n        #evaluate system equation by fixed-point iteration\n        self._update(time_stage) \n        total_evals += 1\n\n        #timestep for dynamical blocks (with internal states)\n        _1, error_norm, _3 = self._step(time_stage, dt)\n\n    #system time after timestep\n    time_dt = self.time + dt\n\n    #evaluate system equation before sampling and event check (+dt)\n    self._update(time_dt) \n    total_evals += 1\n\n    #handle events chronologically after timestep (+dt)\n    for event, _, ratio in self._detected_events(time_dt):\n\n        #fixed timestep -> resolve event directly\n        event.resolve(self.time + ratio * dt)  \n\n        #after resolve, evaluate system equation again -> propagate event\n        self._update(time_dt)  \n        total_evals += 1\n\n    #sample data after successful timestep (+dt)\n    self._sample(time_dt)\n\n    #increment global time and continue simulation\n    self.time = time_dt \n\n    #max local truncation error, timestep rescale, successful step\n    return True, error_norm, 1.0, total_evals, 0",
              "signature": "(dt = None)",
              "parameters": [
                {
                  "name": "dt",
                  "type": null,
                  "default": "None",
                  "description": "timestep"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "timestep_fixed_implicit",
              "description": "Advances the simulation by one timestep 'dt' for implicit",
              "docstring_html": "<p>Advances the simulation by one timestep 'dt' for implicit\nfixed step solvers.</p>\n<p>If discrete events are detected, they are resolved immediately\nwithin the timestep.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>timestep</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>success <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>indicator if the timestep was successful</dd>\n<dt>max_error <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>maximum local truncation error from integration</dd>\n<dt>scale <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>rescale factor for timestep</dd>\n<dt>total_evals <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>total number of system evaluations</dd>\n<dt>total_solver_its <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>total number of implicit solver iterations</dd>\n</dl>\n",
              "source": "def timestep_fixed_implicit(self, dt=None): \n    \"\"\"Advances the simulation by one timestep 'dt' for implicit \n    fixed step solvers.\n\n    If discrete events are detected, they are resolved immediately \n    within the timestep.\n\n    Parameters\n    ----------\n    dt : float\n        timestep\n\n    Returns\n    -------\n    success : bool\n        indicator if the timestep was successful\n    max_error : float\n        maximum local truncation error from integration\n    scale : float\n        rescale factor for timestep\n    total_evals : int\n        total number of system evaluations\n    total_solver_its : int\n        total number of implicit solver iterations\n    \"\"\"\n\n    #successful by default\n    success = True\n\n    #default global timestep as local timestep\n    if dt is None: \n        dt = self.dt\n\n    #buffer states for event system\n    self._buffer_events(self.time)\n\n    #buffer internal states for solvers\n    self._buffer_blocks(dt)\n\n    #total function evaluations and implicit solver iterations\n    total_evals, total_solver_its = 0, 0\n\n    #iterate explicit solver stages with evaluation time (generator)\n    for time_stage in self.engine.stages(self.time, dt):\n\n        #solve implicit update equation and get iteration count\n        success, evals, solver_its = self._solve(time_stage, dt)\n\n        #warning if implicit solver didnt converge in timestep\n        if not success:\n            self._logger_warning(\n                f\"implicit solver not converged in {solver_its} iterations!\"\n                )\n\n        #count solver iterations and function evaluations\n        total_solver_its += solver_its\n        total_evals += evals\n\n        #timestep for dynamical blocks (with internal states)\n        _1, error_norm, _3 = self._step(time_stage, dt)\n\n    #system time after timestep\n    time_dt = self.time + dt\n\n    #evaluate system equation before sampling and event check (+dt)\n    self._update(time_dt) \n    total_evals += 1\n\n    #handle events chronologically after timestep (+dt)\n    for event, _, ratio in self._detected_events(time_dt):\n\n        #fixed timestep -> resolve event directly\n        event.resolve(self.time + ratio * dt)  \n\n        #after resolve, evaluate system equation again -> propagate event\n        self._update(time_dt)  \n        total_evals += 1    \n\n    #sample data after successful timestep (+dt)\n    self._sample(time_dt)\n\n    #increment global time and continue simulation\n    self.time = time_dt \n\n    #max local truncation error, timestep rescale, successful step\n    return success, error_norm, 1.0, total_evals, total_solver_its",
              "signature": "(dt = None)",
              "parameters": [
                {
                  "name": "dt",
                  "type": null,
                  "default": "None",
                  "description": "timestep"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "timestep_adaptive_explicit",
              "description": "Advances the simulation by one timestep 'dt' for explicit",
              "docstring_html": "<p>Advances the simulation by one timestep 'dt' for explicit\nadaptive solvers.</p>\n<p>If the local truncation error of the solver exceeds the tolerances\nset in the 'solver_kwargs', the simulation state is reverted to the\nstate that was buffered (<cite>_buffer(time, dt)</cite>) at the beginning of\nthe timestep.</p>\n<p>If discrete events are detected, the chronologically first event is\nhandled only. The event location (in time) is approached adaptively\nby reverting the step and adjusting the stepsize (this is equivalent\nto the secant method for finding zeros of the event function) until\nthe tolerance of the event is satisfied (close==True).</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>timestep</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>success <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>indicator if the timestep was successful</dd>\n<dt>max_error <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>maximum local truncation error from integration</dd>\n<dt>scale <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>rescale factor for timestep</dd>\n<dt>total_evals <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>total number of system evaluations</dd>\n<dt>total_solver_its <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>total number of implicit solver iterations</dd>\n</dl>\n",
              "source": "def timestep_adaptive_explicit(self, dt=None): \n    \"\"\"Advances the simulation by one timestep 'dt' for explicit \n    adaptive solvers.\n\n    If the local truncation error of the solver exceeds the tolerances \n    set in the 'solver_kwargs', the simulation state is reverted to the \n    state that was buffered (`_buffer(time, dt)`) at the beginning of \n    the timestep.\n\n    If discrete events are detected, the chronologically first event is \n    handled only. The event location (in time) is approached adaptively \n    by reverting the step and adjusting the stepsize (this is equivalent \n    to the secant method for finding zeros of the event function) until \n    the tolerance of the event is satisfied (close==True).\n\n    Parameters\n    ----------\n    dt : float\n        timestep\n\n    Returns\n    -------\n    success : bool\n        indicator if the timestep was successful\n    max_error : float\n        maximum local truncation error from integration\n    scale : float\n        rescale factor for timestep\n    total_evals : int\n        total number of system evaluations\n    total_solver_its : int\n        total number of implicit solver iterations\n    \"\"\"\n\n    #default global timestep as local timestep\n    if dt is None: \n        dt = self.dt\n\n    #buffer states for event system\n    self._buffer_events(self.time)\n\n    #buffer internal states for solvers\n    self._buffer_blocks(dt)\n\n    #total function evaluations and implicit solver iterations\n    total_evals = 0\n\n    #iterate explicit solver stages with evaluation time (generator)\n    for time_stage in self.engine.stages(self.time, dt):\n\n        #evaluate system equation by fixed-point iteration\n        self._update(time_stage) \n        total_evals += 1\n\n        #timestep for dynamical blocks (with internal states)\n        success, error_norm, scale = self._step(time_stage, dt)\n\n    #if step not successful -> roll back timestep\n    if not success:\n        self._revert()\n        self._update(self.time) \n        total_evals += 1\n        return False, error_norm, scale, total_evals, 0\n\n    #system time after timestep\n    time_dt = self.time + dt\n\n    #evaluate system equation before sampling and event check (+dt)\n    self._update(time_dt) \n    total_evals += 1\n\n    #handle detected events chronologically after timestep (+dt)\n    for event, close, ratio in self._detected_events(time_dt):\n\n        #close enough to event (ratio approx 1.0) -> resolve it\n        if close:\n            event.resolve(time_dt)\n\n            #after resolve, evaluate system equation again -> propagate event\n            self._update(time_dt) \n            total_evals += 1\n\n        #not close enough -> roll back timestep (secant step)\n        else:\n            self._revert()\n            self._update(self.time) \n            total_evals += 1\n            return False, error_norm, ratio, total_evals, 0\n\n    #sample data after successful timestep (+dt)\n    self._sample(time_dt)\n\n    #increment global time and continue simulation\n    self.time = time_dt    \n\n    #max local truncation error, timestep rescale, successful step\n    return success, error_norm, scale, total_evals, 0",
              "signature": "(dt = None)",
              "parameters": [
                {
                  "name": "dt",
                  "type": null,
                  "default": "None",
                  "description": "timestep"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "timestep_adaptive_implicit",
              "description": "Advances the simulation by one timestep 'dt' for implicit",
              "docstring_html": "<p>Advances the simulation by one timestep 'dt' for implicit\nadaptive solvers.</p>\n<p>If the local truncation error of the solver exceeds the tolerances\nset in the 'solver_kwargs', the simulation state is reverted to the\nstate that was buffered (<cite>_buffer(time, dt)</cite>) at the beginning of\nthe timestep.</p>\n<p>If the solution of the implicit update equation in 'solve' doesnt\nconverge, the timestep is also considered unsuccessful. Then it is\nreverted and the timestep is halfed.</p>\n<p>If discrete events are detected, the chronologically first event is\nhandled only. The event location (in time) is approached adaptively\nby reverting the step and adjusting the stepsize (this is equivalent\nto the secant method for finding zeros of the event function) until\nthe tolerance of the event is satisfied (close==True).</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>timestep</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>success <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>indicator if the timestep was successful</dd>\n<dt>max_error <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>maximum local truncation error from integration</dd>\n<dt>scale <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>rescale factor for timestep</dd>\n<dt>total_evals <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>total number of system evaluations</dd>\n<dt>total_solver_its <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>total number of implicit solver iterations</dd>\n</dl>\n",
              "source": "def timestep_adaptive_implicit(self, dt=None): \n    \"\"\"Advances the simulation by one timestep 'dt' for implicit \n    adaptive solvers.\n\n    If the local truncation error of the solver exceeds the tolerances \n    set in the 'solver_kwargs', the simulation state is reverted to the \n    state that was buffered (`_buffer(time, dt)`) at the beginning of \n    the timestep.\n\n    If the solution of the implicit update equation in 'solve' doesnt \n    converge, the timestep is also considered unsuccessful. Then it is \n    reverted and the timestep is halfed.\n\n    If discrete events are detected, the chronologically first event is \n    handled only. The event location (in time) is approached adaptively \n    by reverting the step and adjusting the stepsize (this is equivalent \n    to the secant method for finding zeros of the event function) until \n    the tolerance of the event is satisfied (close==True).\n\n    Parameters\n    ----------\n    dt : float\n        timestep\n\n    Returns\n    -------\n    success : bool\n        indicator if the timestep was successful\n    max_error : float\n        maximum local truncation error from integration\n    scale : float\n        rescale factor for timestep\n    total_evals : int\n        total number of system evaluations\n    total_solver_its : int\n        total number of implicit solver iterations\n    \"\"\"\n\n    #default global timestep as local timestep\n    if dt is None: \n        dt = self.dt\n\n    #buffer states for event system\n    self._buffer_events(self.time)\n\n    #buffer internal states for solvers\n    self._buffer_blocks(dt)\n\n    #total function evaluations and implicit solver iterations\n    total_evals, total_solver_its = 0, 0\n\n    #iterate explicit solver stages with evaluation time (generator)\n    for time_stage in self.engine.stages(self.time, dt):\n\n        #solve implicit update equation and get iteration count\n        success, evals, solver_its = self._solve(time_stage, dt)\n\n        #count solver iterations and function evaluations\n        total_solver_its += solver_its\n        total_evals += evals\n\n        #if solver did not converge -> quit early (adaptive only)\n        if not success:\n            self._revert()\n            self._update(self.time) \n            return False, 0.0, 0.5, total_evals+1, total_solver_its  \n\n        #timestep for dynamical blocks (with internal states)\n        success, error_norm, scale = self._step(time_stage, dt)\n\n    #if step not successful -> roll back timestep\n    if not success:\n        self._revert()\n        self._update(self.time) \n        return False, error_norm, scale, total_evals+1, total_solver_its\n\n    #system time after timestep\n    time_dt = self.time + dt\n\n    #evaluate system equation before sampling and event check (+dt)\n    self._update(time_dt) \n    total_evals += 1\n\n    #handle detected events chronologically after timestep (+dt)\n    for event, close, ratio in self._detected_events(time_dt):\n\n        #close enough to event (ratio approx 1) -> resolve it\n        if close:\n            event.resolve(time_dt)\n\n            #after resolve, evaluate system equation again -> propagate event\n            self._update(time_dt) \n            total_evals += 1\n\n        #not close enough -> roll back timestep (secant step)\n        else:\n            self._revert()\n            self._update(self.time) \n            total_evals += 1\n            return False, error_norm, ratio, total_evals, total_solver_its\n\n    #sample data after successful timestep (+dt)\n    self._sample(time_dt)\n\n    #increment global time and continue simulation\n    self.time = time_dt    \n\n    #max local truncation error, timestep rescale, successful step\n    return success, error_norm, scale, total_evals, total_solver_its",
              "signature": "(dt = None)",
              "parameters": [
                {
                  "name": "dt",
                  "type": null,
                  "default": "None",
                  "description": "timestep"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "timestep",
              "description": "Advances the transient simulation by one timestep 'dt'.",
              "docstring_html": "<p>Advances the transient simulation by one timestep 'dt'.</p>\n<p>Automatic stepping method selection based on\nselected <cite>Solver</cite>.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>timestep size for transient simulation</dd>\n<dt>adaptive <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>explicitly select the addaptive timestepping branch</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>success <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>indicator if the timestep was successful</dd>\n<dt>max_error <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>maximum local truncation error from integration</dd>\n<dt>scale <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>rescale factor for timestep</dd>\n<dt>total_evals <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>total number of system evaluations</dd>\n<dt>total_solver_its <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>total number of implicit solver iterations</dd>\n</dl>\n",
              "source": "def timestep(self, dt=None, adaptive=True):\n    \"\"\"Advances the transient simulation by one timestep 'dt'. \n\n    Automatic stepping method selection based on \n    selected `Solver`.\n\n    Parameters\n    ----------\n    dt : float\n        timestep size for transient simulation\n    adaptive : bool\n        explicitly select the addaptive timestepping branch\n\n    Returns\n    -------\n    success : bool\n        indicator if the timestep was successful\n    max_error : float\n        maximum local truncation error from integration\n    scale : float\n        rescale factor for timestep\n    total_evals : int\n        total number of system evaluations\n    total_solver_its : int\n        total number of implicit solver iterations            \n    \"\"\"\n    if adaptive and self.engine.is_adaptive:\n        if self.engine.is_explicit:\n            return self.timestep_adaptive_explicit(dt)\n        else:                \n            return self.timestep_adaptive_implicit(dt)\n    else:\n        if self.engine.is_explicit:\n            return self.timestep_fixed_explicit(dt)\n        else:                \n            return self.timestep_fixed_implicit(dt)",
              "signature": "(dt = None, adaptive = True)",
              "parameters": [
                {
                  "name": "dt",
                  "type": null,
                  "default": "None",
                  "description": "timestep size for transient simulation"
                },
                {
                  "name": "adaptive",
                  "type": null,
                  "default": "True",
                  "description": "explicitly select the addaptive timestepping branch"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "step",
              "description": "Wraps 'Simulation.timestep' for backward compatibility",
              "docstring_html": "<p>Wraps 'Simulation.timestep' for backward compatibility</p>\n",
              "source": "def step(self, dt=None, adaptive=True):\n    \"\"\"Wraps 'Simulation.timestep' for backward compatibility\"\"\"\n    self._logger_warning(\n        \"'Simulation.step' method will be deprecated in next release, use 'Simulation.timestep' instead!\"\n        )\n    return self.timestep(dt, adaptive)",
              "signature": "(dt = None, adaptive = True)",
              "parameters": [
                {
                  "name": "dt",
                  "type": null,
                  "default": "None",
                  "description": ""
                },
                {
                  "name": "adaptive",
                  "type": null,
                  "default": "True",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "run",
              "description": "Perform multiple simulation timesteps for a given 'duration'.",
              "docstring_html": "<p>Perform multiple simulation timesteps for a given 'duration'.</p>\n<p>Tracks the total number of block evaluations (proxy for function\ncalls, although larger, since one function call of the system equation\nconsists of many block evaluations) and the total number of solver\niterations for implicit solvers.</p>\n<p>Additionally the progress of the simulation is tracked by a custom\n'ProgressTracker' class that is a dynamic generator and interfaces\nthe logging system.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>duration <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>simulation time (in time units)</dd>\n<dt>reset <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>reset the simulation before running (default False)</dd>\n<dt>adaptive <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>use adaptive timesteps if solver is adaptive (default True)</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>stats <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">dict</span></dt>\n<dd>stats of simulation run tracked by the ´ProgressTracker´</dd>\n</dl>\n",
              "source": "def run(self, duration=10, reset=False, adaptive=True):\n    \"\"\"Perform multiple simulation timesteps for a given 'duration'.\n\n    Tracks the total number of block evaluations (proxy for function \n    calls, although larger, since one function call of the system equation \n    consists of many block evaluations) and the total number of solver\n    iterations for implicit solvers.\n\n    Additionally the progress of the simulation is tracked by a custom\n    'ProgressTracker' class that is a dynamic generator and interfaces \n    the logging system.\n\n    Parameters\n    ----------\n    duration : float\n        simulation time (in time units)\n    reset : bool\n        reset the simulation before running (default False)\n    adaptive : bool\n        use adaptive timesteps if solver is adaptive (default True)\n\n    Returns\n    -------\n    stats : dict\n        stats of simulation run tracked by the ´ProgressTracker´ \n    \"\"\"\n\n    #reset the simulation before running it\n    if reset:\n        self.reset()\n\n    #make an adaptive run?\n    _adaptive = adaptive and self.engine.is_adaptive\n\n    #simulation start and end time\n    start_time, end_time = self.time, self.time + duration\n\n    #effective timestep for duration\n    _dt = self.dt\n\n    #initial system function evaluation \n    self._update(self.time)\n    initial_evals = 1\n\n    #catch and resolve initial events\n    for event, *_ in self._detected_events(self.time):\n\n        #resolve events directly\n        event.resolve(self.time)\n\n        #evaluate system function again -> propagate event\n        self._update(self.time) \n        initial_evals += 1\n\n    #sampling states and inputs at 'self.time == starting_time' \n    self._sample(self.time)\n\n    #initialize progress tracker\n    tracker = ProgressTracker(\n        total_duration=duration, \n        description=\"TRANSIENT\", \n        logger=self.logger,\n        log=self.log\n        )\n\n    #enter tracker context\n    with tracker:\n\n        #iterate progress tracker generator until 'progress >= 1.0' is reached\n        for _ in tracker:\n\n            #advance the simulation by one (effective) timestep '_dt'\n            success, error_norm, scale, *_ = self.timestep(\n                dt=_dt, \n                adaptive=_adaptive\n                )\n\n            #perform adaptive rescale\n            if _adaptive:            \n\n                #if no error estimate and rescale -> back to default timestep\n                if not error_norm and scale == 1:\n                    _dt = self.dt\n\n                #rescale due to error control\n                _dt = scale * _dt\n\n                #estimate time until next event and adjust timestep\n                _dt_evt = self._estimate_events(self.time)\n                if _dt_evt is not None and _dt_evt < _dt:\n                    _dt = _dt_evt\n\n                #rescale if in danger of overshooting 'end_time' at next step\n                if self.time + _dt > end_time:\n                    _dt = end_time - self.time\n\n                #apply bounds to timestep after rescale\n                _dt = np.clip(_dt, self.dt_min, self.dt_max)\n\n            #compute simulation progress\n            progress = np.clip((self.time - start_time)/duration, 0.0, 1.0)\n\n            #update the tracker\n            tracker.update(progress, success=success)\n\n    return tracker.stats",
              "signature": "(duration = 10, reset = False, adaptive = True)",
              "parameters": [
                {
                  "name": "duration",
                  "type": null,
                  "default": "10",
                  "description": "simulation time (in time units)"
                },
                {
                  "name": "reset",
                  "type": null,
                  "default": "False",
                  "description": "reset the simulation before running (default False)"
                },
                {
                  "name": "adaptive",
                  "type": null,
                  "default": "True",
                  "description": "use adaptive timesteps if solver is adaptive (default True)"
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "blocks",
              "description": "",
              "type": null,
              "value": "[]"
            },
            {
              "name": "connections",
              "description": "",
              "type": null,
              "value": "[]"
            },
            {
              "name": "events",
              "description": "",
              "type": null,
              "value": "[]"
            },
            {
              "name": "dt",
              "description": "",
              "type": null,
              "value": "dt"
            },
            {
              "name": "dt_min",
              "description": "",
              "type": null,
              "value": "dt_min"
            },
            {
              "name": "dt_max",
              "description": "",
              "type": null,
              "value": "dt_max"
            },
            {
              "name": "Solver",
              "description": "",
              "type": null,
              "value": "Solver"
            },
            {
              "name": "engine",
              "description": "",
              "type": null,
              "value": "Solver()"
            },
            {
              "name": "graph",
              "description": "",
              "type": null,
              "value": "None"
            },
            {
              "name": "tolerance_fpi",
              "description": "",
              "type": null,
              "value": "tolerance_fpi"
            },
            {
              "name": "solver_kwargs",
              "description": "",
              "type": null,
              "value": "solver_kwargs"
            },
            {
              "name": "iterations_max",
              "description": "",
              "type": null,
              "value": "iterations_max"
            },
            {
              "name": "log",
              "description": "",
              "type": null,
              "value": "log"
            },
            {
              "name": "time",
              "description": "",
              "type": null,
              "value": "0.0"
            },
            {
              "name": "_needs_buffering",
              "description": "",
              "type": null,
              "value": "True"
            },
            {
              "name": "_blocks_dyn",
              "description": "",
              "type": null,
              "value": "[]"
            }
          ],
          "parameters": [
            {
              "name": "blocks",
              "type": null,
              "default": "None",
              "description": "blocks that define the system"
            },
            {
              "name": "connections",
              "type": null,
              "default": "None",
              "description": "connections that connect the blocks"
            },
            {
              "name": "events",
              "type": null,
              "default": "None",
              "description": "list of event trackers (zero crossing detection, schedule, etc.)"
            },
            {
              "name": "dt",
              "type": null,
              "default": "SIM_TIMESTEP",
              "description": "transient simulation timestep in time units, default see ´SIM_TIMESTEP´ in ´_constants.py´"
            },
            {
              "name": "dt_min",
              "type": null,
              "default": "SIM_TIMESTEP_MIN",
              "description": "lower bound for transient simulation timestep, default see ´SIM_TIMESTEP_MIN´ in ´_constants.py´"
            },
            {
              "name": "dt_max",
              "type": null,
              "default": "SIM_TIMESTEP_MAX",
              "description": "upper bound for transient simulation timestep, default see ´SIM_TIMESTEP_MAX´ in ´_constants.py´"
            },
            {
              "name": "Solver",
              "type": null,
              "default": "SSPRK22",
              "description": "ODE solver class for numerical integration from ´pathsim.solvers´, default is ´pathsim.solvers.ssprk22.SSPRK22´ (2nd order expl. Runge Kutta)"
            },
            {
              "name": "tolerance_fpi",
              "type": null,
              "default": "SIM_TOLERANCE_FPI",
              "description": "absolute tolerance for convergence of algebraic loops and internal optimizers of implicit ODE solvers, default see ´SIM_TOLERANCE_FPI´ in ´_constants.py´"
            },
            {
              "name": "iterations_max",
              "type": null,
              "default": "SIM_ITERATIONS_MAX",
              "description": "maximum allowed number of iterations for implicit ODE solver optimizers and algebraic loop solver, default see ´SIM_ITERATIONS_MAX´ in ´_constants.py´"
            },
            {
              "name": "log",
              "type": null,
              "default": "LOG_ENABLE",
              "description": "flag to enable logging, default see ´LOG_ENABLE´ in ´_constants.py´ (alternatively a path to a log file can be specified)"
            },
            {
              "name": "solver_kwargs",
              "type": null,
              "default": "{}",
              "description": "additional parameters for numerical solvers such as absolute (´tolerance_lte_abs´) and relative (´tolerance_lte_rel´) tolerance, defaults are defined in ´_constants.py´"
            }
          ]
        }
      ],
      "functions": []
    },
    "pathsim.subsystem": {
      "name": "pathsim.subsystem",
      "description": "",
      "docstring_html": "",
      "classes": [
        {
          "name": "Interface",
          "description": "Bare-bone block that serves as a data interface for the 'Subsystem' class.",
          "docstring_html": "<p>Bare-bone block that serves as a data interface for the 'Subsystem' class.</p>\n<p>It works like this:</p>\n<ul class=\"simple\">\n<li>Internal blocks of the subsystem are connected to the inputs and outputs\nof this Interface block via the internal connections.</li>\n<li>It behaves like a normal block (inherits the main 'Block' class methods).</li>\n<li>It implements some special methods to get and set the inputs and outputs\nof the blocks, that are used to translate between the internal blocks of the\nsubsystem and the inputs and outputs of the subsystem.</li>\n<li>Handles data transfer to and from the internal subsystem blocks\nto and from the inputs and outputs of the subsystem.</li>\n</ul>\n",
          "source": "class Interface(Block):\n    \"\"\"Bare-bone block that serves as a data interface for the 'Subsystem' class.\n\n    It works like this:\n\n    - Internal blocks of the subsystem are connected to the inputs and outputs \n      of this Interface block via the internal connections.\n    - It behaves like a normal block (inherits the main 'Block' class methods).\n    - It implements some special methods to get and set the inputs and outputs \n      of the blocks, that are used to translate between the internal blocks of the \n      subsystem and the inputs and outputs of the subsystem.\n    - Handles data transfer to and from the internal subsystem blocks \n      to and from the inputs and outputs of the subsystem.\n    \"\"\"\n    def __len__(self):\n        return 0",
          "bases": [
            "pathsim.blocks._block.Block"
          ],
          "methods": [],
          "attributes": [],
          "parameters": []
        },
        {
          "name": "Subsystem",
          "description": "Subsystem class that holds its own blocks and connecions and",
          "docstring_html": "<p>Subsystem class that holds its own blocks and connecions and\ncan natively interface with the main simulation loop.</p>\n<p>IO interface is realized by a special 'Interface' block, that has extra\nmethods for setting and getting inputs and outputs and serves\nas the interface of the internal blocks to the outside.</p>\n<p>The subsystem doesnt use its 'inputs' and 'outputs' dicts directly.\nIt exclusively handles data transfer via the 'Interface' block.</p>\n<p>This class can be used just like any other block during the simulation,\nsince it implements the required methods 'update' for the fixed-point\niteration (resolving algebraic loops with instant time blocks),\nthe 'step' method that performs timestepping (especially for dynamic\nblocks with internal states) and the 'solve' method for solving the\nimplicit update equation for implicit solvers.</p>\n<div class=\"section\" id=\"example\">\n<h4>Example</h4>\n<p>This is how we can wrap up multiple blocks within a subsystem.\nIn this case vanderpol system built from discrete components\ninstead of using an ODE block (in practice you should use\na monolithic ODE whenever possible due to performance).</p>\n<pre class=\"code python literal-block\">\n<span class=\"kn\">from</span><span class=\"w\"> </span><span class=\"nn\">pathsim</span><span class=\"w\"> </span><span class=\"kn\">import</span> <span class=\"n\">Subsystem</span><span class=\"p\">,</span> <span class=\"n\">Interface</span><span class=\"p\">,</span> <span class=\"n\">Connection</span><span class=\"w\">\n</span><span class=\"kn\">from</span><span class=\"w\"> </span><span class=\"nn\">pathsim.blocks</span><span class=\"w\"> </span><span class=\"kn\">import</span> <span class=\"n\">Integrator</span><span class=\"p\">,</span> <span class=\"n\">Function</span><span class=\"w\">\n\n</span><span class=\"c1\">#van der Pol parameter</span><span class=\"w\">\n</span><span class=\"n\">mu</span> <span class=\"o\">=</span> <span class=\"mi\">1000</span><span class=\"w\">\n\n</span><span class=\"c1\">#blocks in the subsystem</span><span class=\"w\">\n</span><span class=\"n\">If</span> <span class=\"o\">=</span> <span class=\"n\">Interface</span><span class=\"p\">()</span> <span class=\"c1\"># this is the interface to the outside</span><span class=\"w\">\n</span><span class=\"n\">I1</span> <span class=\"o\">=</span> <span class=\"n\">Integrator</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">)</span><span class=\"w\">\n</span><span class=\"n\">I2</span> <span class=\"o\">=</span> <span class=\"n\">Integrator</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">)</span><span class=\"w\">\n</span><span class=\"n\">Fn</span> <span class=\"o\">=</span> <span class=\"n\">Function</span><span class=\"p\">(</span><span class=\"k\">lambda</span> <span class=\"n\">x1</span><span class=\"p\">,</span> <span class=\"n\">x2</span><span class=\"p\">:</span> <span class=\"n\">mu</span><span class=\"o\">*</span><span class=\"p\">(</span><span class=\"mi\">1</span> <span class=\"o\">-</span> <span class=\"n\">x1</span><span class=\"o\">**</span><span class=\"mi\">2</span><span class=\"p\">)</span><span class=\"o\">*</span><span class=\"n\">x2</span> <span class=\"o\">-</span> <span class=\"n\">x1</span><span class=\"p\">)</span><span class=\"w\">\n\n</span><span class=\"n\">sub_blocks</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"n\">If</span><span class=\"p\">,</span> <span class=\"n\">I1</span><span class=\"p\">,</span> <span class=\"n\">I2</span><span class=\"p\">,</span> <span class=\"n\">Fn</span><span class=\"p\">]</span><span class=\"w\">\n\n</span><span class=\"c1\">#connections in the subsystem</span><span class=\"w\">\n</span><span class=\"n\">sub_connections</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"w\">\n</span>    <span class=\"n\">Connection</span><span class=\"p\">(</span><span class=\"n\">I2</span><span class=\"p\">,</span> <span class=\"n\">I1</span><span class=\"p\">,</span> <span class=\"n\">Fn</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">],</span> <span class=\"n\">If</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]),</span><span class=\"w\">\n</span>    <span class=\"n\">Connection</span><span class=\"p\">(</span><span class=\"n\">I1</span><span class=\"p\">,</span> <span class=\"n\">Fn</span><span class=\"p\">,</span> <span class=\"n\">If</span><span class=\"p\">),</span><span class=\"w\">\n</span>    <span class=\"n\">Connection</span><span class=\"p\">(</span><span class=\"n\">Fn</span><span class=\"p\">,</span> <span class=\"n\">I2</span><span class=\"p\">)</span><span class=\"w\">\n</span>    <span class=\"p\">]</span><span class=\"w\">\n\n</span><span class=\"c1\">#the subsystem acts just like a normal block</span><span class=\"w\">\n</span><span class=\"n\">vdp</span> <span class=\"o\">=</span> <span class=\"n\">Subsystem</span><span class=\"p\">(</span><span class=\"n\">sub_blocks</span><span class=\"p\">,</span> <span class=\"n\">sub_connections</span><span class=\"p\">)</span>\n</pre>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>blocks <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">list[Block]</span></dt>\n<dd>internal blocks of the subsystem</dd>\n<dt>connections <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">list[Connection]</span></dt>\n<dd>internal connections of the subsystem</dd>\n<dt>tolerance_fpi <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>absolute tolerance for convergence of algebraic loops\ndefault see ´SIM_TOLERANCE_FPI´ in ´_constants.py´</dd>\n<dt>iterations_max <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>maximum allowed number of iterations for algebraic loop solver,\ndefault see ´SIM_ITERATIONS_MAX´ in ´_constants.py´</dd>\n</dl>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>interface <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">Interface</span></dt>\n<dd>internal interface block for data transfer to the outside</dd>\n</dl>\n</div>\n",
          "source": "class Subsystem(Block):\n    \"\"\"Subsystem class that holds its own blocks and connecions and \n    can natively interface with the main simulation loop. \n\n    IO interface is realized by a special 'Interface' block, that has extra \n    methods for setting and getting inputs and outputs and serves \n    as the interface of the internal blocks to the outside. \n\n    The subsystem doesnt use its 'inputs' and 'outputs' dicts directly. \n    It exclusively handles data transfer via the 'Interface' block. \n\n    This class can be used just like any other block during the simulation, \n    since it implements the required methods 'update' for the fixed-point \n    iteration (resolving algebraic loops with instant time blocks), \n    the 'step' method that performs timestepping (especially for dynamic \n    blocks with internal states) and the 'solve' method for solving the \n    implicit update equation for implicit solvers. \n\n\n    Example\n    -------\n\n    This is how we can wrap up multiple blocks within a subsystem. \n    In this case vanderpol system built from discrete components \n    instead of using an ODE block (in practice you should use \n    a monolithic ODE whenever possible due to performance).\n\n    .. code-block:: python\n\n        from pathsim import Subsystem, Interface, Connection\n        from pathsim.blocks import Integrator, Function\n\n        #van der Pol parameter\n        mu = 1000\n\n        #blocks in the subsystem\n        If = Interface() # this is the interface to the outside\n        I1 = Integrator(2)\n        I2 = Integrator(0)\n        Fn = Function(lambda x1, x2: mu*(1 - x1**2)*x2 - x1)\n\n        sub_blocks = [If, I1, I2, Fn]\n\n        #connections in the subsystem\n        sub_connections = [\n            Connection(I2, I1, Fn[1], If[1]), \n            Connection(I1, Fn, If), \n            Connection(Fn, I2)\n            ]\n\n        #the subsystem acts just like a normal block\n        vdp = Subsystem(sub_blocks, sub_connections)\n\n\n    Parameters\n    ----------\n    blocks : list[Block] \n        internal blocks of the subsystem\n    connections : list[Connection]\n        internal connections of the subsystem\n    tolerance_fpi : float\n        absolute tolerance for convergence of algebraic loops\n        default see ´SIM_TOLERANCE_FPI´ in ´_constants.py´\n    iterations_max : int\n        maximum allowed number of iterations for algebraic loop solver, \n        default see ´SIM_ITERATIONS_MAX´ in ´_constants.py´\n\n    Attributes\n    ----------\n    interface : Interface\n        internal interface block for data transfer to the outside\n    \"\"\"\n\n    def __init__(self, \n        blocks=None, \n        connections=None,\n        tolerance_fpi=SIM_TOLERANCE_FPI, \n        iterations_max=SIM_ITERATIONS_MAX\n        ):\n\n        #internal integration engine as 'None'\n        self.engine = None\n\n        #flag to set block (subsystem) active\n        self._active = True\n\n        #error tolerance for alg. loop solver\n        self.tolerance_fpi = tolerance_fpi\n\n        #max iterations for internal alg. loop solver\n        self.iterations_max = iterations_max\n\n        #internal discrete events (for mixed signal blocks)\n        self.events = []\n\n        #operators for algebraic and dynamic components (not here)\n        self.op_alg = None\n        self.op_dyn = None\n\n        #internal graph representation\n        self.graph = None\n\n        #internal connecions\n        self.connections = [] if connections is None else connections\n\n        #collect and organize internal blocks\n        self.blocks, self.interface = [], None\n\n        if blocks is not None:\n            for block in blocks:\n                if isinstance(block, Interface): \n\n                    if self.interface is not None:\n                        #interface block is already defined\n                        raise ValueError(\"Subsystem can only have one 'Interface' block!\")\n\n                    self.interface = block\n                else: \n                    #regular blocks\n                    self.blocks.append(block)\n\n        #check if interface is defined\n        if self.interface is None:\n            raise ValueError(\"Subsystem 'blocks' list needs to contain 'Interface' block!\")\n\n        #validate the internal connections upon initialization\n        self._check_connections()\n\n        #assemble internal graph\n        self._assemble_graph()\n\n\n    def __len__(self):\n        \"\"\"Recursively compute the longest signal path in the subsytem by \n        depth first search, leveraging the '__len__' methods of the blocks. \n\n        This enables the path length computation even for nested subsystems.\n\n        Iterate internal blocks and compute longest path from each block \n        as starting block.\n\n        Basically the same as in the 'Simulation' class.\n        \"\"\"\n\n        #no graph yet -> no passthrough anyway\n        if not self.graph:\n            return 0\n\n        #internal loops -> tainted (inf)\n        if self.graph.has_loops:\n            return None\n\n        #check if algebraic path from interface back to itself \n        is_alg = self.graph.is_algebraic_path(self.interface, self.interface)\n        return int(is_alg)\n\n\n    def __call__(self):\n        \"\"\"Recursively get the subsystems internal states of engines \n        (if available) of all internal blocks and nested subsystems \n        and the subsystem inputs and outputs as arrays for use outside. \n\n        Either for monitoring, postprocessing or event detection. \n        In any case this enables easy access to the current block state.\n        \"\"\"\n        _inputs  = self.interface.outputs.to_array()\n        _outputs = self.interface.inputs.to_array()\n        _states  = []\n        for block in self.blocks:\n            _i, _o, _s = block()\n            _states.append(_s)\n        return _inputs, _outputs, np.hstack(_states)\n\n\n    def __contains__(self, other):\n        \"\"\"Check if blocks and connections are already part of the subsystem\n\n        Paramters\n        ---------\n        other : obj\n            object to check if its part of subsystem\n\n        Returns\n        -------\n        bool\n        \"\"\"\n        return other in self.blocks or other in self.connections\n\n\n    # methods for verification ----------------------------------------------------------\n\n    def _check_connections(self):\n        \"\"\"Check if connections are valid and if there is no input port \n        that recieves multiple outputs and could be overwritten unintentionally.\n\n        If multiple outputs are assigned to the same input, an error is raised.\n        \"\"\"\n\n        #iterate connections and check if they are valid\n        for i, conn_1 in enumerate(self.connections):\n\n            #check if connections overwrite each other and raise exception\n            for conn_2 in self.connections[(i+1):]:\n                if conn_1.overwrites(conn_2):\n                    _msg = f\"{conn_1} overwrites {conn_2}\"\n                    raise ValueError(_msg)\n\n\n    # subsystem graph assembly --------------------------------------------------------------\n\n    def _assemble_graph(self):\n        \"\"\"Assemble internal graph of subsystem for fast \n        algebraic evaluation during simulation.\n        \"\"\"\n        self.graph = Graph(self.blocks, self.connections)\n\n\n    # methods for access to metadata --------------------------------------------------------\n\n    def size(self):\n        \"\"\"Get size information from subsystem, recursively assembled \n        from internal blocks, including nested subsystems.\n\n        Returns\n        -------\n        sizes : tuple[int]\n            size of block (default 1) and number \n            of internal states (from internal engine)\n        \"\"\"\n        total_n, total_nx = 0, 0\n        for block in self.blocks:\n            n, nx = block.size()\n            total_n += n\n            total_nx += nx\n        return total_n, total_nx\n\n\n    # visualization -------------------------------------------------------------------------\n\n    def plot(self, *args, **kwargs):\n        \"\"\"Plot the simulation results by calling all the blocks \n        that have visualization capabilities such as the 'Scope' \n        and 'Spectrum'.\n\n        Parameters\n        ----------\n        args : tuple\n            args for the plot methods\n        kwargs : dict\n            kwargs for the plot method\n        \"\"\"\n        for block in self.blocks:\n            block.plot(*args, **kwargs)\n\n\n    # system management ---------------------------------------------------------------------\n\n    def reset(self):\n        \"\"\"Reset the subsystem interface and all internal blocks\"\"\"\n\n        #reset interface\n        self.interface.reset()\n\n        #reset internal blocks\n        for block in self.blocks:\n            block.reset()\n\n\n    def on(self):\n        \"\"\"Activate the subsystem and all internal blocks, sets the boolean\n        evaluation flag to 'True'.\n        \"\"\"\n        self._active = True\n        for block in self.blocks: \n            block.on()\n\n\n    def off(self):\n        \"\"\"Deactivate the subsystem and all internal blocks, sets the boolean\n        evaluation flag to 'False'. Also resets the subsystem.\n        \"\"\"\n        self._active = False\n        for block in self.blocks: \n            block.off()\n        self.reset()\n\n\n    def linearize(self, t):\n        \"\"\"Linearize the algebraic and dynamic components of the internal blocks.\n\n        This is done by linearizing the internal 'Operator' and 'DynamicOperator' \n        instances of all the internal blocks of the subsystem in the current system \n        operating point. The operators create 1st order tayler approximations \n        internally and use them on subsequent calls after linarization.\n\n        Recursively traverses down the hierarchy for nested subsystems and linearizes \n        all of them.\n\n        Parameters\n        ----------\n        t : float \n            evaluation time\n        \"\"\"\n        for block in self.blocks: \n            block.linearize(t)\n\n\n    def delinearize(self):\n        \"\"\"Revert the linearization of the internal blocks.\"\"\"\n        for block in self.blocks: \n            block.delinearize()\n\n\n    # serialization / deserialization -------------------------------------------------------\n\n    def to_dict(self):\n        \"\"\"Custom serialization for Subsystem\"\"\"\n        data = super().to_dict()\n\n        #serialization for internal blocks and interface\n        data[\"params\"][\"blocks\"] = [block.to_dict() for block in self.blocks + [self.interface]]\n\n        #serialize connections\n        data[\"params\"][\"connections\"] = [conn.to_dict() for conn in self.connections]\n\n        return data\n\n\n    @classmethod\n    def from_dict(cls, data):\n        \"\"\"Custom deserialization for Subsystem\"\"\"\n        from .connection import Connection\n\n        #deserialize blocks and create block ID mapping\n        blocks, id_to_block = [], {}\n        for blk_data in data[\"params\"].pop(\"blocks\", []):\n            block = Block.from_dict(blk_data)\n            blocks.append(block)\n            id_to_block[blk_data[\"id\"]] = block\n\n        #deserialize connections\n        connections = []\n        for conn_data in data[\"params\"].pop(\"connections\", []):\n\n            #source data\n            source_block = id_to_block[conn_data[\"source\"][\"block\"]]\n            source_ports = conn_data[\"source\"][\"ports\"]\n            source = PortReference(source_block, source_ports)\n\n            #target data\n            targets = []\n            for trg in conn_data[\"targets\"]:\n                target_block = id_to_block[trg[\"block\"]]\n                target_ports = trg[\"ports\"]\n                targets.append(\n                    PortReference(target_block, target_ports)\n                    )\n\n            #create the connection\n            connections.append(\n                Connection(source, *targets)\n                )\n\n        #finally construct the subsystem\n        return cls(blocks, connections)\n\n\n    # methods for discrete event management -------------------------------------------------\n\n    def get_events(self):\n        \"\"\"Recursively collect and return events spawned by the \n        internal blocks of the subsystem, for discrete time \n        blocks such as triggers / comparators, clocks, etc.\n        \"\"\"\n        _events = []\n        for block in self.blocks:\n            _events.extend(block.get_events())\n        return _events\n\n\n    # methods for inter-block data transfer -------------------------------------------------\n\n    @property    \n    def inputs(self):\n        return self.interface.outputs\n\n    @property\n    def outputs(self):\n        return self.interface.inputs\n\n\n    # methods for data recording ------------------------------------------------------------\n\n    def sample(self, t):\n        \"\"\"Update the internal connections again and sample data from \n        the internal blocks that implement the 'sample' method.\n\n        Parameters\n        ----------\n        t : float\n            evaluation time \n        \"\"\"\n\n        #record data if required\n        for block in self.blocks:\n            block.sample(t)\n\n\n    # methods for block output and state updates --------------------------------------------\n\n    def update(self, t):\n        \"\"\"Update the instant time components of the internal blocks \n        to evaluate the (distributed) system equation.\n\n        Parameters\n        ----------\n        t : float\n            evaluation time \n        \"\"\"\n\n        #evaluate DAG\n        self._dag(t)\n\n        #algebraic loops -> solve them\n        if self.graph.has_loops:   \n            self._loops(t)\n\n\n    def _dag(self, t):\n        \"\"\"Update the directed acyclic graph components of the system.\n\n        Parameters\n        ----------\n        t : float\n            evaluation time for system function\n        \"\"\"\n\n        #update interface outgoing connections\n        for connection in self.graph.outgoing_connections(self.interface):\n            if connection: connection.update()\n\n        #perform gauss-seidel iterations without error checking\n        for _, blocks_dag, connections_dag in self.graph.dag():\n\n            #update blocks at algebraic depth\n            for block in blocks_dag:\n                if block: block.update(t)\n\n            #update connenctions at algebraic depth (data transfer)\n            for connection in connections_dag:\n                if connection: connection.update()\n\n\n    def _loops(self, t):\n        \"\"\"Perform the algebraic loop solve of the system using accelerated \n        fixed-point iterations on the broken loop directed graph.\n\n        Parameters\n        ----------\n        t : float\n            evaluation time for system function\n        \"\"\"\n\n        #perform solver iterations on algebraic loops\n        for iteration in range(1, self.iterations_max):\n\n            #iterate DAG depths of broken loops\n            max_error = 0.0\n            for depth, blocks_loop, connections_loop in self.graph.loop():\n\n                #update blocks at algebraic depth (with error control)\n                for block in blocks_loop:\n                    if block: block.update(t)                \n\n                #step accelerated connenctions at algebraic depth (data transfer)\n                for connection in connections_loop:\n\n                    #skip inactive connections\n                    if not connection: \n                        continue\n\n                    #connections at first depth\n                    if loop_depth == 0:\n\n                        #reset solver at first iteration\n                        if iteration == 1: \n                            connection.reset()\n\n                        #step fixed-point solver (for alg. loops)\n                        err = connection.step() \n                        if err > max_error:\n                            max_error = err\n\n                    else:\n\n                        #connections at lower depths\n                        connection.update()\n\n            #check convergence\n            if max_error <= self.tolerance_fpi:\n                return\n\n        #not converged -> error\n        raise RuntimeError(\n            \"algebraic loop in 'Subsystem' not converged (iters: {}, err: {})\".format(\n                self.iterations_max, max_error)\n            )\n\n\n    # methods for blocks with integration engines -------------------------------------------\n\n    def solve(self, t, dt):\n        \"\"\"Advance solution of implicit update equation \n        for internal blocks.\n\n        Parameters\n        ----------\n        t : float\n            evaluation time \n        dt : float\n            timestep\n\n        Returns\n        -------\n        max_error : float\n            maximum error of implicit update equaiton\n        \"\"\"\n        max_error = 0.0\n        for block in self._blocks_dyn:\n            if not block: continue\n            err = block.solve(t, dt)\n            if err > max_error:\n                max_error = err\n        return max_error\n\n\n    def step(self, t, dt):\n        \"\"\"Explicit component of timestep for internal blocks \n        including error propagation.\n\n        Notes\n        ----- \n        This is pretty much an exact copy of the '_step' method \n        from the 'Simulation' class.\n\n        Parameters\n        ---------- \n        t : float\n            evaluation time \n        dt : float\n            timestep\n\n        Returns\n        -------\n        success : bool\n            indicator if the timestep was successful\n        max_error : float\n            maximum local truncation error from integration\n        scale : float\n            rescale factor for timestep\n        \"\"\"\n\n        #initial timestep rescale and error estimate\n        success, max_error_norm, relevant_scales = True, 0.0, []\n\n        #step blocks and get error estimates if available\n        for block in self._blocks_dyn:\n\n            #skip inactive internal blocks\n            if not block: continue\n\n            suc, err_norm, scl = block.step(t, dt)\n\n            #check solver stepping success\n            if not suc: \n                success = False\n\n            #update error tracking\n            if err_norm > max_error_norm: \n                max_error_norm = err_norm\n\n            #update timestep rescale if relevant\n            if scl != 1.0 and scl > 0.0: \n                relevant_scales.append(scl)\n\n        #no relevant timestep rescale -> quit early\n        if not relevant_scales: \n            return success, max_error_norm, 1.0\n\n        #compute real timestep rescale\n        return success, max_error_norm, min(relevant_scales)\n\n\n    def set_solver(self, Solver, **solver_args):\n        \"\"\"Initialize all blocks with solver for numerical integration\n        and additional args for the solver such as tolerances, etc.\n\n        If blocks already have solvers, change the numerical integrator\n        to the 'Solver' class.\n\n        Parameters\n        ----------\n        Solver : Solver\n            numerical solver definition\n        solver_args : dict\n            args to initialize solver with \n        \"\"\"\n\n        #set internal dummy engine\n        self.engine = Solver()\n\n        #set integration engines and assemble list of dynamic blocks\n        self._blocks_dyn = []\n        for block in self.blocks:\n            block.set_solver(Solver, **solver_args)\n            if block.engine:\n                self._blocks_dyn.append(block)\n\n\n    def revert(self):\n        \"\"\"revert the internal blocks to the state \n        of the previous timestep \n        \"\"\"\n        for block in self._blocks_dyn:\n            if block: block.revert()\n\n\n    def buffer(self, dt):\n        \"\"\"buffer internal states of blocks with \n        internal integration engines \n\n        Parameters\n        ----------\n        dt : float\n            evaluation time for buffering    \n        \"\"\"\n        for block in self._blocks_dyn:\n            if block: block.buffer(dt)",
          "bases": [
            "pathsim.blocks._block.Block"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, \n    blocks=None, \n    connections=None,\n    tolerance_fpi=SIM_TOLERANCE_FPI, \n    iterations_max=SIM_ITERATIONS_MAX\n    ):\n\n    #internal integration engine as 'None'\n    self.engine = None\n\n    #flag to set block (subsystem) active\n    self._active = True\n\n    #error tolerance for alg. loop solver\n    self.tolerance_fpi = tolerance_fpi\n\n    #max iterations for internal alg. loop solver\n    self.iterations_max = iterations_max\n\n    #internal discrete events (for mixed signal blocks)\n    self.events = []\n\n    #operators for algebraic and dynamic components (not here)\n    self.op_alg = None\n    self.op_dyn = None\n\n    #internal graph representation\n    self.graph = None\n\n    #internal connecions\n    self.connections = [] if connections is None else connections\n\n    #collect and organize internal blocks\n    self.blocks, self.interface = [], None\n\n    if blocks is not None:\n        for block in blocks:\n            if isinstance(block, Interface): \n\n                if self.interface is not None:\n                    #interface block is already defined\n                    raise ValueError(\"Subsystem can only have one 'Interface' block!\")\n\n                self.interface = block\n            else: \n                #regular blocks\n                self.blocks.append(block)\n\n    #check if interface is defined\n    if self.interface is None:\n        raise ValueError(\"Subsystem 'blocks' list needs to contain 'Interface' block!\")\n\n    #validate the internal connections upon initialization\n    self._check_connections()\n\n    #assemble internal graph\n    self._assemble_graph()",
              "signature": "(blocks = None, connections = None, tolerance_fpi = SIM_TOLERANCE_FPI, iterations_max = SIM_ITERATIONS_MAX)",
              "parameters": [
                {
                  "name": "blocks",
                  "type": null,
                  "default": "None",
                  "description": ""
                },
                {
                  "name": "connections",
                  "type": null,
                  "default": "None",
                  "description": ""
                },
                {
                  "name": "tolerance_fpi",
                  "type": null,
                  "default": "SIM_TOLERANCE_FPI",
                  "description": ""
                },
                {
                  "name": "iterations_max",
                  "type": null,
                  "default": "SIM_ITERATIONS_MAX",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "_check_connections",
              "description": "Check if connections are valid and if there is no input port",
              "docstring_html": "<p>Check if connections are valid and if there is no input port\nthat recieves multiple outputs and could be overwritten unintentionally.</p>\n<p>If multiple outputs are assigned to the same input, an error is raised.</p>\n",
              "source": "def _check_connections(self):\n    \"\"\"Check if connections are valid and if there is no input port \n    that recieves multiple outputs and could be overwritten unintentionally.\n\n    If multiple outputs are assigned to the same input, an error is raised.\n    \"\"\"\n\n    #iterate connections and check if they are valid\n    for i, conn_1 in enumerate(self.connections):\n\n        #check if connections overwrite each other and raise exception\n        for conn_2 in self.connections[(i+1):]:\n            if conn_1.overwrites(conn_2):\n                _msg = f\"{conn_1} overwrites {conn_2}\"\n                raise ValueError(_msg)",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "_assemble_graph",
              "description": "Assemble internal graph of subsystem for fast",
              "docstring_html": "<p>Assemble internal graph of subsystem for fast\nalgebraic evaluation during simulation.</p>\n",
              "source": "def _assemble_graph(self):\n    \"\"\"Assemble internal graph of subsystem for fast \n    algebraic evaluation during simulation.\n    \"\"\"\n    self.graph = Graph(self.blocks, self.connections)",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "size",
              "description": "Get size information from subsystem, recursively assembled",
              "docstring_html": "<p>Get size information from subsystem, recursively assembled\nfrom internal blocks, including nested subsystems.</p>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>sizes <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">tuple[int]</span></dt>\n<dd>size of block (default 1) and number\nof internal states (from internal engine)</dd>\n</dl>\n",
              "source": "def size(self):\n    \"\"\"Get size information from subsystem, recursively assembled \n    from internal blocks, including nested subsystems.\n\n    Returns\n    -------\n    sizes : tuple[int]\n        size of block (default 1) and number \n        of internal states (from internal engine)\n    \"\"\"\n    total_n, total_nx = 0, 0\n    for block in self.blocks:\n        n, nx = block.size()\n        total_n += n\n        total_nx += nx\n    return total_n, total_nx",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "plot",
              "description": "Plot the simulation results by calling all the blocks",
              "docstring_html": "<p>Plot the simulation results by calling all the blocks\nthat have visualization capabilities such as the 'Scope'\nand 'Spectrum'.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>args <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">tuple</span></dt>\n<dd>args for the plot methods</dd>\n<dt>kwargs <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">dict</span></dt>\n<dd>kwargs for the plot method</dd>\n</dl>\n",
              "source": "def plot(self, *args, **kwargs):\n    \"\"\"Plot the simulation results by calling all the blocks \n    that have visualization capabilities such as the 'Scope' \n    and 'Spectrum'.\n\n    Parameters\n    ----------\n    args : tuple\n        args for the plot methods\n    kwargs : dict\n        kwargs for the plot method\n    \"\"\"\n    for block in self.blocks:\n        block.plot(*args, **kwargs)",
              "signature": "(args = (), kwargs = {})",
              "parameters": [
                {
                  "name": "args",
                  "type": null,
                  "default": "()",
                  "description": "args for the plot methods"
                },
                {
                  "name": "kwargs",
                  "type": null,
                  "default": "{}",
                  "description": "kwargs for the plot method"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "reset",
              "description": "Reset the subsystem interface and all internal blocks",
              "docstring_html": "<p>Reset the subsystem interface and all internal blocks</p>\n",
              "source": "def reset(self):\n    \"\"\"Reset the subsystem interface and all internal blocks\"\"\"\n\n    #reset interface\n    self.interface.reset()\n\n    #reset internal blocks\n    for block in self.blocks:\n        block.reset()",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "on",
              "description": "Activate the subsystem and all internal blocks, sets the boolean",
              "docstring_html": "<p>Activate the subsystem and all internal blocks, sets the boolean\nevaluation flag to 'True'.</p>\n",
              "source": "def on(self):\n    \"\"\"Activate the subsystem and all internal blocks, sets the boolean\n    evaluation flag to 'True'.\n    \"\"\"\n    self._active = True\n    for block in self.blocks: \n        block.on()",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "off",
              "description": "Deactivate the subsystem and all internal blocks, sets the boolean",
              "docstring_html": "<p>Deactivate the subsystem and all internal blocks, sets the boolean\nevaluation flag to 'False'. Also resets the subsystem.</p>\n",
              "source": "def off(self):\n    \"\"\"Deactivate the subsystem and all internal blocks, sets the boolean\n    evaluation flag to 'False'. Also resets the subsystem.\n    \"\"\"\n    self._active = False\n    for block in self.blocks: \n        block.off()\n    self.reset()",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "linearize",
              "description": "Linearize the algebraic and dynamic components of the internal blocks.",
              "docstring_html": "<p>Linearize the algebraic and dynamic components of the internal blocks.</p>\n<p>This is done by linearizing the internal 'Operator' and 'DynamicOperator'\ninstances of all the internal blocks of the subsystem in the current system\noperating point. The operators create 1st order tayler approximations\ninternally and use them on subsequent calls after linarization.</p>\n<p>Recursively traverses down the hierarchy for nested subsystems and linearizes\nall of them.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time</dd>\n</dl>\n",
              "source": "def linearize(self, t):\n    \"\"\"Linearize the algebraic and dynamic components of the internal blocks.\n\n    This is done by linearizing the internal 'Operator' and 'DynamicOperator' \n    instances of all the internal blocks of the subsystem in the current system \n    operating point. The operators create 1st order tayler approximations \n    internally and use them on subsequent calls after linarization.\n\n    Recursively traverses down the hierarchy for nested subsystems and linearizes \n    all of them.\n\n    Parameters\n    ----------\n    t : float \n        evaluation time\n    \"\"\"\n    for block in self.blocks: \n        block.linearize(t)",
              "signature": "(t)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "delinearize",
              "description": "Revert the linearization of the internal blocks.",
              "docstring_html": "<p>Revert the linearization of the internal blocks.</p>\n",
              "source": "def delinearize(self):\n    \"\"\"Revert the linearization of the internal blocks.\"\"\"\n    for block in self.blocks: \n        block.delinearize()",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "to_dict",
              "description": "Custom serialization for Subsystem",
              "docstring_html": "<p>Custom serialization for Subsystem</p>\n",
              "source": "def to_dict(self):\n    \"\"\"Custom serialization for Subsystem\"\"\"\n    data = super().to_dict()\n\n    #serialization for internal blocks and interface\n    data[\"params\"][\"blocks\"] = [block.to_dict() for block in self.blocks + [self.interface]]\n\n    #serialize connections\n    data[\"params\"][\"connections\"] = [conn.to_dict() for conn in self.connections]\n\n    return data",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "from_dict",
              "description": "Custom deserialization for Subsystem",
              "docstring_html": "<p>Custom deserialization for Subsystem</p>\n",
              "source": "@classmethod\ndef from_dict(cls, data):\n    \"\"\"Custom deserialization for Subsystem\"\"\"\n    from .connection import Connection\n\n    #deserialize blocks and create block ID mapping\n    blocks, id_to_block = [], {}\n    for blk_data in data[\"params\"].pop(\"blocks\", []):\n        block = Block.from_dict(blk_data)\n        blocks.append(block)\n        id_to_block[blk_data[\"id\"]] = block\n\n    #deserialize connections\n    connections = []\n    for conn_data in data[\"params\"].pop(\"connections\", []):\n\n        #source data\n        source_block = id_to_block[conn_data[\"source\"][\"block\"]]\n        source_ports = conn_data[\"source\"][\"ports\"]\n        source = PortReference(source_block, source_ports)\n\n        #target data\n        targets = []\n        for trg in conn_data[\"targets\"]:\n            target_block = id_to_block[trg[\"block\"]]\n            target_ports = trg[\"ports\"]\n            targets.append(\n                PortReference(target_block, target_ports)\n                )\n\n        #create the connection\n        connections.append(\n            Connection(source, *targets)\n            )\n\n    #finally construct the subsystem\n    return cls(blocks, connections)",
              "signature": "(cls, data)",
              "parameters": [
                {
                  "name": "cls",
                  "type": null,
                  "default": null,
                  "description": ""
                },
                {
                  "name": "data",
                  "type": null,
                  "default": null,
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "classmethod"
            },
            {
              "name": "get_events",
              "description": "Recursively collect and return events spawned by the",
              "docstring_html": "<p>Recursively collect and return events spawned by the\ninternal blocks of the subsystem, for discrete time\nblocks such as triggers / comparators, clocks, etc.</p>\n",
              "source": "def get_events(self):\n    \"\"\"Recursively collect and return events spawned by the \n    internal blocks of the subsystem, for discrete time \n    blocks such as triggers / comparators, clocks, etc.\n    \"\"\"\n    _events = []\n    for block in self.blocks:\n        _events.extend(block.get_events())\n    return _events",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "sample",
              "description": "Update the internal connections again and sample data from",
              "docstring_html": "<p>Update the internal connections again and sample data from\nthe internal blocks that implement the 'sample' method.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time</dd>\n</dl>\n",
              "source": "def sample(self, t):\n    \"\"\"Update the internal connections again and sample data from \n    the internal blocks that implement the 'sample' method.\n\n    Parameters\n    ----------\n    t : float\n        evaluation time \n    \"\"\"\n\n    #record data if required\n    for block in self.blocks:\n        block.sample(t)",
              "signature": "(t)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "update",
              "description": "Update the instant time components of the internal blocks",
              "docstring_html": "<p>Update the instant time components of the internal blocks\nto evaluate the (distributed) system equation.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time</dd>\n</dl>\n",
              "source": "def update(self, t):\n    \"\"\"Update the instant time components of the internal blocks \n    to evaluate the (distributed) system equation.\n\n    Parameters\n    ----------\n    t : float\n        evaluation time \n    \"\"\"\n\n    #evaluate DAG\n    self._dag(t)\n\n    #algebraic loops -> solve them\n    if self.graph.has_loops:   \n        self._loops(t)",
              "signature": "(t)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "_dag",
              "description": "Update the directed acyclic graph components of the system.",
              "docstring_html": "<p>Update the directed acyclic graph components of the system.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time for system function</dd>\n</dl>\n",
              "source": "def _dag(self, t):\n    \"\"\"Update the directed acyclic graph components of the system.\n\n    Parameters\n    ----------\n    t : float\n        evaluation time for system function\n    \"\"\"\n\n    #update interface outgoing connections\n    for connection in self.graph.outgoing_connections(self.interface):\n        if connection: connection.update()\n\n    #perform gauss-seidel iterations without error checking\n    for _, blocks_dag, connections_dag in self.graph.dag():\n\n        #update blocks at algebraic depth\n        for block in blocks_dag:\n            if block: block.update(t)\n\n        #update connenctions at algebraic depth (data transfer)\n        for connection in connections_dag:\n            if connection: connection.update()",
              "signature": "(t)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time for system function"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "_loops",
              "description": "Perform the algebraic loop solve of the system using accelerated",
              "docstring_html": "<p>Perform the algebraic loop solve of the system using accelerated\nfixed-point iterations on the broken loop directed graph.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time for system function</dd>\n</dl>\n",
              "source": "def _loops(self, t):\n    \"\"\"Perform the algebraic loop solve of the system using accelerated \n    fixed-point iterations on the broken loop directed graph.\n\n    Parameters\n    ----------\n    t : float\n        evaluation time for system function\n    \"\"\"\n\n    #perform solver iterations on algebraic loops\n    for iteration in range(1, self.iterations_max):\n\n        #iterate DAG depths of broken loops\n        max_error = 0.0\n        for depth, blocks_loop, connections_loop in self.graph.loop():\n\n            #update blocks at algebraic depth (with error control)\n            for block in blocks_loop:\n                if block: block.update(t)                \n\n            #step accelerated connenctions at algebraic depth (data transfer)\n            for connection in connections_loop:\n\n                #skip inactive connections\n                if not connection: \n                    continue\n\n                #connections at first depth\n                if loop_depth == 0:\n\n                    #reset solver at first iteration\n                    if iteration == 1: \n                        connection.reset()\n\n                    #step fixed-point solver (for alg. loops)\n                    err = connection.step() \n                    if err > max_error:\n                        max_error = err\n\n                else:\n\n                    #connections at lower depths\n                    connection.update()\n\n        #check convergence\n        if max_error <= self.tolerance_fpi:\n            return\n\n    #not converged -> error\n    raise RuntimeError(\n        \"algebraic loop in 'Subsystem' not converged (iters: {}, err: {})\".format(\n            self.iterations_max, max_error)\n        )",
              "signature": "(t)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time for system function"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "solve",
              "description": "Advance solution of implicit update equation",
              "docstring_html": "<p>Advance solution of implicit update equation\nfor internal blocks.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time</dd>\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>timestep</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>max_error <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>maximum error of implicit update equaiton</dd>\n</dl>\n",
              "source": "def solve(self, t, dt):\n    \"\"\"Advance solution of implicit update equation \n    for internal blocks.\n\n    Parameters\n    ----------\n    t : float\n        evaluation time \n    dt : float\n        timestep\n\n    Returns\n    -------\n    max_error : float\n        maximum error of implicit update equaiton\n    \"\"\"\n    max_error = 0.0\n    for block in self._blocks_dyn:\n        if not block: continue\n        err = block.solve(t, dt)\n        if err > max_error:\n            max_error = err\n    return max_error",
              "signature": "(t, dt)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time"
                },
                {
                  "name": "dt",
                  "type": null,
                  "default": null,
                  "description": "timestep"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "step",
              "description": "Explicit component of timestep for internal blocks",
              "docstring_html": "<p>Explicit component of timestep for internal blocks\nincluding error propagation.</p>\n<p><strong>Notes</strong></p>\n<p>This is pretty much an exact copy of the '_step' method\nfrom the 'Simulation' class.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time</dd>\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>timestep</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>success <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>indicator if the timestep was successful</dd>\n<dt>max_error <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>maximum local truncation error from integration</dd>\n<dt>scale <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>rescale factor for timestep</dd>\n</dl>\n",
              "source": "def step(self, t, dt):\n    \"\"\"Explicit component of timestep for internal blocks \n    including error propagation.\n\n    Notes\n    ----- \n    This is pretty much an exact copy of the '_step' method \n    from the 'Simulation' class.\n\n    Parameters\n    ---------- \n    t : float\n        evaluation time \n    dt : float\n        timestep\n\n    Returns\n    -------\n    success : bool\n        indicator if the timestep was successful\n    max_error : float\n        maximum local truncation error from integration\n    scale : float\n        rescale factor for timestep\n    \"\"\"\n\n    #initial timestep rescale and error estimate\n    success, max_error_norm, relevant_scales = True, 0.0, []\n\n    #step blocks and get error estimates if available\n    for block in self._blocks_dyn:\n\n        #skip inactive internal blocks\n        if not block: continue\n\n        suc, err_norm, scl = block.step(t, dt)\n\n        #check solver stepping success\n        if not suc: \n            success = False\n\n        #update error tracking\n        if err_norm > max_error_norm: \n            max_error_norm = err_norm\n\n        #update timestep rescale if relevant\n        if scl != 1.0 and scl > 0.0: \n            relevant_scales.append(scl)\n\n    #no relevant timestep rescale -> quit early\n    if not relevant_scales: \n        return success, max_error_norm, 1.0\n\n    #compute real timestep rescale\n    return success, max_error_norm, min(relevant_scales)",
              "signature": "(t, dt)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time"
                },
                {
                  "name": "dt",
                  "type": null,
                  "default": null,
                  "description": "timestep"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "set_solver",
              "description": "Initialize all blocks with solver for numerical integration",
              "docstring_html": "<p>Initialize all blocks with solver for numerical integration\nand additional args for the solver such as tolerances, etc.</p>\n<p>If blocks already have solvers, change the numerical integrator\nto the 'Solver' class.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>Solver <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">Solver</span></dt>\n<dd>numerical solver definition</dd>\n<dt>solver_args <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">dict</span></dt>\n<dd>args to initialize solver with</dd>\n</dl>\n",
              "source": "def set_solver(self, Solver, **solver_args):\n    \"\"\"Initialize all blocks with solver for numerical integration\n    and additional args for the solver such as tolerances, etc.\n\n    If blocks already have solvers, change the numerical integrator\n    to the 'Solver' class.\n\n    Parameters\n    ----------\n    Solver : Solver\n        numerical solver definition\n    solver_args : dict\n        args to initialize solver with \n    \"\"\"\n\n    #set internal dummy engine\n    self.engine = Solver()\n\n    #set integration engines and assemble list of dynamic blocks\n    self._blocks_dyn = []\n    for block in self.blocks:\n        block.set_solver(Solver, **solver_args)\n        if block.engine:\n            self._blocks_dyn.append(block)",
              "signature": "(Solver, solver_args = {})",
              "parameters": [
                {
                  "name": "Solver",
                  "type": null,
                  "default": null,
                  "description": "numerical solver definition"
                },
                {
                  "name": "solver_args",
                  "type": null,
                  "default": "{}",
                  "description": "args to initialize solver with"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "revert",
              "description": "revert the internal blocks to the state",
              "docstring_html": "<p>revert the internal blocks to the state\nof the previous timestep</p>\n",
              "source": "def revert(self):\n    \"\"\"revert the internal blocks to the state \n    of the previous timestep \n    \"\"\"\n    for block in self._blocks_dyn:\n        if block: block.revert()",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "buffer",
              "description": "buffer internal states of blocks with",
              "docstring_html": "<p>buffer internal states of blocks with\ninternal integration engines</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time for buffering</dd>\n</dl>\n",
              "source": "def buffer(self, dt):\n    \"\"\"buffer internal states of blocks with \n    internal integration engines \n\n    Parameters\n    ----------\n    dt : float\n        evaluation time for buffering    \n    \"\"\"\n    for block in self._blocks_dyn:\n        if block: block.buffer(dt)",
              "signature": "(dt)",
              "parameters": [
                {
                  "name": "dt",
                  "type": null,
                  "default": null,
                  "description": "evaluation time for buffering"
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "engine",
              "description": "",
              "type": null,
              "value": "None"
            },
            {
              "name": "_active",
              "description": "",
              "type": null,
              "value": "True"
            },
            {
              "name": "tolerance_fpi",
              "description": "",
              "type": null,
              "value": "tolerance_fpi"
            },
            {
              "name": "iterations_max",
              "description": "",
              "type": null,
              "value": "iterations_max"
            },
            {
              "name": "events",
              "description": "",
              "type": null,
              "value": "[]"
            },
            {
              "name": "op_alg",
              "description": "",
              "type": null,
              "value": "None"
            },
            {
              "name": "op_dyn",
              "description": "",
              "type": null,
              "value": "None"
            },
            {
              "name": "graph",
              "description": "",
              "type": null,
              "value": "None"
            },
            {
              "name": "connections",
              "description": "",
              "type": null,
              "value": "[] if connections is None else connections"
            },
            {
              "name": "interface",
              "description": "",
              "type": null,
              "value": "block"
            },
            {
              "name": "inputs",
              "description": "",
              "type": null,
              "value": null
            },
            {
              "name": "outputs",
              "description": "",
              "type": null,
              "value": null
            }
          ],
          "parameters": [
            {
              "name": "blocks",
              "type": null,
              "default": "None",
              "description": "internal blocks of the subsystem"
            },
            {
              "name": "connections",
              "type": null,
              "default": "None",
              "description": "internal connections of the subsystem"
            },
            {
              "name": "tolerance_fpi",
              "type": null,
              "default": "SIM_TOLERANCE_FPI",
              "description": "absolute tolerance for convergence of algebraic loops default see ´SIM_TOLERANCE_FPI´ in ´_constants.py´"
            },
            {
              "name": "iterations_max",
              "type": null,
              "default": "SIM_ITERATIONS_MAX",
              "description": "maximum allowed number of iterations for algebraic loop solver, default see ´SIM_ITERATIONS_MAX´ in ´_constants.py´"
            }
          ]
        }
      ],
      "functions": []
    },
    "pathsim.blocks._block": {
      "name": "pathsim.blocks._block",
      "description": "",
      "docstring_html": "",
      "classes": [
        {
          "name": "Block",
          "description": "Base 'Block' object that defines the inputs, outputs and the connect method.",
          "docstring_html": "<p>Base 'Block' object that defines the inputs, outputs and the connect method.</p>\n<p>Block interconnections are handeled via the io interface of the blocks.\nIt is realized by dicts for the 'inputs' and for the 'outputs', where the\nkey of the dict is the input/output channel and the corresponding value is\nthe input/output value.</p>\n<p>The block can spawn discrete events that are handled by the main simulation\nfor triggers, discrete time blocks, etc.</p>\n<p>Mathematically the block behavior is defined by two operators in most cases</p>\n<div class=\"math\">\n\\begin{equation*}\n\\begin{eqnarray}\n\\dot{x} &amp;= f_\\mathrm{dyn}(x, u, t)\\\\\n       y &amp;= f_\\mathrm{alg}(x, u, t)\n\\end{eqnarray}\n\\end{equation*}\n</div>\n<p>they are algebraic operators for the algebraic path of the block and for the\ndynamic path that feeds into the internal numerical integration engine.</p>\n<p>There are special cases where one or both of them are not defined, also for\npurely algebraic blocks such as multipliers and functions, there exists a\nsimplified operator definition:</p>\n<div class=\"math\">\n\\begin{equation*}\ny = f_\\mathrm{alg}(u)\n\\end{equation*}\n</div>\n<div class=\"section\" id=\"note\">\n<h4>Note</h4>\n<p>This block is not intended to be used directly and serves as a base\nclass definition for other blocks to be inherited.</p>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>inputs <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">Register</span></dt>\n<dd>input value register of block</dd>\n<dt>outputs <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">Register</span></dt>\n<dd>output value register of block</dd>\n<dt>engine <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">None | Solver</span></dt>\n<dd>numerical integrator instance</dd>\n<dt>events <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">list[Event]</span></dt>\n<dd>list of internal events, for mixed signal blocks</dd>\n<dt>_active <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>flag that sets the block active or inactive</dd>\n<dt>op_alg <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">Operator | DynamicOperator | None</span></dt>\n<dd>internal callable operator for algebraic components of block</dd>\n<dt>op_dyn <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">DynamicOperator | None</span></dt>\n<dd>internal callable operator for dynamic (ODE) components of block</dd>\n<dt>_n_in_max <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int | None</span></dt>\n<dd>maximum number of allowed input ports, None -&gt; infinite</dd>\n<dt>_n_out_max <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int | None</span></dt>\n<dd>maximum number of allowed output ports, None -&gt; infinite</dd>\n<dt>_port_map_in <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">dict[str: int] | None</span></dt>\n<dd>string aliases for input port numbers to be referenced in\nconnections or for internal use</dd>\n<dt>_port_map_out <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">dict[str: int] | None</span></dt>\n<dd>string aliases for output port numbers to be referenced in\nconnections or for internal use</dd>\n</dl>\n</div>\n",
          "source": "class Block(Serializable):\n    \"\"\"Base 'Block' object that defines the inputs, outputs and the connect method.\n\n    Block interconnections are handeled via the io interface of the blocks. \n    It is realized by dicts for the 'inputs' and for the 'outputs', where the \n    key of the dict is the input/output channel and the corresponding value is \n    the input/output value. \n\n    The block can spawn discrete events that are handled by the main simulation \n    for triggers, discrete time blocks, etc.\n\n    Mathematically the block behavior is defined by two operators in most cases\n\n    .. math::\n\n        \\\\begin{eqnarray}\n        \\\\dot{x} &= f_\\\\mathrm{dyn}(x, u, t)\\\\\\\\\n               y &= f_\\\\mathrm{alg}(x, u, t)\n        \\\\end{eqnarray}\n\n\n    they are algebraic operators for the algebraic path of the block and for the \n    dynamic path that feeds into the internal numerical integration engine.\n\n    There are special cases where one or both of them are not defined, also for \n    purely algebraic blocks such as multipliers and functions, there exists a \n    simplified operator definition:\n\n    .. math::\n\n        y = f_\\\\mathrm{alg}(u)\n\n\n    Note\n    ----\n    This block is not intended to be used directly and serves as a base \n    class definition for other blocks to be inherited.\n\n\n    Attributes\n    ----------\n    inputs : Register\n        input value register of block\n    outputs : Register\n        output value register of block\n    engine : None | Solver\n        numerical integrator instance\n    events : list[Event]\n        list of internal events, for mixed signal blocks\n    _active : bool\n        flag that sets the block active or inactive\n    op_alg : Operator | DynamicOperator | None\n        internal callable operator for algebraic components of block\n    op_dyn : DynamicOperator | None\n        internal callable operator for dynamic (ODE) components of block\n    _n_in_max : int | None\n        maximum number of allowed input ports, None -> infinite\n    _n_out_max : int | None\n        maximum number of allowed output ports, None -> infinite\n    _port_map_in : dict[str: int] | None\n        string aliases for input port numbers to be referenced in \n        connections or for internal use\n    _port_map_out : dict[str: int] | None\n        string aliases for output port numbers to be referenced in \n        connections or for internal use\n    \"\"\"\n\n    #number of max input and output ports\n    _n_in_max = None\n    _n_out_max = None\n\n    #maps for input and output port labels to indices\n    _port_map_in = None\n    _port_map_out = None\n\n    def __init__(self):\n\n        #default register sizes\n        _n_in = 1 if self._n_in_max is None else self._n_in_max\n        _n_out = 1 if self._n_out_max is None else self._n_out_max\n\n        #registers to hold input and output values\n        self.inputs = Register(size=_n_in, mapping=self._port_map_in)\n        self.outputs = Register(size=_n_out, mapping=self._port_map_out)\n\n        #initialize integration engine as 'None' by default\n        self.engine = None\n\n        #flag to set block active\n        self._active = True\n\n        #internal discrete events (for mixed signal blocks)\n        self.events = []\n\n        #operators for algebraic and dynamic components\n        self.op_alg = None\n        self.op_dyn = None\n\n\n    def __len__(self):\n        \"\"\"The '__len__' method of the block is used to compute the length of the \n        algebraic path of the block. \n\n        For instant time blocks or blocks with purely algenbraic components \n        (adders, amplifiers, etc.) it returns 1, otherwise (integrator, delay, etc.) \n        it returns 0.\n\n        If the block is disabled '_active == False', it returns 0 as well, since\n        this breaks the signal path.\n\n        Returns\n        -------\n        len : int\n            length of the algebraic path of the block\n        \"\"\"\n        return 1 if self._active else 0\n\n\n    def __getitem__(self, key):\n        \"\"\"The '__getitem__' method is intended to make connection creation more \n        convenient and therefore just returns the block itself and the key directly \n        after doing some basic checks.\n\n        Parameters\n        ----------\n        key : int, str, slice, tuple[int, str], list[int, str]\n            port indices or port names, or list / tuple of them\n\n        Returns\n        -------\n        PortReference\n            container object that hold block reference and list of ports\n        \"\"\"\n\n        if isinstance(key, slice):\n\n            #slice validation\n            if key.stop is None: raise ValueError(\"Port slice cannot be open ended!\")\n            if key.stop == 0: raise ValueError(\"Port slice cannot end with 0!\")\n\n            #start, step handling\n            start = 0 if key.start is None else key.start\n            step  = 1 if key.step  is None else key.step\n\n            #build port list\n            ports = list(range(start, key.stop, step))\n            return PortReference(self, ports)\n\n        elif isinstance(key, (tuple, list)):\n\n            for k in key:\n\n                #port type validation\n                if not isinstance(k, (int, str)):\n                    raise ValueError(f\"Port '{k}' must be (int, str) but is '{type(k)}'!\")\n\n            #duplicate validation\n            if len(set(key)) < len(key):\n                raise ValueError(\"Ports cannot be duplicates!\")\n\n            return PortReference(self, list(key))\n\n        elif isinstance(key, (int, str)):\n\n            #standard key\n            return PortReference(self, [key])\n\n        else:\n            raise ValueError(f\"Port must be type (int, str, slice, tuple[int, str], list[int, str]) but is '{type(key)}'!\")\n\n\n    def __call__(self):\n        \"\"\"The '__call__' is an alias for the 'get_all' method.\"\"\"\n        return self.get_all()\n\n\n    def __bool__(self):\n        return self._active\n\n\n    # methods for access to metadata ----------------------------------------------------\n\n    def size(self):\n        \"\"\"Get size information from block, such as \n        number of internal states, etc.\n\n        Returns\n        -------\n        sizes : tuple[int]\n            size of block (default 1) and number \n            of internal states (from internal engine)\n        \"\"\"\n        nx = len(self.engine) if self.engine else 0\n        return 1, nx\n\n\n    def shape(self):\n        \"\"\"Get the number of input and output ports of the block\n\n        Returns\n        -------\n        shape : tuple[int]\n            number of input and output ports\n        \"\"\" \n        return len(self.inputs), len(self.outputs)\n\n\n    # methods for visualization ---------------------------------------------------------\n\n    def plot(self, *args, **kwargs):\n        \"\"\"Block specific visualization, enables plotting \n        access from the simulation level.\n\n        This gets primarily used by the visualization blocks \n        such as the 'Scope' and 'Spectrum'.\n\n        Parameters\n        ----------\n        args : tuple\n            args for the plot methods\n        kwargs : dict\n            kwargs for the plot method\n        \"\"\"\n        pass\n\n\n    # methods for simulation management -------------------------------------------------\n\n    def on(self):\n        \"\"\"Activate the block and all internal events, sets the boolean\n        evaluation flag to 'True'.\n        \"\"\"\n        self._active = True\n        for event in self.events: \n            event.on()\n\n\n    def off(self):\n        \"\"\"Deactivate the block and all internal events, sets the boolean \n        evaluation flag to 'False'. Also resets the block.\n        \"\"\"\n        self._active = False\n        for event in self.events: \n            event.off()\n        self.reset()  \n\n\n    def reset(self):\n        \"\"\"Reset the blocks inputs and outputs and also its internal solver, \n        if the block has a solver instance.\n        \"\"\"\n        #reset inputs and outputs\n        self.inputs.reset()\n        self.outputs.reset()\n\n        #reset engine if block has solver\n        if self.engine: self.engine.reset()\n\n        #reset operators if defined\n        if self.op_alg: self.op_alg.reset()\n        if self.op_dyn: self.op_dyn.reset()\n\n\n    def linearize(self, t):\n        \"\"\"Linearize the algebraic and dynamic components of the block.\n\n        This is done by linearizing the internal 'Operator' and 'DynamicOperator' \n        instances in the current system operating point. The operators create \n        1st order taylor approximations internally and use them on subsequent \n        calls after linarization.\n\n        Parameters\n        ----------\n        t : float \n            evaluation time\n        \"\"\"\n\n        #get current state\n        u, _, x = self.get_all()\n\n        #no engine -> stateless\n        if not self.engine:\n            #linearize only algebraic operator \n            if self.op_alg: self.op_alg.linearize(u)\n        else:\n            #linearize algebraic and dynamic operators\n            if self.op_alg: self.op_alg.linearize(x, u, t)\n            if self.op_dyn: self.op_dyn.linearize(x, u, t)\n\n\n    def delinearize(self):\n        \"\"\"Revert the linearization of the blocks algebraic and dynamic components.\n\n        This is resets the internal 'Operator' and 'DynamicOperator' instances, \n        deleting the linear surrogate model and using the original function for \n        subsequent calls.\n        \"\"\"\n        #reset algebraic and dynamic operators\n        if self.op_alg: self.op_alg.reset()\n        if self.op_dyn: self.op_dyn.reset()\n\n\n    # methods for blocks with discrete events -------------------------------------------\n\n    def get_events(self):\n        \"\"\"Return internal events of the block, for discrete time blocks \n        such as triggers / comparators, clocks, etc.\n\n        Returns\n        -------\n        events : list[Event]\n            internal events of the block\n        \"\"\"\n        return self.events\n\n\n    # methods for blocks with integration engines ---------------------------------------\n\n    def set_solver(self, Solver, **solver_args):\n        \"\"\"Initialize the numerical integration engine with local truncation error \n        tolerance if required.\n\n        If the block already has an integration engine, it is changed, \n        if it does not require an integration engine, this method just passes.\n\n        Parameters\n        ----------\n        Solver : Solver\n            numerical integrator\n        solver_args : dict\n            additional args for the solver\n        \"\"\"\n        pass\n\n\n    def revert(self):\n        \"\"\"Revert the block to the state of the previous timestep, if the \n        block has a solver instance indicated by the 'has_engine' flag.\n\n        This is required for adaptive solvers to revert the state to the \n        previous timestep.\n        \"\"\"\n        if self.engine: self.engine.revert()\n\n\n    def buffer(self, dt):\n        \"\"\"\n        Buffer current internal state of the block and the current timestep\n        if the block has a solver instance (is stateful).\n\n        This is required for multistage, multistep and adaptive integrators.\n\n        Parameters\n        ----------\n        dt : float\n            integration timestep\n        \"\"\"\n        if self.engine: self.engine.buffer(dt)\n\n\n    # methods for sampling data ---------------------------------------------------------\n\n    def sample(self, t):\n        \"\"\"Samples the data of the blocks inputs or internal state when called. \n\n        This can record block parameters after a succesful timestep such as \n        for the 'Scope' and 'Delay' blocks but also for sampling from a random \n        distribution in the 'RNG' and the noise blocks.\n\n        Parameters\n        ----------\n        t : float\n            evaluation time for sampling\n        \"\"\"\n        pass\n\n\n    # methods for inter-block data transfer ---------------------------------------------\n\n    def get_all(self):\n        \"\"\"Retrieves and returns internal states of engine (if available) \n        and the block inputs and outputs as arrays for use outside. \n\n        Either for monitoring, postprocessing or event detection. \n        In any case this enables easy access to the current block state.\n\n        Returns\n        -------\n        inputs : array\n            block input register\n        outputs : array\n            block output register\n        states : array\n            internal states of the block\n        \"\"\"\n        _inputs  = self.inputs.to_array()\n        _outputs = self.outputs.to_array()\n        _states  = self.engine.get() if self.engine else []\n        return _inputs, _outputs, _states\n\n\n    # methods for block output and state updates ----------------------------------------\n\n    def update(self, t):\n        \"\"\"The 'update' method is called iteratively for all blocks to evaluate the \n        algbebraic components of the global system ode from the DAG. \n\n        It is meant for instant time blocks (blocks that dont have a delay due to the \n        timestep, such as Amplifier, etc.) and updates the 'outputs' of the block \n        directly based on the 'inputs' and possibly internal states. \n\n        Note\n        ----\n        The implementation of the 'update' method in the base 'Block' class is intended \n        as a fallback and is not performance optimized. Special blocks might reimplement \n        this method differently for higher performance, for example SISO or MISO blocks.\n\n        Parameters\n        ----------\n        t : float\n            evaluation time\n        \"\"\"\n\n        #no internal algebraic operator -> early exit\n        if self.op_alg is None:\n            return 0.0\n\n        #block inputs \n        u = self.inputs.to_array()\n\n        #no internal state -> standard 'Operator'\n        if self.engine: \n            x = self.engine.get()\n            y = self.op_alg(x, u, t)\n        else: \n            y = self.op_alg(u)           \n\n        #update register\n        self.outputs.update_from_array(y)\n\n\n    def solve(self, t, dt):\n        \"\"\"The 'solve' method performes one iterative solution step that is required \n        to solve the implicit update equation of the solver if an implicit solver \n        (numerical integrator) is used.\n\n        It returns the relative difference between the new updated solution \n        and the previous iteration of the solution to track convergence within \n        an outer loop.\n\n        This only has to be implemented by blocks that have an internal \n        integration engine with an implicit solver.\n\n        Parameters\n        ----------\n        t : float\n            evaluation time\n        dt : float\n            integration timestep\n\n        Returns\n        ------- \n        error : float\n            solver residual norm\n        \"\"\"\n        return 0.0 \n\n\n    def step(self, t, dt):\n        \"\"\"The 'step' method is used in transient simulations and performs an action \n        (numeric integration timestep, recording data, etc.) based on the current \n        inputs and the current internal state. \n\n        It performes one timestep for the internal states. For instant time blocks, \n        the 'step' method does not has to be implemented specifically. \n\n        The method handles timestepping for dynamic blocks with internal states\n        such as 'Integrator', 'StateSpace', etc.\n\n        Parameters\n        ----------\n        t : float\n            evaluation time\n        dt : float\n            integration timestep\n\n        Returns\n        ------- \n        success : bool\n            step was successful\n        error : float\n            local truncation error from adaptive integrators\n        scale : float\n            timestep rescale from adaptive integrators\n        \"\"\"\n\n        #by default no error estimate (error norm -> 0.0)\n        return True, 0.0, 1.0",
          "bases": [
            "pathsim.utils.serialization.Serializable"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self):\n\n    #default register sizes\n    _n_in = 1 if self._n_in_max is None else self._n_in_max\n    _n_out = 1 if self._n_out_max is None else self._n_out_max\n\n    #registers to hold input and output values\n    self.inputs = Register(size=_n_in, mapping=self._port_map_in)\n    self.outputs = Register(size=_n_out, mapping=self._port_map_out)\n\n    #initialize integration engine as 'None' by default\n    self.engine = None\n\n    #flag to set block active\n    self._active = True\n\n    #internal discrete events (for mixed signal blocks)\n    self.events = []\n\n    #operators for algebraic and dynamic components\n    self.op_alg = None\n    self.op_dyn = None",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "size",
              "description": "Get size information from block, such as",
              "docstring_html": "<p>Get size information from block, such as\nnumber of internal states, etc.</p>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>sizes <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">tuple[int]</span></dt>\n<dd>size of block (default 1) and number\nof internal states (from internal engine)</dd>\n</dl>\n",
              "source": "def size(self):\n    \"\"\"Get size information from block, such as \n    number of internal states, etc.\n\n    Returns\n    -------\n    sizes : tuple[int]\n        size of block (default 1) and number \n        of internal states (from internal engine)\n    \"\"\"\n    nx = len(self.engine) if self.engine else 0\n    return 1, nx",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "shape",
              "description": "Get the number of input and output ports of the block",
              "docstring_html": "<p>Get the number of input and output ports of the block</p>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>shape <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">tuple[int]</span></dt>\n<dd>number of input and output ports</dd>\n</dl>\n",
              "source": "def shape(self):\n    \"\"\"Get the number of input and output ports of the block\n\n    Returns\n    -------\n    shape : tuple[int]\n        number of input and output ports\n    \"\"\" \n    return len(self.inputs), len(self.outputs)",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "plot",
              "description": "Block specific visualization, enables plotting",
              "docstring_html": "<p>Block specific visualization, enables plotting\naccess from the simulation level.</p>\n<p>This gets primarily used by the visualization blocks\nsuch as the 'Scope' and 'Spectrum'.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>args <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">tuple</span></dt>\n<dd>args for the plot methods</dd>\n<dt>kwargs <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">dict</span></dt>\n<dd>kwargs for the plot method</dd>\n</dl>\n",
              "source": "def plot(self, *args, **kwargs):\n    \"\"\"Block specific visualization, enables plotting \n    access from the simulation level.\n\n    This gets primarily used by the visualization blocks \n    such as the 'Scope' and 'Spectrum'.\n\n    Parameters\n    ----------\n    args : tuple\n        args for the plot methods\n    kwargs : dict\n        kwargs for the plot method\n    \"\"\"\n    pass",
              "signature": "(args = (), kwargs = {})",
              "parameters": [
                {
                  "name": "args",
                  "type": null,
                  "default": "()",
                  "description": "args for the plot methods"
                },
                {
                  "name": "kwargs",
                  "type": null,
                  "default": "{}",
                  "description": "kwargs for the plot method"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "on",
              "description": "Activate the block and all internal events, sets the boolean",
              "docstring_html": "<p>Activate the block and all internal events, sets the boolean\nevaluation flag to 'True'.</p>\n",
              "source": "def on(self):\n    \"\"\"Activate the block and all internal events, sets the boolean\n    evaluation flag to 'True'.\n    \"\"\"\n    self._active = True\n    for event in self.events: \n        event.on()",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "off",
              "description": "Deactivate the block and all internal events, sets the boolean",
              "docstring_html": "<p>Deactivate the block and all internal events, sets the boolean\nevaluation flag to 'False'. Also resets the block.</p>\n",
              "source": "def off(self):\n    \"\"\"Deactivate the block and all internal events, sets the boolean \n    evaluation flag to 'False'. Also resets the block.\n    \"\"\"\n    self._active = False\n    for event in self.events: \n        event.off()\n    self.reset()",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "reset",
              "description": "Reset the blocks inputs and outputs and also its internal solver,",
              "docstring_html": "<p>Reset the blocks inputs and outputs and also its internal solver,\nif the block has a solver instance.</p>\n",
              "source": "def reset(self):\n    \"\"\"Reset the blocks inputs and outputs and also its internal solver, \n    if the block has a solver instance.\n    \"\"\"\n    #reset inputs and outputs\n    self.inputs.reset()\n    self.outputs.reset()\n\n    #reset engine if block has solver\n    if self.engine: self.engine.reset()\n\n    #reset operators if defined\n    if self.op_alg: self.op_alg.reset()\n    if self.op_dyn: self.op_dyn.reset()",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "linearize",
              "description": "Linearize the algebraic and dynamic components of the block.",
              "docstring_html": "<p>Linearize the algebraic and dynamic components of the block.</p>\n<p>This is done by linearizing the internal 'Operator' and 'DynamicOperator'\ninstances in the current system operating point. The operators create\n1st order taylor approximations internally and use them on subsequent\ncalls after linarization.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time</dd>\n</dl>\n",
              "source": "def linearize(self, t):\n    \"\"\"Linearize the algebraic and dynamic components of the block.\n\n    This is done by linearizing the internal 'Operator' and 'DynamicOperator' \n    instances in the current system operating point. The operators create \n    1st order taylor approximations internally and use them on subsequent \n    calls after linarization.\n\n    Parameters\n    ----------\n    t : float \n        evaluation time\n    \"\"\"\n\n    #get current state\n    u, _, x = self.get_all()\n\n    #no engine -> stateless\n    if not self.engine:\n        #linearize only algebraic operator \n        if self.op_alg: self.op_alg.linearize(u)\n    else:\n        #linearize algebraic and dynamic operators\n        if self.op_alg: self.op_alg.linearize(x, u, t)\n        if self.op_dyn: self.op_dyn.linearize(x, u, t)",
              "signature": "(t)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "delinearize",
              "description": "Revert the linearization of the blocks algebraic and dynamic components.",
              "docstring_html": "<p>Revert the linearization of the blocks algebraic and dynamic components.</p>\n<p>This is resets the internal 'Operator' and 'DynamicOperator' instances,\ndeleting the linear surrogate model and using the original function for\nsubsequent calls.</p>\n",
              "source": "def delinearize(self):\n    \"\"\"Revert the linearization of the blocks algebraic and dynamic components.\n\n    This is resets the internal 'Operator' and 'DynamicOperator' instances, \n    deleting the linear surrogate model and using the original function for \n    subsequent calls.\n    \"\"\"\n    #reset algebraic and dynamic operators\n    if self.op_alg: self.op_alg.reset()\n    if self.op_dyn: self.op_dyn.reset()",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "get_events",
              "description": "Return internal events of the block, for discrete time blocks",
              "docstring_html": "<p>Return internal events of the block, for discrete time blocks\nsuch as triggers / comparators, clocks, etc.</p>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>events <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">list[Event]</span></dt>\n<dd>internal events of the block</dd>\n</dl>\n",
              "source": "def get_events(self):\n    \"\"\"Return internal events of the block, for discrete time blocks \n    such as triggers / comparators, clocks, etc.\n\n    Returns\n    -------\n    events : list[Event]\n        internal events of the block\n    \"\"\"\n    return self.events",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "set_solver",
              "description": "Initialize the numerical integration engine with local truncation error",
              "docstring_html": "<p>Initialize the numerical integration engine with local truncation error\ntolerance if required.</p>\n<p>If the block already has an integration engine, it is changed,\nif it does not require an integration engine, this method just passes.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>Solver <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">Solver</span></dt>\n<dd>numerical integrator</dd>\n<dt>solver_args <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">dict</span></dt>\n<dd>additional args for the solver</dd>\n</dl>\n",
              "source": "def set_solver(self, Solver, **solver_args):\n    \"\"\"Initialize the numerical integration engine with local truncation error \n    tolerance if required.\n\n    If the block already has an integration engine, it is changed, \n    if it does not require an integration engine, this method just passes.\n\n    Parameters\n    ----------\n    Solver : Solver\n        numerical integrator\n    solver_args : dict\n        additional args for the solver\n    \"\"\"\n    pass",
              "signature": "(Solver, solver_args = {})",
              "parameters": [
                {
                  "name": "Solver",
                  "type": null,
                  "default": null,
                  "description": "numerical integrator"
                },
                {
                  "name": "solver_args",
                  "type": null,
                  "default": "{}",
                  "description": "additional args for the solver"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "revert",
              "description": "Revert the block to the state of the previous timestep, if the",
              "docstring_html": "<p>Revert the block to the state of the previous timestep, if the\nblock has a solver instance indicated by the 'has_engine' flag.</p>\n<p>This is required for adaptive solvers to revert the state to the\nprevious timestep.</p>\n",
              "source": "def revert(self):\n    \"\"\"Revert the block to the state of the previous timestep, if the \n    block has a solver instance indicated by the 'has_engine' flag.\n\n    This is required for adaptive solvers to revert the state to the \n    previous timestep.\n    \"\"\"\n    if self.engine: self.engine.revert()",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "buffer",
              "description": "Buffer current internal state of the block and the current timestep",
              "docstring_html": "<p>Buffer current internal state of the block and the current timestep\nif the block has a solver instance (is stateful).</p>\n<p>This is required for multistage, multistep and adaptive integrators.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>integration timestep</dd>\n</dl>\n",
              "source": "def buffer(self, dt):\n    \"\"\"\n    Buffer current internal state of the block and the current timestep\n    if the block has a solver instance (is stateful).\n\n    This is required for multistage, multistep and adaptive integrators.\n\n    Parameters\n    ----------\n    dt : float\n        integration timestep\n    \"\"\"\n    if self.engine: self.engine.buffer(dt)",
              "signature": "(dt)",
              "parameters": [
                {
                  "name": "dt",
                  "type": null,
                  "default": null,
                  "description": "integration timestep"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "sample",
              "description": "Samples the data of the blocks inputs or internal state when called.",
              "docstring_html": "<p>Samples the data of the blocks inputs or internal state when called.</p>\n<p>This can record block parameters after a succesful timestep such as\nfor the 'Scope' and 'Delay' blocks but also for sampling from a random\ndistribution in the 'RNG' and the noise blocks.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time for sampling</dd>\n</dl>\n",
              "source": "def sample(self, t):\n    \"\"\"Samples the data of the blocks inputs or internal state when called. \n\n    This can record block parameters after a succesful timestep such as \n    for the 'Scope' and 'Delay' blocks but also for sampling from a random \n    distribution in the 'RNG' and the noise blocks.\n\n    Parameters\n    ----------\n    t : float\n        evaluation time for sampling\n    \"\"\"\n    pass",
              "signature": "(t)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time for sampling"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "get_all",
              "description": "Retrieves and returns internal states of engine (if available)",
              "docstring_html": "<p>Retrieves and returns internal states of engine (if available)\nand the block inputs and outputs as arrays for use outside.</p>\n<p>Either for monitoring, postprocessing or event detection.\nIn any case this enables easy access to the current block state.</p>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>inputs <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array</span></dt>\n<dd>block input register</dd>\n<dt>outputs <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array</span></dt>\n<dd>block output register</dd>\n<dt>states <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array</span></dt>\n<dd>internal states of the block</dd>\n</dl>\n",
              "source": "def get_all(self):\n    \"\"\"Retrieves and returns internal states of engine (if available) \n    and the block inputs and outputs as arrays for use outside. \n\n    Either for monitoring, postprocessing or event detection. \n    In any case this enables easy access to the current block state.\n\n    Returns\n    -------\n    inputs : array\n        block input register\n    outputs : array\n        block output register\n    states : array\n        internal states of the block\n    \"\"\"\n    _inputs  = self.inputs.to_array()\n    _outputs = self.outputs.to_array()\n    _states  = self.engine.get() if self.engine else []\n    return _inputs, _outputs, _states",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "update",
              "description": "The 'update' method is called iteratively for all blocks to evaluate the",
              "docstring_html": "<p>The 'update' method is called iteratively for all blocks to evaluate the\nalgbebraic components of the global system ode from the DAG.</p>\n<p>It is meant for instant time blocks (blocks that dont have a delay due to the\ntimestep, such as Amplifier, etc.) and updates the 'outputs' of the block\ndirectly based on the 'inputs' and possibly internal states.</p>\n<div class=\"section\" id=\"note\">\n<h4>Note</h4>\n<p>The implementation of the 'update' method in the base 'Block' class is intended\nas a fallback and is not performance optimized. Special blocks might reimplement\nthis method differently for higher performance, for example SISO or MISO blocks.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time</dd>\n</dl>\n</div>\n",
              "source": "def update(self, t):\n    \"\"\"The 'update' method is called iteratively for all blocks to evaluate the \n    algbebraic components of the global system ode from the DAG. \n\n    It is meant for instant time blocks (blocks that dont have a delay due to the \n    timestep, such as Amplifier, etc.) and updates the 'outputs' of the block \n    directly based on the 'inputs' and possibly internal states. \n\n    Note\n    ----\n    The implementation of the 'update' method in the base 'Block' class is intended \n    as a fallback and is not performance optimized. Special blocks might reimplement \n    this method differently for higher performance, for example SISO or MISO blocks.\n\n    Parameters\n    ----------\n    t : float\n        evaluation time\n    \"\"\"\n\n    #no internal algebraic operator -> early exit\n    if self.op_alg is None:\n        return 0.0\n\n    #block inputs \n    u = self.inputs.to_array()\n\n    #no internal state -> standard 'Operator'\n    if self.engine: \n        x = self.engine.get()\n        y = self.op_alg(x, u, t)\n    else: \n        y = self.op_alg(u)           \n\n    #update register\n    self.outputs.update_from_array(y)",
              "signature": "(t)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "solve",
              "description": "The 'solve' method performes one iterative solution step that is required",
              "docstring_html": "<p>The 'solve' method performes one iterative solution step that is required\nto solve the implicit update equation of the solver if an implicit solver\n(numerical integrator) is used.</p>\n<p>It returns the relative difference between the new updated solution\nand the previous iteration of the solution to track convergence within\nan outer loop.</p>\n<p>This only has to be implemented by blocks that have an internal\nintegration engine with an implicit solver.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time</dd>\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>integration timestep</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>error <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>solver residual norm</dd>\n</dl>\n",
              "source": "def solve(self, t, dt):\n    \"\"\"The 'solve' method performes one iterative solution step that is required \n    to solve the implicit update equation of the solver if an implicit solver \n    (numerical integrator) is used.\n\n    It returns the relative difference between the new updated solution \n    and the previous iteration of the solution to track convergence within \n    an outer loop.\n\n    This only has to be implemented by blocks that have an internal \n    integration engine with an implicit solver.\n\n    Parameters\n    ----------\n    t : float\n        evaluation time\n    dt : float\n        integration timestep\n\n    Returns\n    ------- \n    error : float\n        solver residual norm\n    \"\"\"\n    return 0.0",
              "signature": "(t, dt)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time"
                },
                {
                  "name": "dt",
                  "type": null,
                  "default": null,
                  "description": "integration timestep"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "step",
              "description": "The 'step' method is used in transient simulations and performs an action",
              "docstring_html": "<p>The 'step' method is used in transient simulations and performs an action\n(numeric integration timestep, recording data, etc.) based on the current\ninputs and the current internal state.</p>\n<p>It performes one timestep for the internal states. For instant time blocks,\nthe 'step' method does not has to be implemented specifically.</p>\n<p>The method handles timestepping for dynamic blocks with internal states\nsuch as 'Integrator', 'StateSpace', etc.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time</dd>\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>integration timestep</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>success <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>step was successful</dd>\n<dt>error <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>local truncation error from adaptive integrators</dd>\n<dt>scale <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>timestep rescale from adaptive integrators</dd>\n</dl>\n",
              "source": "def step(self, t, dt):\n    \"\"\"The 'step' method is used in transient simulations and performs an action \n    (numeric integration timestep, recording data, etc.) based on the current \n    inputs and the current internal state. \n\n    It performes one timestep for the internal states. For instant time blocks, \n    the 'step' method does not has to be implemented specifically. \n\n    The method handles timestepping for dynamic blocks with internal states\n    such as 'Integrator', 'StateSpace', etc.\n\n    Parameters\n    ----------\n    t : float\n        evaluation time\n    dt : float\n        integration timestep\n\n    Returns\n    ------- \n    success : bool\n        step was successful\n    error : float\n        local truncation error from adaptive integrators\n    scale : float\n        timestep rescale from adaptive integrators\n    \"\"\"\n\n    #by default no error estimate (error norm -> 0.0)\n    return True, 0.0, 1.0",
              "signature": "(t, dt)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time"
                },
                {
                  "name": "dt",
                  "type": null,
                  "default": null,
                  "description": "integration timestep"
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "_n_in_max",
              "description": "",
              "type": null,
              "value": "None"
            },
            {
              "name": "_n_out_max",
              "description": "",
              "type": null,
              "value": "None"
            },
            {
              "name": "_port_map_in",
              "description": "",
              "type": null,
              "value": "None"
            },
            {
              "name": "_port_map_out",
              "description": "",
              "type": null,
              "value": "None"
            },
            {
              "name": "inputs",
              "description": "",
              "type": null,
              "value": "Register(size=_n_in, mapping=(self._port_map_in))"
            },
            {
              "name": "outputs",
              "description": "",
              "type": null,
              "value": "Register(size=_n_out, mapping=(self._port_map_out))"
            },
            {
              "name": "engine",
              "description": "",
              "type": null,
              "value": "None"
            },
            {
              "name": "_active",
              "description": "",
              "type": null,
              "value": "True"
            },
            {
              "name": "events",
              "description": "",
              "type": null,
              "value": "[]"
            },
            {
              "name": "op_alg",
              "description": "",
              "type": null,
              "value": "None"
            },
            {
              "name": "op_dyn",
              "description": "",
              "type": null,
              "value": "None"
            }
          ],
          "parameters": []
        }
      ],
      "functions": []
    },
    "pathsim.blocks.adder": {
      "name": "pathsim.blocks.adder",
      "description": "",
      "docstring_html": "",
      "classes": [
        {
          "name": "Adder",
          "description": "Summs / adds up all input signals to a single output signal (MISO)",
          "docstring_html": "<p>Summs / adds up all input signals to a single output signal (MISO)</p>\n<p>This is how it works in the default case</p>\n<div class=\"math\">\n\\begin{equation*}\ny(t) = \\sum_i u_i(t)\n\\end{equation*}\n</div>\n<p>and like this when additional operations are defined</p>\n<div class=\"math\">\n\\begin{equation*}\ny(t) = \\sum_i \\mathrm{op}_i \\cdot u_i(t)\n\\end{equation*}\n</div>\n<div class=\"section\" id=\"example\">\n<h4>Example</h4>\n<p>This is the default initialization that just adds up all the inputs:</p>\n<pre class=\"code python literal-block\">\n<span class=\"n\">A</span> <span class=\"o\">=</span> <span class=\"n\">Adder</span><span class=\"p\">()</span>\n</pre>\n<p>and this is the initialization with specific operations that subtracts\nthe second from first input and neglects all others:</p>\n<pre class=\"code python literal-block\">\n<span class=\"n\">A</span> <span class=\"o\">=</span> <span class=\"n\">Adder</span><span class=\"p\">(</span><span class=\"s1\">'+-'</span><span class=\"p\">)</span>\n</pre>\n</div>\n<div class=\"section\" id=\"note\">\n<h4>Note</h4>\n<p>This block is purely algebraic and its operation (<cite>op_alg</cite>) will be called\nmultiple times per timestep, each time when <cite>Simulation._update(t)</cite> is\ncalled in the global simulation loop.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>operations <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">str, optional</span></dt>\n<dd>optional string of operations to be applied before\nsummation, i.e. '+-' will compute the difference,\n'None' will just perform regular sum</dd>\n</dl>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>_ops <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">dict</span></dt>\n<dd>dict that maps string operations to numerical</dd>\n<dt>_ops_array <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array_like</span></dt>\n<dd>operations converted to array</dd>\n<dt>op_alg <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">Operator</span></dt>\n<dd>internal algebraic operator</dd>\n</dl>\n</div>\n",
          "source": "class Adder(Block):\n    \"\"\"Summs / adds up all input signals to a single output signal (MISO)\n\n    This is how it works in the default case\n\n    .. math::\n\n        y(t) = \\\\sum_i u_i(t)\n\n    and like this when additional operations are defined\n\n    .. math::\n\n        y(t) = \\\\sum_i \\\\mathrm{op}_i \\\\cdot u_i(t)\n\n\n    Example\n    -------\n    This is the default initialization that just adds up all the inputs:\n\n    .. code-block:: python\n\n        A = Adder()\n\n    and this is the initialization with specific operations that subtracts \n    the second from first input and neglects all others:\n\n    .. code-block:: python\n\n        A = Adder('+-')\n\n\n    Note\n    ----\n    This block is purely algebraic and its operation (`op_alg`) will be called \n    multiple times per timestep, each time when `Simulation._update(t)` is \n    called in the global simulation loop.\n\n\n    Parameters\n    ----------\n    operations : str, optional\n        optional string of operations to be applied before \n        summation, i.e. '+-' will compute the difference, \n        'None' will just perform regular sum\n\n\n    Attributes\n    ----------\n    _ops : dict\n        dict that maps string operations to numerical\n    _ops_array : array_like\n        operations converted to array\n    op_alg : Operator\n        internal algebraic operator\n    \"\"\"\n\n    #max number of ports\n    _n_in_max = None\n    _n_out_max = 1\n\n    #maps for input and output port labels\n    _port_map_out = {\"out\": 0}\n\n    def __init__(self, operations=None):\n        super().__init__()\n\n        #allowed arithmetic operations\n        self._ops = {\"+\":1.0, \"-\":-1.0, \"0\":0.0}\n        self.operations = operations    \n\n        #are special operations defined?\n        if self.operations is None:\n\n            #create internal algebraic operator\n            self.op_alg = Operator(\n                func=sum, \n                jac=lambda x: np.ones_like(x)\n                )\n\n        else:\n\n            #input validation\n            if not isinstance(self.operations, str):\n                raise ValueError(\"'operations' must be string or 'None'\")\n            for op in self.operations:\n                if op not in self._ops:\n                    raise ValueError(f\"operation '{op}' not in {self._ops}\")\n\n            #construct array from operations\n            self._ops_array = np.array([self._ops[op] for op in self.operations])\n\n            def sum_ops(X):\n                return sum(x*op for x, op in zip(X, self._ops_array))\n            def jac_ops(X):\n                nx, no = len(X), len(self._ops_array)\n                if nx < no: return self._ops_array[:nx]\n                return np.pad(self._ops_array, nx-no, mode=\"constant\")\n\n            #create internal algebraic operator\n            self.op_alg = Operator(\n                func=sum_ops, \n                jac=jac_ops\n                )\n\n\n    def __len__(self):\n        \"\"\"Purely algebraic block\"\"\"\n        return 1\n\n\n    def update(self, t):\n        \"\"\"update system equation in fixed point loop for \n        algebraic loops, with optional error control\n\n        Parameters\n        ----------\n        t : float\n            evaluation time\n        \"\"\"\n        u = self.inputs.to_array()\n        y = self.op_alg(u)\n        self.outputs.update_from_array(y)",
          "bases": [
            "pathsim.blocks._block.Block"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, operations=None):\n    super().__init__()\n\n    #allowed arithmetic operations\n    self._ops = {\"+\":1.0, \"-\":-1.0, \"0\":0.0}\n    self.operations = operations    \n\n    #are special operations defined?\n    if self.operations is None:\n\n        #create internal algebraic operator\n        self.op_alg = Operator(\n            func=sum, \n            jac=lambda x: np.ones_like(x)\n            )\n\n    else:\n\n        #input validation\n        if not isinstance(self.operations, str):\n            raise ValueError(\"'operations' must be string or 'None'\")\n        for op in self.operations:\n            if op not in self._ops:\n                raise ValueError(f\"operation '{op}' not in {self._ops}\")\n\n        #construct array from operations\n        self._ops_array = np.array([self._ops[op] for op in self.operations])\n\n        def sum_ops(X):\n            return sum(x*op for x, op in zip(X, self._ops_array))\n        def jac_ops(X):\n            nx, no = len(X), len(self._ops_array)\n            if nx < no: return self._ops_array[:nx]\n            return np.pad(self._ops_array, nx-no, mode=\"constant\")\n\n        #create internal algebraic operator\n        self.op_alg = Operator(\n            func=sum_ops, \n            jac=jac_ops\n            )",
              "signature": "(operations = None)",
              "parameters": [
                {
                  "name": "operations",
                  "type": null,
                  "default": "None",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "update",
              "description": "update system equation in fixed point loop for",
              "docstring_html": "<p>update system equation in fixed point loop for\nalgebraic loops, with optional error control</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time</dd>\n</dl>\n",
              "source": "def update(self, t):\n    \"\"\"update system equation in fixed point loop for \n    algebraic loops, with optional error control\n\n    Parameters\n    ----------\n    t : float\n        evaluation time\n    \"\"\"\n    u = self.inputs.to_array()\n    y = self.op_alg(u)\n    self.outputs.update_from_array(y)",
              "signature": "(t)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time"
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "_n_in_max",
              "description": "",
              "type": null,
              "value": "None"
            },
            {
              "name": "_n_out_max",
              "description": "",
              "type": null,
              "value": "1"
            },
            {
              "name": "_port_map_out",
              "description": "",
              "type": null,
              "value": "{'out': 0}"
            },
            {
              "name": "_ops",
              "description": "",
              "type": null,
              "value": "{'+': 1.0, '-': -1.0, '0': 0.0}"
            },
            {
              "name": "operations",
              "description": "",
              "type": null,
              "value": "operations"
            },
            {
              "name": "op_alg",
              "description": "",
              "type": null,
              "value": "Operator(func=sum, jac=(lambda x: np.ones_like(x)))"
            },
            {
              "name": "_ops_array",
              "description": "",
              "type": null,
              "value": "np.array([(self._ops[op]) for op in (self.operations)])"
            }
          ],
          "parameters": [
            {
              "name": "operations",
              "type": null,
              "default": "None",
              "description": "optional string of operations to be applied before summation, i.e. '+-' will compute the difference, 'None' will just perform regular sum"
            }
          ]
        }
      ],
      "functions": []
    },
    "pathsim.blocks.amplifier": {
      "name": "pathsim.blocks.amplifier",
      "description": "",
      "docstring_html": "",
      "classes": [
        {
          "name": "Amplifier",
          "description": "Amplifies the input signal by",
          "docstring_html": "<p>Amplifies the input signal by\nmultiplication with a constant gain term like this:</p>\n<div class=\"math\">\n\\begin{equation*}\ny(t) = \\mathrm{gain} \\cdot u(t)\n\\end{equation*}\n</div>\n<div class=\"section\" id=\"note\">\n<h4>Note</h4>\n<p>This block is purely algebraic and its operation (<cite>op_alg</cite>) will be called\nmultiple times per timestep, each time when <cite>Simulation._update(t)</cite> is\ncalled in the global simulation loop.</p>\n</div>\n<div class=\"section\" id=\"example\">\n<h4>Example</h4>\n<p>The block is initialized like this:</p>\n<pre class=\"code python literal-block\">\n<span class=\"c1\">#amplification by factor 5</span><span class=\"w\">\n</span><span class=\"n\">A</span> <span class=\"o\">=</span> <span class=\"n\">Amplifier</span><span class=\"p\">(</span><span class=\"n\">gain</span><span class=\"o\">=</span><span class=\"mi\">5</span><span class=\"p\">)</span>\n</pre>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>gain <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>amplifier gain</dd>\n</dl>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>op_alg <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">Operator</span></dt>\n<dd>internal algebraic operator</dd>\n</dl>\n</div>\n",
          "source": "class Amplifier(Block):\n    \"\"\"Amplifies the input signal by \n    multiplication with a constant gain term like this:\n\n    .. math::\n\n        y(t) = \\\\mathrm{gain} \\\\cdot u(t)\n\n\n    Note\n    ----\n    This block is purely algebraic and its operation (`op_alg`) will be called \n    multiple times per timestep, each time when `Simulation._update(t)` is \n    called in the global simulation loop.\n\n\n    Example\n    -------\n    The block is initialized like this:\n\n    .. code-block:: python\n\n        #amplification by factor 5\n        A = Amplifier(gain=5)\n\n\n    Parameters\n    ----------\n    gain : float\n        amplifier gain\n\n\n    Attributes\n    ----------\n    op_alg : Operator\n        internal algebraic operator\n    \"\"\"\n\n    #max number of ports\n    _n_in_max = 1\n    _n_out_max = 1\n\n    #maps for input and output port labels\n    _port_map_in = {\"in\": 0}\n    _port_map_out = {\"out\": 0}\n\n    def __init__(self, gain=1.0):\n        super().__init__()\n        self.gain = gain\n\n        self.op_alg = Operator(\n            func=lambda x: x*self.gain, \n            jac=lambda x: self.gain\n            )\n\n\n    def update(self, t):\n        \"\"\"update system equation in fixed point loop\n\n        Parameters\n        ----------\n        t : float\n            evaluation time\n        \"\"\"\n        self.outputs[0] = self.op_alg(self.inputs[0])",
          "bases": [
            "pathsim.blocks._block.Block"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, gain=1.0):\n    super().__init__()\n    self.gain = gain\n\n    self.op_alg = Operator(\n        func=lambda x: x*self.gain, \n        jac=lambda x: self.gain\n        )",
              "signature": "(gain = 1.0)",
              "parameters": [
                {
                  "name": "gain",
                  "type": null,
                  "default": "1.0",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "update",
              "description": "update system equation in fixed point loop",
              "docstring_html": "<p>update system equation in fixed point loop</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time</dd>\n</dl>\n",
              "source": "def update(self, t):\n    \"\"\"update system equation in fixed point loop\n\n    Parameters\n    ----------\n    t : float\n        evaluation time\n    \"\"\"\n    self.outputs[0] = self.op_alg(self.inputs[0])",
              "signature": "(t)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time"
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "_n_in_max",
              "description": "",
              "type": null,
              "value": "1"
            },
            {
              "name": "_n_out_max",
              "description": "",
              "type": null,
              "value": "1"
            },
            {
              "name": "_port_map_in",
              "description": "",
              "type": null,
              "value": "{'in': 0}"
            },
            {
              "name": "_port_map_out",
              "description": "",
              "type": null,
              "value": "{'out': 0}"
            },
            {
              "name": "gain",
              "description": "",
              "type": null,
              "value": "gain"
            },
            {
              "name": "op_alg",
              "description": "",
              "type": null,
              "value": "Operator(func=(lambda x: x * self.gain), jac=(lambda x: self.gain))"
            }
          ],
          "parameters": [
            {
              "name": "gain",
              "type": null,
              "default": "1.0",
              "description": "amplifier gain"
            }
          ]
        }
      ],
      "functions": []
    },
    "pathsim.blocks.comparator": {
      "name": "pathsim.blocks.comparator",
      "description": "",
      "docstring_html": "",
      "classes": [
        {
          "name": "Comparator",
          "description": "Comparator block that sets the output to '1' it the input",
          "docstring_html": "<p>Comparator block that sets the output to '1' it the input\nsignal crosses a predefined threshold and to '-1' if it\ncrosses in the reverse direction.</p>\n<p>This is realized by the block spawning a zero-crossing\nevent detector that watches the input of the block and\nlocates the transition up to a tolerance.</p>\n<p>The block output is determined by a simple sign check in\nthe 'update' method.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>threshold <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>threshold value for the comparator</dd>\n<dt>tolerance <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>tolerance for zero crossing detection</dd>\n<dt>span <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">list[float] or tuple[float], optional</span></dt>\n<dd>output value range [min, max]</dd>\n</dl>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>events <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">list[ZeroCrossing]</span></dt>\n<dd>internal zero crossing event</dd>\n</dl>\n",
          "source": "class Comparator(Block):\n    \"\"\"Comparator block that sets the output to '1' it the input \n    signal crosses a predefined threshold and to '-1' if it \n    crosses in the reverse direction. \n\n    This is realized by the block spawning a zero-crossing \n    event detector that watches the input of the block and \n    locates the transition up to a tolerance. \n\n    The block output is determined by a simple sign check in\n    the 'update' method.\n\n    Parameters\n    ----------\n    threshold : float\n        threshold value for the comparator\n    tolerance : float\n        tolerance for zero crossing detection    \n    span : list[float] or tuple[float], optional\n        output value range [min, max]\n\n    Attributes\n    ----------\n    events : list[ZeroCrossing]\n        internal zero crossing event\n    \"\"\"\n\n    #max number of ports\n    _n_in_max = 1\n    _n_out_max = 1\n\n    #maps for input and output port labels\n    _port_map_in = {\"in\": 0}\n    _port_map_out = {\"out\": 0}\n\n    def __init__(self, threshold=0, tolerance=1e-4, span=[-1, 1]):\n        super().__init__()\n\n        self.threshold = threshold\n        self.tolerance = tolerance\n        self.span = span\n\n        def func_evt(t):\n            return self.inputs[0] - self.threshold\n\n        #internal event for transition detection\n        self.events = [\n            ZeroCrossing(\n                func_evt=func_evt, \n                tolerance=tolerance\n                )\n            ]\n\n\n    def update(self, t):\n        \"\"\"update system equation for fixed point loop, \n        here just setting the outputs\n\n        Note\n        ----\n        no direct passthrough, so the 'update' method \n        is optimized for this case        \n\n        Parameters\n        ----------\n        t : float\n            evaluation time\n\n        Returns\n        -------\n        error : float\n            absolute error to previous iteration for convergence \n            control (here '0.0' because discrete block)\n        \"\"\"\n\n        if self.inputs[0] >= self.threshold:\n            self.outputs[0] = max(self.span)\n        else:\n            self.outputs[0] = min(self.span)",
          "bases": [
            "pathsim.blocks._block.Block"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, threshold=0, tolerance=1e-4, span=[-1, 1]):\n    super().__init__()\n\n    self.threshold = threshold\n    self.tolerance = tolerance\n    self.span = span\n\n    def func_evt(t):\n        return self.inputs[0] - self.threshold\n\n    #internal event for transition detection\n    self.events = [\n        ZeroCrossing(\n            func_evt=func_evt, \n            tolerance=tolerance\n            )\n        ]",
              "signature": "(threshold = 0, tolerance = 0.0001, span = [-1, 1])",
              "parameters": [
                {
                  "name": "threshold",
                  "type": null,
                  "default": "0",
                  "description": ""
                },
                {
                  "name": "tolerance",
                  "type": null,
                  "default": "0.0001",
                  "description": ""
                },
                {
                  "name": "span",
                  "type": null,
                  "default": "[-1, 1]",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "update",
              "description": "update system equation for fixed point loop,",
              "docstring_html": "<p>update system equation for fixed point loop,\nhere just setting the outputs</p>\n<div class=\"section\" id=\"note\">\n<h4>Note</h4>\n<p>no direct passthrough, so the 'update' method\nis optimized for this case</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>error <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>absolute error to previous iteration for convergence\ncontrol (here '0.0' because discrete block)</dd>\n</dl>\n</div>\n",
              "source": "def update(self, t):\n    \"\"\"update system equation for fixed point loop, \n    here just setting the outputs\n\n    Note\n    ----\n    no direct passthrough, so the 'update' method \n    is optimized for this case        \n\n    Parameters\n    ----------\n    t : float\n        evaluation time\n\n    Returns\n    -------\n    error : float\n        absolute error to previous iteration for convergence \n        control (here '0.0' because discrete block)\n    \"\"\"\n\n    if self.inputs[0] >= self.threshold:\n        self.outputs[0] = max(self.span)\n    else:\n        self.outputs[0] = min(self.span)",
              "signature": "(t)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time"
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "_n_in_max",
              "description": "",
              "type": null,
              "value": "1"
            },
            {
              "name": "_n_out_max",
              "description": "",
              "type": null,
              "value": "1"
            },
            {
              "name": "_port_map_in",
              "description": "",
              "type": null,
              "value": "{'in': 0}"
            },
            {
              "name": "_port_map_out",
              "description": "",
              "type": null,
              "value": "{'out': 0}"
            },
            {
              "name": "threshold",
              "description": "",
              "type": null,
              "value": "threshold"
            },
            {
              "name": "tolerance",
              "description": "",
              "type": null,
              "value": "tolerance"
            },
            {
              "name": "span",
              "description": "",
              "type": null,
              "value": "span"
            },
            {
              "name": "events",
              "description": "",
              "type": null,
              "value": "[ZeroCrossing(func_evt=func_evt, tolerance=tolerance)]"
            }
          ],
          "parameters": [
            {
              "name": "threshold",
              "type": null,
              "default": "0",
              "description": "threshold value for the comparator"
            },
            {
              "name": "tolerance",
              "type": null,
              "default": "0.0001",
              "description": "tolerance for zero crossing detection"
            },
            {
              "name": "span",
              "type": null,
              "default": "[-1, 1]",
              "description": "output value range [min, max]"
            }
          ]
        }
      ],
      "functions": []
    },
    "pathsim.blocks.converters": {
      "name": "pathsim.blocks.converters",
      "description": "",
      "docstring_html": "",
      "classes": [
        {
          "name": "ADC",
          "description": "Models an ideal Analog-to-Digital Converter (ADC).",
          "docstring_html": "<p>Models an ideal Analog-to-Digital Converter (ADC).</p>\n<p>This block samples an analog input signal periodically, quantizes it\naccording to the specified number of bits and input span, and outputs\nthe resulting digital code on multiple output ports. The sampling\nis triggered by a scheduled event.</p>\n<p>Functionality:</p>\n<ol class=\"arabic simple\">\n<li>Samples the analog input <cite>inputs[0]</cite> at intervals of <cite>T</cite>, starting after delay <cite>tau</cite>.</li>\n<li>Clips the input voltage to the defined <cite>span</cite> [min_voltage, max_voltage].</li>\n<li>Scales the clipped voltage to the range [0, 1].</li>\n<li>Quantizes the scaled value to an integer code between 0 and 2^n_bits - 1 using flooring.</li>\n<li>Converts the integer code to an n_bits binary representation.</li>\n<li>Outputs the binary code on ports 0 (LSB) to n_bits-1 (MSB).</li>\n</ol>\n<p>Ideal characteristics:</p>\n<ul class=\"simple\">\n<li>Instantaneous sampling at scheduled times.</li>\n<li>Perfect, noise-free quantization.</li>\n<li>No aperture jitter or other dynamic errors.</li>\n</ul>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>n_bits <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int, optional</span></dt>\n<dd>Number of bits for the digital output code. Default is 4.</dd>\n<dt>span <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">list[float] or tuple[float], optional</span></dt>\n<dd>The valid analog input value range [min_voltage, max_voltage].\nInputs outside this range will be clipped. Default is [-1, 1].</dd>\n<dt>T <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float, optional</span></dt>\n<dd>Sampling period (time between samples). Default is 1 time unit.</dd>\n<dt>tau <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float, optional</span></dt>\n<dd>Initial delay before the first sample is taken. Default is 0.</dd>\n</dl>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>events <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">list[Schedule]</span></dt>\n<dd>Internal scheduled event responsible for periodic sampling and conversion.</dd>\n</dl>\n",
          "source": "class ADC(Block):\n    \"\"\"Models an ideal Analog-to-Digital Converter (ADC).\n\n    This block samples an analog input signal periodically, quantizes it\n    according to the specified number of bits and input span, and outputs\n    the resulting digital code on multiple output ports. The sampling\n    is triggered by a scheduled event.\n\n    Functionality:\n\n    1. Samples the analog input `inputs[0]` at intervals of `T`, starting after delay `tau`.\n    2. Clips the input voltage to the defined `span` [min_voltage, max_voltage].\n    3. Scales the clipped voltage to the range [0, 1].\n    4. Quantizes the scaled value to an integer code between 0 and 2^n_bits - 1 using flooring.\n    5. Converts the integer code to an n_bits binary representation.\n    6. Outputs the binary code on ports 0 (LSB) to n_bits-1 (MSB).\n\n    Ideal characteristics:\n\n    - Instantaneous sampling at scheduled times.\n    - Perfect, noise-free quantization.\n    - No aperture jitter or other dynamic errors.\n\n\n    Parameters\n    ----------\n    n_bits : int, optional\n        Number of bits for the digital output code. Default is 4.\n    span : list[float] or tuple[float], optional\n        The valid analog input value range [min_voltage, max_voltage].\n        Inputs outside this range will be clipped. Default is [-1, 1].\n    T : float, optional\n        Sampling period (time between samples). Default is 1 time unit.\n    tau : float, optional\n        Initial delay before the first sample is taken. Default is 0.\n\n\n    Attributes\n    ----------\n    events : list[Schedule]\n        Internal scheduled event responsible for periodic sampling and conversion.\n    \"\"\"\n\n    #max number of ports\n    _n_in_max = 1\n    _n_out_max = None\n\n    #maps for input and output port labels\n    _port_map_in = {\"in\": 0}\n\n    def __init__(self, n_bits=4, span=[-1, 1], T=1, tau=0):\n        super().__init__()\n\n        self.n_bits = n_bits\n        self.span = span\n        self.T = T\n        self.tau = tau\n\n        #port alias map\n        self._port_map_out = {f\"b{self.n_bits-n}\":n for n in range(self.n_bits)}\n\n        #initialize outputs to have 'n_bits' ports\n        self.outputs = Register(size=self.n_bits, mapping=self._port_map_out)\n\n        def _sample(t):\n\n            #clip and scale to ADC span\n            lower, upper = self.span\n            analog_in = self.inputs[0]\n\n            clipped_val = np.clip(analog_in, lower, upper)\n            scaled_val = (clipped_val - lower) / (upper - lower)\n            int_val = np.floor(scaled_val * (2**self.n_bits))\n            int_val = min(int_val, 2**self.n_bits - 1)\n\n            #convert to bits\n            bits = format(int(int_val), \"b\").zfill(self.n_bits)\n\n            #set bits to block outputs LSB -> MSB\n            for i, b in enumerate(bits):\n                self.outputs[self.n_bits-1-i] = int(b)\n\n        #internal scheduled events\n        self.events = [\n            Schedule(\n                t_start=tau,\n                t_period=T,\n                func_act=_sample\n                ),\n            ]\n\n\n    def __len__(self):\n        \"\"\"This block has no direct passthrough\"\"\"\n        return 0",
          "bases": [
            "pathsim.blocks._block.Block"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, n_bits=4, span=[-1, 1], T=1, tau=0):\n    super().__init__()\n\n    self.n_bits = n_bits\n    self.span = span\n    self.T = T\n    self.tau = tau\n\n    #port alias map\n    self._port_map_out = {f\"b{self.n_bits-n}\":n for n in range(self.n_bits)}\n\n    #initialize outputs to have 'n_bits' ports\n    self.outputs = Register(size=self.n_bits, mapping=self._port_map_out)\n\n    def _sample(t):\n\n        #clip and scale to ADC span\n        lower, upper = self.span\n        analog_in = self.inputs[0]\n\n        clipped_val = np.clip(analog_in, lower, upper)\n        scaled_val = (clipped_val - lower) / (upper - lower)\n        int_val = np.floor(scaled_val * (2**self.n_bits))\n        int_val = min(int_val, 2**self.n_bits - 1)\n\n        #convert to bits\n        bits = format(int(int_val), \"b\").zfill(self.n_bits)\n\n        #set bits to block outputs LSB -> MSB\n        for i, b in enumerate(bits):\n            self.outputs[self.n_bits-1-i] = int(b)\n\n    #internal scheduled events\n    self.events = [\n        Schedule(\n            t_start=tau,\n            t_period=T,\n            func_act=_sample\n            ),\n        ]",
              "signature": "(n_bits = 4, span = [-1, 1], T = 1, tau = 0)",
              "parameters": [
                {
                  "name": "n_bits",
                  "type": null,
                  "default": "4",
                  "description": ""
                },
                {
                  "name": "span",
                  "type": null,
                  "default": "[-1, 1]",
                  "description": ""
                },
                {
                  "name": "T",
                  "type": null,
                  "default": "1",
                  "description": ""
                },
                {
                  "name": "tau",
                  "type": null,
                  "default": "0",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "_n_in_max",
              "description": "",
              "type": null,
              "value": "1"
            },
            {
              "name": "_n_out_max",
              "description": "",
              "type": null,
              "value": "None"
            },
            {
              "name": "_port_map_in",
              "description": "",
              "type": null,
              "value": "{'in': 0}"
            },
            {
              "name": "n_bits",
              "description": "",
              "type": null,
              "value": "n_bits"
            },
            {
              "name": "span",
              "description": "",
              "type": null,
              "value": "span"
            },
            {
              "name": "T",
              "description": "",
              "type": null,
              "value": "T"
            },
            {
              "name": "tau",
              "description": "",
              "type": null,
              "value": "tau"
            },
            {
              "name": "_port_map_out",
              "description": "",
              "type": null,
              "value": "{f'b{self.n_bits - n}': n for n in (range(self.n_bits))}"
            },
            {
              "name": "outputs",
              "description": "",
              "type": null,
              "value": "Register(size=(self.n_bits), mapping=(self._port_map_out))"
            },
            {
              "name": "events",
              "description": "",
              "type": null,
              "value": "[Schedule(t_start=tau, t_period=T, func_act=_sample)]"
            }
          ],
          "parameters": [
            {
              "name": "n_bits",
              "type": null,
              "default": "4",
              "description": "Number of bits for the digital output code. Default is 4."
            },
            {
              "name": "span",
              "type": null,
              "default": "[-1, 1]",
              "description": "The valid analog input value range [min_voltage, max_voltage]. Inputs outside this range will be clipped. Default is [-1, 1]."
            },
            {
              "name": "T",
              "type": null,
              "default": "1",
              "description": "Sampling period (time between samples). Default is 1 time unit."
            },
            {
              "name": "tau",
              "type": null,
              "default": "0",
              "description": "Initial delay before the first sample is taken. Default is 0."
            }
          ]
        },
        {
          "name": "DAC",
          "description": "Models an ideal Digital-to-Analog Converter (DAC).",
          "docstring_html": "<p>Models an ideal Digital-to-Analog Converter (DAC).</p>\n<p>This block reads a digital input code periodically from its input ports,\nreconstructs the corresponding analog value based on the number of bits\nand output span, and holds the output constant between updates. The update\nis triggered by a scheduled event.</p>\n<p>Functionality:</p>\n<ol class=\"arabic simple\">\n<li>Reads the digital code from input ports 0 (LSB) to n_bits-1 (MSB) at intervals of <cite>T</cite>, starting after delay <cite>tau</cite>.</li>\n<li>Interprets the inputs as an unsigned binary integer code.</li>\n<li>Converts the integer code to a fractional value between 0 and (2^n_bits - 1) / 2^n_bits.</li>\n<li>Scales this fractional value to the specified analog output <cite>span</cite>.</li>\n<li>Outputs the resulting analog value on <cite>outputs[0]</cite>.</li>\n<li>Holds the output value constant until the next scheduled update.</li>\n</ol>\n<p>Ideal characteristics:</p>\n<ul class=\"simple\">\n<li>Instantaneous update at scheduled times.</li>\n<li>Perfect, noise-free reconstruction.</li>\n<li>No glitches or settling time.</li>\n</ul>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>n_bits <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int, optional</span></dt>\n<dd>Number of digital input bits expected. Default is 4.</dd>\n<dt>span <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">list[float] or tuple[float], optional</span></dt>\n<dd>The analog output value range [min_voltage, max_voltage] corresponding\nto the digital codes 0 and 2^n_bits - 1, respectively (approximately).\nDefault is [-1, 1].</dd>\n<dt>T <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float, optional</span></dt>\n<dd>Update period (time between output updates). Default is 1 time unit.</dd>\n<dt>tau <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float, optional</span></dt>\n<dd>Initial delay before the first output update. Default is 0.</dd>\n</dl>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>events <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">list[Schedule]</span></dt>\n<dd>Internal scheduled event responsible for periodic updates.</dd>\n</dl>\n",
          "source": "class DAC(Block):\n    \"\"\"Models an ideal Digital-to-Analog Converter (DAC).\n\n    This block reads a digital input code periodically from its input ports,\n    reconstructs the corresponding analog value based on the number of bits\n    and output span, and holds the output constant between updates. The update\n    is triggered by a scheduled event.\n\n    Functionality:\n\n    1. Reads the digital code from input ports 0 (LSB) to n_bits-1 (MSB) at intervals of `T`, starting after delay `tau`.\n    2. Interprets the inputs as an unsigned binary integer code.\n    3. Converts the integer code to a fractional value between 0 and (2^n_bits - 1) / 2^n_bits.\n    4. Scales this fractional value to the specified analog output `span`.\n    5. Outputs the resulting analog value on `outputs[0]`.\n    6. Holds the output value constant until the next scheduled update.\n\n    Ideal characteristics:\n\n    - Instantaneous update at scheduled times.\n    - Perfect, noise-free reconstruction.\n    - No glitches or settling time.\n\n\n    Parameters\n    ----------\n    n_bits : int, optional\n        Number of digital input bits expected. Default is 4.\n    span : list[float] or tuple[float], optional\n        The analog output value range [min_voltage, max_voltage] corresponding\n        to the digital codes 0 and 2^n_bits - 1, respectively (approximately).\n        Default is [-1, 1].\n    T : float, optional\n        Update period (time between output updates). Default is 1 time unit.\n    tau : float, optional\n        Initial delay before the first output update. Default is 0.\n\n\n    Attributes\n    ----------\n    events : list[Schedule]\n        Internal scheduled event responsible for periodic updates.\n    \"\"\"\n\n    #max number of ports\n    _n_in_max = None\n    _n_out_max = 1\n\n    #maps for input and output port labels\n    _port_map_out = {\"out\": 0}\n\n    def __init__(self, n_bits=4, span=[-1, 1], T=1, tau=0):\n        super().__init__()\n\n        self.n_bits = n_bits\n        self.span = span\n        self.T = T\n        self.tau = tau\n\n        #port alias map\n        self._port_map_in = {f\"b{self.n_bits-n}\":n for n in range(self.n_bits)}\n\n        #initialize inputs to expect 'n_bits' entries\n        self.inputs = Register(self.n_bits, mapping=self._port_map_in)\n\n        def _sample(t):\n\n            #convert bits to integer LSB -> MSB\n            val = sum(self.inputs[i] * (2**i) for i in range(self.n_bits))\n\n            #scale to DAC span and set output\n            lower, upper = self.span\n            levels = 2**self.n_bits\n\n            scaled_val =  val / (levels - 1) if levels > 1 else 0.0\n            self.outputs[0] = lower + (upper - lower) * scaled_val\n\n        #internal scheduled events\n        self.events = [\n            Schedule(\n                t_start=tau,\n                t_period=T,\n                func_act=_sample\n                ),\n            ]\n\n\n    def __len__(self):\n        \"\"\"This block has no direct passthrough\"\"\"\n        return 0",
          "bases": [
            "pathsim.blocks._block.Block"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, n_bits=4, span=[-1, 1], T=1, tau=0):\n    super().__init__()\n\n    self.n_bits = n_bits\n    self.span = span\n    self.T = T\n    self.tau = tau\n\n    #port alias map\n    self._port_map_in = {f\"b{self.n_bits-n}\":n for n in range(self.n_bits)}\n\n    #initialize inputs to expect 'n_bits' entries\n    self.inputs = Register(self.n_bits, mapping=self._port_map_in)\n\n    def _sample(t):\n\n        #convert bits to integer LSB -> MSB\n        val = sum(self.inputs[i] * (2**i) for i in range(self.n_bits))\n\n        #scale to DAC span and set output\n        lower, upper = self.span\n        levels = 2**self.n_bits\n\n        scaled_val =  val / (levels - 1) if levels > 1 else 0.0\n        self.outputs[0] = lower + (upper - lower) * scaled_val\n\n    #internal scheduled events\n    self.events = [\n        Schedule(\n            t_start=tau,\n            t_period=T,\n            func_act=_sample\n            ),\n        ]",
              "signature": "(n_bits = 4, span = [-1, 1], T = 1, tau = 0)",
              "parameters": [
                {
                  "name": "n_bits",
                  "type": null,
                  "default": "4",
                  "description": ""
                },
                {
                  "name": "span",
                  "type": null,
                  "default": "[-1, 1]",
                  "description": ""
                },
                {
                  "name": "T",
                  "type": null,
                  "default": "1",
                  "description": ""
                },
                {
                  "name": "tau",
                  "type": null,
                  "default": "0",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "_n_in_max",
              "description": "",
              "type": null,
              "value": "None"
            },
            {
              "name": "_n_out_max",
              "description": "",
              "type": null,
              "value": "1"
            },
            {
              "name": "_port_map_out",
              "description": "",
              "type": null,
              "value": "{'out': 0}"
            },
            {
              "name": "n_bits",
              "description": "",
              "type": null,
              "value": "n_bits"
            },
            {
              "name": "span",
              "description": "",
              "type": null,
              "value": "span"
            },
            {
              "name": "T",
              "description": "",
              "type": null,
              "value": "T"
            },
            {
              "name": "tau",
              "description": "",
              "type": null,
              "value": "tau"
            },
            {
              "name": "_port_map_in",
              "description": "",
              "type": null,
              "value": "{f'b{self.n_bits - n}': n for n in (range(self.n_bits))}"
            },
            {
              "name": "inputs",
              "description": "",
              "type": null,
              "value": "Register(self.n_bits, mapping=(self._port_map_in))"
            },
            {
              "name": "events",
              "description": "",
              "type": null,
              "value": "[Schedule(t_start=tau, t_period=T, func_act=_sample)]"
            }
          ],
          "parameters": [
            {
              "name": "n_bits",
              "type": null,
              "default": "4",
              "description": "Number of digital input bits expected. Default is 4."
            },
            {
              "name": "span",
              "type": null,
              "default": "[-1, 1]",
              "description": "The analog output value range [min_voltage, max_voltage] corresponding to the digital codes 0 and 2^n_bits - 1, respectively (approximately). Default is [-1, 1]."
            },
            {
              "name": "T",
              "type": null,
              "default": "1",
              "description": "Update period (time between output updates). Default is 1 time unit."
            },
            {
              "name": "tau",
              "type": null,
              "default": "0",
              "description": "Initial delay before the first output update. Default is 0."
            }
          ]
        }
      ],
      "functions": []
    },
    "pathsim.blocks.counter": {
      "name": "pathsim.blocks.counter",
      "description": "",
      "docstring_html": "",
      "classes": [
        {
          "name": "Counter",
          "description": "Counter block that counts the number of detected bidirectional",
          "docstring_html": "<p>Counter block that counts the number of detected bidirectional\nzero-crossing events and sets the output accordingly.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>start <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>counter start (initial condition)</dd>\n<dt>threshold <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>threshold for zero crossing</dd>\n</dl>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>E <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">ZeroCrossing</span></dt>\n<dd>internal event manager</dd>\n<dt>events <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">list[ZeroCrossing]</span></dt>\n<dd>internal zero crossing event</dd>\n</dl>\n",
          "source": "class Counter(Block):\n    \"\"\"Counter block that counts the number of detected bidirectional\n    zero-crossing events and sets the output accordingly.\n\n    Parameters\n    ----------\n    start : int\n        counter start (initial condition)\n    threshold : float\n        threshold for zero crossing\n\n    Attributes\n    ----------\n    E : ZeroCrossing\n        internal event manager\n    events : list[ZeroCrossing]\n        internal zero crossing event\n    \"\"\"\n\n    #max number of ports\n    _n_in_max = 1\n    _n_out_max = 1\n\n    #maps for input and output port labels\n    _port_map_in = {\"in\": 0}\n    _port_map_out = {\"out\": 0}\n\n    def __init__(self, start=0, threshold=0.0):\n        super().__init__()\n\n        self.start = start\n        self.threshold = threshold\n\n        #internal event\n        self.E = ZeroCrossing(\n            func_evt=lambda t: self.inputs[0] - self.threshold\n            )\n\n        #internal event for transition detection\n        self.events = [self.E]\n\n\n    def __len__(self):\n        \"\"\"This block has no direct passthrough\"\"\"\n        return 0\n\n\n    def update(self, t):\n        \"\"\"update system equation for fixed point loop, \n        here just setting the outputs\n\n        Note\n        ----\n        no direct passthrough, so the 'update' method \n        is optimized for this case        \n\n        Parameters\n        ----------\n        t : float\n            evaluation time\n        \"\"\"\n\n        #start + number of detected events\n        self.outputs[0] = self.start + len(self.E)",
          "bases": [
            "pathsim.blocks._block.Block"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, start=0, threshold=0.0):\n    super().__init__()\n\n    self.start = start\n    self.threshold = threshold\n\n    #internal event\n    self.E = ZeroCrossing(\n        func_evt=lambda t: self.inputs[0] - self.threshold\n        )\n\n    #internal event for transition detection\n    self.events = [self.E]",
              "signature": "(start = 0, threshold = 0.0)",
              "parameters": [
                {
                  "name": "start",
                  "type": null,
                  "default": "0",
                  "description": ""
                },
                {
                  "name": "threshold",
                  "type": null,
                  "default": "0.0",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "update",
              "description": "update system equation for fixed point loop,",
              "docstring_html": "<p>update system equation for fixed point loop,\nhere just setting the outputs</p>\n<div class=\"section\" id=\"note\">\n<h4>Note</h4>\n<p>no direct passthrough, so the 'update' method\nis optimized for this case</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time</dd>\n</dl>\n</div>\n",
              "source": "def update(self, t):\n    \"\"\"update system equation for fixed point loop, \n    here just setting the outputs\n\n    Note\n    ----\n    no direct passthrough, so the 'update' method \n    is optimized for this case        \n\n    Parameters\n    ----------\n    t : float\n        evaluation time\n    \"\"\"\n\n    #start + number of detected events\n    self.outputs[0] = self.start + len(self.E)",
              "signature": "(t)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time"
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "_n_in_max",
              "description": "",
              "type": null,
              "value": "1"
            },
            {
              "name": "_n_out_max",
              "description": "",
              "type": null,
              "value": "1"
            },
            {
              "name": "_port_map_in",
              "description": "",
              "type": null,
              "value": "{'in': 0}"
            },
            {
              "name": "_port_map_out",
              "description": "",
              "type": null,
              "value": "{'out': 0}"
            },
            {
              "name": "start",
              "description": "",
              "type": null,
              "value": "start"
            },
            {
              "name": "threshold",
              "description": "",
              "type": null,
              "value": "threshold"
            },
            {
              "name": "E",
              "description": "",
              "type": null,
              "value": "ZeroCrossing(func_evt=(lambda t: self.inputs[0] - self.threshold))"
            },
            {
              "name": "events",
              "description": "",
              "type": null,
              "value": "[self.E]"
            }
          ],
          "parameters": [
            {
              "name": "start",
              "type": null,
              "default": "0",
              "description": "counter start (initial condition)"
            },
            {
              "name": "threshold",
              "type": null,
              "default": "0.0",
              "description": "threshold for zero crossing"
            }
          ]
        },
        {
          "name": "CounterUp",
          "description": "Counter block that counts the number of detected unidirectional",
          "docstring_html": "<p>Counter block that counts the number of detected unidirectional\nzero-crossing events and sets the output accordingly.</p>\n<div class=\"section\" id=\"note\">\n<h4>Note</h4>\n<p>This is a modification of 'Counter' which only counts\nunidirectional zero-crossings (low -&gt; high)</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>start <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>counter start (initial condition)</dd>\n<dt>threshold <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>threshold for zero crossing</dd>\n</dl>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>E <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">ZeroCrossingUp</span></dt>\n<dd>internal event manager</dd>\n<dt>events <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">list[ZeroCrossing]</span></dt>\n<dd>internal zero crossing event</dd>\n</dl>\n</div>\n",
          "source": "class CounterUp(Counter):\n    \"\"\"Counter block that counts the number of detected unidirectional\n    zero-crossing events and sets the output accordingly.\n\n    Note\n    ----\n    This is a modification of 'Counter' which only counts \n    unidirectional zero-crossings (low -> high)\n\n    Parameters\n    ----------\n    start : int\n        counter start (initial condition)\n    threshold : float\n        threshold for zero crossing\n\n    Attributes\n    ----------\n    E : ZeroCrossingUp\n        internal event manager\n    events : list[ZeroCrossing]\n        internal zero crossing event\n    \"\"\"\n\n    def __init__(self, start=0, threshold=0.0):\n        super().__init__(start, threshold)\n\n        #internal event\n        self.E = ZeroCrossingUp(\n            func_evt=lambda t: self.inputs[0] - self.threshold\n            )\n\n        #internal event for transition detection\n        self.events = [self.E]",
          "bases": [
            "pathsim.blocks.counter.Counter"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, start=0, threshold=0.0):\n    super().__init__(start, threshold)\n\n    #internal event\n    self.E = ZeroCrossingUp(\n        func_evt=lambda t: self.inputs[0] - self.threshold\n        )\n\n    #internal event for transition detection\n    self.events = [self.E]",
              "signature": "(start = 0, threshold = 0.0)",
              "parameters": [
                {
                  "name": "start",
                  "type": null,
                  "default": "0",
                  "description": ""
                },
                {
                  "name": "threshold",
                  "type": null,
                  "default": "0.0",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "E",
              "description": "",
              "type": null,
              "value": "ZeroCrossingUp(func_evt=(lambda t: self.inputs[0] - self.threshold))"
            },
            {
              "name": "events",
              "description": "",
              "type": null,
              "value": "[self.E]"
            }
          ],
          "parameters": [
            {
              "name": "start",
              "type": null,
              "default": "0",
              "description": "counter start (initial condition)"
            },
            {
              "name": "threshold",
              "type": null,
              "default": "0.0",
              "description": "threshold for zero crossing"
            }
          ]
        },
        {
          "name": "CounterDown",
          "description": "Counter block that counts the number of detected unidirectional",
          "docstring_html": "<p>Counter block that counts the number of detected unidirectional\nzero-crossing events and sets the output accordingly.</p>\n<div class=\"section\" id=\"note\">\n<h4>Note</h4>\n<p>This is a modification of 'Counter' which only counts\nunidirectional zero-crossings (high -&gt; low)</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>start <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>counter start (initial condition)</dd>\n<dt>threshold <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>threshold for zero crossing</dd>\n</dl>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>E <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">ZeroCrossingDown</span></dt>\n<dd>internal event manager</dd>\n<dt>events <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">list[ZeroCrossing]</span></dt>\n<dd>internal zero crossing event</dd>\n</dl>\n</div>\n",
          "source": "class CounterDown(Counter):\n    \"\"\"Counter block that counts the number of detected unidirectional\n    zero-crossing events and sets the output accordingly.\n\n    Note\n    ----\n    This is a modification of 'Counter' which only counts \n    unidirectional zero-crossings (high -> low)\n\n    Parameters\n    ----------\n    start : int\n        counter start (initial condition)\n    threshold : float\n        threshold for zero crossing\n\n    Attributes\n    ----------\n    E : ZeroCrossingDown\n        internal event manager\n    events : list[ZeroCrossing]\n        internal zero crossing event\n    \"\"\"\n\n    def __init__(self, start=0, threshold=0.0):\n        super().__init__(start, threshold)\n\n        #internal event\n        self.E = ZeroCrossingDown(\n            func_evt=lambda t: self.inputs[0] - self.threshold\n            )\n\n        #internal event for transition detection\n        self.events = [self.E]",
          "bases": [
            "pathsim.blocks.counter.Counter"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, start=0, threshold=0.0):\n    super().__init__(start, threshold)\n\n    #internal event\n    self.E = ZeroCrossingDown(\n        func_evt=lambda t: self.inputs[0] - self.threshold\n        )\n\n    #internal event for transition detection\n    self.events = [self.E]",
              "signature": "(start = 0, threshold = 0.0)",
              "parameters": [
                {
                  "name": "start",
                  "type": null,
                  "default": "0",
                  "description": ""
                },
                {
                  "name": "threshold",
                  "type": null,
                  "default": "0.0",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "E",
              "description": "",
              "type": null,
              "value": "ZeroCrossingDown(func_evt=(lambda t: self.inputs[0] - self.threshold))"
            },
            {
              "name": "events",
              "description": "",
              "type": null,
              "value": "[self.E]"
            }
          ],
          "parameters": [
            {
              "name": "start",
              "type": null,
              "default": "0",
              "description": "counter start (initial condition)"
            },
            {
              "name": "threshold",
              "type": null,
              "default": "0.0",
              "description": "threshold for zero crossing"
            }
          ]
        }
      ],
      "functions": []
    },
    "pathsim.blocks.ctrl": {
      "name": "pathsim.blocks.ctrl",
      "description": "",
      "docstring_html": "",
      "classes": [
        {
          "name": "PID",
          "description": "Proportional-Integral-Differntiation (PID) controller.",
          "docstring_html": "<p>Proportional-Integral-Differntiation (PID) controller.</p>\n<p>The transfer function is defined as</p>\n<div class=\"math\">\n\\begin{equation*}\nH_\\mathrm{diff}(s) = K_p + K_i \\frac{1}{s} + K_d \\frac{s}{1 + s / f_\\mathrm{max}}\n\\end{equation*}\n</div>\n<p>where the differentiation is approximated by a high pass filter that holds\nfor signals up to a frequency of approximately <cite>f_max</cite>.</p>\n<div class=\"section\" id=\"note\">\n<h4>Note</h4>\n<p>Depending on <cite>f_max</cite>, the resulting system might become stiff or ill conditioned!\nAs a practical choice set <cite>f_max</cite> to 3x the highest expected signal frequency.\nSince this block uses an approximation of real differentiation, the approximation will\nnot hold if there are high frequency components present in the signal. For example if\nyou have discontinuities such as steps or square waves.</p>\n</div>\n<div class=\"section\" id=\"example\">\n<h4>Example</h4>\n<p>The block is initialized like this:</p>\n<pre class=\"code python literal-block\">\n<span class=\"c1\">#cutoff at 1kHz</span><span class=\"w\">\n</span><span class=\"n\">pid</span> <span class=\"o\">=</span> <span class=\"n\">PID</span><span class=\"p\">(</span><span class=\"n\">Kp</span><span class=\"o\">=</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"n\">Ki</span><span class=\"o\">=</span><span class=\"mf\">0.5</span><span class=\"p\">,</span> <span class=\"n\">Kd</span><span class=\"o\">=</span><span class=\"mf\">0.1</span><span class=\"p\">,</span> <span class=\"n\">f_max</span><span class=\"o\">=</span><span class=\"mf\">1e3</span><span class=\"p\">)</span>\n</pre>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>Kp <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>poroportional controller coefficient</dd>\n<dt>Ki <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>integral controller coefficient</dd>\n<dt>Kd <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>differentiator controller coefficient</dd>\n<dt>f_max <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>highest expected signal frequency</dd>\n</dl>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>op_dyn <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">DynamicOperator</span></dt>\n<dd>internal dynamic operator for ODE component</dd>\n<dt>op_alg <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">DynamicOperator</span></dt>\n<dd>internal algebraic operator</dd>\n</dl>\n</div>\n",
          "source": "class PID(Block):\n    \"\"\"Proportional-Integral-Differntiation (PID) controller.\n\n    The transfer function is defined as\n\n    .. math::\n\n        H_\\\\mathrm{diff}(s) = K_p + K_i \\\\frac{1}{s} + K_d \\\\frac{s}{1 + s / f_\\\\mathrm{max}} \n\n    where the differentiation is approximated by a high pass filter that holds \n    for signals up to a frequency of approximately `f_max`.\n\n\n    Note\n    ----\n    Depending on `f_max`, the resulting system might become stiff or ill conditioned!\n    As a practical choice set `f_max` to 3x the highest expected signal frequency.\n    Since this block uses an approximation of real differentiation, the approximation will \n    not hold if there are high frequency components present in the signal. For example if \n    you have discontinuities such as steps or square waves.\n\n\n    Example\n    -------\n    The block is initialized like this:\n\n    .. code-block:: python\n\n        #cutoff at 1kHz\n        pid = PID(Kp=2, Ki=0.5, Kd=0.1, f_max=1e3)\n\n\n    Parameters\n    ----------\n    Kp : float\n        poroportional controller coefficient\n    Ki : float\n        integral controller coefficient\n    Kd : float\n        differentiator controller coefficient\n    f_max : float\n        highest expected signal frequency\n\n\n    Attributes\n    ----------\n    op_dyn : DynamicOperator\n        internal dynamic operator for ODE component\n    op_alg : DynamicOperator\n        internal algebraic operator\n\n    \"\"\"\n\n    #max number of ports\n    _n_in_max = 1\n    _n_out_max = 1\n\n    #maps for input and output port labels\n    _port_map_in = {\"in\": 0}\n    _port_map_out = {\"out\": 0}\n\n    def __init__(self, Kp=0, Ki=0, Kd=0, f_max=100):\n        super().__init__()\n\n        #pid controller coefficients\n        self.Kp = Kp\n        self.Ki = Ki\n        self.Kd = Kd\n\n        #maximum frequency for differentiator approximation\n        self.f_max = f_max\n\n        def _g_pid(x, u, t):\n            x1, x2 = x\n            yp = self.Kp * u\n            yi = self.Ki * x2\n            yd = self.Kd * self.f_max * (u - x1)\n            return yp + yi + yd\n\n        def _jac_x_g_pid(x, u, t):\n            return np.array([-self.Kd * self.f_max, self.Ki])\n\n        def _jac_u_g_pid(x, u, t):\n            return self.Kd * self.f_max + self.Kp\n\n        def _f_pid(x, u, t):\n            x1, x2 = x\n            dx1, dx2 = self.f_max * (u - x1), u\n            return np.array([dx1, dx2])\n\n        #internal operators\n        self.op_dyn = DynamicOperator(\n            func=_f_pid,\n            )\n        self.op_alg = DynamicOperator(\n            func=_g_pid,\n            jac_x=_jac_x_g_pid,\n            jac_u=_jac_u_g_pid,\n            )\n\n\n    def __len__(self):\n        return 1 if self._active and (self.Kp or self.Kd) else 0\n\n\n    def set_solver(self, Solver, **solver_args):\n        \"\"\"set the internal numerical integrator\n\n        Parameters\n        ----------\n        Solver : Solver\n            numerical integration solver class\n        solver_args : dict\n            parameters for solver initialization\n        \"\"\"\n        #initialize the numerical integration engine with kernel\n        if not self.engine: self.engine = Solver(np.zeros(2), **solver_args)\n        #change solver if already initialized    \n        else: self.engine = Solver.cast(self.engine, **solver_args)\n\n\n    def update(self, t):\n        \"\"\"update system equation fixed point loop, with convergence control\n\n        Parameters\n        ----------\n        t : float\n            evaluation time\n        \"\"\"\n        x, u = self.engine.get(), self.inputs[0]\n        y = self.op_alg(x, u, t)\n        self.outputs.update_from_array(y)\n\n\n    def solve(self, t, dt):\n        \"\"\"advance solution of implicit update equation\n\n        Parameters\n        ----------\n        t : float\n            evaluation time\n        dt : float\n            integration timestep\n\n        Returns\n        ------- \n        error : float\n            solver residual norm\n        \"\"\"\n        x, u = self.engine.get(), self.inputs[0]\n        f, J = self.op_dyn(x, u, t), self.op_dyn.jac_x(x, u, t)\n        return self.engine.solve(f, J, dt)\n\n\n    def step(self, t, dt):\n        \"\"\"compute update step with integration engine\n\n        Parameters\n        ----------\n        t : float\n            evaluation time\n        dt : float\n            integration timestep\n\n        Returns\n        ------- \n        success : bool\n            step was successful\n        error : float\n            local truncation error from adaptive integrators\n        scale : float\n            timestep rescale from adaptive integrators\n        \"\"\"\n        x, u = self.engine.get(), self.inputs[0]\n        f = self.op_dyn(x, u, t)\n        return self.engine.step(f, dt)",
          "bases": [
            "pathsim.blocks._block.Block"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, Kp=0, Ki=0, Kd=0, f_max=100):\n    super().__init__()\n\n    #pid controller coefficients\n    self.Kp = Kp\n    self.Ki = Ki\n    self.Kd = Kd\n\n    #maximum frequency for differentiator approximation\n    self.f_max = f_max\n\n    def _g_pid(x, u, t):\n        x1, x2 = x\n        yp = self.Kp * u\n        yi = self.Ki * x2\n        yd = self.Kd * self.f_max * (u - x1)\n        return yp + yi + yd\n\n    def _jac_x_g_pid(x, u, t):\n        return np.array([-self.Kd * self.f_max, self.Ki])\n\n    def _jac_u_g_pid(x, u, t):\n        return self.Kd * self.f_max + self.Kp\n\n    def _f_pid(x, u, t):\n        x1, x2 = x\n        dx1, dx2 = self.f_max * (u - x1), u\n        return np.array([dx1, dx2])\n\n    #internal operators\n    self.op_dyn = DynamicOperator(\n        func=_f_pid,\n        )\n    self.op_alg = DynamicOperator(\n        func=_g_pid,\n        jac_x=_jac_x_g_pid,\n        jac_u=_jac_u_g_pid,\n        )",
              "signature": "(Kp = 0, Ki = 0, Kd = 0, f_max = 100)",
              "parameters": [
                {
                  "name": "Kp",
                  "type": null,
                  "default": "0",
                  "description": ""
                },
                {
                  "name": "Ki",
                  "type": null,
                  "default": "0",
                  "description": ""
                },
                {
                  "name": "Kd",
                  "type": null,
                  "default": "0",
                  "description": ""
                },
                {
                  "name": "f_max",
                  "type": null,
                  "default": "100",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "set_solver",
              "description": "set the internal numerical integrator",
              "docstring_html": "<p>set the internal numerical integrator</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>Solver <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">Solver</span></dt>\n<dd>numerical integration solver class</dd>\n<dt>solver_args <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">dict</span></dt>\n<dd>parameters for solver initialization</dd>\n</dl>\n",
              "source": "def set_solver(self, Solver, **solver_args):\n    \"\"\"set the internal numerical integrator\n\n    Parameters\n    ----------\n    Solver : Solver\n        numerical integration solver class\n    solver_args : dict\n        parameters for solver initialization\n    \"\"\"\n    #initialize the numerical integration engine with kernel\n    if not self.engine: self.engine = Solver(np.zeros(2), **solver_args)\n    #change solver if already initialized    \n    else: self.engine = Solver.cast(self.engine, **solver_args)",
              "signature": "(Solver, solver_args = {})",
              "parameters": [
                {
                  "name": "Solver",
                  "type": null,
                  "default": null,
                  "description": "numerical integration solver class"
                },
                {
                  "name": "solver_args",
                  "type": null,
                  "default": "{}",
                  "description": "parameters for solver initialization"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "update",
              "description": "update system equation fixed point loop, with convergence control",
              "docstring_html": "<p>update system equation fixed point loop, with convergence control</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time</dd>\n</dl>\n",
              "source": "def update(self, t):\n    \"\"\"update system equation fixed point loop, with convergence control\n\n    Parameters\n    ----------\n    t : float\n        evaluation time\n    \"\"\"\n    x, u = self.engine.get(), self.inputs[0]\n    y = self.op_alg(x, u, t)\n    self.outputs.update_from_array(y)",
              "signature": "(t)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "solve",
              "description": "advance solution of implicit update equation",
              "docstring_html": "<p>advance solution of implicit update equation</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time</dd>\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>integration timestep</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>error <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>solver residual norm</dd>\n</dl>\n",
              "source": "def solve(self, t, dt):\n    \"\"\"advance solution of implicit update equation\n\n    Parameters\n    ----------\n    t : float\n        evaluation time\n    dt : float\n        integration timestep\n\n    Returns\n    ------- \n    error : float\n        solver residual norm\n    \"\"\"\n    x, u = self.engine.get(), self.inputs[0]\n    f, J = self.op_dyn(x, u, t), self.op_dyn.jac_x(x, u, t)\n    return self.engine.solve(f, J, dt)",
              "signature": "(t, dt)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time"
                },
                {
                  "name": "dt",
                  "type": null,
                  "default": null,
                  "description": "integration timestep"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "step",
              "description": "compute update step with integration engine",
              "docstring_html": "<p>compute update step with integration engine</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time</dd>\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>integration timestep</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>success <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>step was successful</dd>\n<dt>error <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>local truncation error from adaptive integrators</dd>\n<dt>scale <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>timestep rescale from adaptive integrators</dd>\n</dl>\n",
              "source": "def step(self, t, dt):\n    \"\"\"compute update step with integration engine\n\n    Parameters\n    ----------\n    t : float\n        evaluation time\n    dt : float\n        integration timestep\n\n    Returns\n    ------- \n    success : bool\n        step was successful\n    error : float\n        local truncation error from adaptive integrators\n    scale : float\n        timestep rescale from adaptive integrators\n    \"\"\"\n    x, u = self.engine.get(), self.inputs[0]\n    f = self.op_dyn(x, u, t)\n    return self.engine.step(f, dt)",
              "signature": "(t, dt)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time"
                },
                {
                  "name": "dt",
                  "type": null,
                  "default": null,
                  "description": "integration timestep"
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "_n_in_max",
              "description": "",
              "type": null,
              "value": "1"
            },
            {
              "name": "_n_out_max",
              "description": "",
              "type": null,
              "value": "1"
            },
            {
              "name": "_port_map_in",
              "description": "",
              "type": null,
              "value": "{'in': 0}"
            },
            {
              "name": "_port_map_out",
              "description": "",
              "type": null,
              "value": "{'out': 0}"
            },
            {
              "name": "Kp",
              "description": "",
              "type": null,
              "value": "Kp"
            },
            {
              "name": "Ki",
              "description": "",
              "type": null,
              "value": "Ki"
            },
            {
              "name": "Kd",
              "description": "",
              "type": null,
              "value": "Kd"
            },
            {
              "name": "f_max",
              "description": "",
              "type": null,
              "value": "f_max"
            },
            {
              "name": "op_dyn",
              "description": "",
              "type": null,
              "value": "DynamicOperator(func=_f_pid)"
            },
            {
              "name": "op_alg",
              "description": "",
              "type": null,
              "value": "DynamicOperator(func=_g_pid, jac_x=_jac_x_g_pid, jac_u=_jac_u_g_pid)"
            }
          ],
          "parameters": [
            {
              "name": "Kp",
              "type": null,
              "default": "0",
              "description": "poroportional controller coefficient"
            },
            {
              "name": "Ki",
              "type": null,
              "default": "0",
              "description": "integral controller coefficient"
            },
            {
              "name": "Kd",
              "type": null,
              "default": "0",
              "description": "differentiator controller coefficient"
            },
            {
              "name": "f_max",
              "type": null,
              "default": "100",
              "description": "highest expected signal frequency"
            }
          ]
        },
        {
          "name": "AntiWindupPID",
          "description": "Proportional-Integral-Differntiation (PID) controller with tracking",
          "docstring_html": "<p>Proportional-Integral-Differntiation (PID) controller with tracking\nanti-windup mechanism (back-calculation).</p>\n<p>Anti-windup mechanisms are needed when the magnitude of the control signal\nfrom the PID controller is limited by some real world saturation. In these cases,\nthe integrator will continue to acumulate the control error and &quot;wind itself up&quot;.\nOnce the setpoint is reached, this can result in significant overshoots. This\nimplementation adds a conditional feedback term to the internal integrator that\n&quot;unwinds&quot; it when the PID output crosses some limits. This is pretty much a\ndeadzone feedback element for the integrator.</p>\n<p>Mathematically, this block implements the following set of ODEs</p>\n<div class=\"math\">\n\\begin{equation*}\n\\begin{eqnarray}\n\\dot{x}_1 =&amp; f_\\mathrm{max} (u - x_1) \\\\\n\\dot{x}_2 =&amp; u - w \\\\\n\\end{eqnarray}\n\\end{equation*}\n</div>\n<p>with the anti-windup feedback (depending on the pid output)</p>\n<div class=\"math\">\n\\begin{equation*}\nw = K_s (y - \\min(\\max(y, y_\\mathrm{min}), y_\\mathrm{max}))\n\\end{equation*}\n</div>\n<p>and the output itself</p>\n<div class=\"math\">\n\\begin{equation*}\ny = K_p u - K_d f_\\mathrm{max} x_1 + K_i x_2\n\\end{equation*}\n</div>\n<div class=\"section\" id=\"note\">\n<h4>Note</h4>\n<p>Depending on <cite>f_max</cite>, the resulting system might become stiff or ill conditioned!\nAs a practical choice set <cite>f_max</cite> to 3x the highest expected signal frequency.\nSince this block uses an approximation of real differentiation, the approximation will\nnot hold if there are high frequency components present in the signal. For example if\nyou have discontinuities such as steps or squere waves.</p>\n</div>\n<div class=\"section\" id=\"example\">\n<h4>Example</h4>\n<p>The block is initialized like this:</p>\n<pre class=\"code python literal-block\">\n<span class=\"c1\">#cutoff at 1kHz, windup limits at [-5, 5]</span><span class=\"w\">\n</span><span class=\"n\">pid</span> <span class=\"o\">=</span> <span class=\"n\">AntiWindupPID</span><span class=\"p\">(</span><span class=\"n\">Kp</span><span class=\"o\">=</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"n\">Ki</span><span class=\"o\">=</span><span class=\"mf\">0.5</span><span class=\"p\">,</span> <span class=\"n\">Kd</span><span class=\"o\">=</span><span class=\"mf\">0.1</span><span class=\"p\">,</span> <span class=\"n\">f_max</span><span class=\"o\">=</span><span class=\"mf\">1e3</span><span class=\"p\">,</span> <span class=\"n\">limits</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"o\">-</span><span class=\"mi\">5</span><span class=\"p\">,</span> <span class=\"mi\">5</span><span class=\"p\">])</span>\n</pre>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>Kp <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>poroportional controller coefficient</dd>\n<dt>Ki <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>integral controller coefficient</dd>\n<dt>Kd <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>differentiator controller coefficient</dd>\n<dt>f_max <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>highest expected signal frequency</dd>\n<dt>Ks <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>feedback term for back calculation for anti-windup control of integrator</dd>\n<dt>limits <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array_like[float]</span></dt>\n<dd>lower and upper limit for PID output that triggers anti-windup of integrator</dd>\n</dl>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>op_dyn <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">DynamicOperator</span></dt>\n<dd>internal dynamic operator for ODE component</dd>\n<dt>op_alg <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">DynamicOperator</span></dt>\n<dd>internal algebraic operator</dd>\n</dl>\n</div>\n",
          "source": "class AntiWindupPID(PID):\n    \"\"\"Proportional-Integral-Differntiation (PID) controller with tracking \n    anti-windup mechanism (back-calculation).\n\n    Anti-windup mechanisms are needed when the magnitude of the control signal \n    from the PID controller is limited by some real world saturation. In these cases, \n    the integrator will continue to acumulate the control error and \"wind itself up\". \n    Once the setpoint is reached, this can result in significant overshoots. This \n    implementation adds a conditional feedback term to the internal integrator that \n    \"unwinds\" it when the PID output crosses some limits. This is pretty much a \n    deadzone feedback element for the integrator.\n\n    Mathematically, this block implements the following set of ODEs \n\n    .. math::\n\n        \\\\begin{eqnarray}    \n        \\\\dot{x}_1 =& f_\\\\mathrm{max} (u - x_1) \\\\\\\\\n        \\\\dot{x}_2 =& u - w \\\\\\\\\n        \\\\end{eqnarray}\n\n    with the anti-windup feedback (depending on the pid output)\n\n    .. math::\n\n        w = K_s (y - \\\\min(\\\\max(y, y_\\\\mathrm{min}), y_\\\\mathrm{max}))\n\n    and the output itself\n\n    .. math::\n\n        y = K_p u - K_d f_\\\\mathrm{max} x_1 + K_i x_2\n\n\n    Note\n    ----\n    Depending on `f_max`, the resulting system might become stiff or ill conditioned!\n    As a practical choice set `f_max` to 3x the highest expected signal frequency.\n    Since this block uses an approximation of real differentiation, the approximation will \n    not hold if there are high frequency components present in the signal. For example if \n    you have discontinuities such as steps or squere waves.\n\n\n    Example\n    -------\n    The block is initialized like this:\n\n    .. code-block:: python\n\n        #cutoff at 1kHz, windup limits at [-5, 5]\n        pid = AntiWindupPID(Kp=2, Ki=0.5, Kd=0.1, f_max=1e3, limits=[-5, 5])\n\n\n    Parameters\n    ----------\n    Kp : float\n        poroportional controller coefficient\n    Ki : float\n        integral controller coefficient\n    Kd : float\n        differentiator controller coefficient\n    f_max : float\n        highest expected signal frequency\n    Ks : float\n        feedback term for back calculation for anti-windup control of integrator\n    limits : array_like[float]\n        lower and upper limit for PID output that triggers anti-windup of integrator\n\n\n    Attributes\n    ----------\n    op_dyn : DynamicOperator\n        internal dynamic operator for ODE component\n    op_alg : DynamicOperator\n        internal algebraic operator\n\n    \"\"\"\n\n    def __init__(self, Kp=0, Ki=0, Kd=0, f_max=100, Ks=10, limits=[-10, 10]):\n        super().__init__(Kp, Ki, Kd, f_max)\n\n        #anti-windup control\n        self.Ks = Ks\n        self.limits = limits\n\n        def _g_pid(x, u, t):\n            x1, x2 = x\n            yp = self.Kp * u\n            yi = self.Ki * x2\n            yd = self.Kd * self.f_max * (u - x1)\n            return yp + yi + yd\n\n        def _jac_x_g_pid(x, u, t):\n            return np.array([-self.Kd * self.f_max, self.Ki])\n\n        def _jac_u_g_pid(x, u, t):\n            return self.Kd * self.f_max + self.Kp\n\n        def _f_pid(x, u, t):\n            x1, x2 = x\n\n            #differentiator state\n            dx1 = self.f_max * (u - x1) \n\n            #integrator state with windup control\n            y = _g_pid(x, u, t) #pid output\n            w = self.Ks * (y - np.clip(y, *self.limits)) #anti-windup feedback\n            dx2 = u - w\n\n            return np.array([dx1, dx2])\n\n        #internal operators\n        self.op_dyn = DynamicOperator(\n            func=_f_pid,\n            )\n        self.op_alg = DynamicOperator(\n            func=_g_pid,\n            jac_x=_jac_x_g_pid,\n            jac_u=_jac_u_g_pid,\n            )",
          "bases": [
            "pathsim.blocks.ctrl.PID"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, Kp=0, Ki=0, Kd=0, f_max=100, Ks=10, limits=[-10, 10]):\n    super().__init__(Kp, Ki, Kd, f_max)\n\n    #anti-windup control\n    self.Ks = Ks\n    self.limits = limits\n\n    def _g_pid(x, u, t):\n        x1, x2 = x\n        yp = self.Kp * u\n        yi = self.Ki * x2\n        yd = self.Kd * self.f_max * (u - x1)\n        return yp + yi + yd\n\n    def _jac_x_g_pid(x, u, t):\n        return np.array([-self.Kd * self.f_max, self.Ki])\n\n    def _jac_u_g_pid(x, u, t):\n        return self.Kd * self.f_max + self.Kp\n\n    def _f_pid(x, u, t):\n        x1, x2 = x\n\n        #differentiator state\n        dx1 = self.f_max * (u - x1) \n\n        #integrator state with windup control\n        y = _g_pid(x, u, t) #pid output\n        w = self.Ks * (y - np.clip(y, *self.limits)) #anti-windup feedback\n        dx2 = u - w\n\n        return np.array([dx1, dx2])\n\n    #internal operators\n    self.op_dyn = DynamicOperator(\n        func=_f_pid,\n        )\n    self.op_alg = DynamicOperator(\n        func=_g_pid,\n        jac_x=_jac_x_g_pid,\n        jac_u=_jac_u_g_pid,\n        )",
              "signature": "(Kp = 0, Ki = 0, Kd = 0, f_max = 100, Ks = 10, limits = [-10, 10])",
              "parameters": [
                {
                  "name": "Kp",
                  "type": null,
                  "default": "0",
                  "description": ""
                },
                {
                  "name": "Ki",
                  "type": null,
                  "default": "0",
                  "description": ""
                },
                {
                  "name": "Kd",
                  "type": null,
                  "default": "0",
                  "description": ""
                },
                {
                  "name": "f_max",
                  "type": null,
                  "default": "100",
                  "description": ""
                },
                {
                  "name": "Ks",
                  "type": null,
                  "default": "10",
                  "description": ""
                },
                {
                  "name": "limits",
                  "type": null,
                  "default": "[-10, 10]",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "Ks",
              "description": "",
              "type": null,
              "value": "Ks"
            },
            {
              "name": "limits",
              "description": "",
              "type": null,
              "value": "limits"
            },
            {
              "name": "op_dyn",
              "description": "",
              "type": null,
              "value": "DynamicOperator(func=_f_pid)"
            },
            {
              "name": "op_alg",
              "description": "",
              "type": null,
              "value": "DynamicOperator(func=_g_pid, jac_x=_jac_x_g_pid, jac_u=_jac_u_g_pid)"
            }
          ],
          "parameters": [
            {
              "name": "Kp",
              "type": null,
              "default": "0",
              "description": "poroportional controller coefficient"
            },
            {
              "name": "Ki",
              "type": null,
              "default": "0",
              "description": "integral controller coefficient"
            },
            {
              "name": "Kd",
              "type": null,
              "default": "0",
              "description": "differentiator controller coefficient"
            },
            {
              "name": "f_max",
              "type": null,
              "default": "100",
              "description": "highest expected signal frequency"
            },
            {
              "name": "Ks",
              "type": null,
              "default": "10",
              "description": "feedback term for back calculation for anti-windup control of integrator"
            },
            {
              "name": "limits",
              "type": null,
              "default": "[-10, 10]",
              "description": "lower and upper limit for PID output that triggers anti-windup of integrator"
            }
          ]
        }
      ],
      "functions": []
    },
    "pathsim.blocks.delay": {
      "name": "pathsim.blocks.delay",
      "description": "",
      "docstring_html": "",
      "classes": [
        {
          "name": "Delay",
          "description": "Delays the input signal by a time constant 'tau' in seconds",
          "docstring_html": "<p>Delays the input signal by a time constant 'tau' in seconds\nusing an adaptive rolling buffer.</p>\n<p>Mathematically this block creates a time delay of the input signal like this:</p>\n<div class=\"math\">\n\\begin{equation*}\ny(t) =\n\\begin{cases}\nx(t - \\tau) &amp; , t \\geq \\tau \\\\\n0            &amp; , t &lt; \\tau\n\\end{cases}\n\\end{equation*}\n</div>\n<div class=\"section\" id=\"note\">\n<h4>Note</h4>\n<p>The internal adaptive buffer uses interpolation for the evaluation. This is\nrequired to be compatible with variable step solvers. It has a drawback however.\nThe order of the ode solver used will degrade when this block is used, due to\nthe interpolation.</p>\n</div>\n<div class=\"section\" id=\"example\">\n<h4>Example</h4>\n<p>The block is initialized like this:</p>\n<pre class=\"code python literal-block\">\n<span class=\"c1\">#5 time units delay</span><span class=\"w\">\n</span><span class=\"n\">D</span> <span class=\"o\">=</span> <span class=\"n\">Delay</span><span class=\"p\">(</span><span class=\"n\">tau</span><span class=\"o\">=</span><span class=\"mi\">5</span><span class=\"p\">)</span>\n</pre>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>tau <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>delay time constant</dd>\n</dl>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>_buffer <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">AdaptiveBuffer</span></dt>\n<dd>internal interpolatable adaptive rolling buffer</dd>\n</dl>\n</div>\n",
          "source": "class Delay(Block):\n    \"\"\"Delays the input signal by a time constant 'tau' in seconds\n    using an adaptive rolling buffer.\n\n    Mathematically this block creates a time delay of the input signal like this:\n\n    .. math::\n\n        y(t) = \n        \\\\begin{cases}\n        x(t - \\\\tau) & , t \\\\geq \\\\tau \\\\\\\\\n        0            & , t < \\\\tau\n        \\\\end{cases}\n\n    Note\n    ----\n    The internal adaptive buffer uses interpolation for the evaluation. This is \n    required to be compatible with variable step solvers. It has a drawback however. \n    The order of the ode solver used will degrade when this block is used, due to \n    the interpolation.\n\n    Example\n    -------\n    The block is initialized like this:\n\n    .. code-block:: python\n\n        #5 time units delay\n        D = Delay(tau=5)\n\n    Parameters\n    ----------\n    tau : float\n        delay time constant\n\n    Attributes\n    ----------\n    _buffer : AdaptiveBuffer\n        internal interpolatable adaptive rolling buffer\n    \"\"\"\n\n    #max number of ports\n    _n_in_max = 1\n    _n_out_max = 1\n\n    #maps for input and output port labels\n    _port_map_in = {\"in\": 0}\n    _port_map_out = {\"out\": 0}\n\n    def __init__(self, tau=1e-3):\n        super().__init__()\n\n        #time delay in seconds \n        self.tau = tau\n\n        #create adaptive buffer\n        self._buffer = AdaptiveBuffer(self.tau)\n\n\n    def __len__(self):\n        #no passthrough by definition\n        return 0\n\n\n    def reset(self):\n        super().reset()\n\n        #clear the buffer\n        self._buffer.clear()\n\n\n    def update(self, t):\n        \"\"\"Evaluation of the buffer at different times \n        via interpolation.\n\n        Parameters\n        ----------\n        t : float\n            evaluation time\n        \"\"\"\n\n        #retrieve value from buffer\n        y = self._buffer.get(t)\n        self.outputs.update_from_array(y)\n\n\n    def sample(self, t):\n        \"\"\"Sample input values and time of sampling \n        and add them to the buffer.\n\n        Parameters\n        ----------\n        t : float\n            evaluation time for sampling\n        \"\"\"\n\n        #add new value to buffer\n        self._buffer.add(t, self.inputs[0])",
          "bases": [
            "pathsim.blocks._block.Block"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, tau=1e-3):\n    super().__init__()\n\n    #time delay in seconds \n    self.tau = tau\n\n    #create adaptive buffer\n    self._buffer = AdaptiveBuffer(self.tau)",
              "signature": "(tau = 0.001)",
              "parameters": [
                {
                  "name": "tau",
                  "type": null,
                  "default": "0.001",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "reset",
              "description": "",
              "docstring_html": "",
              "source": "def reset(self):\n    super().reset()\n\n    #clear the buffer\n    self._buffer.clear()",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "update",
              "description": "Evaluation of the buffer at different times",
              "docstring_html": "<p>Evaluation of the buffer at different times\nvia interpolation.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time</dd>\n</dl>\n",
              "source": "def update(self, t):\n    \"\"\"Evaluation of the buffer at different times \n    via interpolation.\n\n    Parameters\n    ----------\n    t : float\n        evaluation time\n    \"\"\"\n\n    #retrieve value from buffer\n    y = self._buffer.get(t)\n    self.outputs.update_from_array(y)",
              "signature": "(t)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "sample",
              "description": "Sample input values and time of sampling",
              "docstring_html": "<p>Sample input values and time of sampling\nand add them to the buffer.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time for sampling</dd>\n</dl>\n",
              "source": "def sample(self, t):\n    \"\"\"Sample input values and time of sampling \n    and add them to the buffer.\n\n    Parameters\n    ----------\n    t : float\n        evaluation time for sampling\n    \"\"\"\n\n    #add new value to buffer\n    self._buffer.add(t, self.inputs[0])",
              "signature": "(t)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time for sampling"
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "_n_in_max",
              "description": "",
              "type": null,
              "value": "1"
            },
            {
              "name": "_n_out_max",
              "description": "",
              "type": null,
              "value": "1"
            },
            {
              "name": "_port_map_in",
              "description": "",
              "type": null,
              "value": "{'in': 0}"
            },
            {
              "name": "_port_map_out",
              "description": "",
              "type": null,
              "value": "{'out': 0}"
            },
            {
              "name": "tau",
              "description": "",
              "type": null,
              "value": "tau"
            },
            {
              "name": "_buffer",
              "description": "",
              "type": null,
              "value": "AdaptiveBuffer(self.tau)"
            }
          ],
          "parameters": [
            {
              "name": "tau",
              "type": null,
              "default": "0.001",
              "description": "delay time constant"
            }
          ]
        }
      ],
      "functions": []
    },
    "pathsim.blocks.differentiator": {
      "name": "pathsim.blocks.differentiator",
      "description": "",
      "docstring_html": "",
      "classes": [
        {
          "name": "Differentiator",
          "description": "Differentiates the input signal (SISO) using a first order transfer function",
          "docstring_html": "<p>Differentiates the input signal (SISO) using a first order transfer function\nwith a pole at the origin which implements a high pass filter.</p>\n<div class=\"math\">\n\\begin{equation*}\nH_\\mathrm{diff}(s) = \\frac{s}{1 + s / f_\\mathrm{max}}\n\\end{equation*}\n</div>\n<p>The approximation holds for signals up to a frequency of approximately f_max.</p>\n<div class=\"section\" id=\"note\">\n<h4>Note</h4>\n<p>Depending on <cite>f_max</cite>, the resulting system might become stiff or ill conditioned!\nAs a practical choice set <cite>f_max</cite> to 3x the highest expected signal frequency.</p>\n</div>\n<div class=\"section\" id=\"note-1\">\n<h4>Note</h4>\n<p>Since this is an approximation of real differentiation, the approximation will not hold\nif there are high frequency components present in the signal. For example if you have\ndiscontinuities such as steps or squere waves.</p>\n</div>\n<div class=\"section\" id=\"example\">\n<h4>Example</h4>\n<p>The block is initialized like this:</p>\n<pre class=\"code python literal-block\">\n<span class=\"c1\">#cutoff at 1kHz</span><span class=\"w\">\n</span><span class=\"n\">D</span> <span class=\"o\">=</span> <span class=\"n\">Differentiator</span><span class=\"p\">(</span><span class=\"n\">f_max</span><span class=\"o\">=</span><span class=\"mf\">1e3</span><span class=\"p\">)</span>\n</pre>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>f_max <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>highest expected signal frequency</dd>\n</dl>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>op_dyn <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">DynamicOperator</span></dt>\n<dd>internal dynamic operator for ODE component</dd>\n<dt>op_alg <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">DynamicOperator</span></dt>\n<dd>internal algebraic operator</dd>\n</dl>\n</div>\n",
          "source": "class Differentiator(Block):\n    \"\"\"Differentiates the input signal (SISO) using a first order transfer function \n    with a pole at the origin which implements a high pass filter. \n\n    .. math::\n\n        H_\\\\mathrm{diff}(s) = \\\\frac{s}{1 + s / f_\\\\mathrm{max}} \n\n    The approximation holds for signals up to a frequency of approximately f_max.\n\n    Note\n    -----\n    Depending on `f_max`, the resulting system might become stiff or ill conditioned!\n    As a practical choice set `f_max` to 3x the highest expected signal frequency.\n\n    Note\n    ----\n    Since this is an approximation of real differentiation, the approximation will not hold \n    if there are high frequency components present in the signal. For example if you have \n    discontinuities such as steps or squere waves.\n\n    Example\n    -------\n    The block is initialized like this:\n\n    .. code-block:: python\n\n        #cutoff at 1kHz\n        D = Differentiator(f_max=1e3)\n\n    Parameters\n    ----------\n    f_max : float\n        highest expected signal frequency\n\n    Attributes\n    ----------\n    op_dyn : DynamicOperator\n        internal dynamic operator for ODE component\n    op_alg : DynamicOperator\n        internal algebraic operator\n\n    \"\"\"\n\n    #max number of ports\n    _n_in_max = 1\n    _n_out_max = 1\n\n    #maps for input and output port labels\n    _port_map_in = {\"in\": 0}\n    _port_map_out = {\"out\": 0}\n\n    def __init__(self, f_max=1e2):\n        super().__init__()\n\n        #maximum frequency for differentiator approximation\n        self.f_max = f_max\n\n        self.op_dyn = DynamicOperator(\n            func=lambda x, u, t: self.f_max * (u - x),\n            jac_x=lambda x, u, t: -self.f_max\n            )\n        self.op_alg = DynamicOperator(\n            func=lambda x, u, t: self.f_max * (u - x),\n            jac_x=lambda x, u, t: -self.f_max,\n            jac_u=lambda x, u, t: self.f_max,\n            )\n\n    def __len__(self):\n        return 1 if self._active else 0\n\n\n    def set_solver(self, Solver, **solver_args):\n        \"\"\"set the internal numerical integrator\n\n        Parameters\n        ----------\n        Solver : Solver\n            numerical integration solver class\n        solver_args : dict\n            parameters for solver initialization\n        \"\"\"\n\n        #initialize the numerical integration engine with kernel\n        if self.engine is None: self.engine = Solver(0.0, **solver_args)\n        #change solver if already initialized\n        else: self.engine = Solver.cast(self.engine, **solver_args)\n\n\n    def update(self, t):\n        \"\"\"update system equation fixed point loop,\n        with convergence control\n\n        Parameters\n        ----------\n        t : float\n            evaluation time\n        \"\"\"\n        x, u = self.engine.get(), self.inputs[0]\n        y = self.op_alg(x, u, t)\n        self.outputs.update_from_array(y)\n\n\n    def solve(self, t, dt):\n        \"\"\"advance solution of implicit update equation\n\n        Parameters\n        ----------\n        t : float\n            evaluation time\n        dt : float\n            integration timestep\n\n        Returns\n        ------- \n        error : float\n            solver residual norm\n        \"\"\"\n        x, u = self.engine.get(), self.inputs[0]\n        f, J = self.op_dyn(x, u, t), self.op_dyn.jac_x(x, u, t)\n        return self.engine.solve(f, J, dt)\n\n\n    def step(self, t, dt):\n        \"\"\"compute update step with integration engine\n\n        Parameters\n        ----------\n        t : float\n            evaluation time\n        dt : float\n            integration timestep\n\n        Returns\n        ------- \n        success : bool\n            step was successful\n        error : float\n            local truncation error from adaptive integrators\n        scale : float\n            timestep rescale from adaptive integrators\n        \"\"\"\n        x, u = self.engine.get(), self.inputs[0]\n        f = self.op_dyn(x, u, t)\n        return self.engine.step(f, dt)",
          "bases": [
            "pathsim.blocks._block.Block"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, f_max=1e2):\n    super().__init__()\n\n    #maximum frequency for differentiator approximation\n    self.f_max = f_max\n\n    self.op_dyn = DynamicOperator(\n        func=lambda x, u, t: self.f_max * (u - x),\n        jac_x=lambda x, u, t: -self.f_max\n        )\n    self.op_alg = DynamicOperator(\n        func=lambda x, u, t: self.f_max * (u - x),\n        jac_x=lambda x, u, t: -self.f_max,\n        jac_u=lambda x, u, t: self.f_max,\n        )",
              "signature": "(f_max = 100.0)",
              "parameters": [
                {
                  "name": "f_max",
                  "type": null,
                  "default": "100.0",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "set_solver",
              "description": "set the internal numerical integrator",
              "docstring_html": "<p>set the internal numerical integrator</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>Solver <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">Solver</span></dt>\n<dd>numerical integration solver class</dd>\n<dt>solver_args <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">dict</span></dt>\n<dd>parameters for solver initialization</dd>\n</dl>\n",
              "source": "def set_solver(self, Solver, **solver_args):\n    \"\"\"set the internal numerical integrator\n\n    Parameters\n    ----------\n    Solver : Solver\n        numerical integration solver class\n    solver_args : dict\n        parameters for solver initialization\n    \"\"\"\n\n    #initialize the numerical integration engine with kernel\n    if self.engine is None: self.engine = Solver(0.0, **solver_args)\n    #change solver if already initialized\n    else: self.engine = Solver.cast(self.engine, **solver_args)",
              "signature": "(Solver, solver_args = {})",
              "parameters": [
                {
                  "name": "Solver",
                  "type": null,
                  "default": null,
                  "description": "numerical integration solver class"
                },
                {
                  "name": "solver_args",
                  "type": null,
                  "default": "{}",
                  "description": "parameters for solver initialization"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "update",
              "description": "update system equation fixed point loop,",
              "docstring_html": "<p>update system equation fixed point loop,\nwith convergence control</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time</dd>\n</dl>\n",
              "source": "def update(self, t):\n    \"\"\"update system equation fixed point loop,\n    with convergence control\n\n    Parameters\n    ----------\n    t : float\n        evaluation time\n    \"\"\"\n    x, u = self.engine.get(), self.inputs[0]\n    y = self.op_alg(x, u, t)\n    self.outputs.update_from_array(y)",
              "signature": "(t)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "solve",
              "description": "advance solution of implicit update equation",
              "docstring_html": "<p>advance solution of implicit update equation</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time</dd>\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>integration timestep</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>error <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>solver residual norm</dd>\n</dl>\n",
              "source": "def solve(self, t, dt):\n    \"\"\"advance solution of implicit update equation\n\n    Parameters\n    ----------\n    t : float\n        evaluation time\n    dt : float\n        integration timestep\n\n    Returns\n    ------- \n    error : float\n        solver residual norm\n    \"\"\"\n    x, u = self.engine.get(), self.inputs[0]\n    f, J = self.op_dyn(x, u, t), self.op_dyn.jac_x(x, u, t)\n    return self.engine.solve(f, J, dt)",
              "signature": "(t, dt)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time"
                },
                {
                  "name": "dt",
                  "type": null,
                  "default": null,
                  "description": "integration timestep"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "step",
              "description": "compute update step with integration engine",
              "docstring_html": "<p>compute update step with integration engine</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time</dd>\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>integration timestep</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>success <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>step was successful</dd>\n<dt>error <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>local truncation error from adaptive integrators</dd>\n<dt>scale <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>timestep rescale from adaptive integrators</dd>\n</dl>\n",
              "source": "def step(self, t, dt):\n    \"\"\"compute update step with integration engine\n\n    Parameters\n    ----------\n    t : float\n        evaluation time\n    dt : float\n        integration timestep\n\n    Returns\n    ------- \n    success : bool\n        step was successful\n    error : float\n        local truncation error from adaptive integrators\n    scale : float\n        timestep rescale from adaptive integrators\n    \"\"\"\n    x, u = self.engine.get(), self.inputs[0]\n    f = self.op_dyn(x, u, t)\n    return self.engine.step(f, dt)",
              "signature": "(t, dt)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time"
                },
                {
                  "name": "dt",
                  "type": null,
                  "default": null,
                  "description": "integration timestep"
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "_n_in_max",
              "description": "",
              "type": null,
              "value": "1"
            },
            {
              "name": "_n_out_max",
              "description": "",
              "type": null,
              "value": "1"
            },
            {
              "name": "_port_map_in",
              "description": "",
              "type": null,
              "value": "{'in': 0}"
            },
            {
              "name": "_port_map_out",
              "description": "",
              "type": null,
              "value": "{'out': 0}"
            },
            {
              "name": "f_max",
              "description": "",
              "type": null,
              "value": "f_max"
            },
            {
              "name": "op_dyn",
              "description": "",
              "type": null,
              "value": "DynamicOperator(func=(lambda x, u, t: self.f_max * (u - x)), jac_x=(lambda x, u, t: -self.f_max))"
            },
            {
              "name": "op_alg",
              "description": "",
              "type": null,
              "value": "DynamicOperator(func=(lambda x, u, t: self.f_max * (u - x)), jac_x=(lambda x, u, t: -self.f_max), jac_u=(lambda x, u, t: self.f_max))"
            }
          ],
          "parameters": [
            {
              "name": "f_max",
              "type": null,
              "default": "100.0",
              "description": "highest expected signal frequency"
            }
          ]
        }
      ],
      "functions": []
    },
    "pathsim.blocks.filters": {
      "name": "pathsim.blocks.filters",
      "description": "",
      "docstring_html": "",
      "classes": [
        {
          "name": "ButterworthLowpassFilter",
          "description": "Direct implementation of a low pass butterworth filter block.",
          "docstring_html": "<p>Direct implementation of a low pass butterworth filter block.</p>\n<p>Follows the same structure as the 'StateSpace' block in the\n'pathsim.blocks' module. The numerator and denominator of the\nfilter transfer function are generated and then the transfer\nfunction is realized as a state space model.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>Fc <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>corner frequency of the filter in [Hz]</dd>\n<dt>n <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>filter order</dd>\n</dl>\n",
          "source": "class ButterworthLowpassFilter(StateSpace):\n    \"\"\"Direct implementation of a low pass butterworth filter block.\n\n    Follows the same structure as the 'StateSpace' block in the \n    'pathsim.blocks' module. The numerator and denominator of the \n    filter transfer function are generated and then the transfer \n    function is realized as a state space model. \n\n    Parameters\n    ----------\n    Fc : float\n        corner frequency of the filter in [Hz]\n    n : int\n        filter order\n    \"\"\"\n\n    #max number of ports\n    _n_in_max = 1\n    _n_out_max = 1\n\n    #maps for input and output port labels\n    _port_map_in = {\"in\": 0}\n    _port_map_out = {\"out\": 0}\n\n    def __init__(self, Fc=100, n=2):\n\n        #filter parameters\n        self.Fc = Fc\n        self.n = n\n\n        #use scipy.signal for filter design for unit frequency\n        num, den = butter(n, 1.0, btype=\"low\", analog=True, output=\"ba\")\n        A, B, C, D = tf2ss(num, den)\n\n        #rescale to actual bandwidth and make statespace model\n        omega_c = 2*np.pi*self.Fc\n        super().__init__(omega_c*A, omega_c*B, C, D)",
          "bases": [
            "pathsim.blocks.lti.StateSpace"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, Fc=100, n=2):\n\n    #filter parameters\n    self.Fc = Fc\n    self.n = n\n\n    #use scipy.signal for filter design for unit frequency\n    num, den = butter(n, 1.0, btype=\"low\", analog=True, output=\"ba\")\n    A, B, C, D = tf2ss(num, den)\n\n    #rescale to actual bandwidth and make statespace model\n    omega_c = 2*np.pi*self.Fc\n    super().__init__(omega_c*A, omega_c*B, C, D)",
              "signature": "(Fc = 100, n = 2)",
              "parameters": [
                {
                  "name": "Fc",
                  "type": null,
                  "default": "100",
                  "description": ""
                },
                {
                  "name": "n",
                  "type": null,
                  "default": "2",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "_n_in_max",
              "description": "",
              "type": null,
              "value": "1"
            },
            {
              "name": "_n_out_max",
              "description": "",
              "type": null,
              "value": "1"
            },
            {
              "name": "_port_map_in",
              "description": "",
              "type": null,
              "value": "{'in': 0}"
            },
            {
              "name": "_port_map_out",
              "description": "",
              "type": null,
              "value": "{'out': 0}"
            },
            {
              "name": "Fc",
              "description": "",
              "type": null,
              "value": "Fc"
            },
            {
              "name": "n",
              "description": "",
              "type": null,
              "value": "n"
            }
          ],
          "parameters": [
            {
              "name": "Fc",
              "type": null,
              "default": "100",
              "description": "corner frequency of the filter in [Hz]"
            },
            {
              "name": "n",
              "type": null,
              "default": "2",
              "description": "filter order"
            }
          ]
        },
        {
          "name": "ButterworthHighpassFilter",
          "description": "Direct implementation of a high pass butterworth filter block.",
          "docstring_html": "<p>Direct implementation of a high pass butterworth filter block.</p>\n<p>Follows the same structure as the 'StateSpace' block in the\n'pathsim.blocks' module. The numerator and denominator of the\nfilter transfer function are generated and then the transfer\nfunction is realized as a state space model.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>Fc <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>corner frequency of the filter in [Hz]</dd>\n<dt>n <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>filter order</dd>\n</dl>\n",
          "source": "class ButterworthHighpassFilter(StateSpace):\n    \"\"\"Direct implementation of a high pass butterworth filter block.\n\n    Follows the same structure as the 'StateSpace' block in the \n    'pathsim.blocks' module. The numerator and denominator of the \n    filter transfer function are generated and then the transfer \n    function is realized as a state space model. \n\n    Parameters\n    ----------\n    Fc : float\n        corner frequency of the filter in [Hz]\n    n : int\n        filter order\n    \"\"\"\n\n    #max number of ports\n    _n_in_max = 1\n    _n_out_max = 1\n\n    #maps for input and output port labels\n    _port_map_in = {\"in\": 0}\n    _port_map_out = {\"out\": 0}\n\n    def __init__(self, Fc=100, n=2):\n\n        #filter parameters\n        self.Fc = Fc\n        self.n = n\n\n        #use scipy.signal for filter design for unit frequency\n        num, den = butter(n, 1.0, btype=\"high\", analog=True, output=\"ba\")\n        A, B, C, D = tf2ss(num, den)\n\n        #rescale to actual bandwidth and make statespace model\n        omega_c = 2*np.pi*self.Fc\n        super().__init__(omega_c*A, omega_c*B, C, D)",
          "bases": [
            "pathsim.blocks.lti.StateSpace"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, Fc=100, n=2):\n\n    #filter parameters\n    self.Fc = Fc\n    self.n = n\n\n    #use scipy.signal for filter design for unit frequency\n    num, den = butter(n, 1.0, btype=\"high\", analog=True, output=\"ba\")\n    A, B, C, D = tf2ss(num, den)\n\n    #rescale to actual bandwidth and make statespace model\n    omega_c = 2*np.pi*self.Fc\n    super().__init__(omega_c*A, omega_c*B, C, D)",
              "signature": "(Fc = 100, n = 2)",
              "parameters": [
                {
                  "name": "Fc",
                  "type": null,
                  "default": "100",
                  "description": ""
                },
                {
                  "name": "n",
                  "type": null,
                  "default": "2",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "_n_in_max",
              "description": "",
              "type": null,
              "value": "1"
            },
            {
              "name": "_n_out_max",
              "description": "",
              "type": null,
              "value": "1"
            },
            {
              "name": "_port_map_in",
              "description": "",
              "type": null,
              "value": "{'in': 0}"
            },
            {
              "name": "_port_map_out",
              "description": "",
              "type": null,
              "value": "{'out': 0}"
            },
            {
              "name": "Fc",
              "description": "",
              "type": null,
              "value": "Fc"
            },
            {
              "name": "n",
              "description": "",
              "type": null,
              "value": "n"
            }
          ],
          "parameters": [
            {
              "name": "Fc",
              "type": null,
              "default": "100",
              "description": "corner frequency of the filter in [Hz]"
            },
            {
              "name": "n",
              "type": null,
              "default": "2",
              "description": "filter order"
            }
          ]
        },
        {
          "name": "ButterworthBandpassFilter",
          "description": "Direct implementation of a bandpass butterworth filter block.",
          "docstring_html": "<p>Direct implementation of a bandpass butterworth filter block.</p>\n<p>Follows the same structure as the 'StateSpace' block in the\n'pathsim.blocks' module. The numerator and denominator of the\nfilter transfer function are generated and then the transfer\nfunction is realized as a state space model.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>Fc <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">list[float]</span></dt>\n<dd>corner frequencies (left, right) of the filter in [Hz]</dd>\n<dt>n <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>filter order</dd>\n</dl>\n",
          "source": "class ButterworthBandpassFilter(StateSpace):\n    \"\"\"Direct implementation of a bandpass butterworth filter block.\n\n    Follows the same structure as the 'StateSpace' block in the \n    'pathsim.blocks' module. The numerator and denominator of the \n    filter transfer function are generated and then the transfer \n    function is realized as a state space model. \n\n    Parameters\n    ----------\n    Fc : list[float]\n        corner frequencies (left, right) of the filter in [Hz]\n    n : int\n        filter order\n    \"\"\"\n\n    #max number of ports\n    _n_in_max = 1\n    _n_out_max = 1\n\n    #maps for input and output port labels\n    _port_map_in = {\"in\": 0}\n    _port_map_out = {\"out\": 0}\n\n    def __init__(self, Fc=[50, 100], n=2):\n\n        #filter parameters\n        self.Fc = np.asarray(Fc)\n        self.n = n\n\n        if len(Fc) != 2:\n            raise ValueError(\"'ButterworthBandpassFilter' requires two corner frequencies!\")\n\n        #use scipy.signal for filter design\n        num, den = butter(n, 2*np.pi*self.Fc, btype=\"bandpass\", analog=True, output=\"ba\")\n\n        #initialize parent block\n        super().__init__(*tf2ss(num, den))",
          "bases": [
            "pathsim.blocks.lti.StateSpace"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, Fc=[50, 100], n=2):\n\n    #filter parameters\n    self.Fc = np.asarray(Fc)\n    self.n = n\n\n    if len(Fc) != 2:\n        raise ValueError(\"'ButterworthBandpassFilter' requires two corner frequencies!\")\n\n    #use scipy.signal for filter design\n    num, den = butter(n, 2*np.pi*self.Fc, btype=\"bandpass\", analog=True, output=\"ba\")\n\n    #initialize parent block\n    super().__init__(*tf2ss(num, den))",
              "signature": "(Fc = [50, 100], n = 2)",
              "parameters": [
                {
                  "name": "Fc",
                  "type": null,
                  "default": "[50, 100]",
                  "description": ""
                },
                {
                  "name": "n",
                  "type": null,
                  "default": "2",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "_n_in_max",
              "description": "",
              "type": null,
              "value": "1"
            },
            {
              "name": "_n_out_max",
              "description": "",
              "type": null,
              "value": "1"
            },
            {
              "name": "_port_map_in",
              "description": "",
              "type": null,
              "value": "{'in': 0}"
            },
            {
              "name": "_port_map_out",
              "description": "",
              "type": null,
              "value": "{'out': 0}"
            },
            {
              "name": "Fc",
              "description": "",
              "type": null,
              "value": "np.asarray(Fc)"
            },
            {
              "name": "n",
              "description": "",
              "type": null,
              "value": "n"
            }
          ],
          "parameters": [
            {
              "name": "Fc",
              "type": null,
              "default": "[50, 100]",
              "description": "corner frequencies (left, right) of the filter in [Hz]"
            },
            {
              "name": "n",
              "type": null,
              "default": "2",
              "description": "filter order"
            }
          ]
        },
        {
          "name": "ButterworthBandstopFilter",
          "description": "Direct implementation of a bandstop butterworth filter block.",
          "docstring_html": "<p>Direct implementation of a bandstop butterworth filter block.</p>\n<p>Follows the same structure as the 'StateSpace' block in the\n'pathsim.blocks' module. The numerator and denominator of the\nfilter transfer function are generated and then the transfer\nfunction is realized as a state space model.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>Fc <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">tuple[float], list[float]</span></dt>\n<dd>corner frequencies (left, right) of the filter in [Hz]</dd>\n<dt>n <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>filter order</dd>\n</dl>\n",
          "source": "class ButterworthBandstopFilter(StateSpace):\n    \"\"\"Direct implementation of a bandstop butterworth filter block.\n\n    Follows the same structure as the 'StateSpace' block in the \n    'pathsim.blocks' module. The numerator and denominator of the \n    filter transfer function are generated and then the transfer \n    function is realized as a state space model. \n\n    Parameters\n    ----------\n    Fc : tuple[float], list[float]\n        corner frequencies (left, right) of the filter in [Hz]\n    n : int\n        filter order\n    \"\"\"\n\n    #max number of ports\n    _n_in_max = 1\n    _n_out_max = 1\n\n    #maps for input and output port labels\n    _port_map_in = {\"in\": 0}\n    _port_map_out = {\"out\": 0}\n\n    def __init__(self, Fc=[50, 100], n=2):\n\n        #filter parameters\n        self.Fc = np.asarray(Fc)\n        self.n = n\n\n        if len(Fc) != 2:\n            raise ValueError(\"'ButterworthBandstopFilter' requires two corner frequencies!\")\n\n        #use scipy.signal for filter design\n        num, den = butter(n, 2*np.pi*self.Fc, btype=\"bandstop\", analog=True, output=\"ba\")\n\n        #initialize parent block\n        super().__init__(*tf2ss(num, den))",
          "bases": [
            "pathsim.blocks.lti.StateSpace"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, Fc=[50, 100], n=2):\n\n    #filter parameters\n    self.Fc = np.asarray(Fc)\n    self.n = n\n\n    if len(Fc) != 2:\n        raise ValueError(\"'ButterworthBandstopFilter' requires two corner frequencies!\")\n\n    #use scipy.signal for filter design\n    num, den = butter(n, 2*np.pi*self.Fc, btype=\"bandstop\", analog=True, output=\"ba\")\n\n    #initialize parent block\n    super().__init__(*tf2ss(num, den))",
              "signature": "(Fc = [50, 100], n = 2)",
              "parameters": [
                {
                  "name": "Fc",
                  "type": null,
                  "default": "[50, 100]",
                  "description": ""
                },
                {
                  "name": "n",
                  "type": null,
                  "default": "2",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "_n_in_max",
              "description": "",
              "type": null,
              "value": "1"
            },
            {
              "name": "_n_out_max",
              "description": "",
              "type": null,
              "value": "1"
            },
            {
              "name": "_port_map_in",
              "description": "",
              "type": null,
              "value": "{'in': 0}"
            },
            {
              "name": "_port_map_out",
              "description": "",
              "type": null,
              "value": "{'out': 0}"
            },
            {
              "name": "Fc",
              "description": "",
              "type": null,
              "value": "np.asarray(Fc)"
            },
            {
              "name": "n",
              "description": "",
              "type": null,
              "value": "n"
            }
          ],
          "parameters": [
            {
              "name": "Fc",
              "type": null,
              "default": "[50, 100]",
              "description": "corner frequencies (left, right) of the filter in [Hz]"
            },
            {
              "name": "n",
              "type": null,
              "default": "2",
              "description": "filter order"
            }
          ]
        },
        {
          "name": "AllpassFilter",
          "description": "Direct implementation of a first order allpass filter, or a cascade",
          "docstring_html": "<p>Direct implementation of a first order allpass filter, or a cascade\nof n 1st order allpass filters</p>\n<div class=\"math\">\n\\begin{equation*}\nH(s) = \\frac{s - 2\\pi f_s}{s + 2\\pi f_s}\n\\end{equation*}\n</div>\n<p>where f_s is the frequency, where the 1st order allpass has a 90 deg phase shift.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>fs <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>frequency for 90 deg phase shift of 1st order allpass</dd>\n<dt>n <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>number of cascades</dd>\n</dl>\n",
          "source": "class AllpassFilter(StateSpace):\n    \"\"\"Direct implementation of a first order allpass filter, or a cascade \n    of n 1st order allpass filters\n\n    .. math:: \n\n        H(s) = \\\\frac{s - 2\\\\pi f_s}{s + 2\\\\pi f_s}\n\n    where f_s is the frequency, where the 1st order allpass has a 90 deg phase shift.\n\n    Parameters\n    ----------\n    fs : float\n        frequency for 90 deg phase shift of 1st order allpass\n    n : int\n        number of cascades\n    \"\"\"\n\n    #max number of ports\n    _n_in_max = 1\n    _n_out_max = 1\n\n    #maps for input and output port labels\n    _port_map_in = {\"in\": 0}\n    _port_map_out = {\"out\": 0}\n\n    def __init__(self, fs=100, n=1):\n\n        #filter parameters\n        self.fs = fs\n        self.n = n\n\n        #1st order allpass for numerator and denominator (normalized frequency)\n        num = [-1, 1]\n        den = [1, 1]\n\n        #higher order by convolution\n        for _ in range(1, self.n):\n            num = np.convolve(num, [-1, 1])\n            den = np.convolve(den, [1, 1])\n\n        #create statespace model\n        A, B, C, D = tf2ss(num, den)\n\n        #rescale to actual frequency and make statespace model\n        omega_s = 2*np.pi*fs\n\n        #initialize parent block\n        super().__init__(omega_s*A, omega_s*B, C, D)",
          "bases": [
            "pathsim.blocks.lti.StateSpace"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, fs=100, n=1):\n\n    #filter parameters\n    self.fs = fs\n    self.n = n\n\n    #1st order allpass for numerator and denominator (normalized frequency)\n    num = [-1, 1]\n    den = [1, 1]\n\n    #higher order by convolution\n    for _ in range(1, self.n):\n        num = np.convolve(num, [-1, 1])\n        den = np.convolve(den, [1, 1])\n\n    #create statespace model\n    A, B, C, D = tf2ss(num, den)\n\n    #rescale to actual frequency and make statespace model\n    omega_s = 2*np.pi*fs\n\n    #initialize parent block\n    super().__init__(omega_s*A, omega_s*B, C, D)",
              "signature": "(fs = 100, n = 1)",
              "parameters": [
                {
                  "name": "fs",
                  "type": null,
                  "default": "100",
                  "description": ""
                },
                {
                  "name": "n",
                  "type": null,
                  "default": "1",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "_n_in_max",
              "description": "",
              "type": null,
              "value": "1"
            },
            {
              "name": "_n_out_max",
              "description": "",
              "type": null,
              "value": "1"
            },
            {
              "name": "_port_map_in",
              "description": "",
              "type": null,
              "value": "{'in': 0}"
            },
            {
              "name": "_port_map_out",
              "description": "",
              "type": null,
              "value": "{'out': 0}"
            },
            {
              "name": "fs",
              "description": "",
              "type": null,
              "value": "fs"
            },
            {
              "name": "n",
              "description": "",
              "type": null,
              "value": "n"
            }
          ],
          "parameters": [
            {
              "name": "fs",
              "type": null,
              "default": "100",
              "description": "frequency for 90 deg phase shift of 1st order allpass"
            },
            {
              "name": "n",
              "type": null,
              "default": "1",
              "description": "number of cascades"
            }
          ]
        }
      ],
      "functions": []
    },
    "pathsim.blocks.fir": {
      "name": "pathsim.blocks.fir",
      "description": "",
      "docstring_html": "",
      "classes": [
        {
          "name": "FIR",
          "description": "Models a discrete-time Finite-Impulse-Response (FIR) filter.",
          "docstring_html": "<p>Models a discrete-time Finite-Impulse-Response (FIR) filter.</p>\n<p>This block applies an FIR filter to an input signal sampled periodically.\nThe output at each sample time is a weighted sum of the current and a finite number\nof past input samples. The operation is triggered by a scheduled event.</p>\n<p>Functionality:</p>\n<div class=\"math\">\n\\begin{equation*}\ny[n] = b[0] x[n] + b[1] x[n-1] + \\dots + b[N] x[n-N]\n\\end{equation*}\n</div>\n<p>where <cite>b</cite> are the filter coefficients and <cite>N</cite> is the filter order (number of\ncoefficients - 1).</p>\n<ol class=\"arabic simple\">\n<li>Samples the input <cite>inputs[0]</cite> at intervals of <cite>T</cite>, starting after delay <cite>tau</cite>.</li>\n<li>Stores the current and past <cite>len(coefficients) - 1</cite> input samples in an internal buffer.</li>\n<li>Computes the filter output using the dot product of the coefficients\nand the buffered input samples.</li>\n<li>Outputs the result on <cite>outputs[0]</cite>.</li>\n<li>Holds the output constant between updates.</li>\n</ol>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>coeffs <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array_like</span></dt>\n<dd>List or numpy array of FIR filter coefficients [b0, b1, ..., bN].\nThe number of coefficients determines the filter's order and memory.</dd>\n<dt>T <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float, optional</span></dt>\n<dd>Sampling period (time between input samples and output updates). Default is 1.</dd>\n<dt>tau <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float, optional</span></dt>\n<dd>Initial delay before the first sample is processed. Default is 0.</dd>\n</dl>\n<div class=\"section\" id=\"input-ports\">\n<h4>Input Ports</h4>\n<dl class=\"docutils\">\n<dt>inputs[0] <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>Input signal sample at the current time step.</dd>\n</dl>\n</div>\n<div class=\"section\" id=\"output-ports\">\n<h4>Output Ports</h4>\n<dl class=\"docutils\">\n<dt>outputs[0] <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>Filtered output signal sample.</dd>\n</dl>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>buffer <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">deque</span></dt>\n<dd>Internal buffer storing the most recent input samples.</dd>\n<dt>events <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">list[Schedule]</span></dt>\n<dd>Internal scheduled event triggering the filter calculation.</dd>\n</dl>\n</div>\n",
          "source": "class FIR(Block):\n    \"\"\"Models a discrete-time Finite-Impulse-Response (FIR) filter.\n\n    This block applies an FIR filter to an input signal sampled periodically.\n    The output at each sample time is a weighted sum of the current and a finite number \n    of past input samples. The operation is triggered by a scheduled event.\n\n    Functionality:\n\n    .. math::\n\n        y[n] = b[0] x[n] + b[1] x[n-1] + \\\\dots + b[N] x[n-N]\n\n    where `b` are the filter coefficients and `N` is the filter order (number of \n    coefficients - 1).\n\n    1. Samples the input `inputs[0]` at intervals of `T`, starting after delay `tau`.\n    2. Stores the current and past `len(coefficients) - 1` input samples in an internal buffer.\n    3. Computes the filter output using the dot product of the coefficients\n       and the buffered input samples.\n    4. Outputs the result on `outputs[0]`.\n    5. Holds the output constant between updates.\n\n    Parameters\n    ----------\n    coeffs : array_like\n        List or numpy array of FIR filter coefficients [b0, b1, ..., bN].\n        The number of coefficients determines the filter's order and memory.\n    T : float, optional\n        Sampling period (time between input samples and output updates). Default is 1.\n    tau : float, optional\n        Initial delay before the first sample is processed. Default is 0.\n\n    Input Ports\n    -----------\n    inputs[0] : float\n        Input signal sample at the current time step.\n\n    Output Ports\n    ------------\n    outputs[0] : float\n        Filtered output signal sample.\n\n    Attributes\n    ----------\n    buffer : deque\n        Internal buffer storing the most recent input samples.\n    events : list[Schedule]\n        Internal scheduled event triggering the filter calculation.\n    \"\"\"\n\n    #max number of ports\n    _n_in_max = 1\n    _n_out_max = 1\n\n    #maps for input and output port labels\n    _port_map_in = {\"in\": 0}\n    _port_map_out = {\"out\": 0}\n\n    def __init__(self, coeffs=[1.0], T=1, tau=0):\n        super().__init__()\n\n        self.coeffs = np.array(coeffs)\n        self.T = T\n        self.tau = tau\n\n        #buffer to store the last N+1 input samples (current + N past)\n        n = len(self.coeffs)\n        self._buffer = deque([0.0]*n, maxlen=n)\n\n        def _update_fir(t):\n\n            #update internal buffer\n            self._buffer.appendleft(self.inputs[0])\n\n            #compute the FIR output: y[n] = sum(b[k] * x[n-k])\n            current_output = np.dot(self.coeffs, self._buffer)\n\n            #update the block's output port\n            self.outputs[0] = current_output\n\n        #internal scheduled event\n        self.events = [\n            Schedule(\n                t_start=self.tau,\n                t_period=self.T,\n                func_act=_update_fir\n                )\n            ]\n\n\n    def reset(self):\n        \"\"\"Resets the filter state (buffer) and output.\"\"\"\n        super().reset()\n        n = len(self.coeffs)\n        self._buffer = deque([0.0]*n, maxlen=n)\n\n\n    def __len__(self):\n        \"\"\"This block has no direct passthrough\"\"\"\n        return 0",
          "bases": [
            "pathsim.blocks._block.Block"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, coeffs=[1.0], T=1, tau=0):\n    super().__init__()\n\n    self.coeffs = np.array(coeffs)\n    self.T = T\n    self.tau = tau\n\n    #buffer to store the last N+1 input samples (current + N past)\n    n = len(self.coeffs)\n    self._buffer = deque([0.0]*n, maxlen=n)\n\n    def _update_fir(t):\n\n        #update internal buffer\n        self._buffer.appendleft(self.inputs[0])\n\n        #compute the FIR output: y[n] = sum(b[k] * x[n-k])\n        current_output = np.dot(self.coeffs, self._buffer)\n\n        #update the block's output port\n        self.outputs[0] = current_output\n\n    #internal scheduled event\n    self.events = [\n        Schedule(\n            t_start=self.tau,\n            t_period=self.T,\n            func_act=_update_fir\n            )\n        ]",
              "signature": "(coeffs = [1.0], T = 1, tau = 0)",
              "parameters": [
                {
                  "name": "coeffs",
                  "type": null,
                  "default": "[1.0]",
                  "description": ""
                },
                {
                  "name": "T",
                  "type": null,
                  "default": "1",
                  "description": ""
                },
                {
                  "name": "tau",
                  "type": null,
                  "default": "0",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "reset",
              "description": "Resets the filter state (buffer) and output.",
              "docstring_html": "<p>Resets the filter state (buffer) and output.</p>\n",
              "source": "def reset(self):\n    \"\"\"Resets the filter state (buffer) and output.\"\"\"\n    super().reset()\n    n = len(self.coeffs)\n    self._buffer = deque([0.0]*n, maxlen=n)",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "_n_in_max",
              "description": "",
              "type": null,
              "value": "1"
            },
            {
              "name": "_n_out_max",
              "description": "",
              "type": null,
              "value": "1"
            },
            {
              "name": "_port_map_in",
              "description": "",
              "type": null,
              "value": "{'in': 0}"
            },
            {
              "name": "_port_map_out",
              "description": "",
              "type": null,
              "value": "{'out': 0}"
            },
            {
              "name": "coeffs",
              "description": "",
              "type": null,
              "value": "np.array(coeffs)"
            },
            {
              "name": "T",
              "description": "",
              "type": null,
              "value": "T"
            },
            {
              "name": "tau",
              "description": "",
              "type": null,
              "value": "tau"
            },
            {
              "name": "_buffer",
              "description": "",
              "type": null,
              "value": "deque([0.0] * n, maxlen=n)"
            },
            {
              "name": "events",
              "description": "",
              "type": null,
              "value": "[Schedule(t_start=(self.tau), t_period=(self.T), func_act=_update_fir)]"
            }
          ],
          "parameters": [
            {
              "name": "coeffs",
              "type": null,
              "default": "[1.0]",
              "description": "List or numpy array of FIR filter coefficients [b0, b1, ..., bN]. The number of coefficients determines the filter's order and memory."
            },
            {
              "name": "T",
              "type": null,
              "default": "1",
              "description": "Sampling period (time between input samples and output updates). Default is 1."
            },
            {
              "name": "tau",
              "type": null,
              "default": "0",
              "description": "Initial delay before the first sample is processed. Default is 0."
            }
          ]
        }
      ],
      "functions": []
    },
    "pathsim.blocks.function": {
      "name": "pathsim.blocks.function",
      "description": "",
      "docstring_html": "",
      "classes": [
        {
          "name": "Function",
          "description": "Arbitrary MIMO function block, defined by a callable object,",
          "docstring_html": "<p>Arbitrary MIMO function block, defined by a callable object,\ni.e. function or <cite>lambda</cite> expression.</p>\n<p>The function can have multiple arguments that are then provided\nby the input channels of the function block.</p>\n<p>Form multi input, the function has to specify multiple arguments\nand for multi output, the aoutputs have to be provided as a\ntuple or list.</p>\n<p>In the context of the global system, this block implements algebraic\ncomponents of the global system ODE/DAE.</p>\n<div class=\"math\">\n\\begin{equation*}\n\\vec{y} = \\mathrm{func}(\\vec{u})\n\\end{equation*}\n</div>\n<div class=\"section\" id=\"note\">\n<h4>Note</h4>\n<p>This block is purely algebraic and its operation (<cite>op_alg</cite>) will be called\nmultiple times per timestep, each time when <cite>Simulation._update(t)</cite> is\ncalled in the global simulation loop.\nTherefore <cite>func</cite> must be purely algebraic and not introduce states,\ndelay, etc. For interfacing with external stateful APIs, use the\nAPI block.</p>\n</div>\n<div class=\"section\" id=\"note-1\">\n<h4>Note</h4>\n<p>If the outputs are provided as a single numpy array, they are\nconsidered a single output. For MIMO, output has to be tuple.</p>\n</div>\n<div class=\"section\" id=\"example\">\n<h4>Example</h4>\n<p>consider the function:</p>\n<pre class=\"code python literal-block\">\n<span class=\"kn\">from</span><span class=\"w\"> </span><span class=\"nn\">pathsim.blocks</span><span class=\"w\"> </span><span class=\"kn\">import</span> <span class=\"n\">Function</span><span class=\"w\">\n\n</span><span class=\"k\">def</span><span class=\"w\"> </span><span class=\"nf\">f</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">,</span> <span class=\"n\">b</span><span class=\"p\">,</span> <span class=\"n\">c</span><span class=\"p\">):</span><span class=\"w\">\n</span>    <span class=\"k\">return</span> <span class=\"n\">a</span><span class=\"o\">**</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"n\">a</span><span class=\"o\">*</span><span class=\"n\">b</span><span class=\"p\">,</span> <span class=\"n\">b</span><span class=\"o\">/</span><span class=\"n\">c</span><span class=\"w\">\n\n</span><span class=\"n\">fn</span> <span class=\"o\">=</span> <span class=\"n\">Function</span><span class=\"p\">(</span><span class=\"n\">f</span><span class=\"p\">)</span>\n</pre>\n<p>then, when the block is uldated, the input channels of the block are\nassigned to the function arguments following this scheme:</p>\n<pre class=\"code literal-block\">\ninputs[0] -&gt; a\ninputs[1] -&gt; b\ninputs[2] -&gt; c\n</pre>\n<p>and the function outputs are assigned to the\noutput channels of the block in the same way:</p>\n<pre class=\"code literal-block\">\na**2 -&gt; outputs[0]\na*b  -&gt; outputs[1]\nb/c  -&gt; outputs[2]\n</pre>\n<p>Because the <cite>Function</cite> block only has a single argument, it can be\nused to decorate a function and make it a <cite>PathSim</cite> block. This might\nbe handy in some cases to keep definitions concise and localized\nin the code:</p>\n<pre class=\"code python literal-block\">\n<span class=\"kn\">from</span><span class=\"w\"> </span><span class=\"nn\">pathsim.blocks</span><span class=\"w\"> </span><span class=\"kn\">import</span> <span class=\"n\">Function</span><span class=\"w\">\n\n</span><span class=\"c1\">#does the same as the definition above</span><span class=\"w\">\n\n</span><span class=\"nd\">&#64;Function</span><span class=\"w\">\n</span><span class=\"k\">def</span><span class=\"w\"> </span><span class=\"nf\">fn</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">,</span> <span class=\"n\">b</span><span class=\"p\">,</span> <span class=\"n\">c</span><span class=\"p\">):</span><span class=\"w\">\n</span>    <span class=\"k\">return</span> <span class=\"n\">a</span><span class=\"o\">**</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"n\">a</span><span class=\"o\">*</span><span class=\"n\">b</span><span class=\"p\">,</span> <span class=\"n\">b</span><span class=\"o\">/</span><span class=\"n\">c</span><span class=\"w\">\n\n</span><span class=\"c1\">#'fn' is now a PathSim block</span>\n</pre>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>func <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">callable</span></dt>\n<dd>MIMO function that defines algebraic block IO behaviour</dd>\n</dl>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>op_alg <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">Operator</span></dt>\n<dd>internal algebraic operator that wraps 'func'</dd>\n</dl>\n</div>\n",
          "source": "class Function(Block):\n    \"\"\"Arbitrary MIMO function block, defined by a callable object, \n    i.e. function or `lambda` expression.\n\n    The function can have multiple arguments that are then provided \n    by the input channels of the function block.\n\n    Form multi input, the function has to specify multiple arguments\n    and for multi output, the aoutputs have to be provided as a \n    tuple or list. \n\n    In the context of the global system, this block implements algebraic \n    components of the global system ODE/DAE.\n\n    .. math::\n\n        \\\\vec{y} = \\\\mathrm{func}(\\\\vec{u})\n\n\n    Note\n    ----\n    This block is purely algebraic and its operation (`op_alg`) will be called \n    multiple times per timestep, each time when `Simulation._update(t)` is \n    called in the global simulation loop.\n    Therefore `func` must be purely algebraic and not introduce states, \n    delay, etc. For interfacing with external stateful APIs, use the \n    API block.\n\n\n    Note\n    -----\n    If the outputs are provided as a single numpy array, they are \n    considered a single output. For MIMO, output has to be tuple.\n\n\n    Example\n    -------\n    consider the function: \n\n    .. code-block:: python\n\n        from pathsim.blocks import Function\n\n        def f(a, b, c):\n            return a**2, a*b, b/c\n\n        fn = Function(f)\n\n\n    then, when the block is uldated, the input channels of the block are \n    assigned to the function arguments following this scheme:\n\n    .. code-block::\n\n        inputs[0] -> a\n        inputs[1] -> b\n        inputs[2] -> c\n\n    and the function outputs are assigned to the \n    output channels of the block in the same way:\n\n    .. code-block::\n\n        a**2 -> outputs[0]\n        a*b  -> outputs[1]\n        b/c  -> outputs[2]\n\n    Because the `Function` block only has a single argument, it can be \n    used to decorate a function and make it a `PathSim` block. This might \n    be handy in some cases to keep definitions concise and localized \n    in the code:\n\n    .. code-block:: python\n\n        from pathsim.blocks import Function\n\n        #does the same as the definition above\n\n        @Function\n        def fn(a, b, c):\n            return a**2, a*b, b/c\n\n        #'fn' is now a PathSim block\n\n\n    Parameters\n    ---------- \n    func : callable\n        MIMO function that defines algebraic block IO behaviour\n\n\n    Attributes\n    ----------\n    op_alg : Operator\n        internal algebraic operator that wraps 'func'\n\n    \"\"\"\n\n    def __init__(self, func=lambda x: x):\n        super().__init__()\n\n        #some checks to ensure that function works correctly\n        if not callable(func):  \n            raise ValueError(f\"'{func}' is not callable\")\n\n        #function defining the block update\n        self.func = func\n        self.op_alg = Operator(func=lambda x: func(*x))\n\n\n    def update(self, t):\n        \"\"\"Evaluate function block as part of algebraic component \n        of global system DAE. \n\n        With convergence control for algebraic loop solver.\n\n        Parameters\n        ----------\n        t : float\n            evaluation time\n        \"\"\"\n\n        #apply operator to get output\n        y = self.op_alg(self.inputs.to_array())\n        self.outputs.update_from_array(y)",
          "bases": [
            "pathsim.blocks._block.Block"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, func=lambda x: x):\n    super().__init__()\n\n    #some checks to ensure that function works correctly\n    if not callable(func):  \n        raise ValueError(f\"'{func}' is not callable\")\n\n    #function defining the block update\n    self.func = func\n    self.op_alg = Operator(func=lambda x: func(*x))",
              "signature": "(func = lambda x: x)",
              "parameters": [
                {
                  "name": "func",
                  "type": null,
                  "default": "lambda x: x",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "update",
              "description": "Evaluate function block as part of algebraic component",
              "docstring_html": "<p>Evaluate function block as part of algebraic component\nof global system DAE.</p>\n<p>With convergence control for algebraic loop solver.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time</dd>\n</dl>\n",
              "source": "def update(self, t):\n    \"\"\"Evaluate function block as part of algebraic component \n    of global system DAE. \n\n    With convergence control for algebraic loop solver.\n\n    Parameters\n    ----------\n    t : float\n        evaluation time\n    \"\"\"\n\n    #apply operator to get output\n    y = self.op_alg(self.inputs.to_array())\n    self.outputs.update_from_array(y)",
              "signature": "(t)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time"
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "func",
              "description": "",
              "type": null,
              "value": "func"
            },
            {
              "name": "op_alg",
              "description": "",
              "type": null,
              "value": "Operator(func=(lambda x: func(*x)))"
            }
          ],
          "parameters": [
            {
              "name": "func",
              "type": null,
              "default": "lambda x: x",
              "description": "MIMO function that defines algebraic block IO behaviour"
            }
          ]
        }
      ],
      "functions": []
    },
    "pathsim.blocks.integrator": {
      "name": "pathsim.blocks.integrator",
      "description": "",
      "docstring_html": "",
      "classes": [
        {
          "name": "Integrator",
          "description": "Integrates the input signal using a numerical integration engine like this:",
          "docstring_html": "<p>Integrates the input signal using a numerical integration engine like this:</p>\n<div class=\"math\">\n\\begin{equation*}\ny(t) = \\int_0^t u(\\tau) \\ d \\tau\n\\end{equation*}\n</div>\n<p>or in differential form like this:</p>\n<div class=\"math\">\n\\begin{equation*}\n\\begin{eqnarray}\n    \\dot{x}(t) &amp;= u(t) \\\\\n           y(t) &amp;= x(t)\n\\end{eqnarray}\n\\end{equation*}\n</div>\n<p>The Integrator block is inherently MIMO capable, so <cite>u</cite> and <cite>y</cite> can be vectors.</p>\n<div class=\"section\" id=\"example\">\n<h4>Example</h4>\n<p>This is how to initialize the integrator:</p>\n<pre class=\"code python literal-block\">\n<span class=\"c1\">#initial value 0.0</span><span class=\"w\">\n</span><span class=\"n\">i1</span> <span class=\"o\">=</span> <span class=\"n\">Integrator</span><span class=\"p\">()</span><span class=\"w\">\n\n</span><span class=\"c1\">#initial value 2.5</span><span class=\"w\">\n</span><span class=\"n\">i2</span> <span class=\"o\">=</span> <span class=\"n\">Integrator</span><span class=\"p\">(</span><span class=\"mf\">2.5</span><span class=\"p\">)</span>\n</pre>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>initial_value <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float, array</span></dt>\n<dd>initial value of integrator</dd>\n</dl>\n</div>\n",
          "source": "class Integrator(Block):\n    \"\"\"Integrates the input signal using a numerical integration engine like this:\n\n    .. math::\n\n        y(t) = \\\\int_0^t u(\\\\tau) \\\\ d \\\\tau\n\n    or in differential form like this:\n\n    .. math::\n        \\\\begin{eqnarray}\n            \\\\dot{x}(t) &= u(t) \\\\\\\\\n                   y(t) &= x(t) \n        \\\\end{eqnarray}\n\n    The Integrator block is inherently MIMO capable, so `u` and `y` can be vectors.\n\n    Example\n    -------\n    This is how to initialize the integrator: \n\n    .. code-block:: python\n\n        #initial value 0.0\n        i1 = Integrator()\n\n        #initial value 2.5\n        i2 = Integrator(2.5)\n\n\n    Parameters\n    ----------\n    initial_value : float, array\n        initial value of integrator\n    \"\"\"\n\n    def __init__(self, initial_value=0.0):\n        super().__init__()\n\n        #save initial value\n        self.initial_value = initial_value\n\n\n    def __len__(self):\n        return 0\n\n\n    def set_solver(self, Solver, **solver_args):\n        \"\"\"set the internal numerical integrator\n\n        Parameters\n        ----------\n        Solver : Solver\n            numerical integration solver class\n        solver_args : dict\n            parameters for solver initialization\n        \"\"\"\n\n        if self.engine is None:\n            #initialize the integration engine\n            self.engine = Solver(self.initial_value, **solver_args)\n\n        else:\n            #change solver if already initialized\n            self.engine = Solver.cast(self.engine, **solver_args)\n\n\n    def update(self, t):\n        \"\"\"update system equation fixed point loop\n\n        Note\n        ----\n        integrator does not have passthrough, therefore this \n        method is performance optimized for this case\n\n        Parameters\n        ----------\n        t : float\n            evaluation time\n        \"\"\"\n        self.outputs.update_from_array(self.engine.get())\n\n\n    def solve(self, t, dt):\n        \"\"\"advance solution of implicit update equation of the solver\n\n        Parameters\n        ----------\n        t : float\n            evaluation time\n        dt : float\n            integration timestep\n\n        Returns\n        ------- \n        error : float\n            solver residual norm\n        \"\"\"\n        f = self.inputs.to_array()\n        return self.engine.solve(f, None, dt)\n\n\n    def step(self, t, dt):\n        \"\"\"compute timestep update with integration engine\n\n        Parameters\n        ----------\n        t : float\n            evaluation time\n        dt : float\n            integration timestep\n\n        Returns\n        ------- \n        success : bool\n            step was successful\n        error : float\n            local truncation error from adaptive integrators\n        scale : float\n            timestep rescale from adaptive integrators\n        \"\"\"\n        f = self.inputs.to_array()\n        return self.engine.step(f, dt)",
          "bases": [
            "pathsim.blocks._block.Block"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, initial_value=0.0):\n    super().__init__()\n\n    #save initial value\n    self.initial_value = initial_value",
              "signature": "(initial_value = 0.0)",
              "parameters": [
                {
                  "name": "initial_value",
                  "type": null,
                  "default": "0.0",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "set_solver",
              "description": "set the internal numerical integrator",
              "docstring_html": "<p>set the internal numerical integrator</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>Solver <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">Solver</span></dt>\n<dd>numerical integration solver class</dd>\n<dt>solver_args <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">dict</span></dt>\n<dd>parameters for solver initialization</dd>\n</dl>\n",
              "source": "def set_solver(self, Solver, **solver_args):\n    \"\"\"set the internal numerical integrator\n\n    Parameters\n    ----------\n    Solver : Solver\n        numerical integration solver class\n    solver_args : dict\n        parameters for solver initialization\n    \"\"\"\n\n    if self.engine is None:\n        #initialize the integration engine\n        self.engine = Solver(self.initial_value, **solver_args)\n\n    else:\n        #change solver if already initialized\n        self.engine = Solver.cast(self.engine, **solver_args)",
              "signature": "(Solver, solver_args = {})",
              "parameters": [
                {
                  "name": "Solver",
                  "type": null,
                  "default": null,
                  "description": "numerical integration solver class"
                },
                {
                  "name": "solver_args",
                  "type": null,
                  "default": "{}",
                  "description": "parameters for solver initialization"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "update",
              "description": "update system equation fixed point loop",
              "docstring_html": "<p>update system equation fixed point loop</p>\n<div class=\"section\" id=\"note\">\n<h4>Note</h4>\n<p>integrator does not have passthrough, therefore this\nmethod is performance optimized for this case</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time</dd>\n</dl>\n</div>\n",
              "source": "def update(self, t):\n    \"\"\"update system equation fixed point loop\n\n    Note\n    ----\n    integrator does not have passthrough, therefore this \n    method is performance optimized for this case\n\n    Parameters\n    ----------\n    t : float\n        evaluation time\n    \"\"\"\n    self.outputs.update_from_array(self.engine.get())",
              "signature": "(t)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "solve",
              "description": "advance solution of implicit update equation of the solver",
              "docstring_html": "<p>advance solution of implicit update equation of the solver</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time</dd>\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>integration timestep</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>error <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>solver residual norm</dd>\n</dl>\n",
              "source": "def solve(self, t, dt):\n    \"\"\"advance solution of implicit update equation of the solver\n\n    Parameters\n    ----------\n    t : float\n        evaluation time\n    dt : float\n        integration timestep\n\n    Returns\n    ------- \n    error : float\n        solver residual norm\n    \"\"\"\n    f = self.inputs.to_array()\n    return self.engine.solve(f, None, dt)",
              "signature": "(t, dt)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time"
                },
                {
                  "name": "dt",
                  "type": null,
                  "default": null,
                  "description": "integration timestep"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "step",
              "description": "compute timestep update with integration engine",
              "docstring_html": "<p>compute timestep update with integration engine</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time</dd>\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>integration timestep</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>success <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>step was successful</dd>\n<dt>error <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>local truncation error from adaptive integrators</dd>\n<dt>scale <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>timestep rescale from adaptive integrators</dd>\n</dl>\n",
              "source": "def step(self, t, dt):\n    \"\"\"compute timestep update with integration engine\n\n    Parameters\n    ----------\n    t : float\n        evaluation time\n    dt : float\n        integration timestep\n\n    Returns\n    ------- \n    success : bool\n        step was successful\n    error : float\n        local truncation error from adaptive integrators\n    scale : float\n        timestep rescale from adaptive integrators\n    \"\"\"\n    f = self.inputs.to_array()\n    return self.engine.step(f, dt)",
              "signature": "(t, dt)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time"
                },
                {
                  "name": "dt",
                  "type": null,
                  "default": null,
                  "description": "integration timestep"
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "initial_value",
              "description": "",
              "type": null,
              "value": "initial_value"
            }
          ],
          "parameters": [
            {
              "name": "initial_value",
              "type": null,
              "default": "0.0",
              "description": "initial value of integrator"
            }
          ]
        }
      ],
      "functions": []
    },
    "pathsim.blocks.lti": {
      "name": "pathsim.blocks.lti",
      "description": "",
      "docstring_html": "",
      "classes": [
        {
          "name": "StateSpace",
          "description": "This block defines a linear time invariant (LTI) multi input multi output (MIMO)",
          "docstring_html": "<p>This block defines a linear time invariant (LTI) multi input multi output (MIMO)\nstate space model with the structure</p>\n<div class=\"math\">\n\\begin{equation*}\n\\begin{eqnarray}\n    \\dot{x} &amp;= \\mathbf{A} x + \\mathbf{B} u \\\\\n           y &amp;= \\mathbf{C} x + \\mathbf{D} u\n\\end{eqnarray}\n\\end{equation*}\n</div>\n<p>where <cite>A</cite>, <cite>B</cite>, <cite>C</cite> and <cite>D</cite> are the state space matrices, <cite>x</cite> is the state,\n<cite>u</cite> the input and <cite>y</cite> the output vector.</p>\n<div class=\"section\" id=\"example\">\n<h4>Example</h4>\n<p>A SISO state space block with two internal states can be initialized\nlike this:</p>\n<pre class=\"code python literal-block\">\n<span class=\"n\">S</span> <span class=\"o\">=</span> <span class=\"n\">StateSpace</span><span class=\"p\">(</span><span class=\"w\">\n</span>    <span class=\"n\">A</span><span class=\"o\">=-</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">eye</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">),</span><span class=\"w\">\n</span>    <span class=\"n\">B</span><span class=\"o\">=</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">ones</span><span class=\"p\">((</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">)),</span><span class=\"w\">\n</span>    <span class=\"n\">C</span><span class=\"o\">=</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">ones</span><span class=\"p\">((</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">)),</span><span class=\"w\">\n</span>    <span class=\"n\">D</span><span class=\"o\">=</span><span class=\"mf\">1.0</span><span class=\"w\">\n</span>    <span class=\"p\">)</span>\n</pre>\n<p>and a MIMO (2 in, 2 out) state space block with three internal states\ncan be initialized like this:</p>\n<pre class=\"code python literal-block\">\n<span class=\"n\">S</span> <span class=\"o\">=</span> <span class=\"n\">StateSpace</span><span class=\"p\">(</span><span class=\"w\">\n</span>    <span class=\"n\">A</span><span class=\"o\">=-</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">eye</span><span class=\"p\">(</span><span class=\"mi\">3</span><span class=\"p\">),</span><span class=\"w\">\n</span>    <span class=\"n\">B</span><span class=\"o\">=</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">ones</span><span class=\"p\">((</span><span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">)),</span><span class=\"w\">\n</span>    <span class=\"n\">C</span><span class=\"o\">=</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">ones</span><span class=\"p\">((</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">)),</span><span class=\"w\">\n</span>    <span class=\"n\">D</span><span class=\"o\">=</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">ones</span><span class=\"p\">((</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">))</span><span class=\"w\">\n</span>    <span class=\"p\">)</span>\n</pre>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>A, B, C, D <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array_like</span></dt>\n<dd>real valued state space matrices</dd>\n<dt>initial_value <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array_like, None</span></dt>\n<dd>initial state / initial condition</dd>\n</dl>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>op_dyn <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">DynamicOperator</span></dt>\n<dd>internal dynamic operator for state equation</dd>\n<dt>op_alg <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">DynamicOperator</span></dt>\n<dd>internal algebraic operator for mapping to outputs</dd>\n</dl>\n</div>\n",
          "source": "class StateSpace(Block):\n    \"\"\"\n    This block defines a linear time invariant (LTI) multi input multi output (MIMO) \n    state space model with the structure\n\n    .. math::\n\n        \\\\begin{eqnarray}\n            \\\\dot{x} &= \\\\mathbf{A} x + \\\\mathbf{B} u \\\\\\\\\n                   y &= \\\\mathbf{C} x + \\\\mathbf{D} u \n        \\\\end{eqnarray}\n\n    where `A`, `B`, `C` and `D` are the state space matrices, `x` is the state, \n    `u` the input and `y` the output vector.\n\n    Example\n    -------\n    A SISO state space block with two internal states can be initialized \n    like this:\n\n    .. code-block:: python\n\n        S = StateSpace(\n            A=-np.eye(2), \n            B=np.ones((2, 1)), \n            C=np.ones((1, 2)), \n            D=1.0\n            )\n\n    and a MIMO (2 in, 2 out) state space block with three internal states \n    can be initialized like this:\n\n    .. code-block:: python\n\n        S = StateSpace(\n            A=-np.eye(3), \n            B=np.ones((3, 2)), \n            C=np.ones((2, 3)), \n            D=np.ones((2, 2))\n            )\n\n    Parameters\n    ----------\n    A, B, C, D : array_like\n        real valued state space matrices\n    initial_value : array_like, None\n        initial state / initial condition\n\n    Attributes\n    ----------\n    op_dyn : DynamicOperator\n        internal dynamic operator for state equation\n    op_alg : DynamicOperator\n        internal algebraic operator for mapping to outputs\n    \"\"\"\n\n    def __init__(self, \n                 A=-1.0, B=1.0, C=-1.0, D=1.0, \n                 initial_value=None):\n        super().__init__()\n\n        #statespace matrices with input shape validation\n        self.A = np.atleast_2d(A)\n        self.B = np.atleast_1d(B)\n        self.C = np.atleast_1d(C)\n        self.D = np.atleast_1d(D)\n\n        #get statespace dimensions\n        n, _ = self.A.shape \n        if self.B.ndim == 1: n_in = 1 \n        else: _, n_in = self.B.shape \n        if self.C.ndim == 1: n_out = 1 \n        else: n_out, _ = self.C.shape\n\n        #set io channels\n        self.inputs = Register(n_in)\n        self.outputs = Register(n_out)\n\n        #initial condition and shape validation\n        if initial_value is None:\n            self.initial_value = np.zeros(n)\n        else: \n            self.initial_value = np.atleast_1d(initial_value)\n\n        #operators\n        self.op_dyn = DynamicOperator(\n            func=lambda x, u, t: np.dot(self.A, x) + np.dot(self.B, u),\n            jac_x=lambda x, u, t: self.A,\n            jac_u=lambda x, u, t: self.B\n            )\n        self.op_alg = DynamicOperator(\n            func=lambda x, u, t: np.dot(self.C, x) + np.dot(self.D, u),\n            jac_x=lambda x, u, t: self.C,\n            jac_u=lambda x, u, t: self.D\n            )\n\n\n    def __len__(self):\n        #check if direct passthrough exists\n        return int(np.any(self.D)) if self._active else 0\n\n\n    def set_solver(self, Solver, **solver_args):\n        \"\"\"set the internal numerical integrator\n\n        Parameters\n        ----------\n        Solver : Solver\n            numerical integration solver class\n        solver_args : dict\n            parameters for solver initialization\n        \"\"\"\n\n        if self.engine is None:\n            #initialize the integration engine with right hand side\n            self.engine = Solver(self.initial_value, **solver_args)\n\n        else:\n            #change solver if already initialized\n            self.engine = Solver.cast(self.engine, **solver_args)\n\n\n    def solve(self, t, dt):\n        \"\"\"advance solution of implicit update equation of the solver\n\n        Parameters\n        ----------\n        t : float\n            evaluation time\n        dt : float\n            integration timestep\n\n        Returns\n        ------- \n        error : float\n            solver residual norm\n        \"\"\"\n        x, u = self.engine.get(), self.inputs.to_array()\n        f, J = self.op_dyn(x, u, t), self.op_dyn.jac_x(x, u, t)\n        return self.engine.solve(f, J, dt)\n\n\n    def step(self, t, dt):\n        \"\"\"compute timestep update with integration engine\n\n        Parameters\n        ----------\n        t : float\n            evaluation time\n        dt : float\n            integration timestep\n\n        Returns\n        ------- \n        success : bool\n            step was successful\n        error : float\n            local truncation error from adaptive integrators\n        scale : float\n            timestep rescale from adaptive integrators\n        \"\"\"\n        x, u = self.engine.get(), self.inputs.to_array()\n        f = self.op_dyn(x, u, t)\n        return self.engine.step(f, dt)",
          "bases": [
            "pathsim.blocks._block.Block"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, \n             A=-1.0, B=1.0, C=-1.0, D=1.0, \n             initial_value=None):\n    super().__init__()\n\n    #statespace matrices with input shape validation\n    self.A = np.atleast_2d(A)\n    self.B = np.atleast_1d(B)\n    self.C = np.atleast_1d(C)\n    self.D = np.atleast_1d(D)\n\n    #get statespace dimensions\n    n, _ = self.A.shape \n    if self.B.ndim == 1: n_in = 1 \n    else: _, n_in = self.B.shape \n    if self.C.ndim == 1: n_out = 1 \n    else: n_out, _ = self.C.shape\n\n    #set io channels\n    self.inputs = Register(n_in)\n    self.outputs = Register(n_out)\n\n    #initial condition and shape validation\n    if initial_value is None:\n        self.initial_value = np.zeros(n)\n    else: \n        self.initial_value = np.atleast_1d(initial_value)\n\n    #operators\n    self.op_dyn = DynamicOperator(\n        func=lambda x, u, t: np.dot(self.A, x) + np.dot(self.B, u),\n        jac_x=lambda x, u, t: self.A,\n        jac_u=lambda x, u, t: self.B\n        )\n    self.op_alg = DynamicOperator(\n        func=lambda x, u, t: np.dot(self.C, x) + np.dot(self.D, u),\n        jac_x=lambda x, u, t: self.C,\n        jac_u=lambda x, u, t: self.D\n        )",
              "signature": "(A = -1.0, B = 1.0, C = -1.0, D = 1.0, initial_value = None)",
              "parameters": [
                {
                  "name": "A",
                  "type": null,
                  "default": "-1.0",
                  "description": ""
                },
                {
                  "name": "B",
                  "type": null,
                  "default": "1.0",
                  "description": ""
                },
                {
                  "name": "C",
                  "type": null,
                  "default": "-1.0",
                  "description": ""
                },
                {
                  "name": "D",
                  "type": null,
                  "default": "1.0",
                  "description": ""
                },
                {
                  "name": "initial_value",
                  "type": null,
                  "default": "None",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "set_solver",
              "description": "set the internal numerical integrator",
              "docstring_html": "<p>set the internal numerical integrator</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>Solver <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">Solver</span></dt>\n<dd>numerical integration solver class</dd>\n<dt>solver_args <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">dict</span></dt>\n<dd>parameters for solver initialization</dd>\n</dl>\n",
              "source": "def set_solver(self, Solver, **solver_args):\n    \"\"\"set the internal numerical integrator\n\n    Parameters\n    ----------\n    Solver : Solver\n        numerical integration solver class\n    solver_args : dict\n        parameters for solver initialization\n    \"\"\"\n\n    if self.engine is None:\n        #initialize the integration engine with right hand side\n        self.engine = Solver(self.initial_value, **solver_args)\n\n    else:\n        #change solver if already initialized\n        self.engine = Solver.cast(self.engine, **solver_args)",
              "signature": "(Solver, solver_args = {})",
              "parameters": [
                {
                  "name": "Solver",
                  "type": null,
                  "default": null,
                  "description": "numerical integration solver class"
                },
                {
                  "name": "solver_args",
                  "type": null,
                  "default": "{}",
                  "description": "parameters for solver initialization"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "solve",
              "description": "advance solution of implicit update equation of the solver",
              "docstring_html": "<p>advance solution of implicit update equation of the solver</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time</dd>\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>integration timestep</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>error <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>solver residual norm</dd>\n</dl>\n",
              "source": "def solve(self, t, dt):\n    \"\"\"advance solution of implicit update equation of the solver\n\n    Parameters\n    ----------\n    t : float\n        evaluation time\n    dt : float\n        integration timestep\n\n    Returns\n    ------- \n    error : float\n        solver residual norm\n    \"\"\"\n    x, u = self.engine.get(), self.inputs.to_array()\n    f, J = self.op_dyn(x, u, t), self.op_dyn.jac_x(x, u, t)\n    return self.engine.solve(f, J, dt)",
              "signature": "(t, dt)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time"
                },
                {
                  "name": "dt",
                  "type": null,
                  "default": null,
                  "description": "integration timestep"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "step",
              "description": "compute timestep update with integration engine",
              "docstring_html": "<p>compute timestep update with integration engine</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time</dd>\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>integration timestep</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>success <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>step was successful</dd>\n<dt>error <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>local truncation error from adaptive integrators</dd>\n<dt>scale <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>timestep rescale from adaptive integrators</dd>\n</dl>\n",
              "source": "def step(self, t, dt):\n    \"\"\"compute timestep update with integration engine\n\n    Parameters\n    ----------\n    t : float\n        evaluation time\n    dt : float\n        integration timestep\n\n    Returns\n    ------- \n    success : bool\n        step was successful\n    error : float\n        local truncation error from adaptive integrators\n    scale : float\n        timestep rescale from adaptive integrators\n    \"\"\"\n    x, u = self.engine.get(), self.inputs.to_array()\n    f = self.op_dyn(x, u, t)\n    return self.engine.step(f, dt)",
              "signature": "(t, dt)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time"
                },
                {
                  "name": "dt",
                  "type": null,
                  "default": null,
                  "description": "integration timestep"
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "A",
              "description": "",
              "type": null,
              "value": "np.atleast_2d(A)"
            },
            {
              "name": "B",
              "description": "",
              "type": null,
              "value": "np.atleast_1d(B)"
            },
            {
              "name": "C",
              "description": "",
              "type": null,
              "value": "np.atleast_1d(C)"
            },
            {
              "name": "D",
              "description": "",
              "type": null,
              "value": "np.atleast_1d(D)"
            },
            {
              "name": "inputs",
              "description": "",
              "type": null,
              "value": "Register(n_in)"
            },
            {
              "name": "outputs",
              "description": "",
              "type": null,
              "value": "Register(n_out)"
            },
            {
              "name": "initial_value",
              "description": "",
              "type": null,
              "value": "np.zeros(n)"
            },
            {
              "name": "op_dyn",
              "description": "",
              "type": null,
              "value": "DynamicOperator(func=(lambda x, u, t: np.dot(self.A, x) + np.dot(self.B, u)), jac_x=(lambda x, u, t: self.A), jac_u=(lambda x, u, t: self.B))"
            },
            {
              "name": "op_alg",
              "description": "",
              "type": null,
              "value": "DynamicOperator(func=(lambda x, u, t: np.dot(self.C, x) + np.dot(self.D, u)), jac_x=(lambda x, u, t: self.C), jac_u=(lambda x, u, t: self.D))"
            }
          ],
          "parameters": [
            {
              "name": "A",
              "type": null,
              "default": "-1.0",
              "description": ""
            },
            {
              "name": "B",
              "type": null,
              "default": "1.0",
              "description": ""
            },
            {
              "name": "C",
              "type": null,
              "default": "-1.0",
              "description": ""
            },
            {
              "name": "D",
              "type": null,
              "default": "1.0",
              "description": "real valued state space matrices"
            },
            {
              "name": "initial_value",
              "type": null,
              "default": "None",
              "description": "initial state / initial condition"
            }
          ]
        },
        {
          "name": "TransferFunctionPRC",
          "description": "This block defines a LTI (MIMO for pole residue) transfer function.",
          "docstring_html": "<p>This block defines a LTI (MIMO for pole residue) transfer function.</p>\n<p>The transfer function is defined in pole-residue-constant (PRC) form</p>\n<div class=\"math\">\n\\begin{equation*}\n\\mathbf{H}(s) = \\mathbf{C} + \\sum_n^N \\frac{\\mathbf{R}_n}{s - p_n}\n\\end{equation*}\n</div>\n<p>where 'Poles' are the scalar (possibly complex conjugate) poles of the\ntransfer function and 'Residues' are the possibly matrix valued (in MIMO case)\nand complex conjugate residues of the transfer function. 'Const' has same\nshape as 'Residues'.</p>\n<p>Upon initialization, the state space realization of the transfer\nfunction is computed using a minimal gilbert realization.</p>\n<p>The resulting state space model of the form</p>\n<div class=\"math\">\n\\begin{equation*}\n\\begin{eqnarray}\n    \\dot{x} &amp;= \\mathbf{A} x + \\mathbf{B} u \\\\\n           y &amp;= \\mathbf{C} x + \\mathbf{D} u\n\\end{eqnarray}\n\\end{equation*}\n</div>\n<p>is handled the same as the 'StateSpace' block, where <cite>A</cite>, <cite>B</cite>, <cite>C</cite> and <cite>D</cite>\nare the state space matrices, <cite>x</cite> is the internal state, <cite>u</cite> the input and\n<cite>y</cite> the output vector.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>Poles <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array</span></dt>\n<dd>transfer function poles</dd>\n<dt>Residues <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array</span></dt>\n<dd>transfer function residues</dd>\n<dt>Const <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array, float</span></dt>\n<dd>constant term of transfer function</dd>\n</dl>\n",
          "source": "class TransferFunctionPRC(StateSpace):\n    \"\"\"This block defines a LTI (MIMO for pole residue) transfer function.\n\n    The transfer function is defined in pole-residue-constant (PRC) form\n\n    .. math::\n\n        \\\\mathbf{H}(s) = \\\\mathbf{C} + \\\\sum_n^N \\\\frac{\\\\mathbf{R}_n}{s - p_n}\n\n    where 'Poles' are the scalar (possibly complex conjugate) poles of the \n    transfer function and 'Residues' are the possibly matrix valued (in MIMO case) \n    and complex conjugate residues of the transfer function. 'Const' has same \n    shape as 'Residues'.\n\n    Upon initialization, the state space realization of the transfer \n    function is computed using a minimal gilbert realization.\n\n    The resulting state space model of the form\n\n    .. math::\n\n        \\\\begin{eqnarray}\n            \\\\dot{x} &= \\\\mathbf{A} x + \\\\mathbf{B} u \\\\\\\\\n                   y &= \\\\mathbf{C} x + \\\\mathbf{D} u \n        \\\\end{eqnarray}\n\n    is handled the same as the 'StateSpace' block, where `A`, `B`, `C` and `D` \n    are the state space matrices, `x` is the internal state, `u` the input and \n    `y` the output vector.\n\n    Parameters\n    ----------\n    Poles : array\n        transfer function poles\n    Residues : array\n        transfer function residues\n    Const : array, float\n        constant term of transfer function\n    \"\"\"\n\n    def __init__(self, Poles=[], Residues=[], Const=0.0):\n\n        #parameters of transfer function in pole-residue-const form\n        self.Const, self.Poles, self.Residues = Const, Poles, Residues\n\n        #Statespace realization of transfer function\n        A, B, C, D = gilbert_realization(Poles, Residues, Const)\n\n        #initialize statespace model\n        super().__init__(A, B, C, D)",
          "bases": [
            "pathsim.blocks.lti.StateSpace"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, Poles=[], Residues=[], Const=0.0):\n\n    #parameters of transfer function in pole-residue-const form\n    self.Const, self.Poles, self.Residues = Const, Poles, Residues\n\n    #Statespace realization of transfer function\n    A, B, C, D = gilbert_realization(Poles, Residues, Const)\n\n    #initialize statespace model\n    super().__init__(A, B, C, D)",
              "signature": "(Poles = [], Residues = [], Const = 0.0)",
              "parameters": [
                {
                  "name": "Poles",
                  "type": null,
                  "default": "[]",
                  "description": ""
                },
                {
                  "name": "Residues",
                  "type": null,
                  "default": "[]",
                  "description": ""
                },
                {
                  "name": "Const",
                  "type": null,
                  "default": "0.0",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [],
          "parameters": [
            {
              "name": "Poles",
              "type": null,
              "default": "[]",
              "description": "transfer function poles"
            },
            {
              "name": "Residues",
              "type": null,
              "default": "[]",
              "description": "transfer function residues"
            },
            {
              "name": "Const",
              "type": null,
              "default": "0.0",
              "description": "constant term of transfer function"
            }
          ]
        },
        {
          "name": "TransferFunction",
          "description": "Alias for `TransferFunctionPRC`.",
          "docstring_html": "<p>Alias for <cite>TransferFunctionPRC</cite>.</p>\n<div class=\"admonition warning\">\n<p class=\"first admonition-title\">Warning</p>\n<p class=\"last\">This class will be deprecated in the future as it is an alias for <cite>TransferFunctionPRC</cite>.\nPlease use <cite>TransferFunctionPRC</cite> for future code.</p>\n</div>\n",
          "source": "class TransferFunction(TransferFunctionPRC): \n    \"\"\"Alias for `TransferFunctionPRC`.\n\n    .. warning::\n\n        This class will be deprecated in the future as it is an alias for `TransferFunctionPRC`.\n        Please use `TransferFunctionPRC` for future code.\n    \"\"\"\n\n    def __init__(self, Poles=[], Residues=[], Const=0.0):\n        super().__init__(Poles, Residues, Const)\n\n        import warnings\n        warnings.warn(\n            \"'TransferFunction' is an alias for 'TransferFunctionPRC' and will be deprecated in the future!\"\n            )",
          "bases": [
            "pathsim.blocks.lti.TransferFunctionPRC"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, Poles=[], Residues=[], Const=0.0):\n    super().__init__(Poles, Residues, Const)\n\n    import warnings\n    warnings.warn(\n        \"'TransferFunction' is an alias for 'TransferFunctionPRC' and will be deprecated in the future!\"\n        )",
              "signature": "(Poles = [], Residues = [], Const = 0.0)",
              "parameters": [
                {
                  "name": "Poles",
                  "type": null,
                  "default": "[]",
                  "description": ""
                },
                {
                  "name": "Residues",
                  "type": null,
                  "default": "[]",
                  "description": ""
                },
                {
                  "name": "Const",
                  "type": null,
                  "default": "0.0",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [],
          "parameters": [
            {
              "name": "Poles",
              "type": null,
              "default": "[]",
              "description": ""
            },
            {
              "name": "Residues",
              "type": null,
              "default": "[]",
              "description": ""
            },
            {
              "name": "Const",
              "type": null,
              "default": "0.0",
              "description": ""
            }
          ]
        },
        {
          "name": "TransferFunctionZPG",
          "description": "This block defines a LTI (SISO) transfer function.",
          "docstring_html": "<p>This block defines a LTI (SISO) transfer function.</p>\n<p>The transfer function is defined in zeros-poles-gain (ZPG) form</p>\n<div class=\"math\">\n\\begin{equation*}\n\\mathbf{H}(s) = k \\frac{(s - z_1)(s - z_2)\\cdots(s - z_m)}{(s - p_1)(s - p_2)\\cdots(s - p_n)}\n\\end{equation*}\n</div>\n<p>where <cite>Zeros</cite> are the scalar (possibly complex conjugate) zeros of the\ntransfer function, and <cite>Poles</cite> are the poles (denominator zeros) of the\ntransfer function. <cite>Gain</cite> is the scalar factor <cite>k</cite>.</p>\n<p>Upon initialization, the state space realization of the transfer function is\ncomputed using <cite>scipy.signal.ZerosPolesGain(Zeros, Poles, Gain).to_ss()</cite>.</p>\n<p>The resulting state space model of the form</p>\n<div class=\"math\">\n\\begin{equation*}\n\\begin{eqnarray}\n    \\dot{x} &amp;= \\mathbf{A} x + \\mathbf{B} u \\\\\n           y &amp;= \\mathbf{C} x + \\mathbf{D} u\n\\end{eqnarray}\n\\end{equation*}\n</div>\n<p>is handled the same as the 'StateSpace' block, where <cite>A</cite>, <cite>B</cite>, <cite>C</cite> and <cite>D</cite>\nare the state space matrices, <cite>x</cite> is the internal state, <cite>u</cite> the input and\n<cite>y</cite> the output vector.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>Poles <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array_like</span></dt>\n<dd>transfer function poles</dd>\n<dt>Zeros <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array_like</span></dt>\n<dd>transfer function zeros</dd>\n<dt>Gain <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>gain term of transfer function</dd>\n</dl>\n",
          "source": "class TransferFunctionZPG(StateSpace):\n    \"\"\"This block defines a LTI (SISO) transfer function.\n\n    The transfer function is defined in zeros-poles-gain (ZPG) form\n\n    .. math::\n\n        \\\\mathbf{H}(s) = k \\\\frac{(s - z_1)(s - z_2)\\\\cdots(s - z_m)}{(s - p_1)(s - p_2)\\\\cdots(s - p_n)}\n\n    where `Zeros` are the scalar (possibly complex conjugate) zeros of the \n    transfer function, and `Poles` are the poles (denominator zeros) of the \n    transfer function. `Gain` is the scalar factor `k`.\n\n    Upon initialization, the state space realization of the transfer function is \n    computed using `scipy.signal.ZerosPolesGain(Zeros, Poles, Gain).to_ss()`.\n\n    The resulting state space model of the form\n\n    .. math::\n\n        \\\\begin{eqnarray}\n            \\\\dot{x} &= \\\\mathbf{A} x + \\\\mathbf{B} u \\\\\\\\\n                   y &= \\\\mathbf{C} x + \\\\mathbf{D} u \n        \\\\end{eqnarray}\n\n    is handled the same as the 'StateSpace' block, where `A`, `B`, `C` and `D` \n    are the state space matrices, `x` is the internal state, `u` the input and \n    `y` the output vector.\n\n    Parameters\n    ----------\n    Poles : array_like\n        transfer function poles\n    Zeros : array_like\n        transfer function zeros\n    Gain : float\n        gain term of transfer function \n    \"\"\"\n\n    def __init__(self, Zeros=[], Poles=[], Gain=1.0):\n\n        #parameters of transfer function in zeros-poles-gain form\n        self.Zeros, self.Poles, self.Gain = Zeros, Poles, Gain\n\n        #build scipy object -> convert to statespace\n        sp_SS = ZerosPolesGain(Zeros, Poles, Gain).to_ss()\n\n        #initialize statespace model\n        super().__init__(sp_SS.A, sp_SS.B, sp_SS.C, sp_SS.D)",
          "bases": [
            "pathsim.blocks.lti.StateSpace"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, Zeros=[], Poles=[], Gain=1.0):\n\n    #parameters of transfer function in zeros-poles-gain form\n    self.Zeros, self.Poles, self.Gain = Zeros, Poles, Gain\n\n    #build scipy object -> convert to statespace\n    sp_SS = ZerosPolesGain(Zeros, Poles, Gain).to_ss()\n\n    #initialize statespace model\n    super().__init__(sp_SS.A, sp_SS.B, sp_SS.C, sp_SS.D)",
              "signature": "(Zeros = [], Poles = [], Gain = 1.0)",
              "parameters": [
                {
                  "name": "Zeros",
                  "type": null,
                  "default": "[]",
                  "description": ""
                },
                {
                  "name": "Poles",
                  "type": null,
                  "default": "[]",
                  "description": ""
                },
                {
                  "name": "Gain",
                  "type": null,
                  "default": "1.0",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [],
          "parameters": [
            {
              "name": "Zeros",
              "type": null,
              "default": "[]",
              "description": "transfer function zeros"
            },
            {
              "name": "Poles",
              "type": null,
              "default": "[]",
              "description": "transfer function poles"
            },
            {
              "name": "Gain",
              "type": null,
              "default": "1.0",
              "description": "gain term of transfer function"
            }
          ]
        },
        {
          "name": "TransferFunctionNumDen",
          "description": "This block defines a LTI (SISO) transfer function.",
          "docstring_html": "<p>This block defines a LTI (SISO) transfer function.</p>\n<p>The transfer function is defined in polynomial (numerator-denominator) form</p>\n<div class=\"math\">\n\\begin{equation*}\n\\mathbf{H}(s) = \\frac{b_n + b_{n-1} s + \\dots + b_{0} s^n}{a_m + a_{m-1} s + \\dots + a_{0} s^m}\n\\end{equation*}\n</div>\n<p>where <cite>Num</cite> is the list of numerator polynomial coefficients and <cite>Den</cite> the\nlist of denominator coefficients.</p>\n<p>Upon initialization, the state space realization of the transfer function is\ncomputed using <cite>scipy.signal.TransferFunction(Num, Den).to_ss()</cite>.</p>\n<p>The resulting state space model of the form</p>\n<div class=\"math\">\n\\begin{equation*}\n\\begin{eqnarray}\n    \\dot{x} &amp;= \\mathbf{A} x + \\mathbf{B} u \\\\\n           y &amp;= \\mathbf{C} x + \\mathbf{D} u\n\\end{eqnarray}\n\\end{equation*}\n</div>\n<p>is handled the same as the 'StateSpace' block, where <cite>A</cite>, <cite>B</cite>, <cite>C</cite> and <cite>D</cite>\nare the state space matrices, <cite>x</cite> is the internal state, <cite>u</cite> the input and\n<cite>y</cite> the output vector.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>Num <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array_like</span></dt>\n<dd>numerator polynomial coefficients</dd>\n<dt>Den <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array_like</span></dt>\n<dd>denominator polynomial coefficients</dd>\n</dl>\n",
          "source": "class TransferFunctionNumDen(StateSpace):\n    \"\"\"This block defines a LTI (SISO) transfer function.\n\n    The transfer function is defined in polynomial (numerator-denominator) form\n\n    .. math::\n\n        \\\\mathbf{H}(s) = \\\\frac{b_n + b_{n-1} s + \\\\dots + b_{0} s^n}{a_m + a_{m-1} s + \\\\dots + a_{0} s^m}\n\n    where `Num` is the list of numerator polynomial coefficients and `Den` the \n    list of denominator coefficients.\n\n    Upon initialization, the state space realization of the transfer function is \n    computed using `scipy.signal.TransferFunction(Num, Den).to_ss()`.\n\n    The resulting state space model of the form\n\n    .. math::\n\n        \\\\begin{eqnarray}\n            \\\\dot{x} &= \\\\mathbf{A} x + \\\\mathbf{B} u \\\\\\\\\n                   y &= \\\\mathbf{C} x + \\\\mathbf{D} u \n        \\\\end{eqnarray}\n\n    is handled the same as the 'StateSpace' block, where `A`, `B`, `C` and `D` \n    are the state space matrices, `x` is the internal state, `u` the input and \n    `y` the output vector.\n\n    Parameters\n    ----------\n    Num : array_like\n        numerator polynomial coefficients\n    Den : array_like\n        denominator polynomial coefficients\n    \"\"\"\n\n    def __init__(self, Num=[], Den=[]):\n\n        #parameters of transfer function in numerator-denominator\n        self.Num, self.Den = Num, Den\n\n        #build scipy object -> convert to statespace\n        sp_SS = _TransferFunction(Num, Den).to_ss()\n\n        #initialize statespace model\n        super().__init__(sp_SS.A, sp_SS.B, sp_SS.C, sp_SS.D)",
          "bases": [
            "pathsim.blocks.lti.StateSpace"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, Num=[], Den=[]):\n\n    #parameters of transfer function in numerator-denominator\n    self.Num, self.Den = Num, Den\n\n    #build scipy object -> convert to statespace\n    sp_SS = _TransferFunction(Num, Den).to_ss()\n\n    #initialize statespace model\n    super().__init__(sp_SS.A, sp_SS.B, sp_SS.C, sp_SS.D)",
              "signature": "(Num = [], Den = [])",
              "parameters": [
                {
                  "name": "Num",
                  "type": null,
                  "default": "[]",
                  "description": ""
                },
                {
                  "name": "Den",
                  "type": null,
                  "default": "[]",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [],
          "parameters": [
            {
              "name": "Num",
              "type": null,
              "default": "[]",
              "description": "numerator polynomial coefficients"
            },
            {
              "name": "Den",
              "type": null,
              "default": "[]",
              "description": "denominator polynomial coefficients"
            }
          ]
        }
      ],
      "functions": []
    },
    "pathsim.blocks.math": {
      "name": "pathsim.blocks.math",
      "description": "",
      "docstring_html": "",
      "classes": [
        {
          "name": "Math",
          "description": "",
          "docstring_html": "",
          "source": "class Math(Block):\n\n\n    def __len__(self):\n        \"\"\"Purely algebraic block\"\"\"\n        return 1\n\n\n    def update(self, t):\n        \"\"\"update algebraic component of system equation \n\n        Parameters\n        ----------\n        t : float\n            evaluation time\n        \"\"\"\n        u = self.inputs.to_array()\n        y = self.op_alg(u)\n        self.outputs.update_from_array(y)",
          "bases": [
            "pathsim.blocks._block.Block"
          ],
          "methods": [
            {
              "name": "update",
              "description": "update algebraic component of system equation",
              "docstring_html": "<p>update algebraic component of system equation</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time</dd>\n</dl>\n",
              "source": "def update(self, t):\n    \"\"\"update algebraic component of system equation \n\n    Parameters\n    ----------\n    t : float\n        evaluation time\n    \"\"\"\n    u = self.inputs.to_array()\n    y = self.op_alg(u)\n    self.outputs.update_from_array(y)",
              "signature": "(t)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time"
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [],
          "parameters": []
        },
        {
          "name": "Sin",
          "description": "Sine operator block.",
          "docstring_html": "<p>Sine operator block.</p>\n<p>This block supports vector inputs. This is the operation it does:</p>\n<div class=\"math\">\n\\begin{equation*}\n\\vec{y} = \\sin(\\vec{u})\n\\end{equation*}\n</div>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>op_alg <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">Operator</span></dt>\n<dd>internal algebraic operator</dd>\n</dl>\n",
          "source": "class Sin(Math):\n    \"\"\"Sine operator block.\n\n    This block supports vector inputs. This is the operation it does:\n\n    .. math::\n\n        \\\\vec{y} = \\\\sin(\\\\vec{u}) \n\n\n    Attributes\n    ----------\n    op_alg : Operator\n        internal algebraic operator\n    \"\"\"\n\n    def __init__(self):\n        super().__init__()\n\n        #create internal algebraic operator\n        self.op_alg = Operator(\n            func=np.sin, \n            jac=lambda x: np.diag(np.cos(x))\n            )",
          "bases": [
            "pathsim.blocks.math.Math"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self):\n    super().__init__()\n\n    #create internal algebraic operator\n    self.op_alg = Operator(\n        func=np.sin, \n        jac=lambda x: np.diag(np.cos(x))\n        )",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "op_alg",
              "description": "",
              "type": null,
              "value": "Operator(func=(np.sin), jac=(lambda x: np.diag(np.cos(x))))"
            }
          ],
          "parameters": []
        },
        {
          "name": "Cos",
          "description": "Cosine operator block.",
          "docstring_html": "<p>Cosine operator block.</p>\n<p>This block supports vector inputs. This is the operation it does:</p>\n<div class=\"math\">\n\\begin{equation*}\n\\vec{y} = \\cos(\\vec{u})\n\\end{equation*}\n</div>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>op_alg <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">Operator</span></dt>\n<dd>internal algebraic operator</dd>\n</dl>\n",
          "source": "class Cos(Math):\n    \"\"\"Cosine operator block.\n\n    This block supports vector inputs. This is the operation it does:\n\n    .. math::\n\n        \\\\vec{y} = \\\\cos(\\\\vec{u}) \n\n    Attributes\n    ----------\n    op_alg : Operator\n        internal algebraic operator\n    \"\"\"\n\n    def __init__(self):\n        super().__init__()\n\n        #create internal algebraic operator\n        self.op_alg = Operator(\n            func=np.cos, \n            jac=lambda x: -np.diag(np.sin(x))\n            )",
          "bases": [
            "pathsim.blocks.math.Math"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self):\n    super().__init__()\n\n    #create internal algebraic operator\n    self.op_alg = Operator(\n        func=np.cos, \n        jac=lambda x: -np.diag(np.sin(x))\n        )",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "op_alg",
              "description": "",
              "type": null,
              "value": "Operator(func=(np.cos), jac=(lambda x: -np.diag(np.sin(x))))"
            }
          ],
          "parameters": []
        },
        {
          "name": "Sqrt",
          "description": "Square root operator block.",
          "docstring_html": "<p>Square root operator block.</p>\n<p>This block supports vector inputs. This is the operation it does:</p>\n<div class=\"math\">\n\\begin{equation*}\n\\vec{y} = \\sqrt{|\\vec{u}|}\n\\end{equation*}\n</div>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>op_alg <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">Operator</span></dt>\n<dd>internal algebraic operator</dd>\n</dl>\n",
          "source": "class Sqrt(Math):\n    \"\"\"Square root operator block.\n\n    This block supports vector inputs. This is the operation it does:\n\n    .. math::\n\n        \\\\vec{y} = \\\\sqrt{|\\\\vec{u}|} \n\n    Attributes\n    ----------\n    op_alg : Operator\n        internal algebraic operator\n    \"\"\"\n\n    def __init__(self):\n        super().__init__()\n\n        #create internal algebraic operator\n        self.op_alg = Operator(\n            func=lambda x: np.sqrt(abs(x)), \n            jac=lambda x: np.diag(1/np.sqrt(abs(x)))\n            )",
          "bases": [
            "pathsim.blocks.math.Math"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self):\n    super().__init__()\n\n    #create internal algebraic operator\n    self.op_alg = Operator(\n        func=lambda x: np.sqrt(abs(x)), \n        jac=lambda x: np.diag(1/np.sqrt(abs(x)))\n        )",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "op_alg",
              "description": "",
              "type": null,
              "value": "Operator(func=(lambda x: np.sqrt(abs(x))), jac=(lambda x: np.diag(1 / np.sqrt(abs(x)))))"
            }
          ],
          "parameters": []
        },
        {
          "name": "Abs",
          "description": "Absolute value operator block.",
          "docstring_html": "<p>Absolute value operator block.</p>\n<p>This block supports vector inputs. This is the operation it does:</p>\n<div class=\"math\">\n\\begin{equation*}\n\\vec{y} = \\vert| \\vec{u} \\vert|\n\\end{equation*}\n</div>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>op_alg <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">Operator</span></dt>\n<dd>internal algebraic operator</dd>\n</dl>\n",
          "source": "class Abs(Math):\n    \"\"\"Absolute value operator block.\n\n    This block supports vector inputs. This is the operation it does:\n\n    .. math::\n\n        \\\\vec{y} = \\\\vert| \\\\vec{u} \\\\vert| \n\n    Attributes\n    ----------\n    op_alg : Operator\n        internal algebraic operator\n    \"\"\"\n\n    def __init__(self):\n        super().__init__()\n\n        #create internal algebraic operator\n        self.op_alg = Operator(\n            func=lambda x: abs(x), \n            jac=lambda x: np.diag(np.sign(x))\n            )",
          "bases": [
            "pathsim.blocks.math.Math"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self):\n    super().__init__()\n\n    #create internal algebraic operator\n    self.op_alg = Operator(\n        func=lambda x: abs(x), \n        jac=lambda x: np.diag(np.sign(x))\n        )",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "op_alg",
              "description": "",
              "type": null,
              "value": "Operator(func=(lambda x: abs(x)), jac=(lambda x: np.diag(np.sign(x))))"
            }
          ],
          "parameters": []
        },
        {
          "name": "Pow",
          "description": "Raise to power operator block.",
          "docstring_html": "<p>Raise to power operator block.</p>\n<p>This block supports vector inputs. This is the operation it does:</p>\n<div class=\"math\">\n\\begin{equation*}\n\\vec{y} = \\vec{u}^{p}\n\\end{equation*}\n</div>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>exponent <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float, array_like</span></dt>\n<dd>exponent to raise the input to the power of</dd>\n</dl>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>op_alg <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">Operator</span></dt>\n<dd>internal algebraic operator</dd>\n</dl>\n",
          "source": "class Pow(Math):\n    \"\"\"Raise to power operator block.\n\n    This block supports vector inputs. This is the operation it does:\n\n    .. math::\n\n        \\\\vec{y} = \\\\vec{u}^{p} \n\n    Parameters\n    ----------\n    exponent : float, array_like\n        exponent to raise the input to the power of\n\n    Attributes\n    ----------\n    op_alg : Operator\n        internal algebraic operator\n    \"\"\"\n\n    def __init__(self, exponent=2):\n        super().__init__()\n\n        self.exponent = exponent\n\n        #create internal algebraic operator\n        self.op_alg = Operator(\n            func=lambda x: np.power(x, self.exponent), \n            jac=lambda x: np.diag(self.exponent * np.power(x, self.exponent - 1))\n            )",
          "bases": [
            "pathsim.blocks.math.Math"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, exponent=2):\n    super().__init__()\n\n    self.exponent = exponent\n\n    #create internal algebraic operator\n    self.op_alg = Operator(\n        func=lambda x: np.power(x, self.exponent), \n        jac=lambda x: np.diag(self.exponent * np.power(x, self.exponent - 1))\n        )",
              "signature": "(exponent = 2)",
              "parameters": [
                {
                  "name": "exponent",
                  "type": null,
                  "default": "2",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "exponent",
              "description": "",
              "type": null,
              "value": "exponent"
            },
            {
              "name": "op_alg",
              "description": "",
              "type": null,
              "value": "Operator(func=(lambda x: np.power(x, self.exponent)), jac=(lambda x: np.diag(self.exponent * np.power(x, self.exponent - 1))))"
            }
          ],
          "parameters": [
            {
              "name": "exponent",
              "type": null,
              "default": "2",
              "description": "exponent to raise the input to the power of Attributes ----------"
            }
          ]
        },
        {
          "name": "PowProd",
          "description": "Power-Product operator block.",
          "docstring_html": "<p>Power-Product operator block.</p>\n<p>This block raises each input to a power and then multiplies all results together:</p>\n<div class=\"math\">\n\\begin{equation*}\ny = \\prod_i u_i^{p_i}\n\\end{equation*}\n</div>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>exponents <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float, array_like</span></dt>\n<dd>exponent(s) to raise the inputs to the power of. If scalar,\napplies same exponent to all inputs.</dd>\n</dl>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>op_alg <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">Operator</span></dt>\n<dd>internal algebraic operator</dd>\n</dl>\n",
          "source": "class PowProd(Math):\n    \"\"\"Power-Product operator block.\n\n    This block raises each input to a power and then multiplies all results together:\n\n    .. math::\n\n        y = \\\\prod_i u_i^{p_i}\n\n    Parameters\n    ----------\n    exponents : float, array_like\n        exponent(s) to raise the inputs to the power of. If scalar, \n        applies same exponent to all inputs.\n\n    Attributes\n    ----------\n    op_alg : Operator\n        internal algebraic operator\n    \"\"\"\n\n    def __init__(self, exponents=2):\n        super().__init__()\n\n        self.exponents = exponents    \n\n        def _jac(x):\n            if np.isscalar(self.exponents):\n                exps = np.full_like(x, self.exponents)\n            else:\n                exps = np.array(self.exponents)\n\n            product = np.prod(np.power(x, exps))\n\n            # Jacobian is a row vector since output is scalar\n            jac = np.zeros((1, len(x)))\n            for j in range(len(x)):\n                if x[j] != 0:\n                    jac[0, j] = product * exps[j] / x[j]\n                else:\n                    jac[0, j] = 0\n\n            return jac\n\n        #create internal algebraic operator\n        self.op_alg = Operator(\n            func=lambda x: np.prod(np.power(x, self.exponents)), \n            jac=_jac\n            )",
          "bases": [
            "pathsim.blocks.math.Math"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, exponents=2):\n    super().__init__()\n\n    self.exponents = exponents    \n\n    def _jac(x):\n        if np.isscalar(self.exponents):\n            exps = np.full_like(x, self.exponents)\n        else:\n            exps = np.array(self.exponents)\n\n        product = np.prod(np.power(x, exps))\n\n        # Jacobian is a row vector since output is scalar\n        jac = np.zeros((1, len(x)))\n        for j in range(len(x)):\n            if x[j] != 0:\n                jac[0, j] = product * exps[j] / x[j]\n            else:\n                jac[0, j] = 0\n\n        return jac\n\n    #create internal algebraic operator\n    self.op_alg = Operator(\n        func=lambda x: np.prod(np.power(x, self.exponents)), \n        jac=_jac\n        )",
              "signature": "(exponents = 2)",
              "parameters": [
                {
                  "name": "exponents",
                  "type": null,
                  "default": "2",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "exponents",
              "description": "",
              "type": null,
              "value": "exponents"
            },
            {
              "name": "op_alg",
              "description": "",
              "type": null,
              "value": "Operator(func=(lambda x: np.prod(np.power(x, self.exponents))), jac=_jac)"
            }
          ],
          "parameters": [
            {
              "name": "exponents",
              "type": null,
              "default": "2",
              "description": "exponent(s) to raise the inputs to the power of. If scalar, applies same exponent to all inputs. Attributes ----------"
            }
          ]
        },
        {
          "name": "Exp",
          "description": "Exponential operator block.",
          "docstring_html": "<p>Exponential operator block.</p>\n<p>This block supports vector inputs. This is the operation it does:</p>\n<div class=\"math\">\n\\begin{equation*}\n\\vec{y} = e^{\\vec{u}}\n\\end{equation*}\n</div>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>op_alg <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">Operator</span></dt>\n<dd>internal algebraic operator</dd>\n</dl>\n",
          "source": "class Exp(Math):\n    \"\"\"Exponential operator block.\n\n    This block supports vector inputs. This is the operation it does:\n\n    .. math::\n\n        \\\\vec{y} = e^{\\\\vec{u}} \n\n    Attributes\n    ----------\n    op_alg : Operator\n        internal algebraic operator\n    \"\"\"\n\n    def __init__(self):\n        super().__init__()\n\n        #create internal algebraic operator\n        self.op_alg = Operator(\n            func=np.exp, \n            jac=lambda x: np.diag(np.exp(x))\n            )",
          "bases": [
            "pathsim.blocks.math.Math"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self):\n    super().__init__()\n\n    #create internal algebraic operator\n    self.op_alg = Operator(\n        func=np.exp, \n        jac=lambda x: np.diag(np.exp(x))\n        )",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "op_alg",
              "description": "",
              "type": null,
              "value": "Operator(func=(np.exp), jac=(lambda x: np.diag(np.exp(x))))"
            }
          ],
          "parameters": []
        },
        {
          "name": "Log",
          "description": "Natural logarithm operator block.",
          "docstring_html": "<p>Natural logarithm operator block.</p>\n<p>This block supports vector inputs. This is the operation it does:</p>\n<div class=\"math\">\n\\begin{equation*}\n\\vec{y} = \\ln(\\vec{u})\n\\end{equation*}\n</div>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>op_alg <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">Operator</span></dt>\n<dd>internal algebraic operator</dd>\n</dl>\n",
          "source": "class Log(Math):\n    \"\"\"Natural logarithm operator block.\n\n    This block supports vector inputs. This is the operation it does:\n\n    .. math::\n\n        \\\\vec{y} = \\\\ln(\\\\vec{u}) \n\n    Attributes\n    ----------\n    op_alg : Operator\n        internal algebraic operator\n    \"\"\"\n\n    def __init__(self):\n        super().__init__()\n\n        #create internal algebraic operator\n        self.op_alg = Operator(\n            func=np.log, \n            jac=lambda x: np.diag(1/x)\n            )",
          "bases": [
            "pathsim.blocks.math.Math"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self):\n    super().__init__()\n\n    #create internal algebraic operator\n    self.op_alg = Operator(\n        func=np.log, \n        jac=lambda x: np.diag(1/x)\n        )",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "op_alg",
              "description": "",
              "type": null,
              "value": "Operator(func=(np.log), jac=(lambda x: np.diag(1 / x)))"
            }
          ],
          "parameters": []
        },
        {
          "name": "Log10",
          "description": "Base-10 logarithm operator block.",
          "docstring_html": "<p>Base-10 logarithm operator block.</p>\n<p>This block supports vector inputs. This is the operation it does:</p>\n<div class=\"math\">\n\\begin{equation*}\n\\vec{y} = \\log_{10}(\\vec{u})\n\\end{equation*}\n</div>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>op_alg <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">Operator</span></dt>\n<dd>internal algebraic operator</dd>\n</dl>\n",
          "source": "class Log10(Math):\n    \"\"\"Base-10 logarithm operator block.\n\n    This block supports vector inputs. This is the operation it does:\n\n    .. math::\n\n        \\\\vec{y} = \\\\log_{10}(\\\\vec{u}) \n\n    Attributes\n    ----------\n    op_alg : Operator\n        internal algebraic operator\n    \"\"\"\n\n    def __init__(self):\n        super().__init__()\n\n        #create internal algebraic operator\n        self.op_alg = Operator(\n            func=np.log10, \n            jac=lambda x: np.diag(1/(x * np.log(10)))\n            )",
          "bases": [
            "pathsim.blocks.math.Math"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self):\n    super().__init__()\n\n    #create internal algebraic operator\n    self.op_alg = Operator(\n        func=np.log10, \n        jac=lambda x: np.diag(1/(x * np.log(10)))\n        )",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "op_alg",
              "description": "",
              "type": null,
              "value": "Operator(func=(np.log10), jac=(lambda x: np.diag(1 / (x * np.log(10)))))"
            }
          ],
          "parameters": []
        },
        {
          "name": "Tan",
          "description": "Tangent operator block.",
          "docstring_html": "<p>Tangent operator block.</p>\n<p>This block supports vector inputs. This is the operation it does:</p>\n<div class=\"math\">\n\\begin{equation*}\n\\vec{y} = \\tan(\\vec{u})\n\\end{equation*}\n</div>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>op_alg <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">Operator</span></dt>\n<dd>internal algebraic operator</dd>\n</dl>\n",
          "source": "class Tan(Math):\n    \"\"\"Tangent operator block.\n\n    This block supports vector inputs. This is the operation it does:\n\n    .. math::\n\n        \\\\vec{y} = \\\\tan(\\\\vec{u}) \n\n    Attributes\n    ----------\n    op_alg : Operator\n        internal algebraic operator\n    \"\"\"\n\n    def __init__(self):\n        super().__init__()\n\n        #create internal algebraic operator\n        self.op_alg = Operator(\n            func=np.tan, \n            jac=lambda x: np.diag(1/np.cos(x)**2)\n            )",
          "bases": [
            "pathsim.blocks.math.Math"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self):\n    super().__init__()\n\n    #create internal algebraic operator\n    self.op_alg = Operator(\n        func=np.tan, \n        jac=lambda x: np.diag(1/np.cos(x)**2)\n        )",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "op_alg",
              "description": "",
              "type": null,
              "value": "Operator(func=(np.tan), jac=(lambda x: np.diag(1 / np.cos(x) ** 2)))"
            }
          ],
          "parameters": []
        },
        {
          "name": "Sinh",
          "description": "Hyperbolic sine operator block.",
          "docstring_html": "<p>Hyperbolic sine operator block.</p>\n<p>This block supports vector inputs. This is the operation it does:</p>\n<div class=\"math\">\n\\begin{equation*}\n\\vec{y} = \\sinh(\\vec{u})\n\\end{equation*}\n</div>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>op_alg <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">Operator</span></dt>\n<dd>internal algebraic operator</dd>\n</dl>\n",
          "source": "class Sinh(Math):\n    \"\"\"Hyperbolic sine operator block.\n\n    This block supports vector inputs. This is the operation it does:\n\n    .. math::\n\n        \\\\vec{y} = \\\\sinh(\\\\vec{u}) \n\n    Attributes\n    ----------\n    op_alg : Operator\n        internal algebraic operator\n    \"\"\"\n\n    def __init__(self):\n        super().__init__()\n\n        #create internal algebraic operator\n        self.op_alg = Operator(\n            func=np.sinh, \n            jac=lambda x: np.diag(np.cosh(x))\n            )",
          "bases": [
            "pathsim.blocks.math.Math"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self):\n    super().__init__()\n\n    #create internal algebraic operator\n    self.op_alg = Operator(\n        func=np.sinh, \n        jac=lambda x: np.diag(np.cosh(x))\n        )",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "op_alg",
              "description": "",
              "type": null,
              "value": "Operator(func=(np.sinh), jac=(lambda x: np.diag(np.cosh(x))))"
            }
          ],
          "parameters": []
        },
        {
          "name": "Cosh",
          "description": "Hyperbolic cosine operator block.",
          "docstring_html": "<p>Hyperbolic cosine operator block.</p>\n<p>This block supports vector inputs. This is the operation it does:</p>\n<div class=\"math\">\n\\begin{equation*}\n\\vec{y} = \\cosh(\\vec{u})\n\\end{equation*}\n</div>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>op_alg <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">Operator</span></dt>\n<dd>internal algebraic operator</dd>\n</dl>\n",
          "source": "class Cosh(Math):\n    \"\"\"Hyperbolic cosine operator block.\n\n    This block supports vector inputs. This is the operation it does:\n\n    .. math::\n\n        \\\\vec{y} = \\\\cosh(\\\\vec{u}) \n\n    Attributes\n    ----------\n    op_alg : Operator\n        internal algebraic operator\n    \"\"\"\n\n    def __init__(self):\n        super().__init__()\n\n        #create internal algebraic operator\n        self.op_alg = Operator(\n            func=np.cosh, \n            jac=lambda x: np.diag(np.sinh(x))\n            )",
          "bases": [
            "pathsim.blocks.math.Math"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self):\n    super().__init__()\n\n    #create internal algebraic operator\n    self.op_alg = Operator(\n        func=np.cosh, \n        jac=lambda x: np.diag(np.sinh(x))\n        )",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "op_alg",
              "description": "",
              "type": null,
              "value": "Operator(func=(np.cosh), jac=(lambda x: np.diag(np.sinh(x))))"
            }
          ],
          "parameters": []
        },
        {
          "name": "Tanh",
          "description": "Hyperbolic tangent operator block.",
          "docstring_html": "<p>Hyperbolic tangent operator block.</p>\n<p>This block supports vector inputs. This is the operation it does:</p>\n<div class=\"math\">\n\\begin{equation*}\n\\vec{y} = \\tanh(\\vec{u})\n\\end{equation*}\n</div>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>op_alg <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">Operator</span></dt>\n<dd>internal algebraic operator</dd>\n</dl>\n",
          "source": "class Tanh(Math):\n    \"\"\"Hyperbolic tangent operator block.\n\n    This block supports vector inputs. This is the operation it does:\n\n    .. math::\n\n        \\\\vec{y} = \\\\tanh(\\\\vec{u}) \n\n    Attributes\n    ----------\n    op_alg : Operator\n        internal algebraic operator\n    \"\"\"\n\n    def __init__(self):\n        super().__init__()\n\n        #create internal algebraic operator\n        self.op_alg = Operator(\n            func=np.tanh, \n            jac=lambda x: np.diag(1 - np.tanh(x)**2)\n            )",
          "bases": [
            "pathsim.blocks.math.Math"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self):\n    super().__init__()\n\n    #create internal algebraic operator\n    self.op_alg = Operator(\n        func=np.tanh, \n        jac=lambda x: np.diag(1 - np.tanh(x)**2)\n        )",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "op_alg",
              "description": "",
              "type": null,
              "value": "Operator(func=(np.tanh), jac=(lambda x: np.diag(1 - np.tanh(x) ** 2)))"
            }
          ],
          "parameters": []
        },
        {
          "name": "Atan",
          "description": "Arctangent operator block.",
          "docstring_html": "<p>Arctangent operator block.</p>\n<p>This block supports vector inputs. This is the operation it does:</p>\n<div class=\"math\">\n\\begin{equation*}\n\\vec{y} = \\arctan(\\vec{u})\n\\end{equation*}\n</div>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>op_alg <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">Operator</span></dt>\n<dd>internal algebraic operator</dd>\n</dl>\n",
          "source": "class Atan(Math):\n    \"\"\"Arctangent operator block.\n\n    This block supports vector inputs. This is the operation it does:\n\n    .. math::\n\n        \\\\vec{y} = \\\\arctan(\\\\vec{u}) \n\n    Attributes\n    ----------\n    op_alg : Operator\n        internal algebraic operator\n    \"\"\"\n\n    def __init__(self):\n        super().__init__()\n\n        #create internal algebraic operator\n        self.op_alg = Operator(\n            func=np.arctan, \n            jac=lambda x: np.diag(1/(1 + x**2))\n            )",
          "bases": [
            "pathsim.blocks.math.Math"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self):\n    super().__init__()\n\n    #create internal algebraic operator\n    self.op_alg = Operator(\n        func=np.arctan, \n        jac=lambda x: np.diag(1/(1 + x**2))\n        )",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "op_alg",
              "description": "",
              "type": null,
              "value": "Operator(func=(np.arctan), jac=(lambda x: np.diag(1 / (1 + x ** 2))))"
            }
          ],
          "parameters": []
        },
        {
          "name": "Norm",
          "description": "Vector norm operator block.",
          "docstring_html": "<p>Vector norm operator block.</p>\n<p>This block computes the Euclidean norm of the input vector:</p>\n<div class=\"math\">\n\\begin{equation*}\ny = \\|\\vec{u}\\|_2 = \\sqrt{\\sum_i u_i^2}\n\\end{equation*}\n</div>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>op_alg <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">Operator</span></dt>\n<dd>internal algebraic operator</dd>\n</dl>\n",
          "source": "class Norm(Math):\n    \"\"\"Vector norm operator block.\n\n    This block computes the Euclidean norm of the input vector:\n\n    .. math::\n\n        y = \\\\|\\\\vec{u}\\\\|_2 = \\\\sqrt{\\\\sum_i u_i^2}\n\n    Attributes\n    ----------\n    op_alg : Operator\n        internal algebraic operator\n    \"\"\"\n\n    def __init__(self):\n        super().__init__()\n\n        #create internal algebraic operator\n        self.op_alg = Operator(\n            func=np.linalg.norm, \n            jac=lambda x: x/np.linalg.norm(x)\n            )",
          "bases": [
            "pathsim.blocks.math.Math"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self):\n    super().__init__()\n\n    #create internal algebraic operator\n    self.op_alg = Operator(\n        func=np.linalg.norm, \n        jac=lambda x: x/np.linalg.norm(x)\n        )",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "op_alg",
              "description": "",
              "type": null,
              "value": "Operator(func=(np.linalg.norm), jac=(lambda x: x / np.linalg.norm(x)))"
            }
          ],
          "parameters": []
        },
        {
          "name": "Mod",
          "description": "Modulo operator block.",
          "docstring_html": "<p>Modulo operator block.</p>\n<p>This block supports vector inputs. This is the operation it does:</p>\n<div class=\"math\">\n\\begin{equation*}\n\\vec{y} = \\vec{u} \\bmod m\n\\end{equation*}\n</div>\n<div class=\"section\" id=\"note\">\n<h4>Note</h4>\n<p>modulo is not differentiable at discontinuities</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>modulus <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>modulus value</dd>\n</dl>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>op_alg <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">Operator</span></dt>\n<dd>internal algebraic operator</dd>\n</dl>\n</div>\n",
          "source": "class Mod(Math):\n    \"\"\"Modulo operator block.\n\n    This block supports vector inputs. This is the operation it does:\n\n    .. math::\n\n        \\\\vec{y} = \\\\vec{u} \\\\bmod m\n\n\n    Note\n    ----\n    modulo is not differentiable at discontinuities\n\n    Parameters\n    ----------\n    modulus : float\n        modulus value\n\n    Attributes\n    ----------\n    op_alg : Operator\n        internal algebraic operator\n    \"\"\"\n\n    def __init__(self, modulus=1.0):\n        super().__init__()\n\n        self.modulus = modulus\n\n        #create internal algebraic operator\n        self.op_alg = Operator(\n            func=lambda x: np.mod(x, self.modulus), \n            jac=lambda x: np.diag(np.ones_like(x)) \n            )",
          "bases": [
            "pathsim.blocks.math.Math"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, modulus=1.0):\n    super().__init__()\n\n    self.modulus = modulus\n\n    #create internal algebraic operator\n    self.op_alg = Operator(\n        func=lambda x: np.mod(x, self.modulus), \n        jac=lambda x: np.diag(np.ones_like(x)) \n        )",
              "signature": "(modulus = 1.0)",
              "parameters": [
                {
                  "name": "modulus",
                  "type": null,
                  "default": "1.0",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "modulus",
              "description": "",
              "type": null,
              "value": "modulus"
            },
            {
              "name": "op_alg",
              "description": "",
              "type": null,
              "value": "Operator(func=(lambda x: np.mod(x, self.modulus)), jac=(lambda x: np.diag(np.ones_like(x))))"
            }
          ],
          "parameters": [
            {
              "name": "modulus",
              "type": null,
              "default": "1.0",
              "description": "modulus value Attributes ----------"
            }
          ]
        },
        {
          "name": "Clip",
          "description": "Clipping/saturation operator block.",
          "docstring_html": "<p>Clipping/saturation operator block.</p>\n<p>This block supports vector inputs. This is the operation it does:</p>\n<div class=\"math\">\n\\begin{equation*}\n\\vec{y} = \\text{clip}(\\vec{u}, u_{min}, u_{max})\n\\end{equation*}\n</div>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>min_val <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float, array_like</span></dt>\n<dd>minimum clipping value</dd>\n<dt>max_val <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float, array_like</span></dt>\n<dd>maximum clipping value</dd>\n</dl>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>op_alg <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">Operator</span></dt>\n<dd>internal algebraic operator</dd>\n</dl>\n",
          "source": "class Clip(Math):\n    \"\"\"Clipping/saturation operator block.\n\n    This block supports vector inputs. This is the operation it does:\n\n    .. math::\n\n        \\\\vec{y} = \\\\text{clip}(\\\\vec{u}, u_{min}, u_{max}) \n\n    Parameters\n    ----------\n    min_val : float, array_like\n        minimum clipping value\n    max_val : float, array_like\n        maximum clipping value\n\n    Attributes\n    ----------\n    op_alg : Operator\n        internal algebraic operator\n    \"\"\"\n\n    def __init__(self, min_val=-1.0, max_val=1.0):\n        super().__init__()\n\n        self.min_val = min_val\n        self.max_val = max_val\n\n        #create internal algebraic operator\n        def _clip_jac(x):\n            \"\"\"Jacobian is 1 where not clipped, 0 where clipped\"\"\"\n            mask = (x >= self.min_val) & (x <= self.max_val)\n            return np.diag(mask.astype(float))\n\n        self.op_alg = Operator(\n            func=lambda x: np.clip(x, self.min_val, self.max_val), \n            jac=_clip_jac\n            )",
          "bases": [
            "pathsim.blocks.math.Math"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, min_val=-1.0, max_val=1.0):\n    super().__init__()\n\n    self.min_val = min_val\n    self.max_val = max_val\n\n    #create internal algebraic operator\n    def _clip_jac(x):\n        \"\"\"Jacobian is 1 where not clipped, 0 where clipped\"\"\"\n        mask = (x >= self.min_val) & (x <= self.max_val)\n        return np.diag(mask.astype(float))\n\n    self.op_alg = Operator(\n        func=lambda x: np.clip(x, self.min_val, self.max_val), \n        jac=_clip_jac\n        )",
              "signature": "(min_val = -1.0, max_val = 1.0)",
              "parameters": [
                {
                  "name": "min_val",
                  "type": null,
                  "default": "-1.0",
                  "description": ""
                },
                {
                  "name": "max_val",
                  "type": null,
                  "default": "1.0",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "min_val",
              "description": "",
              "type": null,
              "value": "min_val"
            },
            {
              "name": "max_val",
              "description": "",
              "type": null,
              "value": "max_val"
            },
            {
              "name": "op_alg",
              "description": "",
              "type": null,
              "value": "Operator(func=(lambda x: np.clip(x, self.min_val, self.max_val)), jac=_clip_jac)"
            }
          ],
          "parameters": [
            {
              "name": "min_val",
              "type": null,
              "default": "-1.0",
              "description": "minimum clipping value"
            },
            {
              "name": "max_val",
              "type": null,
              "default": "1.0",
              "description": "maximum clipping value Attributes ----------"
            }
          ]
        }
      ],
      "functions": []
    },
    "pathsim.blocks.multiplier": {
      "name": "pathsim.blocks.multiplier",
      "description": "",
      "docstring_html": "",
      "classes": [
        {
          "name": "Multiplier",
          "description": "Multiplies all signals from all input ports (MISO).",
          "docstring_html": "<p>Multiplies all signals from all input ports (MISO).</p>\n<div class=\"math\">\n\\begin{equation*}\ny(t) = \\prod_i u_i(t)\n\\end{equation*}\n</div>\n<div class=\"section\" id=\"note\">\n<h4>Note</h4>\n<p>This block is purely algebraic and its operation (<cite>op_alg</cite>) will be called\nmultiple times per timestep, each time when <cite>Simulation._update(t)</cite> is\ncalled in the global simulation loop.</p>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>op_alg <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">Operator</span></dt>\n<dd>internal algebraic operator that wraps 'prod'</dd>\n</dl>\n</div>\n",
          "source": "class Multiplier(Block):\n    \"\"\"Multiplies all signals from all input ports (MISO).\n\n    .. math::\n\n        y(t) = \\\\prod_i u_i(t)\n\n\n    Note\n    ----\n    This block is purely algebraic and its operation (`op_alg`) will be called \n    multiple times per timestep, each time when `Simulation._update(t)` is \n    called in the global simulation loop.\n\n\n    Attributes\n    ----------\n    op_alg : Operator\n        internal algebraic operator that wraps 'prod'\n    \"\"\"\n    #max number of ports\n    _n_in_max = None\n    _n_out_max = 1\n\n    #maps for input and output port labels\n    _port_map_out = {\"out\": 0}\n\n    def __init__(self):\n        super().__init__()\n\n        self.op_alg = Operator(\n            func=prod, \n            jac=lambda x: np.array([\n                prod(np.delete(x, i)) for i in range(len(x))\n                ])\n            )\n\n\n    def update(self, t):\n        \"\"\"update system equation\n\n        Parameters\n        ----------\n        t : float\n            evaluation time\n        \"\"\"\n        u = self.inputs.to_array()\n        self.outputs.update_from_array(self.op_alg(u))",
          "bases": [
            "pathsim.blocks._block.Block"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self):\n    super().__init__()\n\n    self.op_alg = Operator(\n        func=prod, \n        jac=lambda x: np.array([\n            prod(np.delete(x, i)) for i in range(len(x))\n            ])\n        )",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "update",
              "description": "update system equation",
              "docstring_html": "<p>update system equation</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time</dd>\n</dl>\n",
              "source": "def update(self, t):\n    \"\"\"update system equation\n\n    Parameters\n    ----------\n    t : float\n        evaluation time\n    \"\"\"\n    u = self.inputs.to_array()\n    self.outputs.update_from_array(self.op_alg(u))",
              "signature": "(t)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time"
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "_n_in_max",
              "description": "",
              "type": null,
              "value": "None"
            },
            {
              "name": "_n_out_max",
              "description": "",
              "type": null,
              "value": "1"
            },
            {
              "name": "_port_map_out",
              "description": "",
              "type": null,
              "value": "{'out': 0}"
            },
            {
              "name": "op_alg",
              "description": "",
              "type": null,
              "value": "Operator(func=prod, jac=(lambda x: np.array([(prod(np.delete(x, i))) for i in (range(len(x)))])))"
            }
          ],
          "parameters": []
        }
      ],
      "functions": []
    },
    "pathsim.blocks.noise": {
      "name": "pathsim.blocks.noise",
      "description": "",
      "docstring_html": "",
      "classes": [
        {
          "name": "WhiteNoise",
          "description": "White noise source with uniform spectral density. Samples from distribution",
          "docstring_html": "<p>White noise source with uniform spectral density. Samples from distribution\nwith 'sampling_rate' and holds noise values constant for time bins.</p>\n<p>If no 'sampling_rate' (None) is specified, every simulation timestep\ngets a new noise value. This is the default setting.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>spectral_density <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>noise spectral density</dd>\n<dt>noise <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>internal noise value</dd>\n<dt>sampling_rate <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float, None</span></dt>\n<dd>frequency with which the noise is sampled</dd>\n</dl>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>sigma <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>sqrt of spectral density -&gt; signal amplitude</dd>\n<dt>n_samples <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>internal sample counter</dd>\n</dl>\n",
          "source": "class WhiteNoise(Block):\n    \"\"\"White noise source with uniform spectral density. Samples from distribution \n    with 'sampling_rate' and holds noise values constant for time bins.\n\n    If no 'sampling_rate' (None) is specified, every simulation timestep \n    gets a new noise value. This is the default setting.\n\n    Parameters\n    ----------\n    spectral_density : float\n        noise spectral density\n    noise : float\n        internal noise value\n    sampling_rate : float, None\n        frequency with which the noise is sampled \n\n    Attributes\n    ----------\n    sigma : float\n        sqrt of spectral density -> signal amplitude\n    n_samples : int\n        internal sample counter \n    \"\"\"\n    #max number of ports\n    _n_in_max = 0\n    _n_out_max = 1\n\n    #maps for input and output port labels\n    _port_map_out = {\"out\": 0}\n\n    def __init__(self, spectral_density=1, sampling_rate=None):\n        super().__init__()\n\n        #clear all inputs because its a source block\n        self.inputs.clear()\n\n        self.spectral_density = spectral_density\n        self.sampling_rate = sampling_rate \n        self.sigma = np.sqrt(spectral_density)\n        self.n_samples = 0\n        self.noise = 0.0\n\n\n    def __len__(self):\n        return 0\n\n\n    def reset(self):\n        super().reset()\n\n        #reset noise samples\n        self.n_samples = 0\n        self.noise = 0.0\n\n\n    def sample(self, t):\n        \"\"\"Sample from a normal distribution after successful timestep\n\n        Parameters\n        ----------\n        t : float\n            evaluation time for sampling\n        \"\"\"\n        if (self.sampling_rate is None or \n            self.n_samples < t * self.sampling_rate):\n            self.noise = np.random.normal(0, 1) * self.sigma \n            self.n_samples += 1\n\n\n    def update(self, t):\n        \"\"\"update system equation for fixed point loop, \n        here just setting the outputs\n\n        Note\n        ----\n        no direct passthrough, so the 'update' method \n        is optimized for this case        \n\n        Parameters\n        ----------\n        t : float\n            evaluation time\n        \"\"\"\n        self.outputs[0] = self.noise",
          "bases": [
            "pathsim.blocks._block.Block"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, spectral_density=1, sampling_rate=None):\n    super().__init__()\n\n    #clear all inputs because its a source block\n    self.inputs.clear()\n\n    self.spectral_density = spectral_density\n    self.sampling_rate = sampling_rate \n    self.sigma = np.sqrt(spectral_density)\n    self.n_samples = 0\n    self.noise = 0.0",
              "signature": "(spectral_density = 1, sampling_rate = None)",
              "parameters": [
                {
                  "name": "spectral_density",
                  "type": null,
                  "default": "1",
                  "description": ""
                },
                {
                  "name": "sampling_rate",
                  "type": null,
                  "default": "None",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "reset",
              "description": "",
              "docstring_html": "",
              "source": "def reset(self):\n    super().reset()\n\n    #reset noise samples\n    self.n_samples = 0\n    self.noise = 0.0",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "sample",
              "description": "Sample from a normal distribution after successful timestep",
              "docstring_html": "<p>Sample from a normal distribution after successful timestep</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time for sampling</dd>\n</dl>\n",
              "source": "def sample(self, t):\n    \"\"\"Sample from a normal distribution after successful timestep\n\n    Parameters\n    ----------\n    t : float\n        evaluation time for sampling\n    \"\"\"\n    if (self.sampling_rate is None or \n        self.n_samples < t * self.sampling_rate):\n        self.noise = np.random.normal(0, 1) * self.sigma \n        self.n_samples += 1",
              "signature": "(t)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time for sampling"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "update",
              "description": "update system equation for fixed point loop,",
              "docstring_html": "<p>update system equation for fixed point loop,\nhere just setting the outputs</p>\n<div class=\"section\" id=\"note\">\n<h4>Note</h4>\n<p>no direct passthrough, so the 'update' method\nis optimized for this case</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time</dd>\n</dl>\n</div>\n",
              "source": "def update(self, t):\n    \"\"\"update system equation for fixed point loop, \n    here just setting the outputs\n\n    Note\n    ----\n    no direct passthrough, so the 'update' method \n    is optimized for this case        \n\n    Parameters\n    ----------\n    t : float\n        evaluation time\n    \"\"\"\n    self.outputs[0] = self.noise",
              "signature": "(t)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time"
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "_n_in_max",
              "description": "",
              "type": null,
              "value": "0"
            },
            {
              "name": "_n_out_max",
              "description": "",
              "type": null,
              "value": "1"
            },
            {
              "name": "_port_map_out",
              "description": "",
              "type": null,
              "value": "{'out': 0}"
            },
            {
              "name": "spectral_density",
              "description": "",
              "type": null,
              "value": "spectral_density"
            },
            {
              "name": "sampling_rate",
              "description": "",
              "type": null,
              "value": "sampling_rate"
            },
            {
              "name": "sigma",
              "description": "",
              "type": null,
              "value": "np.sqrt(spectral_density)"
            },
            {
              "name": "n_samples",
              "description": "",
              "type": null,
              "value": "0"
            },
            {
              "name": "noise",
              "description": "",
              "type": null,
              "value": "0.0"
            }
          ],
          "parameters": [
            {
              "name": "spectral_density",
              "type": null,
              "default": "1",
              "description": "noise spectral density"
            },
            {
              "name": "sampling_rate",
              "type": null,
              "default": "None",
              "description": "frequency with which the noise is sampled"
            }
          ]
        },
        {
          "name": "PinkNoise",
          "description": "Pink noise (1/f) source using the Voss-McCartney algorithm.",
          "docstring_html": "<p>Pink noise (1/f) source using the Voss-McCartney algorithm.</p>\n<p>Samples from distribution with 'sampling_rate' and generates noise\nwith a power spectral density inversely proportional to frequency.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>spectral_density <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>Desired noise spectral density</dd>\n<dt>num_octaves <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>Number of octaves (levels of randomness)</dd>\n<dt>sampling_rate <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float, None</span></dt>\n<dd>Frequency with which the noise is sampled</dd>\n</dl>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>sigma <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>sqrt of spectral density normalized to number of octaves</dd>\n<dt>n_samples <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>internal sample counter</dd>\n<dt>noise <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>internal noise value</dd>\n<dt>octaves_values <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array[float]</span></dt>\n<dd>internal random numbers for octaves in the Voss-McCartney algorithm</dd>\n</dl>\n",
          "source": "class PinkNoise(Block):\n    \"\"\"Pink noise (1/f) source using the Voss-McCartney algorithm.\n\n    Samples from distribution with 'sampling_rate' and generates noise\n    with a power spectral density inversely proportional to frequency.\n\n    Parameters\n    ----------\n    spectral_density : float\n        Desired noise spectral density\n    num_octaves : int\n        Number of octaves (levels of randomness)\n    sampling_rate : float, None\n        Frequency with which the noise is sampled \n\n    Attributes\n    ----------\n    sigma : float\n        sqrt of spectral density normalized to number of octaves\n    n_samples : int\n        internal sample counter \n    noise : float\n        internal noise value\n    octaves_values : array[float]\n        internal random numbers for octaves in the Voss-McCartney algorithm\n    \"\"\"\n\n    #max number of ports\n    _n_in_max = 0\n    _n_out_max = 1\n\n    #maps for input and output port labels\n    _port_map_out = {\"out\": 0}\n\n    def __init__(self, spectral_density=1, num_octaves=16, sampling_rate=None):\n        super().__init__()\n\n        #clear all inputs because its a source block\n        self.inputs.clear()\n\n        self.spectral_density = spectral_density\n        self.num_octaves = num_octaves\n        self.sampling_rate = sampling_rate\n        self.n_samples = 0\n        self.noise = 0.0\n\n        # Calculate the normalization factor sigma\n        self.sigma = np.sqrt(spectral_density/num_octaves)\n\n        # Initialize the random values for each octave\n        self.octave_values = np.random.normal(0, 1, self.num_octaves)\n\n\n    def __len__(self):\n        return 0\n\n\n    def reset(self):\n        super().reset()\n\n        #reset counters and octave values\n        self.n_samples = 0\n        self.noise = 0.0\n        self.octave_values = np.random.normal(0, 1, self.num_octaves)\n\n\n    def sample(self, t):\n        \"\"\"Generate a new pink noise sample at 't' using \n        the Voss-McCartney algorithm.\n\n        Parameters\n        ----------\n        t : float\n            evaluation time for sampling\n        \"\"\"\n        if (self.sampling_rate is None or \n            self.n_samples < t * self.sampling_rate):\n\n            # Increment the counter\n            self.n_samples += 1\n\n            # Use bitwise operations to determine which octaves to update\n            mask, idx = self.n_samples, 0\n            while mask & 1 == 0 and idx < self.num_octaves:\n                mask >>= 1\n                idx += 1\n\n            # Update the selected octave with a new random value\n            if idx < self.num_octaves:    \n                self.octave_values[idx] = np.random.normal(0, 1)\n\n            # Sum the octave values to produce the pink noise sample\n            pink_sample = np.sum(self.octave_values)\n\n            # Normalize by sigma to maintain consistent amplitude\n            self.noise = pink_sample * self.sigma\n\n\n    def update(self, t):\n        \"\"\"update system equation for fixed point loop, \n        here just setting the outputs\n\n        Note\n        ----\n        no direct passthrough, so the 'update' method \n        is optimized for this case        \n\n        Parameters\n        ----------\n        t : float\n            evaluation time\n        \"\"\"\n        self.outputs[0] = self.noise",
          "bases": [
            "pathsim.blocks._block.Block"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, spectral_density=1, num_octaves=16, sampling_rate=None):\n    super().__init__()\n\n    #clear all inputs because its a source block\n    self.inputs.clear()\n\n    self.spectral_density = spectral_density\n    self.num_octaves = num_octaves\n    self.sampling_rate = sampling_rate\n    self.n_samples = 0\n    self.noise = 0.0\n\n    # Calculate the normalization factor sigma\n    self.sigma = np.sqrt(spectral_density/num_octaves)\n\n    # Initialize the random values for each octave\n    self.octave_values = np.random.normal(0, 1, self.num_octaves)",
              "signature": "(spectral_density = 1, num_octaves = 16, sampling_rate = None)",
              "parameters": [
                {
                  "name": "spectral_density",
                  "type": null,
                  "default": "1",
                  "description": ""
                },
                {
                  "name": "num_octaves",
                  "type": null,
                  "default": "16",
                  "description": ""
                },
                {
                  "name": "sampling_rate",
                  "type": null,
                  "default": "None",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "reset",
              "description": "",
              "docstring_html": "",
              "source": "def reset(self):\n    super().reset()\n\n    #reset counters and octave values\n    self.n_samples = 0\n    self.noise = 0.0\n    self.octave_values = np.random.normal(0, 1, self.num_octaves)",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "sample",
              "description": "Generate a new pink noise sample at 't' using",
              "docstring_html": "<p>Generate a new pink noise sample at 't' using\nthe Voss-McCartney algorithm.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time for sampling</dd>\n</dl>\n",
              "source": "def sample(self, t):\n    \"\"\"Generate a new pink noise sample at 't' using \n    the Voss-McCartney algorithm.\n\n    Parameters\n    ----------\n    t : float\n        evaluation time for sampling\n    \"\"\"\n    if (self.sampling_rate is None or \n        self.n_samples < t * self.sampling_rate):\n\n        # Increment the counter\n        self.n_samples += 1\n\n        # Use bitwise operations to determine which octaves to update\n        mask, idx = self.n_samples, 0\n        while mask & 1 == 0 and idx < self.num_octaves:\n            mask >>= 1\n            idx += 1\n\n        # Update the selected octave with a new random value\n        if idx < self.num_octaves:    \n            self.octave_values[idx] = np.random.normal(0, 1)\n\n        # Sum the octave values to produce the pink noise sample\n        pink_sample = np.sum(self.octave_values)\n\n        # Normalize by sigma to maintain consistent amplitude\n        self.noise = pink_sample * self.sigma",
              "signature": "(t)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time for sampling"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "update",
              "description": "update system equation for fixed point loop,",
              "docstring_html": "<p>update system equation for fixed point loop,\nhere just setting the outputs</p>\n<div class=\"section\" id=\"note\">\n<h4>Note</h4>\n<p>no direct passthrough, so the 'update' method\nis optimized for this case</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time</dd>\n</dl>\n</div>\n",
              "source": "def update(self, t):\n    \"\"\"update system equation for fixed point loop, \n    here just setting the outputs\n\n    Note\n    ----\n    no direct passthrough, so the 'update' method \n    is optimized for this case        \n\n    Parameters\n    ----------\n    t : float\n        evaluation time\n    \"\"\"\n    self.outputs[0] = self.noise",
              "signature": "(t)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time"
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "_n_in_max",
              "description": "",
              "type": null,
              "value": "0"
            },
            {
              "name": "_n_out_max",
              "description": "",
              "type": null,
              "value": "1"
            },
            {
              "name": "_port_map_out",
              "description": "",
              "type": null,
              "value": "{'out': 0}"
            },
            {
              "name": "spectral_density",
              "description": "",
              "type": null,
              "value": "spectral_density"
            },
            {
              "name": "num_octaves",
              "description": "",
              "type": null,
              "value": "num_octaves"
            },
            {
              "name": "sampling_rate",
              "description": "",
              "type": null,
              "value": "sampling_rate"
            },
            {
              "name": "n_samples",
              "description": "",
              "type": null,
              "value": "0"
            },
            {
              "name": "noise",
              "description": "",
              "type": null,
              "value": "0.0"
            },
            {
              "name": "sigma",
              "description": "",
              "type": null,
              "value": "np.sqrt(spectral_density / num_octaves)"
            },
            {
              "name": "octave_values",
              "description": "",
              "type": null,
              "value": "np.random.normal(0, 1, self.num_octaves)"
            }
          ],
          "parameters": [
            {
              "name": "spectral_density",
              "type": null,
              "default": "1",
              "description": "Desired noise spectral density"
            },
            {
              "name": "num_octaves",
              "type": null,
              "default": "16",
              "description": "Number of octaves (levels of randomness)"
            },
            {
              "name": "sampling_rate",
              "type": null,
              "default": "None",
              "description": "Frequency with which the noise is sampled"
            }
          ]
        }
      ],
      "functions": []
    },
    "pathsim.blocks.ode": {
      "name": "pathsim.blocks.ode",
      "description": "",
      "docstring_html": "",
      "classes": [
        {
          "name": "ODE",
          "description": "This block implements an ordinary differential equation (ODE)",
          "docstring_html": "<p>This block implements an ordinary differential equation (ODE)\ndefined by its right hand side</p>\n<div class=\"math\">\n\\begin{equation*}\n\\begin{eqnarray}\n    \\dot{x}(t) =&amp; \\mathrm{func}(x(t), u(t), t) \\\\\n           y(t) =&amp; x(t)\n\\end{eqnarray}\n\\end{equation*}\n</div>\n<p>with inhomogenity (input) <cite>u</cite> and state vector <cite>x</cite>. The function\ncan be nonlinear and the ODE can be of arbitrary order.\nThe block utilizes the integration engine to solve the ODE\nby integrating the <cite>func</cite>, which is the right hand side function.</p>\n<div class=\"section\" id=\"example\">\n<h4>Example</h4>\n<p>For example a linear 1st order ODE:</p>\n<pre class=\"code python literal-block\">\n<span class=\"n\">ode</span> <span class=\"o\">=</span> <span class=\"n\">ODE</span><span class=\"p\">(</span><span class=\"k\">lambda</span> <span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">u</span><span class=\"p\">,</span> <span class=\"n\">t</span><span class=\"p\">:</span> <span class=\"o\">-</span><span class=\"n\">x</span><span class=\"p\">)</span>\n</pre>\n<p>Or something more complex like the <cite>Van der Pol</cite> system, where it makes\nsense to also specify the jacobian, which improves convergence for\nimplicit solvers but is not needed in most cases:</p>\n<pre class=\"code python literal-block\">\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"nn\">numpy</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"nn\">np</span><span class=\"w\">\n\n</span><span class=\"c1\">#initial condition</span><span class=\"w\">\n</span><span class=\"n\">x0</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">array</span><span class=\"p\">([</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">])</span><span class=\"w\">\n\n</span><span class=\"c1\">#van der Pol parameter</span><span class=\"w\">\n</span><span class=\"n\">mu</span> <span class=\"o\">=</span> <span class=\"mi\">1000</span><span class=\"w\">\n\n</span><span class=\"k\">def</span><span class=\"w\"> </span><span class=\"nf\">func</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">u</span><span class=\"p\">,</span> <span class=\"n\">t</span><span class=\"p\">):</span><span class=\"w\">\n</span>    <span class=\"k\">return</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">array</span><span class=\"p\">([</span><span class=\"n\">x</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">],</span> <span class=\"n\">mu</span><span class=\"o\">*</span><span class=\"p\">(</span><span class=\"mi\">1</span> <span class=\"o\">-</span> <span class=\"n\">x</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">**</span><span class=\"mi\">2</span><span class=\"p\">)</span><span class=\"o\">*</span><span class=\"n\">x</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">-</span> <span class=\"n\">x</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]])</span><span class=\"w\">\n\n</span><span class=\"c1\">#analytical jacobian (optional)</span><span class=\"w\">\n</span><span class=\"k\">def</span><span class=\"w\"> </span><span class=\"nf\">jac</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">u</span><span class=\"p\">,</span> <span class=\"n\">t</span><span class=\"p\">):</span><span class=\"w\">\n</span>    <span class=\"k\">return</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">array</span><span class=\"p\">(</span><span class=\"w\">\n</span>        <span class=\"p\">[[</span><span class=\"mi\">0</span>                <span class=\"p\">,</span> <span class=\"mi\">1</span>               <span class=\"p\">],</span><span class=\"w\">\n</span>         <span class=\"p\">[</span><span class=\"o\">-</span><span class=\"n\">mu</span><span class=\"o\">*</span><span class=\"mi\">2</span><span class=\"o\">*</span><span class=\"n\">x</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">*</span><span class=\"n\">x</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">mu</span><span class=\"o\">*</span><span class=\"p\">(</span><span class=\"mi\">1</span> <span class=\"o\">-</span> <span class=\"n\">x</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">**</span><span class=\"mi\">2</span><span class=\"p\">)]]</span><span class=\"w\">\n</span>         <span class=\"p\">)</span><span class=\"w\">\n\n</span><span class=\"c1\">#finally the block</span><span class=\"w\">\n</span><span class=\"n\">vdp</span> <span class=\"o\">=</span> <span class=\"n\">ODE</span><span class=\"p\">(</span><span class=\"n\">func</span><span class=\"p\">,</span> <span class=\"n\">x0</span><span class=\"p\">,</span> <span class=\"n\">jac</span><span class=\"p\">)</span>\n</pre>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>func <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">callable</span></dt>\n<dd>right hand side function of ODE</dd>\n<dt>initial_value <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array[float]</span></dt>\n<dd>initial state / initial condition</dd>\n<dt>jac <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">callable, None</span></dt>\n<dd>jacobian of 'func' or 'None'</dd>\n</dl>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>op_dyn <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">DynamicOperator</span></dt>\n<dd>internal dynamic operator for ODE right hand side 'func'</dd>\n</dl>\n</div>\n",
          "source": "class ODE(Block):\n    \"\"\"\n    This block implements an ordinary differential equation (ODE) \n    defined by its right hand side\n\n    .. math::\n\n        \\\\begin{eqnarray}\n            \\\\dot{x}(t) =& \\\\mathrm{func}(x(t), u(t), t) \\\\\\\\\n                   y(t) =& x(t) \n        \\\\end{eqnarray}\n\n    with inhomogenity (input) `u` and state vector `x`. The function \n    can be nonlinear and the ODE can be of arbitrary order. \n    The block utilizes the integration engine to solve the ODE \n    by integrating the `func`, which is the right hand side function.\n\n    Example\n    -------\n\n    For example a linear 1st order ODE:\n\n    .. code-block:: python\n\n        ode = ODE(lambda x, u, t: -x)\n\n    Or something more complex like the `Van der Pol` system, where it makes \n    sense to also specify the jacobian, which improves convergence for \n    implicit solvers but is not needed in most cases: \n\n    .. code-block:: python\n\n        import numpy as np\n\n        #initial condition\n        x0 = np.array([2, 0])\n\n        #van der Pol parameter\n        mu = 1000\n\n        def func(x, u, t):\n            return np.array([x[1], mu*(1 - x[0]**2)*x[1] - x[0]])\n\n        #analytical jacobian (optional)\n        def jac(x, u, t):\n            return np.array(\n                [[0                , 1               ], \n                 [-mu*2*x[0]*x[1]-1, mu*(1 - x[0]**2)]]\n                 )\n\n        #finally the block\n        vdp = ODE(func, x0, jac) \n\n    Parameters\n    ----------\n    func : callable\n        right hand side function of ODE\n    initial_value : array[float]\n        initial state / initial condition\n    jac : callable, None\n        jacobian of 'func' or 'None'\n\n    Attributes\n    ----------\n    op_dyn : DynamicOperator\n        internal dynamic operator for ODE right hand side 'func'\n    \"\"\"\n\n    def __init__(\n        self,\n        func=lambda x, u, t: -x,\n        initial_value=0.0,\n        jac=None\n        ):\n\n        super().__init__()\n\n        #right hand side function of ODE\n        self.func = func\n\n        #initial condition\n        self.initial_value = initial_value\n\n        #jacobian of 'func'\n        self.jac = jac\n\n        #operators\n        self.op_dyn = DynamicOperator(\n            func=func,\n            jac_x=jac\n            )\n\n\n    def __len__(self):\n        return 0\n\n\n    def set_solver(self, Solver, **solver_args):\n        \"\"\"set the internal numerical integrator\n\n        Parameters\n        ----------\n        Solver : Solver\n            numerical integration solver class\n        solver_args : dict\n            parameters for solver initialization\n        \"\"\"\n        if self.engine is None:\n            #initialize the integration engine with right hand side\n            self.engine = Solver(self.initial_value, **solver_args)\n        else:\n            #change solver if already initialized\n            self.engine = Solver.cast(self.engine, **solver_args)\n\n\n    def update(self, t):\n        \"\"\"update system equation for fixed point loop, \n        here just setting the outputs\n\n        Note\n        ----\n        the ODE block has no direct passthrough, so the \n        'update' method is optimized for this case        \n\n        Parameters\n        ----------\n        t : float\n            evaluation time\n        \"\"\"\n        self.outputs.update_from_array(self.engine.get())\n\n\n    def solve(self, t, dt):\n        \"\"\"advance solution of implicit update equation of the solver\n\n        Parameters\n        ----------\n        t : float\n            evaluation time\n        dt : float\n            integration timestep\n\n        Returns\n        ------- \n        error : float\n            solver residual norm\n        \"\"\"\n        x, u = self.engine.get(), self.inputs.to_array()\n        f, J = self.op_dyn(x, u, t), self.op_dyn.jac_x(x, u, t)\n        return self.engine.solve(f, J, dt)\n\n\n    def step(self, t, dt):\n        \"\"\"compute timestep update with integration engine\n\n        Parameters\n        ----------\n        t : float\n            evaluation time\n        dt : float\n            integration timestep\n\n        Returns\n        ------- \n        success : bool\n            step was successful\n        error : float\n            local truncation error from adaptive integrators\n        scale : float\n            timestep rescale from adaptive integrators\n        \"\"\"\n        x, u = self.engine.get(), self.inputs.to_array()\n        f = self.op_dyn(x, u, t)\n        return self.engine.step(f, dt)",
          "bases": [
            "pathsim.blocks._block.Block"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(\n    self,\n    func=lambda x, u, t: -x,\n    initial_value=0.0,\n    jac=None\n    ):\n\n    super().__init__()\n\n    #right hand side function of ODE\n    self.func = func\n\n    #initial condition\n    self.initial_value = initial_value\n\n    #jacobian of 'func'\n    self.jac = jac\n\n    #operators\n    self.op_dyn = DynamicOperator(\n        func=func,\n        jac_x=jac\n        )",
              "signature": "(func = lambda x, u, t: -x, initial_value = 0.0, jac = None)",
              "parameters": [
                {
                  "name": "func",
                  "type": null,
                  "default": "lambda x, u, t: -x",
                  "description": ""
                },
                {
                  "name": "initial_value",
                  "type": null,
                  "default": "0.0",
                  "description": ""
                },
                {
                  "name": "jac",
                  "type": null,
                  "default": "None",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "set_solver",
              "description": "set the internal numerical integrator",
              "docstring_html": "<p>set the internal numerical integrator</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>Solver <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">Solver</span></dt>\n<dd>numerical integration solver class</dd>\n<dt>solver_args <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">dict</span></dt>\n<dd>parameters for solver initialization</dd>\n</dl>\n",
              "source": "def set_solver(self, Solver, **solver_args):\n    \"\"\"set the internal numerical integrator\n\n    Parameters\n    ----------\n    Solver : Solver\n        numerical integration solver class\n    solver_args : dict\n        parameters for solver initialization\n    \"\"\"\n    if self.engine is None:\n        #initialize the integration engine with right hand side\n        self.engine = Solver(self.initial_value, **solver_args)\n    else:\n        #change solver if already initialized\n        self.engine = Solver.cast(self.engine, **solver_args)",
              "signature": "(Solver, solver_args = {})",
              "parameters": [
                {
                  "name": "Solver",
                  "type": null,
                  "default": null,
                  "description": "numerical integration solver class"
                },
                {
                  "name": "solver_args",
                  "type": null,
                  "default": "{}",
                  "description": "parameters for solver initialization"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "update",
              "description": "update system equation for fixed point loop,",
              "docstring_html": "<p>update system equation for fixed point loop,\nhere just setting the outputs</p>\n<div class=\"section\" id=\"note\">\n<h4>Note</h4>\n<p>the ODE block has no direct passthrough, so the\n'update' method is optimized for this case</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time</dd>\n</dl>\n</div>\n",
              "source": "def update(self, t):\n    \"\"\"update system equation for fixed point loop, \n    here just setting the outputs\n\n    Note\n    ----\n    the ODE block has no direct passthrough, so the \n    'update' method is optimized for this case        \n\n    Parameters\n    ----------\n    t : float\n        evaluation time\n    \"\"\"\n    self.outputs.update_from_array(self.engine.get())",
              "signature": "(t)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "solve",
              "description": "advance solution of implicit update equation of the solver",
              "docstring_html": "<p>advance solution of implicit update equation of the solver</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time</dd>\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>integration timestep</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>error <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>solver residual norm</dd>\n</dl>\n",
              "source": "def solve(self, t, dt):\n    \"\"\"advance solution of implicit update equation of the solver\n\n    Parameters\n    ----------\n    t : float\n        evaluation time\n    dt : float\n        integration timestep\n\n    Returns\n    ------- \n    error : float\n        solver residual norm\n    \"\"\"\n    x, u = self.engine.get(), self.inputs.to_array()\n    f, J = self.op_dyn(x, u, t), self.op_dyn.jac_x(x, u, t)\n    return self.engine.solve(f, J, dt)",
              "signature": "(t, dt)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time"
                },
                {
                  "name": "dt",
                  "type": null,
                  "default": null,
                  "description": "integration timestep"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "step",
              "description": "compute timestep update with integration engine",
              "docstring_html": "<p>compute timestep update with integration engine</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time</dd>\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>integration timestep</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>success <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>step was successful</dd>\n<dt>error <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>local truncation error from adaptive integrators</dd>\n<dt>scale <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>timestep rescale from adaptive integrators</dd>\n</dl>\n",
              "source": "def step(self, t, dt):\n    \"\"\"compute timestep update with integration engine\n\n    Parameters\n    ----------\n    t : float\n        evaluation time\n    dt : float\n        integration timestep\n\n    Returns\n    ------- \n    success : bool\n        step was successful\n    error : float\n        local truncation error from adaptive integrators\n    scale : float\n        timestep rescale from adaptive integrators\n    \"\"\"\n    x, u = self.engine.get(), self.inputs.to_array()\n    f = self.op_dyn(x, u, t)\n    return self.engine.step(f, dt)",
              "signature": "(t, dt)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time"
                },
                {
                  "name": "dt",
                  "type": null,
                  "default": null,
                  "description": "integration timestep"
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "func",
              "description": "",
              "type": null,
              "value": "func"
            },
            {
              "name": "initial_value",
              "description": "",
              "type": null,
              "value": "initial_value"
            },
            {
              "name": "jac",
              "description": "",
              "type": null,
              "value": "jac"
            },
            {
              "name": "op_dyn",
              "description": "",
              "type": null,
              "value": "DynamicOperator(func=func, jac_x=jac)"
            }
          ],
          "parameters": [
            {
              "name": "func",
              "type": null,
              "default": "lambda x, u, t: -x",
              "description": "right hand side function of ODE"
            },
            {
              "name": "initial_value",
              "type": null,
              "default": "0.0",
              "description": "initial state / initial condition"
            },
            {
              "name": "jac",
              "type": null,
              "default": "None",
              "description": "jacobian of 'func' or 'None'"
            }
          ]
        }
      ],
      "functions": []
    },
    "pathsim.blocks.rng": {
      "name": "pathsim.blocks.rng",
      "description": "",
      "docstring_html": "",
      "classes": [
        {
          "name": "RNG",
          "description": "Generates a random output value between -1 and 1",
          "docstring_html": "<p>Generates a random output value between -1 and 1\nfrom a uniform distribution.</p>\n<p>If no <cite>sampling_rate</cite> (None) is specified, every\nsimulation timestep gets a random value.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>sampling_rate <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float, None</span></dt>\n<dd>number of random samples per time unit</dd>\n</dl>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>n_samples <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>internal sample counter</dd>\n<dt>val <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>internal random number state</dd>\n</dl>\n",
          "source": "class RNG(Block):\n    \"\"\"\n    Generates a random output value between -1 and 1 \n    from a uniform distribution.\n\n    If no `sampling_rate` (None) is specified, every \n    simulation timestep gets a random value.\n\n    Parameters\n    ----------\n    sampling_rate : float, None\n        number of random samples per time unit\n\n    Attributes\n    ----------\n    n_samples : int\n        internal sample counter\n    val : float\n        internal random number state\n    \"\"\"\n\n    #max number of ports\n    _n_in_max = 0\n    _n_out_max = 1\n\n    #maps for input and output port labels\n    _port_map_out = {\"out\": 0}\n\n    def __init__(self, sampling_rate=None):\n        super().__init__()\n\n        self.sampling_rate = sampling_rate \n        self.n_samples = 0\n        self.val = 0.0\n\n\n    def __len__(self):\n        return 0\n\n\n    def reset(self):\n        super().reset()\n\n        #reset noise samples\n        self.n_samples = 0\n\n\n    def sample(self, t):\n        \"\"\"Sample from a normal distribution after successful timestep.\n\n        Parameters\n        ----------\n        t : float\n            evaluation time for sampling\n        \"\"\"\n        if (self.sampling_rate is None or \n            self.n_samples < t * self.sampling_rate):\n            self.val = 2.0*np.random.rand() - 1.0\n            self.n_samples += 1\n\n\n    def update(self, t):\n        \"\"\"update system equation for fixed point loop, \n        here just setting the outputs\n\n        Parameters\n        ----------\n        t : float\n            evaluation time\n        \"\"\"\n        self.outputs[0] = self.val",
          "bases": [
            "pathsim.blocks._block.Block"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, sampling_rate=None):\n    super().__init__()\n\n    self.sampling_rate = sampling_rate \n    self.n_samples = 0\n    self.val = 0.0",
              "signature": "(sampling_rate = None)",
              "parameters": [
                {
                  "name": "sampling_rate",
                  "type": null,
                  "default": "None",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "reset",
              "description": "",
              "docstring_html": "",
              "source": "def reset(self):\n    super().reset()\n\n    #reset noise samples\n    self.n_samples = 0",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "sample",
              "description": "Sample from a normal distribution after successful timestep.",
              "docstring_html": "<p>Sample from a normal distribution after successful timestep.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time for sampling</dd>\n</dl>\n",
              "source": "def sample(self, t):\n    \"\"\"Sample from a normal distribution after successful timestep.\n\n    Parameters\n    ----------\n    t : float\n        evaluation time for sampling\n    \"\"\"\n    if (self.sampling_rate is None or \n        self.n_samples < t * self.sampling_rate):\n        self.val = 2.0*np.random.rand() - 1.0\n        self.n_samples += 1",
              "signature": "(t)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time for sampling"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "update",
              "description": "update system equation for fixed point loop,",
              "docstring_html": "<p>update system equation for fixed point loop,\nhere just setting the outputs</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time</dd>\n</dl>\n",
              "source": "def update(self, t):\n    \"\"\"update system equation for fixed point loop, \n    here just setting the outputs\n\n    Parameters\n    ----------\n    t : float\n        evaluation time\n    \"\"\"\n    self.outputs[0] = self.val",
              "signature": "(t)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time"
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "_n_in_max",
              "description": "",
              "type": null,
              "value": "0"
            },
            {
              "name": "_n_out_max",
              "description": "",
              "type": null,
              "value": "1"
            },
            {
              "name": "_port_map_out",
              "description": "",
              "type": null,
              "value": "{'out': 0}"
            },
            {
              "name": "sampling_rate",
              "description": "",
              "type": null,
              "value": "sampling_rate"
            },
            {
              "name": "n_samples",
              "description": "",
              "type": null,
              "value": "0"
            },
            {
              "name": "val",
              "description": "",
              "type": null,
              "value": "0.0"
            }
          ],
          "parameters": [
            {
              "name": "sampling_rate",
              "type": null,
              "default": "None",
              "description": "number of random samples per time unit"
            }
          ]
        }
      ],
      "functions": []
    },
    "pathsim.blocks.samplehold": {
      "name": "pathsim.blocks.samplehold",
      "description": "",
      "docstring_html": "",
      "classes": [
        {
          "name": "SampleHold",
          "description": "Sample and hold stage that samples the inputs",
          "docstring_html": "<p>Sample and hold stage that samples the inputs\nperiodically using scheduled events and produces\nthem at the output.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>T <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>sampling period</dd>\n<dt>tau <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>delay</dd>\n</dl>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>events <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">list[Schedule]</span></dt>\n<dd>internal scheduled event for periodic sampling</dd>\n</dl>\n",
          "source": "class SampleHold(Block):\n    \"\"\"Sample and hold stage that samples the inputs \n    periodically using scheduled events and produces \n    them at the output.\n\n    Parameters\n    ----------\n    T : float\n        sampling period\n    tau : float\n        delay \n\n    Attributes\n    ----------\n    events : list[Schedule]\n        internal scheduled event for periodic sampling\n    \"\"\"\n\n    def __init__(self, T=1, tau=0):\n        super().__init__()\n\n        self.T   = T\n        self.tau = tau\n\n        def _sample(t):\n            self.outputs.update_from_array(\n                self.inputs.to_array()\n                )\n\n        #internal scheduled events\n        self.events = [\n            Schedule(\n                t_start=tau,\n                t_period=T,\n                func_act=_sample\n                ),\n            ]\n\n    def __len__(self):\n        return 0",
          "bases": [
            "pathsim.blocks._block.Block"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, T=1, tau=0):\n    super().__init__()\n\n    self.T   = T\n    self.tau = tau\n\n    def _sample(t):\n        self.outputs.update_from_array(\n            self.inputs.to_array()\n            )\n\n    #internal scheduled events\n    self.events = [\n        Schedule(\n            t_start=tau,\n            t_period=T,\n            func_act=_sample\n            ),\n        ]",
              "signature": "(T = 1, tau = 0)",
              "parameters": [
                {
                  "name": "T",
                  "type": null,
                  "default": "1",
                  "description": ""
                },
                {
                  "name": "tau",
                  "type": null,
                  "default": "0",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "T",
              "description": "",
              "type": null,
              "value": "T"
            },
            {
              "name": "tau",
              "description": "",
              "type": null,
              "value": "tau"
            },
            {
              "name": "events",
              "description": "",
              "type": null,
              "value": "[Schedule(t_start=tau, t_period=T, func_act=_sample)]"
            }
          ],
          "parameters": [
            {
              "name": "T",
              "type": null,
              "default": "1",
              "description": "sampling period"
            },
            {
              "name": "tau",
              "type": null,
              "default": "0",
              "description": "delay Attributes ----------"
            }
          ]
        }
      ],
      "functions": []
    },
    "pathsim.blocks.scope": {
      "name": "pathsim.blocks.scope",
      "description": "",
      "docstring_html": "",
      "classes": [
        {
          "name": "Scope",
          "description": "Block for recording time domain data with variable sampling sampling rate.",
          "docstring_html": "<p>Block for recording time domain data with variable sampling sampling rate.</p>\n<p>A time threshold can be set by 'wait' to start recording data after the simulation\ntime is larger then the specified waiting time, i.e. 't - t_wait &gt; 0'.\nThis is useful for recording data only after all the transients have settled.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>sampling_rate <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int, None</span></dt>\n<dd>number of samples per time unit, default is every timestep</dd>\n<dt>t_wait <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>wait time before starting recording, optional</dd>\n<dt>labels <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">list[str]</span></dt>\n<dd>labels for the scope traces, and for the csv, optional</dd>\n</dl>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>recording <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">dict</span></dt>\n<dd>recording, where key is time, and value the recorded values</dd>\n</dl>\n",
          "source": "class Scope(Block):\n    \"\"\"\n    Block for recording time domain data with variable sampling sampling rate.\n\n    A time threshold can be set by 'wait' to start recording data after the simulation \n    time is larger then the specified waiting time, i.e. 't - t_wait > 0'. \n    This is useful for recording data only after all the transients have settled.\n\n    Parameters\n    ----------\n    sampling_rate : int, None\n        number of samples per time unit, default is every timestep\n    t_wait : float\n        wait time before starting recording, optional\n    labels : list[str]\n        labels for the scope traces, and for the csv, optional\n\n    Attributes\n    ----------\n    recording : dict\n        recording, where key is time, and value the recorded values\n    \"\"\"\n\n    #max number of ports\n    _n_in_max = None\n    _n_out_max = 0\n\n    def __init__(self, sampling_rate=None, t_wait=0.0, labels=None):\n        super().__init__()\n\n        #time delay until start recording\n        self.t_wait = t_wait\n\n        #params for sampling\n        self.sampling_rate = sampling_rate\n\n        #labels for plotting and saving data\n        self.labels = labels if labels is not None else []\n\n        #set recording data and time\n        self.recording = {}\n\n\n    def __len__(self):\n        return 0\n\n\n    def reset(self):\n        super().reset()\n\n        #reset recording data and time\n        self.recording = {}\n\n\n    def read(self):\n        \"\"\"Return the recorded time domain data and the \n        corresponding time for all input ports\n\n        Returns\n        -------\n        time : array[float]\n            recorded time points\n        data : array[obj]\n            recorded data points\n        \"\"\"\n\n        #just return 'None' if no recording available\n        if not self.recording: return None, None\n\n        #reformat the data from the recording dict\n        time = np.array(list(self.recording.keys()))\n        data = np.array(list(self.recording.values())).T\n        return time, data\n\n\n    def sample(self, t):\n        \"\"\"Sample the data from all inputs, and overwrites existing timepoints, \n        since we use a dict for storing the recorded data.\n\n        Parameters\n        ----------\n        t : float\n            evaluation time for sampling\n        \"\"\"\n        if t >= self.t_wait: \n            if (self.sampling_rate is None or \n                t * self.sampling_rate > len(self.recording)):\n                self.recording[t] = self.inputs.to_array()\n\n\n    def plot(self, *args, **kwargs):\n        \"\"\"Directly create a plot of the recorded data for quick visualization and debugging.\n\n        Parameters\n        ----------\n        args : tuple\n            args for ax.plot\n        kwargs : dict\n            kwargs for ax.plot\n\n        Returns\n        -------\n        fig : matplotlib.figure\n            internal figure instance\n        ax : matplotlib.axis\n            internal axis instance\n        \"\"\" \n\n        #just return 'None' if no recording available\n        if not self.recording:\n            warnings.warn(\"no recording available for plotting in 'Scope.plot'\")\n            return None, None\n\n        #get data\n        time, data = self.read() \n\n        #initialize figure\n        fig, ax = plt.subplots(nrows=1, ncols=1, figsize=(8,4), tight_layout=True, dpi=120)\n\n        #custom colors\n        ax.set_prop_cycle(color=COLORS_ALL)\n\n        #plot the recorded data\n        for p, d in enumerate(data):\n            lb = self.labels[p] if p < len(self.labels) else f\"port {p}\"\n            ax.plot(time, d, *args, **kwargs, label=lb)\n\n        #legend labels from ports\n        ax.legend(fancybox=False)\n\n        #other plot settings\n        ax.set_xlabel(\"time [s]\")\n        ax.grid()\n\n        # Legend picking functionality\n        lines = ax.get_lines()  # Get the lines from the plot\n        leg = ax.get_legend()   # Get the legend\n\n        # Map legend lines to original plot lines\n        lined = dict()  \n        for legline, origline in zip(leg.get_lines(), lines):\n            # Enable picking within 5 points tolerance\n            legline.set_picker(5)  \n            lined[legline] = origline\n\n        def on_pick(event):\n            legline = event.artist\n            origline = lined[legline]\n            visible = not origline.get_visible()\n            origline.set_visible(visible)\n            legline.set_alpha(1.0 if visible else 0.2)\n            # Redraw the figure\n            fig.canvas.draw()  \n\n        #enable picking\n        fig.canvas.mpl_connect(\"pick_event\", on_pick)\n\n        #show the plot without blocking following code\n        plt.show(block=False)\n\n        #return figure and axis for outside manipulation\n        return fig, ax\n\n\n    def plot2D(self, *args, axes=(0, 1), **kwargs):\n        \"\"\"Directly create a 2D plot of the recorded data for quick visualization and debugging.\n\n        Parameters\n        ----------\n        args : tuple\n            args for ax.plot\n        axes : tuple[int]\n            axes / ports to select for 2d plot\n        kwargs : dict\n            kwargs for ax.plot\n\n        Returns\n        -------\n        fig : matplotlib.figure\n            internal figure instance\n        ax : matplotlib.axis\n            internal axis instance\n        \"\"\" \n\n        #just return 'None' if no recording available\n        if not self.recording:\n            warnings.warn(\"no recording available for plotting in 'Scope.plot2D'\")\n            return None, None\n\n        #get data\n        time, data = self.read() \n\n        #not enough channels -> early exit\n        if len(data) < 2 or len(axes) != 2:\n            warnings.warn(\"not enough channels for plotting in 'Scope.plot2D'\")\n            return None, None\n\n        #axes selected not available -> early exit\n        ax1_idx, ax2_idx = axes\n        if not (0 <= ax1_idx < data.shape[0] and 0 <= ax2_idx < data.shape[0]):\n             warnings.warn(f\"Selected axes {axes} out of bounds for data shape {data.shape}\")\n             return None, None \n\n        #initialize figure\n        fig, ax = plt.subplots(nrows=1, ncols=1, figsize=(4, 4), tight_layout=True, dpi=120)\n\n        #custom colors\n        ax.set_prop_cycle(color=COLORS_ALL)\n\n        #unpack data for selected axes\n        d1 = data[ax1_idx]\n        d2 = data[ax2_idx]\n\n        #plot the data\n        ax.plot(d1, d2, *args, **kwargs)\n\n        #axis labels\n        l1 = self.labels[ax1_idx] if ax1_idx < len(self.labels) else f\"port {ax1_idx}\"\n        l2 = self.labels[ax2_idx] if ax2_idx < len(self.labels) else f\"port {ax2_idx}\"\n        ax.set_xlabel(l1)\n        ax.set_ylabel(l2)\n\n        ax.grid()\n\n        #show the plot without blocking following code\n        plt.show(block=False)\n\n        #return figure and axis for outside manipulation\n        return fig, ax\n\n\n    def plot3D(self, *args, axes=(0, 1, 2), **kwargs):\n        \"\"\"Directly create a 3D plot of the recorded data for quick visualization.\n\n        Parameters\n        ----------\n        args : tuple\n            args for ax.plot\n        axes : tuple[int]\n            indices of the three data channels (ports) to plot (default: (0, 1, 2)).\n        kwargs : dict\n            kwargs for ax.plot\n\n        Returns\n        -------\n        fig : matplotlib.figure\n            internal figure instance.\n        ax : matplotlib.axes._axes.Axes3D\n            internal 3D axis instance.\n        \"\"\"\n\n        #check if recording is available\n        if not self.recording:\n            warnings.warn(\"no recording available for plotting in 'Scope.plot3D'\")\n            return None, None \n\n        #read the recorded data\n        time, data = self.read()\n\n        #check if enough channels are available\n        if data.shape[0] < 3 or len(axes) != 3:\n            warnings.warn(f\"Need at least 3 channels for plot3D, got {data.shape[0]}. Or axes argument length is not 3.\")\n            return None, None\n\n        #check if selected axes are valid\n        ax1_idx, ax2_idx, ax3_idx = axes\n        if not (0 <= ax1_idx < data.shape[0] and\n                0 <= ax2_idx < data.shape[0] and\n                0 <= ax3_idx < data.shape[0]):\n            warnings.warn(f\"Selected axes {axes} out of bounds for data shape {data.shape}\")\n            return None, None \n\n        #initialize 3D figure\n        fig = plt.figure(figsize=(6, 6), dpi=120)\n        ax = fig.add_subplot(111, projection='3d')\n\n        #custom colors\n        ax.set_prop_cycle(color=COLORS_ALL)\n\n        #unpack data for selected axes\n        d1 = data[ax1_idx]\n        d2 = data[ax2_idx]\n        d3 = data[ax3_idx]\n\n        #plot the 3D data\n        ax.plot(d1, d2, d3, *args, **kwargs)\n\n        #set axis labels using provided labels or default port numbers\n        label1 = self.labels[ax1_idx] if ax1_idx < len(self.labels) else f\"port {ax1_idx}\"\n        label2 = self.labels[ax2_idx] if ax2_idx < len(self.labels) else f\"port {ax2_idx}\"\n        label3 = self.labels[ax3_idx] if ax3_idx < len(self.labels) else f\"port {ax3_idx}\"\n        ax.set_xlabel(label1)\n        ax.set_ylabel(label2)\n        ax.set_zlabel(label3)\n\n        #show the plot without blocking\n        plt.show(block=False)\n\n        return fig, ax\n\n\n    def save(self, path=\"scope.csv\"):\n        \"\"\"Save the recording of the scope to a csv file.\n\n        Parameters\n        ----------\n        path : str\n            path where to save the recording as a csv file\n        \"\"\"\n\n        #check path ending\n        if not path.lower().endswith(\".csv\"):\n            path += \".csv\"\n\n        #get data\n        time, data = self.read() \n\n        #number of ports and labels\n        P, L = len(data), len(self.labels)\n\n        #make csv header\n        header = [\"time [s]\", *[self.labels[p] if p < L else f\"port {p}\" for p in range(P)]]\n\n        #write to csv file\n        with open(path, \"w\", newline=\"\") as file:\n            wrt = csv.writer(file)\n\n            #write the header to csv file\n            wrt.writerow(header)\n\n            #write each sample to the csv file\n            for sample in zip(time, *data):\n                wrt.writerow(sample)\n\n\n    def update(self, t):\n        \"\"\"update system equation for fixed point loop, \n        here just setting the outputs\n\n        Note\n        ----\n        Scope has no passthrough, so the 'update' method \n        is optimized for this case (does nothing)       \n\n        Parameters\n        ----------\n        t : float\n            evaluation time\n\n        Returns\n        -------\n        error : float\n            absolute error to previous iteration for convergence \n            control (always '0.0' because sink-type)\n        \"\"\"\n        return 0.0",
          "bases": [
            "pathsim.blocks._block.Block"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, sampling_rate=None, t_wait=0.0, labels=None):\n    super().__init__()\n\n    #time delay until start recording\n    self.t_wait = t_wait\n\n    #params for sampling\n    self.sampling_rate = sampling_rate\n\n    #labels for plotting and saving data\n    self.labels = labels if labels is not None else []\n\n    #set recording data and time\n    self.recording = {}",
              "signature": "(sampling_rate = None, t_wait = 0.0, labels = None)",
              "parameters": [
                {
                  "name": "sampling_rate",
                  "type": null,
                  "default": "None",
                  "description": ""
                },
                {
                  "name": "t_wait",
                  "type": null,
                  "default": "0.0",
                  "description": ""
                },
                {
                  "name": "labels",
                  "type": null,
                  "default": "None",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "reset",
              "description": "",
              "docstring_html": "",
              "source": "def reset(self):\n    super().reset()\n\n    #reset recording data and time\n    self.recording = {}",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "read",
              "description": "Return the recorded time domain data and the",
              "docstring_html": "<p>Return the recorded time domain data and the\ncorresponding time for all input ports</p>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>time <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array[float]</span></dt>\n<dd>recorded time points</dd>\n<dt>data <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array[obj]</span></dt>\n<dd>recorded data points</dd>\n</dl>\n",
              "source": "def read(self):\n    \"\"\"Return the recorded time domain data and the \n    corresponding time for all input ports\n\n    Returns\n    -------\n    time : array[float]\n        recorded time points\n    data : array[obj]\n        recorded data points\n    \"\"\"\n\n    #just return 'None' if no recording available\n    if not self.recording: return None, None\n\n    #reformat the data from the recording dict\n    time = np.array(list(self.recording.keys()))\n    data = np.array(list(self.recording.values())).T\n    return time, data",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "sample",
              "description": "Sample the data from all inputs, and overwrites existing timepoints,",
              "docstring_html": "<p>Sample the data from all inputs, and overwrites existing timepoints,\nsince we use a dict for storing the recorded data.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time for sampling</dd>\n</dl>\n",
              "source": "def sample(self, t):\n    \"\"\"Sample the data from all inputs, and overwrites existing timepoints, \n    since we use a dict for storing the recorded data.\n\n    Parameters\n    ----------\n    t : float\n        evaluation time for sampling\n    \"\"\"\n    if t >= self.t_wait: \n        if (self.sampling_rate is None or \n            t * self.sampling_rate > len(self.recording)):\n            self.recording[t] = self.inputs.to_array()",
              "signature": "(t)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time for sampling"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "plot",
              "description": "Directly create a plot of the recorded data for quick visualization and debugging.",
              "docstring_html": "<p>Directly create a plot of the recorded data for quick visualization and debugging.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>args <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">tuple</span></dt>\n<dd>args for ax.plot</dd>\n<dt>kwargs <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">dict</span></dt>\n<dd>kwargs for ax.plot</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>fig <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">matplotlib.figure</span></dt>\n<dd>internal figure instance</dd>\n<dt>ax <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">matplotlib.axis</span></dt>\n<dd>internal axis instance</dd>\n</dl>\n",
              "source": "def plot(self, *args, **kwargs):\n    \"\"\"Directly create a plot of the recorded data for quick visualization and debugging.\n\n    Parameters\n    ----------\n    args : tuple\n        args for ax.plot\n    kwargs : dict\n        kwargs for ax.plot\n\n    Returns\n    -------\n    fig : matplotlib.figure\n        internal figure instance\n    ax : matplotlib.axis\n        internal axis instance\n    \"\"\" \n\n    #just return 'None' if no recording available\n    if not self.recording:\n        warnings.warn(\"no recording available for plotting in 'Scope.plot'\")\n        return None, None\n\n    #get data\n    time, data = self.read() \n\n    #initialize figure\n    fig, ax = plt.subplots(nrows=1, ncols=1, figsize=(8,4), tight_layout=True, dpi=120)\n\n    #custom colors\n    ax.set_prop_cycle(color=COLORS_ALL)\n\n    #plot the recorded data\n    for p, d in enumerate(data):\n        lb = self.labels[p] if p < len(self.labels) else f\"port {p}\"\n        ax.plot(time, d, *args, **kwargs, label=lb)\n\n    #legend labels from ports\n    ax.legend(fancybox=False)\n\n    #other plot settings\n    ax.set_xlabel(\"time [s]\")\n    ax.grid()\n\n    # Legend picking functionality\n    lines = ax.get_lines()  # Get the lines from the plot\n    leg = ax.get_legend()   # Get the legend\n\n    # Map legend lines to original plot lines\n    lined = dict()  \n    for legline, origline in zip(leg.get_lines(), lines):\n        # Enable picking within 5 points tolerance\n        legline.set_picker(5)  \n        lined[legline] = origline\n\n    def on_pick(event):\n        legline = event.artist\n        origline = lined[legline]\n        visible = not origline.get_visible()\n        origline.set_visible(visible)\n        legline.set_alpha(1.0 if visible else 0.2)\n        # Redraw the figure\n        fig.canvas.draw()  \n\n    #enable picking\n    fig.canvas.mpl_connect(\"pick_event\", on_pick)\n\n    #show the plot without blocking following code\n    plt.show(block=False)\n\n    #return figure and axis for outside manipulation\n    return fig, ax",
              "signature": "(args = (), kwargs = {})",
              "parameters": [
                {
                  "name": "args",
                  "type": null,
                  "default": "()",
                  "description": "args for ax.plot"
                },
                {
                  "name": "kwargs",
                  "type": null,
                  "default": "{}",
                  "description": "kwargs for ax.plot"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "plot2D",
              "description": "Directly create a 2D plot of the recorded data for quick visualization and debugging.",
              "docstring_html": "<p>Directly create a 2D plot of the recorded data for quick visualization and debugging.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>args <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">tuple</span></dt>\n<dd>args for ax.plot</dd>\n<dt>axes <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">tuple[int]</span></dt>\n<dd>axes / ports to select for 2d plot</dd>\n<dt>kwargs <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">dict</span></dt>\n<dd>kwargs for ax.plot</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>fig <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">matplotlib.figure</span></dt>\n<dd>internal figure instance</dd>\n<dt>ax <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">matplotlib.axis</span></dt>\n<dd>internal axis instance</dd>\n</dl>\n",
              "source": "def plot2D(self, *args, axes=(0, 1), **kwargs):\n    \"\"\"Directly create a 2D plot of the recorded data for quick visualization and debugging.\n\n    Parameters\n    ----------\n    args : tuple\n        args for ax.plot\n    axes : tuple[int]\n        axes / ports to select for 2d plot\n    kwargs : dict\n        kwargs for ax.plot\n\n    Returns\n    -------\n    fig : matplotlib.figure\n        internal figure instance\n    ax : matplotlib.axis\n        internal axis instance\n    \"\"\" \n\n    #just return 'None' if no recording available\n    if not self.recording:\n        warnings.warn(\"no recording available for plotting in 'Scope.plot2D'\")\n        return None, None\n\n    #get data\n    time, data = self.read() \n\n    #not enough channels -> early exit\n    if len(data) < 2 or len(axes) != 2:\n        warnings.warn(\"not enough channels for plotting in 'Scope.plot2D'\")\n        return None, None\n\n    #axes selected not available -> early exit\n    ax1_idx, ax2_idx = axes\n    if not (0 <= ax1_idx < data.shape[0] and 0 <= ax2_idx < data.shape[0]):\n         warnings.warn(f\"Selected axes {axes} out of bounds for data shape {data.shape}\")\n         return None, None \n\n    #initialize figure\n    fig, ax = plt.subplots(nrows=1, ncols=1, figsize=(4, 4), tight_layout=True, dpi=120)\n\n    #custom colors\n    ax.set_prop_cycle(color=COLORS_ALL)\n\n    #unpack data for selected axes\n    d1 = data[ax1_idx]\n    d2 = data[ax2_idx]\n\n    #plot the data\n    ax.plot(d1, d2, *args, **kwargs)\n\n    #axis labels\n    l1 = self.labels[ax1_idx] if ax1_idx < len(self.labels) else f\"port {ax1_idx}\"\n    l2 = self.labels[ax2_idx] if ax2_idx < len(self.labels) else f\"port {ax2_idx}\"\n    ax.set_xlabel(l1)\n    ax.set_ylabel(l2)\n\n    ax.grid()\n\n    #show the plot without blocking following code\n    plt.show(block=False)\n\n    #return figure and axis for outside manipulation\n    return fig, ax",
              "signature": "(args = (), axes = (0, 1), kwargs = {})",
              "parameters": [
                {
                  "name": "args",
                  "type": null,
                  "default": "()",
                  "description": "args for ax.plot"
                },
                {
                  "name": "axes",
                  "type": null,
                  "default": "(0, 1)",
                  "description": "axes / ports to select for 2d plot"
                },
                {
                  "name": "kwargs",
                  "type": null,
                  "default": "{}",
                  "description": "kwargs for ax.plot"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "plot3D",
              "description": "Directly create a 3D plot of the recorded data for quick visualization.",
              "docstring_html": "<p>Directly create a 3D plot of the recorded data for quick visualization.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>args <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">tuple</span></dt>\n<dd>args for ax.plot</dd>\n<dt>axes <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">tuple[int]</span></dt>\n<dd>indices of the three data channels (ports) to plot (default: (0, 1, 2)).</dd>\n<dt>kwargs <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">dict</span></dt>\n<dd>kwargs for ax.plot</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>fig <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">matplotlib.figure</span></dt>\n<dd>internal figure instance.</dd>\n<dt>ax <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">matplotlib.axes._axes.Axes3D</span></dt>\n<dd>internal 3D axis instance.</dd>\n</dl>\n",
              "source": "def plot3D(self, *args, axes=(0, 1, 2), **kwargs):\n    \"\"\"Directly create a 3D plot of the recorded data for quick visualization.\n\n    Parameters\n    ----------\n    args : tuple\n        args for ax.plot\n    axes : tuple[int]\n        indices of the three data channels (ports) to plot (default: (0, 1, 2)).\n    kwargs : dict\n        kwargs for ax.plot\n\n    Returns\n    -------\n    fig : matplotlib.figure\n        internal figure instance.\n    ax : matplotlib.axes._axes.Axes3D\n        internal 3D axis instance.\n    \"\"\"\n\n    #check if recording is available\n    if not self.recording:\n        warnings.warn(\"no recording available for plotting in 'Scope.plot3D'\")\n        return None, None \n\n    #read the recorded data\n    time, data = self.read()\n\n    #check if enough channels are available\n    if data.shape[0] < 3 or len(axes) != 3:\n        warnings.warn(f\"Need at least 3 channels for plot3D, got {data.shape[0]}. Or axes argument length is not 3.\")\n        return None, None\n\n    #check if selected axes are valid\n    ax1_idx, ax2_idx, ax3_idx = axes\n    if not (0 <= ax1_idx < data.shape[0] and\n            0 <= ax2_idx < data.shape[0] and\n            0 <= ax3_idx < data.shape[0]):\n        warnings.warn(f\"Selected axes {axes} out of bounds for data shape {data.shape}\")\n        return None, None \n\n    #initialize 3D figure\n    fig = plt.figure(figsize=(6, 6), dpi=120)\n    ax = fig.add_subplot(111, projection='3d')\n\n    #custom colors\n    ax.set_prop_cycle(color=COLORS_ALL)\n\n    #unpack data for selected axes\n    d1 = data[ax1_idx]\n    d2 = data[ax2_idx]\n    d3 = data[ax3_idx]\n\n    #plot the 3D data\n    ax.plot(d1, d2, d3, *args, **kwargs)\n\n    #set axis labels using provided labels or default port numbers\n    label1 = self.labels[ax1_idx] if ax1_idx < len(self.labels) else f\"port {ax1_idx}\"\n    label2 = self.labels[ax2_idx] if ax2_idx < len(self.labels) else f\"port {ax2_idx}\"\n    label3 = self.labels[ax3_idx] if ax3_idx < len(self.labels) else f\"port {ax3_idx}\"\n    ax.set_xlabel(label1)\n    ax.set_ylabel(label2)\n    ax.set_zlabel(label3)\n\n    #show the plot without blocking\n    plt.show(block=False)\n\n    return fig, ax",
              "signature": "(args = (), axes = (0, 1, 2), kwargs = {})",
              "parameters": [
                {
                  "name": "args",
                  "type": null,
                  "default": "()",
                  "description": "args for ax.plot"
                },
                {
                  "name": "axes",
                  "type": null,
                  "default": "(0, 1, 2)",
                  "description": "indices of the three data channels (ports) to plot (default: (0, 1, 2))."
                },
                {
                  "name": "kwargs",
                  "type": null,
                  "default": "{}",
                  "description": "kwargs for ax.plot"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "save",
              "description": "Save the recording of the scope to a csv file.",
              "docstring_html": "<p>Save the recording of the scope to a csv file.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>path <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">str</span></dt>\n<dd>path where to save the recording as a csv file</dd>\n</dl>\n",
              "source": "def save(self, path=\"scope.csv\"):\n    \"\"\"Save the recording of the scope to a csv file.\n\n    Parameters\n    ----------\n    path : str\n        path where to save the recording as a csv file\n    \"\"\"\n\n    #check path ending\n    if not path.lower().endswith(\".csv\"):\n        path += \".csv\"\n\n    #get data\n    time, data = self.read() \n\n    #number of ports and labels\n    P, L = len(data), len(self.labels)\n\n    #make csv header\n    header = [\"time [s]\", *[self.labels[p] if p < L else f\"port {p}\" for p in range(P)]]\n\n    #write to csv file\n    with open(path, \"w\", newline=\"\") as file:\n        wrt = csv.writer(file)\n\n        #write the header to csv file\n        wrt.writerow(header)\n\n        #write each sample to the csv file\n        for sample in zip(time, *data):\n            wrt.writerow(sample)",
              "signature": "(path = 'scope.csv')",
              "parameters": [
                {
                  "name": "path",
                  "type": null,
                  "default": "'scope.csv'",
                  "description": "path where to save the recording as a csv file"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "update",
              "description": "update system equation for fixed point loop,",
              "docstring_html": "<p>update system equation for fixed point loop,\nhere just setting the outputs</p>\n<div class=\"section\" id=\"note\">\n<h4>Note</h4>\n<p>Scope has no passthrough, so the 'update' method\nis optimized for this case (does nothing)</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>error <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>absolute error to previous iteration for convergence\ncontrol (always '0.0' because sink-type)</dd>\n</dl>\n</div>\n",
              "source": "def update(self, t):\n    \"\"\"update system equation for fixed point loop, \n    here just setting the outputs\n\n    Note\n    ----\n    Scope has no passthrough, so the 'update' method \n    is optimized for this case (does nothing)       \n\n    Parameters\n    ----------\n    t : float\n        evaluation time\n\n    Returns\n    -------\n    error : float\n        absolute error to previous iteration for convergence \n        control (always '0.0' because sink-type)\n    \"\"\"\n    return 0.0",
              "signature": "(t)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time"
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "_n_in_max",
              "description": "",
              "type": null,
              "value": "None"
            },
            {
              "name": "_n_out_max",
              "description": "",
              "type": null,
              "value": "0"
            },
            {
              "name": "t_wait",
              "description": "",
              "type": null,
              "value": "t_wait"
            },
            {
              "name": "sampling_rate",
              "description": "",
              "type": null,
              "value": "sampling_rate"
            },
            {
              "name": "labels",
              "description": "",
              "type": null,
              "value": "labels if labels is not None else []"
            },
            {
              "name": "recording",
              "description": "",
              "type": null,
              "value": "{}"
            }
          ],
          "parameters": [
            {
              "name": "sampling_rate",
              "type": null,
              "default": "None",
              "description": "number of samples per time unit, default is every timestep"
            },
            {
              "name": "t_wait",
              "type": null,
              "default": "0.0",
              "description": "wait time before starting recording, optional"
            },
            {
              "name": "labels",
              "type": null,
              "default": "None",
              "description": "labels for the scope traces, and for the csv, optional"
            }
          ]
        },
        {
          "name": "RealtimeScope",
          "description": "An extension of the 'Scope' block that also initializes a realtime plotter",
          "docstring_html": "<p>An extension of the 'Scope' block that also initializes a realtime plotter\nthat creates an interactive plotting window while the simulation is running.</p>\n<p>Otherwise implements the same functionality as the regular 'Scope' block.</p>\n<div class=\"section\" id=\"note\">\n<h4>Note</h4>\n<p>Due to the plotting being relatively expensive, including this block\nslows down the simulation significantly but may still be valuable for\ndebugging and testing.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>sampling_rate <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int, None</span></dt>\n<dd>number of samples time unit, default is every timestep</dd>\n<dt>t_wait <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>wait time before starting recording</dd>\n<dt>labels <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">list[str]</span></dt>\n<dd>labels for the scope traces, and for the csv</dd>\n<dt>max_samples <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int, None</span></dt>\n<dd>number of samples for realtime display, all per default</dd>\n</dl>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>plotter <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">RealtimePlotter</span></dt>\n<dd>instance of a RealtimePlotter</dd>\n</dl>\n</div>\n",
          "source": "class RealtimeScope(Scope):\n    \"\"\"An extension of the 'Scope' block that also initializes a realtime plotter \n    that creates an interactive plotting window while the simulation is running.\n\n    Otherwise implements the same functionality as the regular 'Scope' block.\n\n    Note\n    -----\n    Due to the plotting being relatively expensive, including this block \n    slows down the simulation significantly but may still be valuable for \n    debugging and testing.\n\n    Parameters\n    ----------\n    sampling_rate : int, None\n        number of samples time unit, default is every timestep\n    t_wait : float\n        wait time before starting recording\n    labels : list[str] \n        labels for the scope traces, and for the csv\n    max_samples : int, None\n        number of samples for realtime display, all per default\n\n    Attributes\n    ----------\n    plotter : RealtimePlotter\n        instance of a RealtimePlotter\n    \"\"\"\n\n    def __init__(self, sampling_rate=None, t_wait=0.0, labels=[], max_samples=None):\n        super().__init__(sampling_rate, t_wait, labels)\n\n        #initialize realtime plotter\n        self.plotter = RealtimePlotter(\n            max_samples=max_samples, \n            update_interval=0.1, \n            labels=labels, \n            x_label=\"time [s]\", \n            y_label=\"\"\n            )\n\n\n    def sample(self, t):\n        \"\"\"Sample the data from all inputs, and overwrites existing timepoints, \n        since we use a dict for storing the recorded data.\n\n        Parameters\n        ----------\n        t : float\n            evaluation time for sampling\n        \"\"\"\n        if (self.sampling_rate is None or t * self.sampling_rate > len(self.recording)):\n            values = self.inputs.to_array()\n            self.plotter.update(t, values)\n            if t >= self.t_wait: \n                self.recording[t] = values",
          "bases": [
            "pathsim.blocks.scope.Scope"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, sampling_rate=None, t_wait=0.0, labels=[], max_samples=None):\n    super().__init__(sampling_rate, t_wait, labels)\n\n    #initialize realtime plotter\n    self.plotter = RealtimePlotter(\n        max_samples=max_samples, \n        update_interval=0.1, \n        labels=labels, \n        x_label=\"time [s]\", \n        y_label=\"\"\n        )",
              "signature": "(sampling_rate = None, t_wait = 0.0, labels = [], max_samples = None)",
              "parameters": [
                {
                  "name": "sampling_rate",
                  "type": null,
                  "default": "None",
                  "description": ""
                },
                {
                  "name": "t_wait",
                  "type": null,
                  "default": "0.0",
                  "description": ""
                },
                {
                  "name": "labels",
                  "type": null,
                  "default": "[]",
                  "description": ""
                },
                {
                  "name": "max_samples",
                  "type": null,
                  "default": "None",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "sample",
              "description": "Sample the data from all inputs, and overwrites existing timepoints,",
              "docstring_html": "<p>Sample the data from all inputs, and overwrites existing timepoints,\nsince we use a dict for storing the recorded data.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time for sampling</dd>\n</dl>\n",
              "source": "def sample(self, t):\n    \"\"\"Sample the data from all inputs, and overwrites existing timepoints, \n    since we use a dict for storing the recorded data.\n\n    Parameters\n    ----------\n    t : float\n        evaluation time for sampling\n    \"\"\"\n    if (self.sampling_rate is None or t * self.sampling_rate > len(self.recording)):\n        values = self.inputs.to_array()\n        self.plotter.update(t, values)\n        if t >= self.t_wait: \n            self.recording[t] = values",
              "signature": "(t)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time for sampling"
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "plotter",
              "description": "",
              "type": null,
              "value": "RealtimePlotter(max_samples=max_samples, update_interval=0.1, labels=labels, x_label='time [s]', y_label='')"
            }
          ],
          "parameters": [
            {
              "name": "sampling_rate",
              "type": null,
              "default": "None",
              "description": "number of samples time unit, default is every timestep"
            },
            {
              "name": "t_wait",
              "type": null,
              "default": "0.0",
              "description": "wait time before starting recording"
            },
            {
              "name": "labels",
              "type": null,
              "default": "[]",
              "description": "labels for the scope traces, and for the csv"
            },
            {
              "name": "max_samples",
              "type": null,
              "default": "None",
              "description": "number of samples for realtime display, all per default"
            }
          ]
        }
      ],
      "functions": []
    },
    "pathsim.blocks.sources": {
      "name": "pathsim.blocks.sources",
      "description": "",
      "docstring_html": "",
      "classes": [
        {
          "name": "Constant",
          "description": "Produces a constant output signal (SISO)",
          "docstring_html": "<p>Produces a constant output signal (SISO)</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>value <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>constant defining block output</dd>\n</dl>\n",
          "source": "class Constant(Block):\n    \"\"\"Produces a constant output signal (SISO)\n\n    Parameters\n    ----------\n    value : float\n        constant defining block output\n    \"\"\"\n\n    #max number of ports\n    _n_in_max = 0\n    _n_out_max = 1\n\n    #maps for input and output port labels\n    _port_map_out = {\"out\": 0}\n\n    def __init__(self, value=1):\n        super().__init__()\n        self.value = value\n\n\n    def __len__(self):\n        \"\"\"No algebraic passthrough\"\"\"\n        return 0\n\n\n    def update(self, t):\n        \"\"\"update system equation fixed point loop\n\n        Parameters\n        ----------\n        t : float\n            evaluation time\n\n        Returns\n        -------\n        error : float\n            absolute error to previous iteration for convergence \n            control (always '0.0' because source-type)\n        \"\"\"\n        self.outputs[0] = self.value\n        return 0.0",
          "bases": [
            "pathsim.blocks._block.Block"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, value=1):\n    super().__init__()\n    self.value = value",
              "signature": "(value = 1)",
              "parameters": [
                {
                  "name": "value",
                  "type": null,
                  "default": "1",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "update",
              "description": "update system equation fixed point loop",
              "docstring_html": "<p>update system equation fixed point loop</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>error <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>absolute error to previous iteration for convergence\ncontrol (always '0.0' because source-type)</dd>\n</dl>\n",
              "source": "def update(self, t):\n    \"\"\"update system equation fixed point loop\n\n    Parameters\n    ----------\n    t : float\n        evaluation time\n\n    Returns\n    -------\n    error : float\n        absolute error to previous iteration for convergence \n        control (always '0.0' because source-type)\n    \"\"\"\n    self.outputs[0] = self.value\n    return 0.0",
              "signature": "(t)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time"
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "_n_in_max",
              "description": "",
              "type": null,
              "value": "0"
            },
            {
              "name": "_n_out_max",
              "description": "",
              "type": null,
              "value": "1"
            },
            {
              "name": "_port_map_out",
              "description": "",
              "type": null,
              "value": "{'out': 0}"
            },
            {
              "name": "value",
              "description": "",
              "type": null,
              "value": "value"
            }
          ],
          "parameters": [
            {
              "name": "value",
              "type": null,
              "default": "1",
              "description": "constant defining block output"
            }
          ]
        },
        {
          "name": "Source",
          "description": "Source that produces an arbitrary time dependent output,",
          "docstring_html": "<p>Source that produces an arbitrary time dependent output,\ndefined by the func (callable).</p>\n<div class=\"math\">\n\\begin{equation*}\ny(t) = \\mathrm{func}(t)\n\\end{equation*}\n</div>\n<div class=\"section\" id=\"note\">\n<h4>Note</h4>\n<p>This block is purely algebraic and its internal function (<cite>func</cite>) will\nbe called multiple times per timestep, each time when <cite>Simulation._update(t)</cite>\nis called in the global simulation loop.</p>\n</div>\n<div class=\"section\" id=\"example\">\n<h4>Example</h4>\n<p>For example a ramp:</p>\n<pre class=\"code python literal-block\">\n<span class=\"kn\">from</span><span class=\"w\"> </span><span class=\"nn\">pathsim.blocks</span><span class=\"w\"> </span><span class=\"kn\">import</span> <span class=\"n\">Source</span><span class=\"w\">\n\n</span><span class=\"n\">src</span> <span class=\"o\">=</span> <span class=\"n\">Source</span><span class=\"p\">(</span><span class=\"k\">lambda</span> <span class=\"n\">t</span> <span class=\"p\">:</span> <span class=\"n\">t</span><span class=\"p\">)</span>\n</pre>\n<p>or a simple sinusoid with some frequency:</p>\n<pre class=\"code python literal-block\">\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"nn\">numpy</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"nn\">np</span><span class=\"w\">\n</span><span class=\"kn\">from</span><span class=\"w\"> </span><span class=\"nn\">pathsim.blocks</span><span class=\"w\"> </span><span class=\"kn\">import</span> <span class=\"n\">Source</span><span class=\"w\">\n\n</span><span class=\"c1\">#some parameter</span><span class=\"w\">\n</span><span class=\"n\">omega</span> <span class=\"o\">=</span> <span class=\"mi\">100</span><span class=\"w\">\n\n</span><span class=\"c1\">#the function that gets evaluated</span><span class=\"w\">\n</span><span class=\"k\">def</span><span class=\"w\"> </span><span class=\"nf\">f</span><span class=\"p\">(</span><span class=\"n\">t</span><span class=\"p\">):</span><span class=\"w\">\n</span>    <span class=\"k\">return</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">sin</span><span class=\"p\">(</span><span class=\"n\">omega</span> <span class=\"o\">*</span> <span class=\"n\">t</span><span class=\"p\">)</span><span class=\"w\">\n\n</span><span class=\"n\">src</span> <span class=\"o\">=</span> <span class=\"n\">Source</span><span class=\"p\">(</span><span class=\"n\">f</span><span class=\"p\">)</span>\n</pre>\n<p>Because the <cite>Source</cite> block only has a single argument, it can be\nused to decorate a function and make it a <cite>PathSim</cite> block. This might\nbe handy in some cases to keep definitions concise and localized\nin the code:</p>\n<pre class=\"code python literal-block\">\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"nn\">numpy</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"nn\">np</span><span class=\"w\">\n</span><span class=\"kn\">from</span><span class=\"w\"> </span><span class=\"nn\">pathsim.blocks</span><span class=\"w\"> </span><span class=\"kn\">import</span> <span class=\"n\">Source</span><span class=\"w\">\n\n</span><span class=\"c1\">#does the same as the definition above</span><span class=\"w\">\n\n</span><span class=\"nd\">&#64;Source</span><span class=\"w\">\n</span><span class=\"k\">def</span><span class=\"w\"> </span><span class=\"nf\">src</span><span class=\"p\">(</span><span class=\"n\">t</span><span class=\"p\">):</span><span class=\"w\">\n</span>    <span class=\"n\">omega</span> <span class=\"o\">=</span> <span class=\"mi\">100</span><span class=\"w\">\n</span>    <span class=\"k\">return</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">sin</span><span class=\"p\">(</span><span class=\"n\">omega</span> <span class=\"o\">*</span> <span class=\"n\">t</span><span class=\"p\">)</span><span class=\"w\">\n\n</span><span class=\"c1\">#'src' is now a PathSim block</span>\n</pre>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>func <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">callable</span></dt>\n<dd>function defining time dependent block output</dd>\n</dl>\n</div>\n",
          "source": "class Source(Block):\n    \"\"\"Source that produces an arbitrary time dependent output, \n    defined by the func (callable).\n\n    .. math::\n\n        y(t) = \\\\mathrm{func}(t)\n\n\n    Note\n    ----\n    This block is purely algebraic and its internal function (`func`) will \n    be called multiple times per timestep, each time when `Simulation._update(t)` \n    is called in the global simulation loop.\n\n\n    Example\n    -------\n    For example a ramp:\n\n    .. code-block:: python\n\n        from pathsim.blocks import Source\n\n        src = Source(lambda t : t)\n\n    or a simple sinusoid with some frequency:\n\n    .. code-block:: python\n\n        import numpy as np\n        from pathsim.blocks import Source\n\n        #some parameter\n        omega = 100\n\n        #the function that gets evaluated\n        def f(t):\n            return np.sin(omega * t)\n\n        src = Source(f)\n\n    Because the `Source` block only has a single argument, it can be \n    used to decorate a function and make it a `PathSim` block. This might \n    be handy in some cases to keep definitions concise and localized \n    in the code:\n\n    .. code-block:: python\n\n        import numpy as np\n        from pathsim.blocks import Source\n\n        #does the same as the definition above\n\n        @Source\n        def src(t):\n            omega = 100\n            return np.sin(omega * t)\n\n        #'src' is now a PathSim block\n\n\n    Parameters\n    ---------- \n    func : callable\n        function defining time dependent block output\n    \"\"\"\n\n    #max number of ports\n    _n_in_max = 0\n    _n_out_max = 1\n\n    #maps for input and output port labels\n    _port_map_out = {\"out\": 0}\n\n    def __init__(self, func=lambda t: 1):\n        super().__init__()\n\n        if not callable(func):\n            raise ValueError(f\"'{func}' is not callable\")\n\n        self.func = func\n\n\n    def __len__(self):\n        \"\"\"No algebraic passthrough\"\"\"\n        return 0\n\n\n    def update(self, t):\n        \"\"\"update system equation fixed point loop \n        by evaluating the internal function 'func'\n\n        Note\n        ----\n        No direct passthrough, so the `update` method \n        is optimized and has no convergence check\n\n        Parameters\n        ----------\n        t : float\n            evaluation time\n        \"\"\"\n        self.outputs[0] = self.func(t)",
          "bases": [
            "pathsim.blocks._block.Block"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, func=lambda t: 1):\n    super().__init__()\n\n    if not callable(func):\n        raise ValueError(f\"'{func}' is not callable\")\n\n    self.func = func",
              "signature": "(func = lambda t: 1)",
              "parameters": [
                {
                  "name": "func",
                  "type": null,
                  "default": "lambda t: 1",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "update",
              "description": "update system equation fixed point loop",
              "docstring_html": "<p>update system equation fixed point loop\nby evaluating the internal function 'func'</p>\n<div class=\"section\" id=\"note\">\n<h4>Note</h4>\n<p>No direct passthrough, so the <cite>update</cite> method\nis optimized and has no convergence check</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time</dd>\n</dl>\n</div>\n",
              "source": "def update(self, t):\n    \"\"\"update system equation fixed point loop \n    by evaluating the internal function 'func'\n\n    Note\n    ----\n    No direct passthrough, so the `update` method \n    is optimized and has no convergence check\n\n    Parameters\n    ----------\n    t : float\n        evaluation time\n    \"\"\"\n    self.outputs[0] = self.func(t)",
              "signature": "(t)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time"
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "_n_in_max",
              "description": "",
              "type": null,
              "value": "0"
            },
            {
              "name": "_n_out_max",
              "description": "",
              "type": null,
              "value": "1"
            },
            {
              "name": "_port_map_out",
              "description": "",
              "type": null,
              "value": "{'out': 0}"
            },
            {
              "name": "func",
              "description": "",
              "type": null,
              "value": "func"
            }
          ],
          "parameters": [
            {
              "name": "func",
              "type": null,
              "default": "lambda t: 1",
              "description": "function defining time dependent block output"
            }
          ]
        },
        {
          "name": "TriangleWaveSource",
          "description": "Source block that generates an analog triangle wave",
          "docstring_html": "<p>Source block that generates an analog triangle wave</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>frequency <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>frequency of the triangle wave</dd>\n<dt>amplitude <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>amplitude of the triangle wave</dd>\n<dt>phase <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>phase of the triangle wave</dd>\n</dl>\n",
          "source": "class TriangleWaveSource(Block):\n    \"\"\"Source block that generates an analog triangle wave\n\n    Parameters\n    ----------\n    frequency : float\n        frequency of the triangle wave\n    amplitude : float\n        amplitude of the triangle wave\n    phase : float\n        phase of the triangle wave\n    \"\"\"\n\n    #max number of ports\n    _n_in_max = 0\n    _n_out_max = 1\n\n    #maps for input and output port labels\n    _port_map_out = {\"out\": 0}\n\n    def __init__(self, frequency=1, amplitude=1, phase=0):\n        super().__init__()\n\n        self.amplitude = amplitude\n        self.frequency = frequency\n        self.phase = phase\n\n\n    def __len__(self):\n        return 0\n\n\n    def _triangle_wave(self, t, f):\n        \"\"\"triangle wave with amplitude '1' and frequency 'f'\n\n        Parameters\n        ----------\n        t : float\n            evaluation time\n        f : float\n            trig wave frequency\n\n        Returns\n        -------\n        out : float\n            trig wave value\n        \"\"\"\n        return 2 * abs(t*f - np.floor(t*f + 0.5)) - 1\n\n\n    def update(self, t):\n        tau = self.phase/(2*np.pi*self.frequency)\n        self.outputs[0] = self.amplitude * self._triangle_wave(t + tau, self.frequency)",
          "bases": [
            "pathsim.blocks._block.Block"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, frequency=1, amplitude=1, phase=0):\n    super().__init__()\n\n    self.amplitude = amplitude\n    self.frequency = frequency\n    self.phase = phase",
              "signature": "(frequency = 1, amplitude = 1, phase = 0)",
              "parameters": [
                {
                  "name": "frequency",
                  "type": null,
                  "default": "1",
                  "description": ""
                },
                {
                  "name": "amplitude",
                  "type": null,
                  "default": "1",
                  "description": ""
                },
                {
                  "name": "phase",
                  "type": null,
                  "default": "0",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "_triangle_wave",
              "description": "triangle wave with amplitude '1' and frequency 'f'",
              "docstring_html": "<p>triangle wave with amplitude '1' and frequency 'f'</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time</dd>\n<dt>f <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>trig wave frequency</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>out <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>trig wave value</dd>\n</dl>\n",
              "source": "def _triangle_wave(self, t, f):\n    \"\"\"triangle wave with amplitude '1' and frequency 'f'\n\n    Parameters\n    ----------\n    t : float\n        evaluation time\n    f : float\n        trig wave frequency\n\n    Returns\n    -------\n    out : float\n        trig wave value\n    \"\"\"\n    return 2 * abs(t*f - np.floor(t*f + 0.5)) - 1",
              "signature": "(t, f)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time"
                },
                {
                  "name": "f",
                  "type": null,
                  "default": null,
                  "description": "trig wave frequency"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "update",
              "description": "",
              "docstring_html": "",
              "source": "def update(self, t):\n    tau = self.phase/(2*np.pi*self.frequency)\n    self.outputs[0] = self.amplitude * self._triangle_wave(t + tau, self.frequency)",
              "signature": "(t)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "_n_in_max",
              "description": "",
              "type": null,
              "value": "0"
            },
            {
              "name": "_n_out_max",
              "description": "",
              "type": null,
              "value": "1"
            },
            {
              "name": "_port_map_out",
              "description": "",
              "type": null,
              "value": "{'out': 0}"
            },
            {
              "name": "amplitude",
              "description": "",
              "type": null,
              "value": "amplitude"
            },
            {
              "name": "frequency",
              "description": "",
              "type": null,
              "value": "frequency"
            },
            {
              "name": "phase",
              "description": "",
              "type": null,
              "value": "phase"
            }
          ],
          "parameters": [
            {
              "name": "frequency",
              "type": null,
              "default": "1",
              "description": "frequency of the triangle wave"
            },
            {
              "name": "amplitude",
              "type": null,
              "default": "1",
              "description": "amplitude of the triangle wave"
            },
            {
              "name": "phase",
              "type": null,
              "default": "0",
              "description": "phase of the triangle wave"
            }
          ]
        },
        {
          "name": "SinusoidalSource",
          "description": "Source block that generates a sinusoid wave",
          "docstring_html": "<p>Source block that generates a sinusoid wave</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>frequency <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>frequency of the sinusoid</dd>\n<dt>amplitude <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>amplitude of the sinusoid</dd>\n<dt>phase <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>phase of the sinusoid</dd>\n</dl>\n",
          "source": "class SinusoidalSource(Block):\n    \"\"\"Source block that generates a sinusoid wave\n\n    Parameters\n    ----------\n    frequency : float\n        frequency of the sinusoid\n    amplitude : float\n        amplitude of the sinusoid\n    phase : float\n        phase of the sinusoid\n    \"\"\"\n\n    #max number of ports\n    _n_in_max = 0\n    _n_out_max = 1\n\n    #maps for input and output port labels\n    _port_map_out = {\"out\": 0}\n\n    def __init__(self, frequency=1, amplitude=1, phase=0):\n        super().__init__()\n\n        self.amplitude = amplitude\n        self.frequency = frequency\n        self.phase = phase\n\n\n    def __len__(self):\n        return 0\n\n\n    def update(self, t):\n        omega = 2*np.pi*self.frequency\n        self.outputs[0] = self.amplitude * np.sin(omega*t + self.phase)",
          "bases": [
            "pathsim.blocks._block.Block"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, frequency=1, amplitude=1, phase=0):\n    super().__init__()\n\n    self.amplitude = amplitude\n    self.frequency = frequency\n    self.phase = phase",
              "signature": "(frequency = 1, amplitude = 1, phase = 0)",
              "parameters": [
                {
                  "name": "frequency",
                  "type": null,
                  "default": "1",
                  "description": ""
                },
                {
                  "name": "amplitude",
                  "type": null,
                  "default": "1",
                  "description": ""
                },
                {
                  "name": "phase",
                  "type": null,
                  "default": "0",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "update",
              "description": "",
              "docstring_html": "",
              "source": "def update(self, t):\n    omega = 2*np.pi*self.frequency\n    self.outputs[0] = self.amplitude * np.sin(omega*t + self.phase)",
              "signature": "(t)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "_n_in_max",
              "description": "",
              "type": null,
              "value": "0"
            },
            {
              "name": "_n_out_max",
              "description": "",
              "type": null,
              "value": "1"
            },
            {
              "name": "_port_map_out",
              "description": "",
              "type": null,
              "value": "{'out': 0}"
            },
            {
              "name": "amplitude",
              "description": "",
              "type": null,
              "value": "amplitude"
            },
            {
              "name": "frequency",
              "description": "",
              "type": null,
              "value": "frequency"
            },
            {
              "name": "phase",
              "description": "",
              "type": null,
              "value": "phase"
            }
          ],
          "parameters": [
            {
              "name": "frequency",
              "type": null,
              "default": "1",
              "description": "frequency of the sinusoid"
            },
            {
              "name": "amplitude",
              "type": null,
              "default": "1",
              "description": "amplitude of the sinusoid"
            },
            {
              "name": "phase",
              "type": null,
              "default": "0",
              "description": "phase of the sinusoid"
            }
          ]
        },
        {
          "name": "GaussianPulseSource",
          "description": "Source block that generates a gaussian pulse",
          "docstring_html": "<p>Source block that generates a gaussian pulse</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>amplitude <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>amplitude of the gaussian pulse</dd>\n<dt>f_max <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>maximum frequency component of the gaussian pulse (steepness)</dd>\n<dt>tau <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>time delay of the gaussian pulse</dd>\n</dl>\n",
          "source": "class GaussianPulseSource(Block):\n    \"\"\"Source block that generates a gaussian pulse\n\n    Parameters\n    ----------\n    amplitude : float\n        amplitude of the gaussian pulse\n    f_max : float\n        maximum frequency component of the gaussian pulse (steepness)\n    tau : float\n        time delay of the gaussian pulse \n    \"\"\"\n\n    #max number of ports\n    _n_in_max = 0\n    _n_out_max = 1\n\n    #maps for input and output port labels\n    _port_map_out = {\"out\": 0}\n\n    def __init__(self, amplitude=1, f_max=1e3, tau=0.0):\n        super().__init__()\n\n        self.amplitude = amplitude\n        self.f_max = f_max\n        self.tau = tau\n\n\n    def __len__(self):\n        return 0\n\n\n    def _gaussian(self, t, f_max):\n        \"\"\"gaussian pulse with its maximum at t=0\n\n        Parameters\n        ----------\n        t : float\n            evaluation time\n        f_max : float\n            maximum frequency component of gaussian\n\n        Returns\n        -------\n        out : float\n            gaussian value\n        \"\"\"\n        tau = 0.5 / f_max\n        return np.exp(-(t/tau)**2)\n\n\n    def update(self, t):\n        self.outputs[0] = self.amplitude * self._gaussian(t-self.tau, self.f_max)",
          "bases": [
            "pathsim.blocks._block.Block"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, amplitude=1, f_max=1e3, tau=0.0):\n    super().__init__()\n\n    self.amplitude = amplitude\n    self.f_max = f_max\n    self.tau = tau",
              "signature": "(amplitude = 1, f_max = 1000.0, tau = 0.0)",
              "parameters": [
                {
                  "name": "amplitude",
                  "type": null,
                  "default": "1",
                  "description": ""
                },
                {
                  "name": "f_max",
                  "type": null,
                  "default": "1000.0",
                  "description": ""
                },
                {
                  "name": "tau",
                  "type": null,
                  "default": "0.0",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "_gaussian",
              "description": "gaussian pulse with its maximum at t=0",
              "docstring_html": "<p>gaussian pulse with its maximum at t=0</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time</dd>\n<dt>f_max <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>maximum frequency component of gaussian</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>out <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>gaussian value</dd>\n</dl>\n",
              "source": "def _gaussian(self, t, f_max):\n    \"\"\"gaussian pulse with its maximum at t=0\n\n    Parameters\n    ----------\n    t : float\n        evaluation time\n    f_max : float\n        maximum frequency component of gaussian\n\n    Returns\n    -------\n    out : float\n        gaussian value\n    \"\"\"\n    tau = 0.5 / f_max\n    return np.exp(-(t/tau)**2)",
              "signature": "(t, f_max)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time"
                },
                {
                  "name": "f_max",
                  "type": null,
                  "default": null,
                  "description": "maximum frequency component of gaussian"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "update",
              "description": "",
              "docstring_html": "",
              "source": "def update(self, t):\n    self.outputs[0] = self.amplitude * self._gaussian(t-self.tau, self.f_max)",
              "signature": "(t)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "_n_in_max",
              "description": "",
              "type": null,
              "value": "0"
            },
            {
              "name": "_n_out_max",
              "description": "",
              "type": null,
              "value": "1"
            },
            {
              "name": "_port_map_out",
              "description": "",
              "type": null,
              "value": "{'out': 0}"
            },
            {
              "name": "amplitude",
              "description": "",
              "type": null,
              "value": "amplitude"
            },
            {
              "name": "f_max",
              "description": "",
              "type": null,
              "value": "f_max"
            },
            {
              "name": "tau",
              "description": "",
              "type": null,
              "value": "tau"
            }
          ],
          "parameters": [
            {
              "name": "amplitude",
              "type": null,
              "default": "1",
              "description": "amplitude of the gaussian pulse"
            },
            {
              "name": "f_max",
              "type": null,
              "default": "1000.0",
              "description": "maximum frequency component of the gaussian pulse (steepness)"
            },
            {
              "name": "tau",
              "type": null,
              "default": "0.0",
              "description": "time delay of the gaussian pulse"
            }
          ]
        },
        {
          "name": "SinusoidalPhaseNoiseSource",
          "description": "Sinusoidal source with cumulative and white phase noise",
          "docstring_html": "<p>Sinusoidal source with cumulative and white phase noise</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>frequency <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>frequency of the sinusoid</dd>\n<dt>amplitude <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>amplitude of the sinusoid</dd>\n<dt>phase <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>phase of the sinusoid</dd>\n<dt>sig_cum <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>weight for cumulative phase noise contribution</dd>\n<dt>sig_white <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>weight for white phase noise contribution</dd>\n<dt>sampling_rate <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>number of samples per unit time for the internal RNG</dd>\n</dl>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>omega <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>angular frequency of the sinusoid, derived from <cite>frequency</cite></dd>\n<dt>noise_1 <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>internal noise value sampled from normal distribution</dd>\n<dt>noise_2 <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>internal noise value sampled from normal distribution</dd>\n<dt>n_samples <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>bin counter for sampling</dd>\n<dt>t_max <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>most recent sampling time, to ensure timing for sampling bins</dd>\n</dl>\n",
          "source": "class SinusoidalPhaseNoiseSource(Block):\n    \"\"\"Sinusoidal source with cumulative and white phase noise\n\n    Parameters\n    ----------\n    frequency : float\n        frequency of the sinusoid\n    amplitude : float\n        amplitude of the sinusoid\n    phase : float\n        phase of the sinusoid\n    sig_cum : float\n        weight for cumulative phase noise contribution\n    sig_white : float\n        weight for white phase noise contribution\n    sampling_rate : float\n        number of samples per unit time for the internal RNG \n\n    Attributes\n    ----------\n    omega : float\n        angular frequency of the sinusoid, derived from `frequency`\n    noise_1 : float\n        internal noise value sampled from normal distribution\n    noise_2 : float\n        internal noise value sampled from normal distribution\n    n_samples : int\n        bin counter for sampling\n    t_max : float\n        most recent sampling time, to ensure timing for sampling bins\n    \"\"\"\n\n    #max number of ports\n    _n_in_max = 0\n    _n_out_max = 1\n\n    #maps for input and output port labels\n    _port_map_out = {\"out\": 0}\n\n    def __init__(\n        self, \n        frequency=1, \n        amplitude=1, \n        phase=0, \n        sig_cum=0, \n        sig_white=0, \n        sampling_rate=10\n        ):\n        super().__init__()\n\n        self.amplitude = amplitude\n        self.frequency = frequency\n        self.phase = phase\n\n        self.sampling_rate = sampling_rate\n\n        self.omega = 2 * np.pi * self.frequency\n\n        #parameters for phase noise\n        self.sig_cum = sig_cum\n        self.sig_white = sig_white\n\n        #initial noise sampling\n        self.noise_1 = np.random.normal() \n        self.noise_2 = np.random.normal() \n\n        #bin counter\n        self.n_samples = 0\n        self.t_max = 0\n\n\n    def __len__(self):\n        return 0\n\n\n    def set_solver(self, Solver, **solver_kwargs):\n        #initialize the numerical integration engine \n        if self.engine is None: self.engine = Solver(0.0, **solver_kwargs)\n        #change solver if already initialized\n        else: self.engine = Solver.cast(self.engine, **solver_kwargs)\n\n\n    def reset(self):\n        super().reset()\n\n        #reset block specific attributes\n        self.n_samples = 0\n        self.t_max = 0\n\n\n    def update(self, t):\n        \"\"\"update system equation for fixed point loop, \n        here just setting the outputs\n\n        Note\n        ----\n        no direct passthrough, so the 'update' method \n        is optimized for this case        \n\n        Parameters\n        ----------\n        t : float\n            evaluation time\n        \"\"\"\n\n        #compute phase error\n        phase_error = self.sig_white * self.noise_1 + self.sig_cum * self.engine.get()\n\n        #set output\n        self.outputs[0] = self.amplitude * np.sin(self.omega*t + self.phase + phase_error)\n\n\n    def sample(self, t):\n        \"\"\"\n        Sample from a normal distribution after successful timestep.\n        \"\"\"\n        if (self.sampling_rate is None or \n            self.n_samples < t * self.sampling_rate):\n            self.noise_1 = np.random.normal() \n            self.noise_2 = np.random.normal() \n            self.n_samples += 1\n\n\n    def solve(self, t, dt):\n        #advance solution of implicit update equation (no jacobian)\n        f = self.noise_2\n        self.engine.solve(f, None, dt)\n        return 0.0\n\n\n    def step(self, t, dt):\n        #compute update step with integration engine\n        f = self.noise_2\n        self.engine.step(f, dt)\n\n        #no error control for noise source\n        return True, 0.0, 1.0",
          "bases": [
            "pathsim.blocks._block.Block"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(\n    self, \n    frequency=1, \n    amplitude=1, \n    phase=0, \n    sig_cum=0, \n    sig_white=0, \n    sampling_rate=10\n    ):\n    super().__init__()\n\n    self.amplitude = amplitude\n    self.frequency = frequency\n    self.phase = phase\n\n    self.sampling_rate = sampling_rate\n\n    self.omega = 2 * np.pi * self.frequency\n\n    #parameters for phase noise\n    self.sig_cum = sig_cum\n    self.sig_white = sig_white\n\n    #initial noise sampling\n    self.noise_1 = np.random.normal() \n    self.noise_2 = np.random.normal() \n\n    #bin counter\n    self.n_samples = 0\n    self.t_max = 0",
              "signature": "(frequency = 1, amplitude = 1, phase = 0, sig_cum = 0, sig_white = 0, sampling_rate = 10)",
              "parameters": [
                {
                  "name": "frequency",
                  "type": null,
                  "default": "1",
                  "description": ""
                },
                {
                  "name": "amplitude",
                  "type": null,
                  "default": "1",
                  "description": ""
                },
                {
                  "name": "phase",
                  "type": null,
                  "default": "0",
                  "description": ""
                },
                {
                  "name": "sig_cum",
                  "type": null,
                  "default": "0",
                  "description": ""
                },
                {
                  "name": "sig_white",
                  "type": null,
                  "default": "0",
                  "description": ""
                },
                {
                  "name": "sampling_rate",
                  "type": null,
                  "default": "10",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "set_solver",
              "description": "",
              "docstring_html": "",
              "source": "def set_solver(self, Solver, **solver_kwargs):\n    #initialize the numerical integration engine \n    if self.engine is None: self.engine = Solver(0.0, **solver_kwargs)\n    #change solver if already initialized\n    else: self.engine = Solver.cast(self.engine, **solver_kwargs)",
              "signature": "(Solver, solver_kwargs = {})",
              "parameters": [
                {
                  "name": "Solver",
                  "type": null,
                  "default": null,
                  "description": ""
                },
                {
                  "name": "solver_kwargs",
                  "type": null,
                  "default": "{}",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "reset",
              "description": "",
              "docstring_html": "",
              "source": "def reset(self):\n    super().reset()\n\n    #reset block specific attributes\n    self.n_samples = 0\n    self.t_max = 0",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "update",
              "description": "update system equation for fixed point loop,",
              "docstring_html": "<p>update system equation for fixed point loop,\nhere just setting the outputs</p>\n<div class=\"section\" id=\"note\">\n<h4>Note</h4>\n<p>no direct passthrough, so the 'update' method\nis optimized for this case</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time</dd>\n</dl>\n</div>\n",
              "source": "def update(self, t):\n    \"\"\"update system equation for fixed point loop, \n    here just setting the outputs\n\n    Note\n    ----\n    no direct passthrough, so the 'update' method \n    is optimized for this case        \n\n    Parameters\n    ----------\n    t : float\n        evaluation time\n    \"\"\"\n\n    #compute phase error\n    phase_error = self.sig_white * self.noise_1 + self.sig_cum * self.engine.get()\n\n    #set output\n    self.outputs[0] = self.amplitude * np.sin(self.omega*t + self.phase + phase_error)",
              "signature": "(t)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "sample",
              "description": "Sample from a normal distribution after successful timestep.",
              "docstring_html": "<p>Sample from a normal distribution after successful timestep.</p>\n",
              "source": "def sample(self, t):\n    \"\"\"\n    Sample from a normal distribution after successful timestep.\n    \"\"\"\n    if (self.sampling_rate is None or \n        self.n_samples < t * self.sampling_rate):\n        self.noise_1 = np.random.normal() \n        self.noise_2 = np.random.normal() \n        self.n_samples += 1",
              "signature": "(t)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "solve",
              "description": "",
              "docstring_html": "",
              "source": "def solve(self, t, dt):\n    #advance solution of implicit update equation (no jacobian)\n    f = self.noise_2\n    self.engine.solve(f, None, dt)\n    return 0.0",
              "signature": "(t, dt)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": ""
                },
                {
                  "name": "dt",
                  "type": null,
                  "default": null,
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "step",
              "description": "",
              "docstring_html": "",
              "source": "def step(self, t, dt):\n    #compute update step with integration engine\n    f = self.noise_2\n    self.engine.step(f, dt)\n\n    #no error control for noise source\n    return True, 0.0, 1.0",
              "signature": "(t, dt)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": ""
                },
                {
                  "name": "dt",
                  "type": null,
                  "default": null,
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "_n_in_max",
              "description": "",
              "type": null,
              "value": "0"
            },
            {
              "name": "_n_out_max",
              "description": "",
              "type": null,
              "value": "1"
            },
            {
              "name": "_port_map_out",
              "description": "",
              "type": null,
              "value": "{'out': 0}"
            },
            {
              "name": "amplitude",
              "description": "",
              "type": null,
              "value": "amplitude"
            },
            {
              "name": "frequency",
              "description": "",
              "type": null,
              "value": "frequency"
            },
            {
              "name": "phase",
              "description": "",
              "type": null,
              "value": "phase"
            },
            {
              "name": "sampling_rate",
              "description": "",
              "type": null,
              "value": "sampling_rate"
            },
            {
              "name": "omega",
              "description": "",
              "type": null,
              "value": "2 * np.pi * self.frequency"
            },
            {
              "name": "sig_cum",
              "description": "",
              "type": null,
              "value": "sig_cum"
            },
            {
              "name": "sig_white",
              "description": "",
              "type": null,
              "value": "sig_white"
            },
            {
              "name": "noise_1",
              "description": "",
              "type": null,
              "value": "np.random.normal()"
            },
            {
              "name": "noise_2",
              "description": "",
              "type": null,
              "value": "np.random.normal()"
            },
            {
              "name": "n_samples",
              "description": "",
              "type": null,
              "value": "0"
            },
            {
              "name": "t_max",
              "description": "",
              "type": null,
              "value": "0"
            }
          ],
          "parameters": [
            {
              "name": "frequency",
              "type": null,
              "default": "1",
              "description": "frequency of the sinusoid"
            },
            {
              "name": "amplitude",
              "type": null,
              "default": "1",
              "description": "amplitude of the sinusoid"
            },
            {
              "name": "phase",
              "type": null,
              "default": "0",
              "description": "phase of the sinusoid"
            },
            {
              "name": "sig_cum",
              "type": null,
              "default": "0",
              "description": "weight for cumulative phase noise contribution"
            },
            {
              "name": "sig_white",
              "type": null,
              "default": "0",
              "description": "weight for white phase noise contribution"
            },
            {
              "name": "sampling_rate",
              "type": null,
              "default": "10",
              "description": "number of samples per unit time for the internal RNG"
            }
          ]
        },
        {
          "name": "ChirpPhaseNoiseSource",
          "description": "Chirp source, sinusoid with frequency ramp up and ramp down.",
          "docstring_html": "<p>Chirp source, sinusoid with frequency ramp up and ramp down.</p>\n<p>This works by using a time dependent triangle wave for the frequency\nand integrating it with a numerical integration engine to get a\ncontinuous phase. This phase is then used to evaluate a sinusoid.</p>\n<p>Additionally the chirp source can have white and cumulative phase noise.\nMathematically it looks like this for the contributions to the phase from\nthe triangular wave:</p>\n<div class=\"math\">\n\\begin{equation*}\n\\varphi_t(t) = \\int_0^t \\mathrm{tri}_{f_0, B, T}(\\tau) \\, d\\tau\n\\end{equation*}\n</div>\n<p>And from the white (w) and cumulative (c) noise:</p>\n<div class=\"math\">\n\\begin{equation*}\n\\varphi_n(t) = \\sigma_w \\, \\mathrm{RNG}_w(t) + \\sigma_c \\int_0^t \\mathrm{RNG}_c(\\tau) \\, d\\tau\n\\end{equation*}\n</div>\n<p>The phase contributions are then used to evaluate a sinusoid to get the final chirp signal:</p>\n<div class=\"math\">\n\\begin{equation*}\ny(t) = A \\sin(\\varphi_t(t) + \\varphi_n(t) + \\varphi_0)\n\\end{equation*}\n</div>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>amplitude <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>amplitude of the chirp signal</dd>\n<dt>f0 <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>start frequency of the chirp signal</dd>\n<dt>BW <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>bandwidth of the frequency ramp of the chirp signal</dd>\n<dt>T <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>period of the frequency ramp of the chirp signal</dd>\n<dt>phase <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>phase of sinusoid (initial)</dd>\n<dt>sig_cum <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>weight for cumulative phase noise contribution</dd>\n<dt>sig_white <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>weight for white phase noise contribution</dd>\n<dt>sampling_rate <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>number of samples per unit time for the internal random number generators</dd>\n</dl>\n",
          "source": "class ChirpPhaseNoiseSource(Block):\n    \"\"\"Chirp source, sinusoid with frequency ramp up and ramp down.\n\n    This works by using a time dependent triangle wave for the frequency \n    and integrating it with a numerical integration engine to get a \n    continuous phase. This phase is then used to evaluate a sinusoid.\n\n    Additionally the chirp source can have white and cumulative phase noise. \n    Mathematically it looks like this for the contributions to the phase from \n    the triangular wave:\n\n    .. math::\n\n        \\\\varphi_t(t) = \\\\int_0^t \\\\mathrm{tri}_{f_0, B, T}(\\\\tau) \\\\, d\\\\tau\n\n    And from the white (w) and cumulative (c) noise:\n\n    .. math::\n\n        \\\\varphi_n(t) = \\\\sigma_w \\\\, \\\\mathrm{RNG}_w(t) + \\\\sigma_c \\\\int_0^t \\\\mathrm{RNG}_c(\\\\tau) \\\\, d\\\\tau\n\n    The phase contributions are then used to evaluate a sinusoid to get the final chirp signal:\n\n    .. math::\n\n        y(t) = A \\\\sin(\\\\varphi_t(t) + \\\\varphi_n(t) + \\\\varphi_0)\n\n    Parameters\n    ----------\n    amplitude : float\n        amplitude of the chirp signal\n    f0 : float\n        start frequency of the chirp signal\n    BW : float\n        bandwidth of the frequency ramp of the chirp signal\n    T : float\n        period of the frequency ramp of the chirp signal\n    phase : float\n        phase of sinusoid (initial)\n    sig_cum : float\n        weight for cumulative phase noise contribution\n    sig_white : float\n        weight for white phase noise contribution\n    sampling_rate : float\n        number of samples per unit time for the internal random number generators\n    \"\"\"\n\n    #max number of ports\n    _n_in_max = 0\n    _n_out_max = 1\n\n    #maps for input and output port labels\n    _port_map_out = {\"out\": 0}\n\n    def __init__(\n        self, \n        amplitude=1, \n        f0=1, \n        BW=1, \n        T=1, \n        phase=0, \n        sig_cum=0, \n        sig_white=0, \n        sampling_rate=10\n        ):\n        super().__init__()\n\n        #parameters of chirp signal\n        self.amplitude = amplitude\n        self.phase = phase\n        self.f0 = f0\n        self.BW = BW\n        self.T = T\n\n        #parameters for phase noise\n        self.sig_cum = sig_cum\n        self.sig_white = sig_white\n        self.sampling_rate = sampling_rate\n\n        #initial noise sampling\n        self.noise_1 = np.random.normal() \n        self.noise_2 = np.random.normal() \n\n        #bin counter\n        self.n_samples = 0\n        self.t_max = 0\n\n\n    def __len__(self):\n        return 0\n\n\n    def _triangle_wave(self, t, f):\n        \"\"\"triangle wave with amplitude '1' and frequency 'f'\n\n        Parameters\n        ----------\n        t : float\n            evaluation time\n        f : float\n            trig wave frequency\n\n        Returns\n        -------\n        out : float\n            trig wave value\n        \"\"\"\n        return 2 * abs(t*f - np.floor(t*f + 0.5)) - 1\n\n\n    def reset(self):\n        super().reset()\n\n        #reset \n        self.n_samples = 0\n        self.t_max = 0\n\n\n    def set_solver(self, Solver, **solver_kwargs):\n        if self.engine is None:\n            #initialize the numerical integration engine\n            self.engine = Solver(self.f0, **solver_kwargs)\n        else:\n            #change solver if already initialized\n            self.engine = Solver.cast(self.engine, **solver_kwargs)\n\n\n    def sample(self, t):\n        \"\"\"Sample from a normal distribution after successful timestep \n        to update internal noise samples\n        \"\"\"\n        if (self.sampling_rate is None or \n            self.n_samples < t * self.sampling_rate):\n            self.noise_1 = np.random.normal() \n            self.noise_2 = np.random.normal() \n            self.n_samples += 1\n\n\n    def update(self, t):\n        \"\"\"update the block output, assebble phase and evaluate the sinusoid\"\"\"\n        _phase = 2 * np.pi * (self.engine.get() + self.sig_white * self.noise_1) + self.phase\n        self.outputs[0] = self.amplitude * np.sin(_phase)\n\n\n    def solve(self, t, dt):\n        \"\"\"advance implicit solver of implicit integration engine, evaluate \n        the triangle wave and cumulative noise RNG\"\"\"\n        f = self.BW * (1 + self._triangle_wave(t, 1/self.T))/2 + self.sig_cum * self.noise_2\n        self.engine.solve(f, None, dt)\n\n        #no error for chirp source\n        return 0.0\n\n\n    def step(self, t, dt):\n        \"\"\"compute update step with integration engine, evaluate the triangle wave \n        and cumulative noise RNG\"\"\"\n        f = self.BW * (1 + self._triangle_wave(t, 1/self.T))/2 + self.sig_cum * self.noise_2\n        self.engine.step(f, dt)\n\n        #no error control for chirp source\n        return True, 0.0, 1.0",
          "bases": [
            "pathsim.blocks._block.Block"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(\n    self, \n    amplitude=1, \n    f0=1, \n    BW=1, \n    T=1, \n    phase=0, \n    sig_cum=0, \n    sig_white=0, \n    sampling_rate=10\n    ):\n    super().__init__()\n\n    #parameters of chirp signal\n    self.amplitude = amplitude\n    self.phase = phase\n    self.f0 = f0\n    self.BW = BW\n    self.T = T\n\n    #parameters for phase noise\n    self.sig_cum = sig_cum\n    self.sig_white = sig_white\n    self.sampling_rate = sampling_rate\n\n    #initial noise sampling\n    self.noise_1 = np.random.normal() \n    self.noise_2 = np.random.normal() \n\n    #bin counter\n    self.n_samples = 0\n    self.t_max = 0",
              "signature": "(amplitude = 1, f0 = 1, BW = 1, T = 1, phase = 0, sig_cum = 0, sig_white = 0, sampling_rate = 10)",
              "parameters": [
                {
                  "name": "amplitude",
                  "type": null,
                  "default": "1",
                  "description": ""
                },
                {
                  "name": "f0",
                  "type": null,
                  "default": "1",
                  "description": ""
                },
                {
                  "name": "BW",
                  "type": null,
                  "default": "1",
                  "description": ""
                },
                {
                  "name": "T",
                  "type": null,
                  "default": "1",
                  "description": ""
                },
                {
                  "name": "phase",
                  "type": null,
                  "default": "0",
                  "description": ""
                },
                {
                  "name": "sig_cum",
                  "type": null,
                  "default": "0",
                  "description": ""
                },
                {
                  "name": "sig_white",
                  "type": null,
                  "default": "0",
                  "description": ""
                },
                {
                  "name": "sampling_rate",
                  "type": null,
                  "default": "10",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "_triangle_wave",
              "description": "triangle wave with amplitude '1' and frequency 'f'",
              "docstring_html": "<p>triangle wave with amplitude '1' and frequency 'f'</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time</dd>\n<dt>f <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>trig wave frequency</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>out <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>trig wave value</dd>\n</dl>\n",
              "source": "def _triangle_wave(self, t, f):\n    \"\"\"triangle wave with amplitude '1' and frequency 'f'\n\n    Parameters\n    ----------\n    t : float\n        evaluation time\n    f : float\n        trig wave frequency\n\n    Returns\n    -------\n    out : float\n        trig wave value\n    \"\"\"\n    return 2 * abs(t*f - np.floor(t*f + 0.5)) - 1",
              "signature": "(t, f)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time"
                },
                {
                  "name": "f",
                  "type": null,
                  "default": null,
                  "description": "trig wave frequency"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "reset",
              "description": "",
              "docstring_html": "",
              "source": "def reset(self):\n    super().reset()\n\n    #reset \n    self.n_samples = 0\n    self.t_max = 0",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "set_solver",
              "description": "",
              "docstring_html": "",
              "source": "def set_solver(self, Solver, **solver_kwargs):\n    if self.engine is None:\n        #initialize the numerical integration engine\n        self.engine = Solver(self.f0, **solver_kwargs)\n    else:\n        #change solver if already initialized\n        self.engine = Solver.cast(self.engine, **solver_kwargs)",
              "signature": "(Solver, solver_kwargs = {})",
              "parameters": [
                {
                  "name": "Solver",
                  "type": null,
                  "default": null,
                  "description": ""
                },
                {
                  "name": "solver_kwargs",
                  "type": null,
                  "default": "{}",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "sample",
              "description": "Sample from a normal distribution after successful timestep",
              "docstring_html": "<p>Sample from a normal distribution after successful timestep\nto update internal noise samples</p>\n",
              "source": "def sample(self, t):\n    \"\"\"Sample from a normal distribution after successful timestep \n    to update internal noise samples\n    \"\"\"\n    if (self.sampling_rate is None or \n        self.n_samples < t * self.sampling_rate):\n        self.noise_1 = np.random.normal() \n        self.noise_2 = np.random.normal() \n        self.n_samples += 1",
              "signature": "(t)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "update",
              "description": "update the block output, assebble phase and evaluate the sinusoid",
              "docstring_html": "<p>update the block output, assebble phase and evaluate the sinusoid</p>\n",
              "source": "def update(self, t):\n    \"\"\"update the block output, assebble phase and evaluate the sinusoid\"\"\"\n    _phase = 2 * np.pi * (self.engine.get() + self.sig_white * self.noise_1) + self.phase\n    self.outputs[0] = self.amplitude * np.sin(_phase)",
              "signature": "(t)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "solve",
              "description": "advance implicit solver of implicit integration engine, evaluate",
              "docstring_html": "<p>advance implicit solver of implicit integration engine, evaluate\nthe triangle wave and cumulative noise RNG</p>\n",
              "source": "def solve(self, t, dt):\n    \"\"\"advance implicit solver of implicit integration engine, evaluate \n    the triangle wave and cumulative noise RNG\"\"\"\n    f = self.BW * (1 + self._triangle_wave(t, 1/self.T))/2 + self.sig_cum * self.noise_2\n    self.engine.solve(f, None, dt)\n\n    #no error for chirp source\n    return 0.0",
              "signature": "(t, dt)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": ""
                },
                {
                  "name": "dt",
                  "type": null,
                  "default": null,
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "step",
              "description": "compute update step with integration engine, evaluate the triangle wave",
              "docstring_html": "<p>compute update step with integration engine, evaluate the triangle wave\nand cumulative noise RNG</p>\n",
              "source": "def step(self, t, dt):\n    \"\"\"compute update step with integration engine, evaluate the triangle wave \n    and cumulative noise RNG\"\"\"\n    f = self.BW * (1 + self._triangle_wave(t, 1/self.T))/2 + self.sig_cum * self.noise_2\n    self.engine.step(f, dt)\n\n    #no error control for chirp source\n    return True, 0.0, 1.0",
              "signature": "(t, dt)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": ""
                },
                {
                  "name": "dt",
                  "type": null,
                  "default": null,
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "_n_in_max",
              "description": "",
              "type": null,
              "value": "0"
            },
            {
              "name": "_n_out_max",
              "description": "",
              "type": null,
              "value": "1"
            },
            {
              "name": "_port_map_out",
              "description": "",
              "type": null,
              "value": "{'out': 0}"
            },
            {
              "name": "amplitude",
              "description": "",
              "type": null,
              "value": "amplitude"
            },
            {
              "name": "phase",
              "description": "",
              "type": null,
              "value": "phase"
            },
            {
              "name": "f0",
              "description": "",
              "type": null,
              "value": "f0"
            },
            {
              "name": "BW",
              "description": "",
              "type": null,
              "value": "BW"
            },
            {
              "name": "T",
              "description": "",
              "type": null,
              "value": "T"
            },
            {
              "name": "sig_cum",
              "description": "",
              "type": null,
              "value": "sig_cum"
            },
            {
              "name": "sig_white",
              "description": "",
              "type": null,
              "value": "sig_white"
            },
            {
              "name": "sampling_rate",
              "description": "",
              "type": null,
              "value": "sampling_rate"
            },
            {
              "name": "noise_1",
              "description": "",
              "type": null,
              "value": "np.random.normal()"
            },
            {
              "name": "noise_2",
              "description": "",
              "type": null,
              "value": "np.random.normal()"
            },
            {
              "name": "n_samples",
              "description": "",
              "type": null,
              "value": "0"
            },
            {
              "name": "t_max",
              "description": "",
              "type": null,
              "value": "0"
            }
          ],
          "parameters": [
            {
              "name": "amplitude",
              "type": null,
              "default": "1",
              "description": "amplitude of the chirp signal"
            },
            {
              "name": "f0",
              "type": null,
              "default": "1",
              "description": "start frequency of the chirp signal"
            },
            {
              "name": "BW",
              "type": null,
              "default": "1",
              "description": "bandwidth of the frequency ramp of the chirp signal"
            },
            {
              "name": "T",
              "type": null,
              "default": "1",
              "description": "period of the frequency ramp of the chirp signal"
            },
            {
              "name": "phase",
              "type": null,
              "default": "0",
              "description": "phase of sinusoid (initial)"
            },
            {
              "name": "sig_cum",
              "type": null,
              "default": "0",
              "description": "weight for cumulative phase noise contribution"
            },
            {
              "name": "sig_white",
              "type": null,
              "default": "0",
              "description": "weight for white phase noise contribution"
            },
            {
              "name": "sampling_rate",
              "type": null,
              "default": "10",
              "description": "number of samples per unit time for the internal random number generators"
            }
          ]
        },
        {
          "name": "ChirpSource",
          "description": "",
          "docstring_html": "",
          "source": "class ChirpSource(ChirpPhaseNoiseSource):\n\n    def __init__(\n        self, \n        amplitude=1, \n        f0=1, \n        BW=1, \n        T=1, \n        phase=0, \n        sig_cum=0, \n        sig_white=0, \n        sampling_rate=10):\n        super().__init__(amplitude, f0, BW, T, phase, sig_cum, sig_white, sampling_rate)\n\n        import warnings\n        warnings.warn(\"'ChirpSource' block will be deprecated and is currently an alias, use 'ChirpPhaseNoiseSource' instead\")",
          "bases": [
            "pathsim.blocks.sources.ChirpPhaseNoiseSource"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(\n    self, \n    amplitude=1, \n    f0=1, \n    BW=1, \n    T=1, \n    phase=0, \n    sig_cum=0, \n    sig_white=0, \n    sampling_rate=10):\n    super().__init__(amplitude, f0, BW, T, phase, sig_cum, sig_white, sampling_rate)\n\n    import warnings\n    warnings.warn(\"'ChirpSource' block will be deprecated and is currently an alias, use 'ChirpPhaseNoiseSource' instead\")",
              "signature": "(amplitude = 1, f0 = 1, BW = 1, T = 1, phase = 0, sig_cum = 0, sig_white = 0, sampling_rate = 10)",
              "parameters": [
                {
                  "name": "amplitude",
                  "type": null,
                  "default": "1",
                  "description": ""
                },
                {
                  "name": "f0",
                  "type": null,
                  "default": "1",
                  "description": ""
                },
                {
                  "name": "BW",
                  "type": null,
                  "default": "1",
                  "description": ""
                },
                {
                  "name": "T",
                  "type": null,
                  "default": "1",
                  "description": ""
                },
                {
                  "name": "phase",
                  "type": null,
                  "default": "0",
                  "description": ""
                },
                {
                  "name": "sig_cum",
                  "type": null,
                  "default": "0",
                  "description": ""
                },
                {
                  "name": "sig_white",
                  "type": null,
                  "default": "0",
                  "description": ""
                },
                {
                  "name": "sampling_rate",
                  "type": null,
                  "default": "10",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [],
          "parameters": [
            {
              "name": "amplitude",
              "type": null,
              "default": "1",
              "description": ""
            },
            {
              "name": "f0",
              "type": null,
              "default": "1",
              "description": ""
            },
            {
              "name": "BW",
              "type": null,
              "default": "1",
              "description": ""
            },
            {
              "name": "T",
              "type": null,
              "default": "1",
              "description": ""
            },
            {
              "name": "phase",
              "type": null,
              "default": "0",
              "description": ""
            },
            {
              "name": "sig_cum",
              "type": null,
              "default": "0",
              "description": ""
            },
            {
              "name": "sig_white",
              "type": null,
              "default": "0",
              "description": ""
            },
            {
              "name": "sampling_rate",
              "type": null,
              "default": "10",
              "description": ""
            }
          ]
        },
        {
          "name": "PulseSource",
          "description": "Generates a periodic pulse waveform with defined rise and fall times",
          "docstring_html": "<p>Generates a periodic pulse waveform with defined rise and fall times\nusing a hybrid approach with scheduled events and continuous updates.</p>\n<p>Scheduled events trigger phase changes (low, rising, high, falling),\nand the <cite>update</cite> method calculates the output value based on the\ncurrent phase, performing linear interpolation during rise and fall.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>amplitude <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float, optional</span></dt>\n<dd>Peak amplitude of the pulse. Default is 1.0.</dd>\n<dt>T <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float, optional</span></dt>\n<dd>Period of the pulse train. Must be positive. Default is 1.0.</dd>\n<dt>t_rise <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float, optional</span></dt>\n<dd>Duration of the rising edge. Default is 0.0.</dd>\n<dt>t_fall <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float, optional</span></dt>\n<dd>Duration of the falling edge. Default is 0.0.</dd>\n<dt>tau <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float, optional</span></dt>\n<dd>Initial delay before the first pulse cycle begins. Default is 0.0.</dd>\n<dt>duty <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float, optional</span></dt>\n<dd>Duty cycle, ratio of the pulse ON duration (plateau time only)\nto the total period T (must be between 0 and 1). Default is 0.5.\nThe high plateau duration is <cite>T * duty</cite>.</dd>\n</dl>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>events <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">list[Schedule]</span></dt>\n<dd>Internal scheduled events triggering phase transitions.</dd>\n<dt>_phase <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">str</span></dt>\n<dd>Current phase of the pulse ('low', 'rising', 'high', 'falling').</dd>\n<dt>_phase_start_time <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>Simulation time when the current phase began.</dd>\n</dl>\n",
          "source": "class PulseSource(Block):\n    \"\"\"Generates a periodic pulse waveform with defined rise and fall times\n    using a hybrid approach with scheduled events and continuous updates.\n\n    Scheduled events trigger phase changes (low, rising, high, falling),\n    and the `update` method calculates the output value based on the\n    current phase, performing linear interpolation during rise and fall.\n\n    Parameters\n    ----------\n    amplitude : float, optional\n        Peak amplitude of the pulse. Default is 1.0.\n    T : float, optional\n        Period of the pulse train. Must be positive. Default is 1.0.\n    t_rise : float, optional\n        Duration of the rising edge. Default is 0.0.\n    t_fall : float, optional\n        Duration of the falling edge. Default is 0.0.\n    tau : float, optional\n        Initial delay before the first pulse cycle begins. Default is 0.0.\n    duty : float, optional\n        Duty cycle, ratio of the pulse ON duration (plateau time only)\n        to the total period T (must be between 0 and 1). Default is 0.5.\n        The high plateau duration is `T * duty`.\n\n    Attributes\n    ----------\n    events : list[Schedule]\n        Internal scheduled events triggering phase transitions.\n    _phase : str\n        Current phase of the pulse ('low', 'rising', 'high', 'falling').\n    _phase_start_time : float\n        Simulation time when the current phase began.\n    \"\"\"\n\n    #max number of ports\n    _n_in_max = 0\n    _n_out_max = 1\n\n    #maps for input and output port labels\n    _port_map_out = {\"out\": 0}\n\n    def __init__(\n        self, \n        amplitude=1.0, \n        T=1.0, \n        t_rise=0.0, \n        t_fall=0.0, \n        tau=0.0, \n        duty=0.5\n        ):\n        super().__init__()\n\n        #input validation\n        if not (T > 0):\n            raise ValueError(\"Period T must be positive.\")\n        if not (0 <= t_rise):\n            raise ValueError(\"Rise time t_rise cannot be negative.\")\n        if not (0 <= t_fall):\n            raise ValueError(\"Fall time t_fall cannot be negative.\")\n        if not (0 <= duty <= 1):\n            raise ValueError(\"Duty cycle must be between 0 and 1.\")\n\n        #ensure rise + high plateau + fall fits within a period\n        t_plateau = T * duty\n        if t_rise + t_plateau + t_fall > T:\n            raise ValueError(\"Total pulse time (rise+plateau+fall) exceeds period T\")\n\n        #parameters\n        self.amplitude = amplitude\n        self.T = T\n        self.t_rise = max(TOLERANCE, t_rise)\n        self.t_fall = max(TOLERANCE, t_fall)\n        self.tau = tau\n        self.duty = duty # Duty cycle now refers to the high plateau time\n\n        #internal state\n        self._phase = 'low'\n        self._phase_start_time = self.tau \n\n        #event timings relative to start of cycle (tau)\n        t_start_rise = self.tau\n        t_start_high = t_start_rise + self.t_rise \n        t_start_fall = t_start_high + t_plateau \n        t_start_low  = t_start_fall + self.t_fall \n\n        #define event actions (update phase and start time) \n        def _set_phase_rising(t):\n            self._phase = 'rising'\n            self._phase_start_time = t\n            self.outputs[0] = 0.0    \n\n        def _set_phase_high(t):\n            self._phase = 'high'\n            self._phase_start_time = t\n            self.outputs[0] = self.amplitude\n\n        def _set_phase_falling(t):\n            self._phase = 'falling'\n            self._phase_start_time = t\n            self.outputs[0] = self.amplitude\n\n        def _set_phase_low(t):\n            self._phase = 'low'\n            self._phase_start_time = t\n            self.outputs[0] = 0.0    \n\n        #start rising\n        _E_rising = Schedule( \n            t_start=max(0.0, t_start_rise), \n            t_period=self.T, \n            func_act=_set_phase_rising\n            )\n\n        #start high plateau (end rising)\n        _E_high = Schedule(\n            t_start=max(0.0, t_start_high), \n            t_period=self.T, \n            func_act=_set_phase_high\n            )\n\n        #start falling\n        _E_falling = Schedule( \n            t_start=max(0.0, t_start_fall), \n            t_period=self.T, \n            func_act=_set_phase_falling\n            )\n\n        #start low (end falling)\n        _E_low = Schedule( \n            t_start=max(0.0, t_start_low), \n            t_period=self.T, \n            func_act=_set_phase_low\n            )\n\n        #scheduled events for state transitions\n        self.events = [_E_rising, _E_high, _E_falling, _E_low]\n\n\n    def reset(self):\n        \"\"\"Resets the block state.\"\"\"\n        super().reset()\n        self._phase = 'low'\n        self._phase_start_time = self.tau\n\n\n    def update(self, t):\n        \"\"\"Calculate the pulse output value based on the current phase.\n        Performs linear interpolation during 'rising' and 'falling' phases.\n\n        Parameters\n        ----------\n        t : float\n            evaluation time\n        \"\"\"\n\n        #calculate output based on phase\n        if self._phase == 'rising':\n            _val = self.amplitude * (t - self._phase_start_time) / self.t_rise\n            self.outputs[0] = np.clip(_val, 0.0, self.amplitude)\n        elif self._phase == 'high':\n            self.outputs[0] = self.amplitude\n        elif self._phase == 'falling':\n            _val = self.amplitude * (1.0 - (t - self._phase_start_time) / self.t_fall)\n            self.outputs[0] = np.clip(_val, 0.0, self.amplitude)\n        elif self._phase == 'low':\n            self.outputs[0] = 0.0\n\n\n    def __len__(self):\n        #no algebraic passthrough\n        return 0",
          "bases": [
            "pathsim.blocks._block.Block"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(\n    self, \n    amplitude=1.0, \n    T=1.0, \n    t_rise=0.0, \n    t_fall=0.0, \n    tau=0.0, \n    duty=0.5\n    ):\n    super().__init__()\n\n    #input validation\n    if not (T > 0):\n        raise ValueError(\"Period T must be positive.\")\n    if not (0 <= t_rise):\n        raise ValueError(\"Rise time t_rise cannot be negative.\")\n    if not (0 <= t_fall):\n        raise ValueError(\"Fall time t_fall cannot be negative.\")\n    if not (0 <= duty <= 1):\n        raise ValueError(\"Duty cycle must be between 0 and 1.\")\n\n    #ensure rise + high plateau + fall fits within a period\n    t_plateau = T * duty\n    if t_rise + t_plateau + t_fall > T:\n        raise ValueError(\"Total pulse time (rise+plateau+fall) exceeds period T\")\n\n    #parameters\n    self.amplitude = amplitude\n    self.T = T\n    self.t_rise = max(TOLERANCE, t_rise)\n    self.t_fall = max(TOLERANCE, t_fall)\n    self.tau = tau\n    self.duty = duty # Duty cycle now refers to the high plateau time\n\n    #internal state\n    self._phase = 'low'\n    self._phase_start_time = self.tau \n\n    #event timings relative to start of cycle (tau)\n    t_start_rise = self.tau\n    t_start_high = t_start_rise + self.t_rise \n    t_start_fall = t_start_high + t_plateau \n    t_start_low  = t_start_fall + self.t_fall \n\n    #define event actions (update phase and start time) \n    def _set_phase_rising(t):\n        self._phase = 'rising'\n        self._phase_start_time = t\n        self.outputs[0] = 0.0    \n\n    def _set_phase_high(t):\n        self._phase = 'high'\n        self._phase_start_time = t\n        self.outputs[0] = self.amplitude\n\n    def _set_phase_falling(t):\n        self._phase = 'falling'\n        self._phase_start_time = t\n        self.outputs[0] = self.amplitude\n\n    def _set_phase_low(t):\n        self._phase = 'low'\n        self._phase_start_time = t\n        self.outputs[0] = 0.0    \n\n    #start rising\n    _E_rising = Schedule( \n        t_start=max(0.0, t_start_rise), \n        t_period=self.T, \n        func_act=_set_phase_rising\n        )\n\n    #start high plateau (end rising)\n    _E_high = Schedule(\n        t_start=max(0.0, t_start_high), \n        t_period=self.T, \n        func_act=_set_phase_high\n        )\n\n    #start falling\n    _E_falling = Schedule( \n        t_start=max(0.0, t_start_fall), \n        t_period=self.T, \n        func_act=_set_phase_falling\n        )\n\n    #start low (end falling)\n    _E_low = Schedule( \n        t_start=max(0.0, t_start_low), \n        t_period=self.T, \n        func_act=_set_phase_low\n        )\n\n    #scheduled events for state transitions\n    self.events = [_E_rising, _E_high, _E_falling, _E_low]",
              "signature": "(amplitude = 1.0, T = 1.0, t_rise = 0.0, t_fall = 0.0, tau = 0.0, duty = 0.5)",
              "parameters": [
                {
                  "name": "amplitude",
                  "type": null,
                  "default": "1.0",
                  "description": ""
                },
                {
                  "name": "T",
                  "type": null,
                  "default": "1.0",
                  "description": ""
                },
                {
                  "name": "t_rise",
                  "type": null,
                  "default": "0.0",
                  "description": ""
                },
                {
                  "name": "t_fall",
                  "type": null,
                  "default": "0.0",
                  "description": ""
                },
                {
                  "name": "tau",
                  "type": null,
                  "default": "0.0",
                  "description": ""
                },
                {
                  "name": "duty",
                  "type": null,
                  "default": "0.5",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "reset",
              "description": "Resets the block state.",
              "docstring_html": "<p>Resets the block state.</p>\n",
              "source": "def reset(self):\n    \"\"\"Resets the block state.\"\"\"\n    super().reset()\n    self._phase = 'low'\n    self._phase_start_time = self.tau",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "update",
              "description": "Calculate the pulse output value based on the current phase.",
              "docstring_html": "<p>Calculate the pulse output value based on the current phase.\nPerforms linear interpolation during 'rising' and 'falling' phases.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time</dd>\n</dl>\n",
              "source": "def update(self, t):\n    \"\"\"Calculate the pulse output value based on the current phase.\n    Performs linear interpolation during 'rising' and 'falling' phases.\n\n    Parameters\n    ----------\n    t : float\n        evaluation time\n    \"\"\"\n\n    #calculate output based on phase\n    if self._phase == 'rising':\n        _val = self.amplitude * (t - self._phase_start_time) / self.t_rise\n        self.outputs[0] = np.clip(_val, 0.0, self.amplitude)\n    elif self._phase == 'high':\n        self.outputs[0] = self.amplitude\n    elif self._phase == 'falling':\n        _val = self.amplitude * (1.0 - (t - self._phase_start_time) / self.t_fall)\n        self.outputs[0] = np.clip(_val, 0.0, self.amplitude)\n    elif self._phase == 'low':\n        self.outputs[0] = 0.0",
              "signature": "(t)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time"
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "_n_in_max",
              "description": "",
              "type": null,
              "value": "0"
            },
            {
              "name": "_n_out_max",
              "description": "",
              "type": null,
              "value": "1"
            },
            {
              "name": "_port_map_out",
              "description": "",
              "type": null,
              "value": "{'out': 0}"
            },
            {
              "name": "amplitude",
              "description": "",
              "type": null,
              "value": "amplitude"
            },
            {
              "name": "T",
              "description": "",
              "type": null,
              "value": "T"
            },
            {
              "name": "t_rise",
              "description": "",
              "type": null,
              "value": "max(TOLERANCE, t_rise)"
            },
            {
              "name": "t_fall",
              "description": "",
              "type": null,
              "value": "max(TOLERANCE, t_fall)"
            },
            {
              "name": "tau",
              "description": "",
              "type": null,
              "value": "tau"
            },
            {
              "name": "duty",
              "description": "",
              "type": null,
              "value": "duty"
            },
            {
              "name": "_phase",
              "description": "",
              "type": null,
              "value": "'low'"
            },
            {
              "name": "_phase_start_time",
              "description": "",
              "type": null,
              "value": "self.tau"
            },
            {
              "name": "events",
              "description": "",
              "type": null,
              "value": "[_E_rising, _E_high, _E_falling, _E_low]"
            }
          ],
          "parameters": [
            {
              "name": "amplitude",
              "type": null,
              "default": "1.0",
              "description": "Peak amplitude of the pulse. Default is 1.0."
            },
            {
              "name": "T",
              "type": null,
              "default": "1.0",
              "description": "Period of the pulse train. Must be positive. Default is 1.0."
            },
            {
              "name": "t_rise",
              "type": null,
              "default": "0.0",
              "description": "Duration of the rising edge. Default is 0.0."
            },
            {
              "name": "t_fall",
              "type": null,
              "default": "0.0",
              "description": "Duration of the falling edge. Default is 0.0."
            },
            {
              "name": "tau",
              "type": null,
              "default": "0.0",
              "description": "Initial delay before the first pulse cycle begins. Default is 0.0."
            },
            {
              "name": "duty",
              "type": null,
              "default": "0.5",
              "description": "Duty cycle, ratio of the pulse ON duration (plateau time only) to the total period T (must be between 0 and 1). Default is 0.5. The high plateau duration is `T * duty`."
            }
          ]
        },
        {
          "name": "Pulse",
          "description": "",
          "docstring_html": "",
          "source": "class Pulse(PulseSource):\n\n    def __init__(self, amplitude=1.0, T=1.0, t_rise=0.0, t_fall=0.0, tau=0.0, duty=0.5):\n        super().__init__(amplitude, T, t_rise, t_fall, tau, duty)\n\n        import warnings\n        warnings.warn(\"'Pulse' block will be deprecated and is currently an alias, use 'PulseSource' instead\")",
          "bases": [
            "pathsim.blocks.sources.PulseSource"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, amplitude=1.0, T=1.0, t_rise=0.0, t_fall=0.0, tau=0.0, duty=0.5):\n    super().__init__(amplitude, T, t_rise, t_fall, tau, duty)\n\n    import warnings\n    warnings.warn(\"'Pulse' block will be deprecated and is currently an alias, use 'PulseSource' instead\")",
              "signature": "(amplitude = 1.0, T = 1.0, t_rise = 0.0, t_fall = 0.0, tau = 0.0, duty = 0.5)",
              "parameters": [
                {
                  "name": "amplitude",
                  "type": null,
                  "default": "1.0",
                  "description": ""
                },
                {
                  "name": "T",
                  "type": null,
                  "default": "1.0",
                  "description": ""
                },
                {
                  "name": "t_rise",
                  "type": null,
                  "default": "0.0",
                  "description": ""
                },
                {
                  "name": "t_fall",
                  "type": null,
                  "default": "0.0",
                  "description": ""
                },
                {
                  "name": "tau",
                  "type": null,
                  "default": "0.0",
                  "description": ""
                },
                {
                  "name": "duty",
                  "type": null,
                  "default": "0.5",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [],
          "parameters": [
            {
              "name": "amplitude",
              "type": null,
              "default": "1.0",
              "description": ""
            },
            {
              "name": "T",
              "type": null,
              "default": "1.0",
              "description": ""
            },
            {
              "name": "t_rise",
              "type": null,
              "default": "0.0",
              "description": ""
            },
            {
              "name": "t_fall",
              "type": null,
              "default": "0.0",
              "description": ""
            },
            {
              "name": "tau",
              "type": null,
              "default": "0.0",
              "description": ""
            },
            {
              "name": "duty",
              "type": null,
              "default": "0.5",
              "description": ""
            }
          ]
        },
        {
          "name": "ClockSource",
          "description": "Discrete time clock source block.",
          "docstring_html": "<p>Discrete time clock source block.</p>\n<p>Utilizes scheduled events to periodically set\nthe block output to 0 or 1 at discrete times.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>T <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>period of the clock</dd>\n<dt>tau <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>clock delay</dd>\n</dl>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>events <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">list[Schedule]</span></dt>\n<dd>internal scheduled event list</dd>\n</dl>\n",
          "source": "class ClockSource(Block):\n    \"\"\"Discrete time clock source block.\n\n    Utilizes scheduled events to periodically set \n    the block output to 0 or 1 at discrete times.\n\n    Parameters\n    ----------\n    T : float\n        period of the clock\n    tau : float\n        clock delay\n\n    Attributes\n    ----------\n    events : list[Schedule]\n        internal scheduled event list \n    \"\"\"\n\n    #max number of ports\n    _n_in_max = 0\n    _n_out_max = 1\n\n    #maps for input and output port labels\n    _port_map_out = {\"out\": 0}\n\n    def __init__(self, T=1, tau=0):\n        super().__init__()\n\n        self.T   = T\n        self.tau = tau\n\n        def clk_up(t):\n            self.outputs[0] = 1\n\n        def clk_down(t):\n            self.outputs[0] = 0\n\n        #internal scheduled events\n        self.events = [\n            Schedule(\n                t_start=tau,\n                t_period=T,\n                func_act=clk_up\n                ),\n            Schedule(\n                t_start=tau+T/2,\n                t_period=T,\n                func_act=clk_down\n                )\n            ]\n\n    def __len__(self):\n        #no algebraic passthrough\n        return 0",
          "bases": [
            "pathsim.blocks._block.Block"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, T=1, tau=0):\n    super().__init__()\n\n    self.T   = T\n    self.tau = tau\n\n    def clk_up(t):\n        self.outputs[0] = 1\n\n    def clk_down(t):\n        self.outputs[0] = 0\n\n    #internal scheduled events\n    self.events = [\n        Schedule(\n            t_start=tau,\n            t_period=T,\n            func_act=clk_up\n            ),\n        Schedule(\n            t_start=tau+T/2,\n            t_period=T,\n            func_act=clk_down\n            )\n        ]",
              "signature": "(T = 1, tau = 0)",
              "parameters": [
                {
                  "name": "T",
                  "type": null,
                  "default": "1",
                  "description": ""
                },
                {
                  "name": "tau",
                  "type": null,
                  "default": "0",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "_n_in_max",
              "description": "",
              "type": null,
              "value": "0"
            },
            {
              "name": "_n_out_max",
              "description": "",
              "type": null,
              "value": "1"
            },
            {
              "name": "_port_map_out",
              "description": "",
              "type": null,
              "value": "{'out': 0}"
            },
            {
              "name": "T",
              "description": "",
              "type": null,
              "value": "T"
            },
            {
              "name": "tau",
              "description": "",
              "type": null,
              "value": "tau"
            },
            {
              "name": "events",
              "description": "",
              "type": null,
              "value": "[Schedule(t_start=tau, t_period=T, func_act=clk_up), Schedule(t_start=(tau + T / 2), t_period=T, func_act=clk_down)]"
            }
          ],
          "parameters": [
            {
              "name": "T",
              "type": null,
              "default": "1",
              "description": "period of the clock"
            },
            {
              "name": "tau",
              "type": null,
              "default": "0",
              "description": "clock delay"
            }
          ]
        },
        {
          "name": "Clock",
          "description": "",
          "docstring_html": "",
          "source": "class Clock(ClockSource):\n\n    def __init__(self, T=1, tau=0):\n        super().__init__(T, tau)\n\n        import warnings\n        warnings.warn(\"'Clock' block will be deprecated and is currently an alias, use 'ClockSource' instead\")",
          "bases": [
            "pathsim.blocks.sources.ClockSource"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, T=1, tau=0):\n    super().__init__(T, tau)\n\n    import warnings\n    warnings.warn(\"'Clock' block will be deprecated and is currently an alias, use 'ClockSource' instead\")",
              "signature": "(T = 1, tau = 0)",
              "parameters": [
                {
                  "name": "T",
                  "type": null,
                  "default": "1",
                  "description": ""
                },
                {
                  "name": "tau",
                  "type": null,
                  "default": "0",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [],
          "parameters": [
            {
              "name": "T",
              "type": null,
              "default": "1",
              "description": ""
            },
            {
              "name": "tau",
              "type": null,
              "default": "0",
              "description": ""
            }
          ]
        },
        {
          "name": "SquareWaveSource",
          "description": "Discrete time square wave source.",
          "docstring_html": "<p>Discrete time square wave source.</p>\n<p>Utilizes scheduled events to periodically set\nthe block output at discrete times.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>amplitude <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>amplitude of the square wave signal</dd>\n<dt>frequency <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>frequency of the square wave signal</dd>\n<dt>phase <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>phase of the square wave signal</dd>\n</dl>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>events <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">list[Schedule]</span></dt>\n<dd>internal scheduled events</dd>\n</dl>\n",
          "source": "class SquareWaveSource(Block):\n    \"\"\"Discrete time square wave source.\n\n    Utilizes scheduled events to periodically set \n    the block output at discrete times.\n\n    Parameters\n    ----------\n    amplitude : float\n        amplitude of the square wave signal\n    frequency : float\n        frequency of the square wave signal\n    phase : float\n        phase of the square wave signal\n\n    Attributes\n    ----------\n    events : list[Schedule]\n        internal scheduled events \n    \"\"\"\n\n    #max number of ports\n    _n_in_max = 0\n    _n_out_max = 1\n\n    #maps for input and output port labels\n    _port_map_out = {\"out\": 0}\n\n    def __init__(self, amplitude=1, frequency=1, phase=0):\n        super().__init__()\n\n        self.amplitude = amplitude\n        self.frequency = frequency\n        self.phase     = phase\n\n        def sqw_up(t):\n            self.outputs[0] = self.amplitude\n\n        def sqw_down(t):\n            self.outputs[0] = -self.amplitude\n\n        #internal scheduled events\n        self.events = [\n            Schedule(\n                t_start=1/frequency * phase/360,\n                t_period=1/frequency,\n                func_act=sqw_up\n                ),\n            Schedule(\n                t_start=1/frequency * (phase/360 + 0.5),\n                t_period=1/frequency,\n                func_act=sqw_down\n                )\n            ]\n\n    def __len__(self):\n        #no algebraic passthrough\n        return 0",
          "bases": [
            "pathsim.blocks._block.Block"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, amplitude=1, frequency=1, phase=0):\n    super().__init__()\n\n    self.amplitude = amplitude\n    self.frequency = frequency\n    self.phase     = phase\n\n    def sqw_up(t):\n        self.outputs[0] = self.amplitude\n\n    def sqw_down(t):\n        self.outputs[0] = -self.amplitude\n\n    #internal scheduled events\n    self.events = [\n        Schedule(\n            t_start=1/frequency * phase/360,\n            t_period=1/frequency,\n            func_act=sqw_up\n            ),\n        Schedule(\n            t_start=1/frequency * (phase/360 + 0.5),\n            t_period=1/frequency,\n            func_act=sqw_down\n            )\n        ]",
              "signature": "(amplitude = 1, frequency = 1, phase = 0)",
              "parameters": [
                {
                  "name": "amplitude",
                  "type": null,
                  "default": "1",
                  "description": ""
                },
                {
                  "name": "frequency",
                  "type": null,
                  "default": "1",
                  "description": ""
                },
                {
                  "name": "phase",
                  "type": null,
                  "default": "0",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "_n_in_max",
              "description": "",
              "type": null,
              "value": "0"
            },
            {
              "name": "_n_out_max",
              "description": "",
              "type": null,
              "value": "1"
            },
            {
              "name": "_port_map_out",
              "description": "",
              "type": null,
              "value": "{'out': 0}"
            },
            {
              "name": "amplitude",
              "description": "",
              "type": null,
              "value": "amplitude"
            },
            {
              "name": "frequency",
              "description": "",
              "type": null,
              "value": "frequency"
            },
            {
              "name": "phase",
              "description": "",
              "type": null,
              "value": "phase"
            },
            {
              "name": "events",
              "description": "",
              "type": null,
              "value": "[Schedule(t_start=(1 / frequency * phase / 360), t_period=(1 / frequency), func_act=sqw_up), Schedule(t_start=(1 / frequency * (phase / 360 + 0.5)), t_period=(1 / frequency), func_act=sqw_down)]"
            }
          ],
          "parameters": [
            {
              "name": "amplitude",
              "type": null,
              "default": "1",
              "description": "amplitude of the square wave signal"
            },
            {
              "name": "frequency",
              "type": null,
              "default": "1",
              "description": "frequency of the square wave signal"
            },
            {
              "name": "phase",
              "type": null,
              "default": "0",
              "description": "phase of the square wave signal"
            }
          ]
        },
        {
          "name": "StepSource",
          "description": "Discrete time unit step block.",
          "docstring_html": "<p>Discrete time unit step block.</p>\n<p>Utilizes a scheduled event to set\nthe block output at the defined delay.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>amplitude <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>amplitude of the step signal</dd>\n<dt>tau <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>delay of the step</dd>\n</dl>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>events <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">list[Schedule]</span></dt>\n<dd>internal scheduled event</dd>\n</dl>\n",
          "source": "class StepSource(Block):\n    \"\"\"Discrete time unit step block.\n\n    Utilizes a scheduled event to set \n    the block output at the defined delay.\n\n    Parameters\n    ----------\n    amplitude : float\n        amplitude of the step signal\n    tau : float\n        delay of the step\n\n    Attributes\n    ----------\n    events : list[Schedule]\n        internal scheduled event \n    \"\"\"\n\n    #max number of ports\n    _n_in_max = 0\n    _n_out_max = 1\n\n    #maps for input and output port labels\n    _port_map_out = {\"out\": 0}\n\n    def __init__(self, amplitude=1, tau=0.0):\n        super().__init__()\n\n        self.amplitude = amplitude\n        self.tau = tau\n\n        def stp_up(t):\n            self.outputs[0] = self.amplitude\n\n        #internal scheduled event\n        self.events = [\n            Schedule(\n                t_start=tau,\n                t_period=tau,\n                t_end=3*tau/2,\n                func_act=stp_up\n                )\n            ]\n\n    def __len__(self):\n        #no algebraic passthrough\n        return 0",
          "bases": [
            "pathsim.blocks._block.Block"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, amplitude=1, tau=0.0):\n    super().__init__()\n\n    self.amplitude = amplitude\n    self.tau = tau\n\n    def stp_up(t):\n        self.outputs[0] = self.amplitude\n\n    #internal scheduled event\n    self.events = [\n        Schedule(\n            t_start=tau,\n            t_period=tau,\n            t_end=3*tau/2,\n            func_act=stp_up\n            )\n        ]",
              "signature": "(amplitude = 1, tau = 0.0)",
              "parameters": [
                {
                  "name": "amplitude",
                  "type": null,
                  "default": "1",
                  "description": ""
                },
                {
                  "name": "tau",
                  "type": null,
                  "default": "0.0",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "_n_in_max",
              "description": "",
              "type": null,
              "value": "0"
            },
            {
              "name": "_n_out_max",
              "description": "",
              "type": null,
              "value": "1"
            },
            {
              "name": "_port_map_out",
              "description": "",
              "type": null,
              "value": "{'out': 0}"
            },
            {
              "name": "amplitude",
              "description": "",
              "type": null,
              "value": "amplitude"
            },
            {
              "name": "tau",
              "description": "",
              "type": null,
              "value": "tau"
            },
            {
              "name": "events",
              "description": "",
              "type": null,
              "value": "[Schedule(t_start=tau, t_period=tau, t_end=(3 * tau / 2), func_act=stp_up)]"
            }
          ],
          "parameters": [
            {
              "name": "amplitude",
              "type": null,
              "default": "1",
              "description": "amplitude of the step signal"
            },
            {
              "name": "tau",
              "type": null,
              "default": "0.0",
              "description": "delay of the step"
            }
          ]
        },
        {
          "name": "Step",
          "description": "",
          "docstring_html": "",
          "source": "class Step(StepSource):\n\n    def __init__(self, amplitude=1, tau=0.0):\n        super().__init__(amplitude, tau)\n\n        import warnings\n        warnings.warn(\"'Step' block will be deprecated and is currently an alias, use 'StepSource' instead\")",
          "bases": [
            "pathsim.blocks.sources.StepSource"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, amplitude=1, tau=0.0):\n    super().__init__(amplitude, tau)\n\n    import warnings\n    warnings.warn(\"'Step' block will be deprecated and is currently an alias, use 'StepSource' instead\")",
              "signature": "(amplitude = 1, tau = 0.0)",
              "parameters": [
                {
                  "name": "amplitude",
                  "type": null,
                  "default": "1",
                  "description": ""
                },
                {
                  "name": "tau",
                  "type": null,
                  "default": "0.0",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [],
          "parameters": [
            {
              "name": "amplitude",
              "type": null,
              "default": "1",
              "description": ""
            },
            {
              "name": "tau",
              "type": null,
              "default": "0.0",
              "description": ""
            }
          ]
        }
      ],
      "functions": []
    },
    "pathsim.blocks.spectrum": {
      "name": "pathsim.blocks.spectrum",
      "description": "",
      "docstring_html": "",
      "classes": [
        {
          "name": "Spectrum",
          "description": "Block for fourier spectrum analysis (basically a spectrum analyzer), computes",
          "docstring_html": "<p>Block for fourier spectrum analysis (basically a spectrum analyzer), computes\ncontinuous time running fourier transform (RFT) of the incoming signal.</p>\n<p>A time threshold can be set by 't_wait' to start recording data only after the\nsimulation time is larger then the specified waiting time, i.e. 't - t_wait &gt; dt'.\nThis is useful for recording the steady state after all the transients have settled.</p>\n<p>An exponential forgetting factor 'alpha' can be specified for realtime spectral\nanalysis. It biases the spectral components exponentially to the most recent signal\nvalues by applying a single sided exponential window like this:</p>\n<div class=\"math\">\n\\begin{equation*}\n\\int_0^t u(\\tau) \\exp(\\alpha (t-\\tau))  \\exp(-j \\omega \\tau)\\ d \\tau\n\\end{equation*}\n</div>\n<p>It is also known as the 'exponentially forgetting transform' (EFT) and a form of\nshort time fourier transform (STFT). It is implemented as a 1st order statespace model</p>\n<div class=\"math\">\n\\begin{equation*}\n\\dot{x} = - \\alpha  x +  \\exp(-j \\omega t) u\n\\end{equation*}\n</div>\n<p>where 'u' is the input signal and 'x' is the state variable that represents the\ncomplex fourier coefficient to the frequency 'omega'. The ODE is integrated using the\nnumerical integration engine of the block.</p>\n<div class=\"section\" id=\"example\">\n<h4>Example</h4>\n<p>This is how to initialize it:</p>\n<pre class=\"code python literal-block\">\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"nn\">numpy</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"nn\">np</span><span class=\"w\">\n\n</span><span class=\"c1\">#linear frequencies (0Hz, DC -&gt; 1kHz)</span><span class=\"w\">\n</span><span class=\"n\">sp1</span> <span class=\"o\">=</span> <span class=\"n\">Spectrum</span><span class=\"p\">(</span><span class=\"w\">\n</span>    <span class=\"n\">freq</span><span class=\"o\">=</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">linspace</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mf\">1e3</span><span class=\"p\">,</span> <span class=\"mi\">100</span><span class=\"p\">),</span><span class=\"w\">\n</span>    <span class=\"n\">labels</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"s1\">'x1'</span><span class=\"p\">,</span> <span class=\"s1\">'x2'</span><span class=\"p\">]</span> <span class=\"c1\">#labels for two inputs</span><span class=\"w\">\n</span>    <span class=\"p\">)</span><span class=\"w\">\n\n</span><span class=\"c1\">#log frequencies (1Hz -&gt; 1kHz)</span><span class=\"w\">\n</span><span class=\"n\">sp2</span> <span class=\"o\">=</span> <span class=\"n\">Spectrum</span><span class=\"p\">(</span><span class=\"w\">\n</span>    <span class=\"n\">freq</span><span class=\"o\">=</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">logspace</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"mi\">100</span><span class=\"p\">)</span><span class=\"w\">\n</span>    <span class=\"p\">)</span><span class=\"w\">\n\n</span><span class=\"c1\">#log frequencies including DC (0Hz, DC + 1Hz -&gt; 1kHz)</span><span class=\"w\">\n</span><span class=\"n\">sp3</span> <span class=\"o\">=</span> <span class=\"n\">Spectrum</span><span class=\"p\">(</span><span class=\"w\">\n</span>    <span class=\"n\">freq</span><span class=\"o\">=</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">hstack</span><span class=\"p\">([</span><span class=\"mf\">0.0</span><span class=\"p\">,</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">logspace</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"mi\">100</span><span class=\"p\">)])</span><span class=\"w\">\n</span>    <span class=\"p\">)</span><span class=\"w\">\n\n</span><span class=\"c1\">#arbitrary frequencies</span><span class=\"w\">\n</span><span class=\"n\">sp4</span> <span class=\"o\">=</span> <span class=\"n\">Spectrum</span><span class=\"p\">(</span><span class=\"w\">\n</span>    <span class=\"n\">freq</span><span class=\"o\">=</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">array</span><span class=\"p\">([</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mf\">0.5</span><span class=\"p\">,</span> <span class=\"mi\">20</span><span class=\"p\">,</span> <span class=\"mf\">1e3</span><span class=\"p\">])</span><span class=\"w\">\n</span>    <span class=\"p\">)</span>\n</pre>\n</div>\n<div class=\"section\" id=\"note\">\n<h4>Note</h4>\n<p>This block is relatively slow! But it is valuable for long running simulations\nwith few evaluation frequencies, where just FFT'ing the time series data\nwouldnt be efficient OR if only the evaluation at weirdly spaced frequencies\nis required. Otherwise its more efficient to just do an FFT on the time\nseries recording after the simulation has finished.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>freq <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array[float]</span></dt>\n<dd>list of evaluation frequencies for RFT, can be arbitrarily spaced</dd>\n<dt>t_wait <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>wait time before starting RFT</dd>\n<dt>alpha <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>exponential forgetting factor for realtime spectrum</dd>\n<dt>labels <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">list[str]</span></dt>\n<dd>labels for the inputs</dd>\n</dl>\n</div>\n",
          "source": "class Spectrum(Block):\n    \"\"\"Block for fourier spectrum analysis (basically a spectrum analyzer), computes \n    continuous time running fourier transform (RFT) of the incoming signal.\n\n    A time threshold can be set by 't_wait' to start recording data only after the \n    simulation time is larger then the specified waiting time, i.e. 't - t_wait > dt'. \n    This is useful for recording the steady state after all the transients have settled.\n\n    An exponential forgetting factor 'alpha' can be specified for realtime spectral \n    analysis. It biases the spectral components exponentially to the most recent signal \n    values by applying a single sided exponential window like this:\n\n    .. math::\n\n        \\\\int_0^t u(\\\\tau) \\\\exp(\\\\alpha (t-\\\\tau))  \\\\exp(-j \\\\omega \\\\tau)\\\\ d \\\\tau\n\n    It is also known as the 'exponentially forgetting transform' (EFT) and a form of \n    short time fourier transform (STFT). It is implemented as a 1st order statespace model \n\n    .. math::\n\n        \\\\dot{x} = - \\\\alpha  x +  \\\\exp(-j \\\\omega t) u\n\n    where 'u' is the input signal and 'x' is the state variable that represents the \n    complex fourier coefficient to the frequency 'omega'. The ODE is integrated using the \n    numerical integration engine of the block.\n\n    Example\n    -------\n    This is how to initialize it: \n\n    .. code-block:: python\n\n        import numpy as np\n\n        #linear frequencies (0Hz, DC -> 1kHz)\n        sp1 = Spectrum(\n            freq=np.linspace(0, 1e3, 100),\n            labels=['x1', 'x2'] #labels for two inputs\n            )\n\n        #log frequencies (1Hz -> 1kHz)\n        sp2 = Spectrum(\n            freq=np.logspace(0, 3, 100)\n            )\n\n        #log frequencies including DC (0Hz, DC + 1Hz -> 1kHz)\n        sp3 = Spectrum(\n            freq=np.hstack([0.0, np.logspace(0, 3, 100)])\n            )\n\n        #arbitrary frequencies\n        sp4 = Spectrum(\n            freq=np.array([0, 0.5, 20, 1e3])\n            )\n\n    Note\n    ----\n    This block is relatively slow! But it is valuable for long running simulations \n    with few evaluation frequencies, where just FFT'ing the time series data \n    wouldnt be efficient OR if only the evaluation at weirdly spaced frequencies \n    is required. Otherwise its more efficient to just do an FFT on the time \n    series recording after the simulation has finished.\n\n\n    Parameters\n    ----------\n    freq : array[float] \n        list of evaluation frequencies for RFT, can be arbitrarily spaced\n    t_wait : float \n        wait time before starting RFT\n    alpha : float\n        exponential forgetting factor for realtime spectrum\n    labels : list[str]\n        labels for the inputs\n    \"\"\"\n\n    #max number of ports\n    _n_in_max = None\n    _n_out_max = 0\n\n    def __init__(self, freq=[], t_wait=0.0, alpha=0.0, labels=[]):\n        super().__init__()\n\n        #time delay until start recording\n        self.t_wait = t_wait\n\n        #local integration time\n        self.time = 0.0\n\n        #forgetting factor\n        self.alpha = alpha\n\n        #labels for plotting and saving data\n        self.labels = labels\n\n        #frequency\n        self.freq = np.array(freq)\n        self.omega = 2.0 * np.pi * self.freq\n\n\n    def __len__(self):\n        return 0\n\n\n    def _kernel(self, x, u, t):\n        \"\"\"Helper method that defines the kernel for the internal \n        running fourier transform (RFT)\n        \"\"\"\n        if self.alpha == 0: return np.kron(u, np.exp(-1j * self.omega * t))\n        return np.kron(u, np.exp(-1j * self.omega * t)) - self.alpha * x\n\n\n    def set_solver(self, Solver, **solver_kwargs):\n        \"\"\"set the internal numerical integrator for the RFT\n\n        Parameters\n        ----------\n        Solver : Solver\n            numerical integration solver class\n        solver_kwargs : dict\n            parameters for solver initialization\n        \"\"\"\n        if self.engine is None: self.engine = Solver(0.0, **solver_kwargs)\n        else: self.engine = Solver.cast(self.engine, **solver_kwargs)\n\n\n    def reset(self):\n        super().reset()\n\n        #local integration time\n        self.time = 0.0\n\n\n\n    def read(self):\n        \"\"\"Read the recorded spectrum\n\n        Example\n        -------\n        This is how to get the recorded spectrum:\n\n        .. code-block:: python\n\n            import numpy as np\n\n            #linear frequencies (0Hz, DC -> 1kHz)\n            spc = Spectrum(\n                freq=np.linspace(0, 1e3, 100),\n                labels=['x1', 'x2'] #labels for two inputs\n                )\n\n            #... run the simulation ...\n\n            #read the complex spectra of x1 and x2\n            freq, [X1, X2] = spc.read()\n\n        Returns\n        -------\n        freq : array[float]\n            evaluation frequencies\n        spec : array[complex]\n            complex spectrum\n        \"\"\"\n\n        #just return zeros if no engine initialized\n        if self.engine is None:\n            return self.freq, [np.zeros_like(self.freq)]*len(self.inputs)\n\n        #catch case where time is still zero\n        if self.time == 0.0:\n            return self.freq, [np.zeros_like(self.freq)]*len(self.inputs)\n\n        #get state from engine\n        state = self.engine.get()\n\n        #catch case where state has not been updated\n        if np.all(state == self.engine.initial_value):\n            return self.freq, [np.zeros_like(self.freq)]*len(self.inputs)\n\n        #reshape state into spectra\n        spec = np.reshape(state, (-1, len(self.freq)))\n\n        #rescale spectrum and return it\n        if self.alpha != 0.0:\n            return self.freq, spec * self.alpha / (1.0 - np.exp(-self.alpha*self.time))\n\n        #return spectrum from RFT\n        return self.freq, spec/self.time\n\n\n    def solve(self, t, dt):\n        \"\"\"advance solution of implicit update equation of the solver\n\n        Parameters\n        ----------\n        t : float\n            evaluation time\n        dt : float\n            integration timestep\n\n        Returns\n        ------- \n        error : float\n            solver residual norm\n        \"\"\"\n\n        #effective time for integration\n        _t = t - self.t_wait\n        if _t > dt:\n\n            #update local integtration time\n            self.time = _t\n\n            #advance solution of implicit update equation (no jacobian)\n            f = self._kernel(self.engine.get(), self.inputs.to_array(), _t)\n            return self.engine.solve(f, None, dt)\n\n        #no error \n        return 0.0\n\n\n    def step(self, t, dt):\n        \"\"\"compute timestep update with integration engine\n\n        Parameters\n        ----------\n        t : float\n            evaluation time\n        dt : float\n            integration timestep\n\n        Returns\n        ------- \n        success : bool\n            step was successful\n        error : float\n            local truncation error from adaptive integrators\n        scale : float\n            timestep rescale from adaptive integrators\n        \"\"\"\n\n        #effective time for integration\n        _t = t - self.t_wait\n        if _t > dt:\n\n            #update local integtration time\n            self.time = _t\n\n            #compute update step with integration engine\n            f = self._kernel(self.engine.get(), self.inputs.to_array(), _t)\n            return self.engine.step(f, dt)\n\n        #no error estimate\n        return True, 0.0, 1.0\n\n\n    def plot(self, *args, **kwargs):\n        \"\"\"Directly create a plot of the recorded data for visualization.\n\n        The 'fig' and 'ax' objects are accessible as attributes of the 'Spectrum' instance \n        from the outside for saving, or modification, etc.\n\n        Parameters\n        ----------\n        args : tuple\n            args for ax.plot\n        kwargs : dict\n            kwargs for ax.plot\n\n        Returns\n        -------\n        fig : matplotlib.figure\n            internal figure instance\n        ax : matplotlib.axis\n            internal axis instance\n        \"\"\"\n\n        #just return 'None' if no engine initialized\n        if self.engine is None:\n            return None\n\n        #get data\n        freq, data = self.read()        \n\n        #initialize figure\n        self.fig, self.ax = plt.subplots(nrows=1, ncols=1, figsize=(8,4), tight_layout=True, dpi=120)\n\n        #custom colors\n        self.ax.set_prop_cycle(color=COLORS_ALL)\n\n        #plot magnitude in dB and add label\n        for p, d in enumerate(data):\n            lb = self.labels[p] if p < len(self.labels) else f\"port {p}\"\n            self.ax.plot(freq, abs(d), *args, **kwargs, label=lb)\n\n        #legend labels from ports\n        self.ax.legend(fancybox=False)\n\n        #other plot settings\n        self.ax.set_xlabel(\"freq [Hz]\")\n        self.ax.set_ylabel(\"magnitude\")\n        self.ax.grid()\n\n        # Legend picking functionality\n        lines = self.ax.get_lines()  # Get the lines from the plot\n        leg = self.ax.get_legend()   # Get the legend\n\n        # Map legend lines to original plot lines\n        lined = dict()  \n        for legline, origline in zip(leg.get_lines(), lines):\n            # Enable picking within 5 points tolerance\n            legline.set_picker(5)  \n            lined[legline] = origline\n\n        def on_pick(event):\n            legline = event.artist\n            origline = lined[legline]\n            visible = not origline.get_visible()\n            origline.set_visible(visible)\n            legline.set_alpha(1.0 if visible else 0.2)\n            # Redraw the figure\n            self.fig.canvas.draw()  \n\n        #enable picking\n        self.fig.canvas.mpl_connect(\"pick_event\", on_pick)\n\n        #show the plot without blocking following code\n        plt.show(block=False)\n\n        #return figure and axis for outside manipulation\n        return self.fig, self.ax\n\n\n    def save(self, path=\"spectrum.csv\"):\n        \"\"\"Save the recording of the spectrum to a csv file        \n\n        Parameters\n        ----------\n        path : str\n            path where to save the recording as a csv file\n        \"\"\"\n\n        #check path ending\n        if not path.lower().endswith(\".csv\"):\n            path += \".csv\"\n\n        #get data\n        freq, data = self.read() \n\n        #number of ports and labels\n        P, L = len(data), len(self.labels)\n\n        #construct port labels\n        port_labels = [self.labels[p] if p < L else f\"port {p}\" for p in range(P)]\n\n        #make csv header\n        header = [\"freq [Hz]\"]\n        for l in port_labels:\n            header.extend([f\"Re({l})\", f\"Im({l})\"])\n\n        #write to csv file\n        with open(path, \"w\", newline=\"\") as file:\n            wrt = csv.writer(file)\n\n            #write the header to csv file\n            wrt.writerow(header)\n\n            #write each sample to the csv file\n            for f, *dta in zip(freq, *data):\n                sample = [f]\n                for d in dta:\n                    sample.extend([np.real(d), np.imag(d)])\n                wrt.writerow(sample)\n\n\n    def update(self, t):\n        \"\"\"update system equation for fixed point loop, \n        here just setting the outputs\n\n        Note\n        ----\n        Spectrum block has no passthrough, so the 'update' method \n        is optimized for this case        \n\n        Parameters\n        ----------\n        t : float\n            evaluation time\n        \"\"\"\n        pass",
          "bases": [
            "pathsim.blocks._block.Block"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, freq=[], t_wait=0.0, alpha=0.0, labels=[]):\n    super().__init__()\n\n    #time delay until start recording\n    self.t_wait = t_wait\n\n    #local integration time\n    self.time = 0.0\n\n    #forgetting factor\n    self.alpha = alpha\n\n    #labels for plotting and saving data\n    self.labels = labels\n\n    #frequency\n    self.freq = np.array(freq)\n    self.omega = 2.0 * np.pi * self.freq",
              "signature": "(freq = [], t_wait = 0.0, alpha = 0.0, labels = [])",
              "parameters": [
                {
                  "name": "freq",
                  "type": null,
                  "default": "[]",
                  "description": ""
                },
                {
                  "name": "t_wait",
                  "type": null,
                  "default": "0.0",
                  "description": ""
                },
                {
                  "name": "alpha",
                  "type": null,
                  "default": "0.0",
                  "description": ""
                },
                {
                  "name": "labels",
                  "type": null,
                  "default": "[]",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "_kernel",
              "description": "Helper method that defines the kernel for the internal",
              "docstring_html": "<p>Helper method that defines the kernel for the internal\nrunning fourier transform (RFT)</p>\n",
              "source": "def _kernel(self, x, u, t):\n    \"\"\"Helper method that defines the kernel for the internal \n    running fourier transform (RFT)\n    \"\"\"\n    if self.alpha == 0: return np.kron(u, np.exp(-1j * self.omega * t))\n    return np.kron(u, np.exp(-1j * self.omega * t)) - self.alpha * x",
              "signature": "(x, u, t)",
              "parameters": [
                {
                  "name": "x",
                  "type": null,
                  "default": null,
                  "description": ""
                },
                {
                  "name": "u",
                  "type": null,
                  "default": null,
                  "description": ""
                },
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "set_solver",
              "description": "set the internal numerical integrator for the RFT",
              "docstring_html": "<p>set the internal numerical integrator for the RFT</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>Solver <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">Solver</span></dt>\n<dd>numerical integration solver class</dd>\n<dt>solver_kwargs <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">dict</span></dt>\n<dd>parameters for solver initialization</dd>\n</dl>\n",
              "source": "def set_solver(self, Solver, **solver_kwargs):\n    \"\"\"set the internal numerical integrator for the RFT\n\n    Parameters\n    ----------\n    Solver : Solver\n        numerical integration solver class\n    solver_kwargs : dict\n        parameters for solver initialization\n    \"\"\"\n    if self.engine is None: self.engine = Solver(0.0, **solver_kwargs)\n    else: self.engine = Solver.cast(self.engine, **solver_kwargs)",
              "signature": "(Solver, solver_kwargs = {})",
              "parameters": [
                {
                  "name": "Solver",
                  "type": null,
                  "default": null,
                  "description": "numerical integration solver class"
                },
                {
                  "name": "solver_kwargs",
                  "type": null,
                  "default": "{}",
                  "description": "parameters for solver initialization"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "reset",
              "description": "",
              "docstring_html": "",
              "source": "def reset(self):\n    super().reset()\n\n    #local integration time\n    self.time = 0.0",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "read",
              "description": "Read the recorded spectrum",
              "docstring_html": "<p>Read the recorded spectrum</p>\n<div class=\"section\" id=\"example\">\n<h4>Example</h4>\n<p>This is how to get the recorded spectrum:</p>\n<pre class=\"code python literal-block\">\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"nn\">numpy</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"nn\">np</span><span class=\"w\">\n\n</span><span class=\"c1\">#linear frequencies (0Hz, DC -&gt; 1kHz)</span><span class=\"w\">\n</span><span class=\"n\">spc</span> <span class=\"o\">=</span> <span class=\"n\">Spectrum</span><span class=\"p\">(</span><span class=\"w\">\n</span>    <span class=\"n\">freq</span><span class=\"o\">=</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">linspace</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mf\">1e3</span><span class=\"p\">,</span> <span class=\"mi\">100</span><span class=\"p\">),</span><span class=\"w\">\n</span>    <span class=\"n\">labels</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"s1\">'x1'</span><span class=\"p\">,</span> <span class=\"s1\">'x2'</span><span class=\"p\">]</span> <span class=\"c1\">#labels for two inputs</span><span class=\"w\">\n</span>    <span class=\"p\">)</span><span class=\"w\">\n\n</span><span class=\"c1\">#... run the simulation ...</span><span class=\"w\">\n\n</span><span class=\"c1\">#read the complex spectra of x1 and x2</span><span class=\"w\">\n</span><span class=\"n\">freq</span><span class=\"p\">,</span> <span class=\"p\">[</span><span class=\"n\">X1</span><span class=\"p\">,</span> <span class=\"n\">X2</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">spc</span><span class=\"o\">.</span><span class=\"n\">read</span><span class=\"p\">()</span>\n</pre>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>freq <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array[float]</span></dt>\n<dd>evaluation frequencies</dd>\n<dt>spec <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array[complex]</span></dt>\n<dd>complex spectrum</dd>\n</dl>\n</div>\n",
              "source": "def read(self):\n    \"\"\"Read the recorded spectrum\n\n    Example\n    -------\n    This is how to get the recorded spectrum:\n\n    .. code-block:: python\n\n        import numpy as np\n\n        #linear frequencies (0Hz, DC -> 1kHz)\n        spc = Spectrum(\n            freq=np.linspace(0, 1e3, 100),\n            labels=['x1', 'x2'] #labels for two inputs\n            )\n\n        #... run the simulation ...\n\n        #read the complex spectra of x1 and x2\n        freq, [X1, X2] = spc.read()\n\n    Returns\n    -------\n    freq : array[float]\n        evaluation frequencies\n    spec : array[complex]\n        complex spectrum\n    \"\"\"\n\n    #just return zeros if no engine initialized\n    if self.engine is None:\n        return self.freq, [np.zeros_like(self.freq)]*len(self.inputs)\n\n    #catch case where time is still zero\n    if self.time == 0.0:\n        return self.freq, [np.zeros_like(self.freq)]*len(self.inputs)\n\n    #get state from engine\n    state = self.engine.get()\n\n    #catch case where state has not been updated\n    if np.all(state == self.engine.initial_value):\n        return self.freq, [np.zeros_like(self.freq)]*len(self.inputs)\n\n    #reshape state into spectra\n    spec = np.reshape(state, (-1, len(self.freq)))\n\n    #rescale spectrum and return it\n    if self.alpha != 0.0:\n        return self.freq, spec * self.alpha / (1.0 - np.exp(-self.alpha*self.time))\n\n    #return spectrum from RFT\n    return self.freq, spec/self.time",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "solve",
              "description": "advance solution of implicit update equation of the solver",
              "docstring_html": "<p>advance solution of implicit update equation of the solver</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time</dd>\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>integration timestep</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>error <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>solver residual norm</dd>\n</dl>\n",
              "source": "def solve(self, t, dt):\n    \"\"\"advance solution of implicit update equation of the solver\n\n    Parameters\n    ----------\n    t : float\n        evaluation time\n    dt : float\n        integration timestep\n\n    Returns\n    ------- \n    error : float\n        solver residual norm\n    \"\"\"\n\n    #effective time for integration\n    _t = t - self.t_wait\n    if _t > dt:\n\n        #update local integtration time\n        self.time = _t\n\n        #advance solution of implicit update equation (no jacobian)\n        f = self._kernel(self.engine.get(), self.inputs.to_array(), _t)\n        return self.engine.solve(f, None, dt)\n\n    #no error \n    return 0.0",
              "signature": "(t, dt)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time"
                },
                {
                  "name": "dt",
                  "type": null,
                  "default": null,
                  "description": "integration timestep"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "step",
              "description": "compute timestep update with integration engine",
              "docstring_html": "<p>compute timestep update with integration engine</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time</dd>\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>integration timestep</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>success <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>step was successful</dd>\n<dt>error <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>local truncation error from adaptive integrators</dd>\n<dt>scale <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>timestep rescale from adaptive integrators</dd>\n</dl>\n",
              "source": "def step(self, t, dt):\n    \"\"\"compute timestep update with integration engine\n\n    Parameters\n    ----------\n    t : float\n        evaluation time\n    dt : float\n        integration timestep\n\n    Returns\n    ------- \n    success : bool\n        step was successful\n    error : float\n        local truncation error from adaptive integrators\n    scale : float\n        timestep rescale from adaptive integrators\n    \"\"\"\n\n    #effective time for integration\n    _t = t - self.t_wait\n    if _t > dt:\n\n        #update local integtration time\n        self.time = _t\n\n        #compute update step with integration engine\n        f = self._kernel(self.engine.get(), self.inputs.to_array(), _t)\n        return self.engine.step(f, dt)\n\n    #no error estimate\n    return True, 0.0, 1.0",
              "signature": "(t, dt)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time"
                },
                {
                  "name": "dt",
                  "type": null,
                  "default": null,
                  "description": "integration timestep"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "plot",
              "description": "Directly create a plot of the recorded data for visualization.",
              "docstring_html": "<p>Directly create a plot of the recorded data for visualization.</p>\n<p>The 'fig' and 'ax' objects are accessible as attributes of the 'Spectrum' instance\nfrom the outside for saving, or modification, etc.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>args <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">tuple</span></dt>\n<dd>args for ax.plot</dd>\n<dt>kwargs <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">dict</span></dt>\n<dd>kwargs for ax.plot</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>fig <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">matplotlib.figure</span></dt>\n<dd>internal figure instance</dd>\n<dt>ax <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">matplotlib.axis</span></dt>\n<dd>internal axis instance</dd>\n</dl>\n",
              "source": "def plot(self, *args, **kwargs):\n    \"\"\"Directly create a plot of the recorded data for visualization.\n\n    The 'fig' and 'ax' objects are accessible as attributes of the 'Spectrum' instance \n    from the outside for saving, or modification, etc.\n\n    Parameters\n    ----------\n    args : tuple\n        args for ax.plot\n    kwargs : dict\n        kwargs for ax.plot\n\n    Returns\n    -------\n    fig : matplotlib.figure\n        internal figure instance\n    ax : matplotlib.axis\n        internal axis instance\n    \"\"\"\n\n    #just return 'None' if no engine initialized\n    if self.engine is None:\n        return None\n\n    #get data\n    freq, data = self.read()        \n\n    #initialize figure\n    self.fig, self.ax = plt.subplots(nrows=1, ncols=1, figsize=(8,4), tight_layout=True, dpi=120)\n\n    #custom colors\n    self.ax.set_prop_cycle(color=COLORS_ALL)\n\n    #plot magnitude in dB and add label\n    for p, d in enumerate(data):\n        lb = self.labels[p] if p < len(self.labels) else f\"port {p}\"\n        self.ax.plot(freq, abs(d), *args, **kwargs, label=lb)\n\n    #legend labels from ports\n    self.ax.legend(fancybox=False)\n\n    #other plot settings\n    self.ax.set_xlabel(\"freq [Hz]\")\n    self.ax.set_ylabel(\"magnitude\")\n    self.ax.grid()\n\n    # Legend picking functionality\n    lines = self.ax.get_lines()  # Get the lines from the plot\n    leg = self.ax.get_legend()   # Get the legend\n\n    # Map legend lines to original plot lines\n    lined = dict()  \n    for legline, origline in zip(leg.get_lines(), lines):\n        # Enable picking within 5 points tolerance\n        legline.set_picker(5)  \n        lined[legline] = origline\n\n    def on_pick(event):\n        legline = event.artist\n        origline = lined[legline]\n        visible = not origline.get_visible()\n        origline.set_visible(visible)\n        legline.set_alpha(1.0 if visible else 0.2)\n        # Redraw the figure\n        self.fig.canvas.draw()  \n\n    #enable picking\n    self.fig.canvas.mpl_connect(\"pick_event\", on_pick)\n\n    #show the plot without blocking following code\n    plt.show(block=False)\n\n    #return figure and axis for outside manipulation\n    return self.fig, self.ax",
              "signature": "(args = (), kwargs = {})",
              "parameters": [
                {
                  "name": "args",
                  "type": null,
                  "default": "()",
                  "description": "args for ax.plot"
                },
                {
                  "name": "kwargs",
                  "type": null,
                  "default": "{}",
                  "description": "kwargs for ax.plot"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "save",
              "description": "Save the recording of the spectrum to a csv file",
              "docstring_html": "<p>Save the recording of the spectrum to a csv file</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>path <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">str</span></dt>\n<dd>path where to save the recording as a csv file</dd>\n</dl>\n",
              "source": "def save(self, path=\"spectrum.csv\"):\n    \"\"\"Save the recording of the spectrum to a csv file        \n\n    Parameters\n    ----------\n    path : str\n        path where to save the recording as a csv file\n    \"\"\"\n\n    #check path ending\n    if not path.lower().endswith(\".csv\"):\n        path += \".csv\"\n\n    #get data\n    freq, data = self.read() \n\n    #number of ports and labels\n    P, L = len(data), len(self.labels)\n\n    #construct port labels\n    port_labels = [self.labels[p] if p < L else f\"port {p}\" for p in range(P)]\n\n    #make csv header\n    header = [\"freq [Hz]\"]\n    for l in port_labels:\n        header.extend([f\"Re({l})\", f\"Im({l})\"])\n\n    #write to csv file\n    with open(path, \"w\", newline=\"\") as file:\n        wrt = csv.writer(file)\n\n        #write the header to csv file\n        wrt.writerow(header)\n\n        #write each sample to the csv file\n        for f, *dta in zip(freq, *data):\n            sample = [f]\n            for d in dta:\n                sample.extend([np.real(d), np.imag(d)])\n            wrt.writerow(sample)",
              "signature": "(path = 'spectrum.csv')",
              "parameters": [
                {
                  "name": "path",
                  "type": null,
                  "default": "'spectrum.csv'",
                  "description": "path where to save the recording as a csv file"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "update",
              "description": "update system equation for fixed point loop,",
              "docstring_html": "<p>update system equation for fixed point loop,\nhere just setting the outputs</p>\n<div class=\"section\" id=\"note\">\n<h4>Note</h4>\n<p>Spectrum block has no passthrough, so the 'update' method\nis optimized for this case</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time</dd>\n</dl>\n</div>\n",
              "source": "def update(self, t):\n    \"\"\"update system equation for fixed point loop, \n    here just setting the outputs\n\n    Note\n    ----\n    Spectrum block has no passthrough, so the 'update' method \n    is optimized for this case        \n\n    Parameters\n    ----------\n    t : float\n        evaluation time\n    \"\"\"\n    pass",
              "signature": "(t)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time"
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "_n_in_max",
              "description": "",
              "type": null,
              "value": "None"
            },
            {
              "name": "_n_out_max",
              "description": "",
              "type": null,
              "value": "0"
            },
            {
              "name": "t_wait",
              "description": "",
              "type": null,
              "value": "t_wait"
            },
            {
              "name": "time",
              "description": "",
              "type": null,
              "value": "0.0"
            },
            {
              "name": "alpha",
              "description": "",
              "type": null,
              "value": "alpha"
            },
            {
              "name": "labels",
              "description": "",
              "type": null,
              "value": "labels"
            },
            {
              "name": "freq",
              "description": "",
              "type": null,
              "value": "np.array(freq)"
            },
            {
              "name": "omega",
              "description": "",
              "type": null,
              "value": "2.0 * np.pi * self.freq"
            }
          ],
          "parameters": [
            {
              "name": "freq",
              "type": null,
              "default": "[]",
              "description": "list of evaluation frequencies for RFT, can be arbitrarily spaced"
            },
            {
              "name": "t_wait",
              "type": null,
              "default": "0.0",
              "description": "wait time before starting RFT"
            },
            {
              "name": "alpha",
              "type": null,
              "default": "0.0",
              "description": "exponential forgetting factor for realtime spectrum"
            },
            {
              "name": "labels",
              "type": null,
              "default": "[]",
              "description": "labels for the inputs"
            }
          ]
        },
        {
          "name": "RealtimeSpectrum",
          "description": "An extension of the 'Spectrum' block that also initializes a realtime plotter that",
          "docstring_html": "<p>An extension of the 'Spectrum' block that also initializes a realtime plotter that\ncreates an interactive plotting window while the simulation is running.</p>\n<p>Otherwise implements the same functionality as the regular 'Spectrum' block.</p>\n<div class=\"section\" id=\"note\">\n<h4>Note</h4>\n<p>Due to the plotting being relatively expensive, including this block slows down\nthe simulation significantly but may still be valuable for debugging and testing.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>freq <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array[float]</span></dt>\n<dd>list of evaluation frequencies for RFT, can be arbitrarily spaced</dd>\n<dt>t_wait <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>wait time before starting RFT</dd>\n<dt>alpha <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>exponential forgetting factor for realtime spectrum</dd>\n<dt>labels <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">list[str]</span></dt>\n<dd>labels for the inputs</dd>\n</dl>\n</div>\n",
          "source": "class RealtimeSpectrum(Spectrum):\n    \"\"\"An extension of the 'Spectrum' block that also initializes a realtime plotter that \n    creates an interactive plotting window while the simulation is running. \n\n    Otherwise implements the same functionality as the regular 'Spectrum' block.\n\n    Note\n    ----\n    Due to the plotting being relatively expensive, including this block slows down \n    the simulation significantly but may still be valuable for debugging and testing.\n\n    Parameters\n    ----------\n    freq : array[float] \n        list of evaluation frequencies for RFT, can be arbitrarily spaced\n    t_wait : float \n        wait time before starting RFT\n    alpha : float\n        exponential forgetting factor for realtime spectrum\n    labels : list[str]\n        labels for the inputs\n    \"\"\"\n\n    def __init__(self, freq=[], t_wait=0.0, alpha=0.0, labels=[]):\n        super().__init__(freq, t_wait, alpha, labels)\n\n        #initialize realtime plotter\n        self.plotter = RealtimePlotter(\n            update_interval=0.1, \n            labels=labels, \n            x_label=\"freq [Hz]\", \n            y_label=\"magnitude\"\n            )\n\n\n    def step(self, t, dt):\n        \"\"\"compute timestep update with integration engine\n\n        Parameters\n        ----------\n        t : float\n            evaluation time\n        dt : float\n            integration timestep\n\n        Returns\n        ------- \n        success : bool\n            step was successful\n        error : float\n            local truncation error from adaptive integrators\n        scale : float\n            timestep rescale from adaptive integrators\n        \"\"\"\n\n        #effective time for integration\n        _t = t - self.t_wait\n        if _t > dt:\n\n            #update local integtration time\n            self.time = _t\n\n            if self.time > 2*dt:\n                #update realtime plotter\n                _, data = self.read()\n                self.plotter.update_all(self.freq, abs(data))\n\n            #compute update step with integration engine\n            f = self._kernel(self.engine.get(), self.inputs.to_array(), _t)\n            return self.engine.step(f, dt)\n\n        #no error estimate\n        return True, 0.0, 1.0",
          "bases": [
            "pathsim.blocks.spectrum.Spectrum"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, freq=[], t_wait=0.0, alpha=0.0, labels=[]):\n    super().__init__(freq, t_wait, alpha, labels)\n\n    #initialize realtime plotter\n    self.plotter = RealtimePlotter(\n        update_interval=0.1, \n        labels=labels, \n        x_label=\"freq [Hz]\", \n        y_label=\"magnitude\"\n        )",
              "signature": "(freq = [], t_wait = 0.0, alpha = 0.0, labels = [])",
              "parameters": [
                {
                  "name": "freq",
                  "type": null,
                  "default": "[]",
                  "description": ""
                },
                {
                  "name": "t_wait",
                  "type": null,
                  "default": "0.0",
                  "description": ""
                },
                {
                  "name": "alpha",
                  "type": null,
                  "default": "0.0",
                  "description": ""
                },
                {
                  "name": "labels",
                  "type": null,
                  "default": "[]",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "step",
              "description": "compute timestep update with integration engine",
              "docstring_html": "<p>compute timestep update with integration engine</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time</dd>\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>integration timestep</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>success <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>step was successful</dd>\n<dt>error <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>local truncation error from adaptive integrators</dd>\n<dt>scale <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>timestep rescale from adaptive integrators</dd>\n</dl>\n",
              "source": "def step(self, t, dt):\n    \"\"\"compute timestep update with integration engine\n\n    Parameters\n    ----------\n    t : float\n        evaluation time\n    dt : float\n        integration timestep\n\n    Returns\n    ------- \n    success : bool\n        step was successful\n    error : float\n        local truncation error from adaptive integrators\n    scale : float\n        timestep rescale from adaptive integrators\n    \"\"\"\n\n    #effective time for integration\n    _t = t - self.t_wait\n    if _t > dt:\n\n        #update local integtration time\n        self.time = _t\n\n        if self.time > 2*dt:\n            #update realtime plotter\n            _, data = self.read()\n            self.plotter.update_all(self.freq, abs(data))\n\n        #compute update step with integration engine\n        f = self._kernel(self.engine.get(), self.inputs.to_array(), _t)\n        return self.engine.step(f, dt)\n\n    #no error estimate\n    return True, 0.0, 1.0",
              "signature": "(t, dt)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time"
                },
                {
                  "name": "dt",
                  "type": null,
                  "default": null,
                  "description": "integration timestep"
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "plotter",
              "description": "",
              "type": null,
              "value": "RealtimePlotter(update_interval=0.1, labels=labels, x_label='freq [Hz]', y_label='magnitude')"
            }
          ],
          "parameters": [
            {
              "name": "freq",
              "type": null,
              "default": "[]",
              "description": "list of evaluation frequencies for RFT, can be arbitrarily spaced"
            },
            {
              "name": "t_wait",
              "type": null,
              "default": "0.0",
              "description": "wait time before starting RFT"
            },
            {
              "name": "alpha",
              "type": null,
              "default": "0.0",
              "description": "exponential forgetting factor for realtime spectrum"
            },
            {
              "name": "labels",
              "type": null,
              "default": "[]",
              "description": "labels for the inputs"
            }
          ]
        }
      ],
      "functions": []
    },
    "pathsim.blocks.switch": {
      "name": "pathsim.blocks.switch",
      "description": "",
      "docstring_html": "",
      "classes": [
        {
          "name": "Switch",
          "description": "Switch block that selects between its inputs and copies",
          "docstring_html": "<p>Switch block that selects between its inputs and copies\none of them to the output.</p>\n<div class=\"section\" id=\"example\">\n<h4>Example</h4>\n<p>The block is initialized like this:</p>\n<pre class=\"code python literal-block\">\n<span class=\"c1\">#default None -&gt; no passthrough</span><span class=\"w\">\n</span><span class=\"n\">s1</span> <span class=\"o\">=</span> <span class=\"n\">Switch</span><span class=\"p\">()</span><span class=\"w\">\n\n</span><span class=\"c1\">#selecting port 2 as passthrough</span><span class=\"w\">\n</span><span class=\"n\">s2</span> <span class=\"o\">=</span> <span class=\"n\">Switch</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">)</span><span class=\"w\">\n\n</span><span class=\"c1\">#change the state of the switch to port 3</span><span class=\"w\">\n</span><span class=\"n\">s2</span><span class=\"o\">.</span><span class=\"n\">select</span><span class=\"p\">(</span><span class=\"mi\">3</span><span class=\"p\">)</span>\n</pre>\n<p>Sets block output depending on <cite>self.state</cite> like this:</p>\n<pre class=\"code literal-block\">\nstate == None -&gt; outputs[0] = 0\n\nstate == 0 -&gt; outputs[0] = inputs[0]\n\nstate == 1 -&gt; outputs[0] = inputs[1]\n\nstate == 2 -&gt; outputs[0] = inputs[2]\n\n...\n</pre>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>state <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int, None</span></dt>\n<dd>state of the switch</dd>\n</dl>\n</div>\n",
          "source": "class Switch(Block):\n    \"\"\"Switch block that selects between its inputs and copies \n    one of them to the output. \n\n    Example\n    -------\n    The block is initialized like this:\n\n    .. code-block:: python \n\n        #default None -> no passthrough \n        s1 = Switch()\n\n        #selecting port 2 as passthrough\n        s2 = Switch(2)\n\n        #change the state of the switch to port 3\n        s2.select(3)\n\n    Sets block output depending on `self.state` like this:\n\n    .. code-block::\n\n        state == None -> outputs[0] = 0\n\n        state == 0 -> outputs[0] = inputs[0]\n\n        state == 1 -> outputs[0] = inputs[1]\n\n        state == 2 -> outputs[0] = inputs[2]\n\n        ...\n\n    Parameters\n    ----------\n    state : int, None\n        state of the switch\n\n    \"\"\"\n\n    #max number of ports\n    _n_in_max = None\n    _n_out_max = 1\n\n    #maps for input and output port labels\n    _port_map_out = {\"out\": 0}\n\n    def __init__(self, state=None):\n        super().__init__()\n\n        self.state = state\n\n\n    def __len__(self):\n        \"\"\"Algebraic passthrough only possible if state is defined\"\"\"\n        return 0 if (self.state is None or not self._active) else 1\n\n\n    def select(self, state=0):\n        \"\"\"\n        This method is unique to the `Switch` block and intended \n        to be used from outside the simulation level for selecting \n        the input ports for the switch state.\n\n        This can be achieved for example with the event management \n        system and its callback/action functions.\n\n        Parameters\n        ---------\n        state : int, None\n            switch state / input port selection\n        \"\"\"\n        self.state = state\n\n\n    def update(self, t):\n        \"\"\"Update switch output depending on inputs and switch state.\n\n        Parameters\n        ----------\n        t : float\n            evaluation time\n        \"\"\"\n\n        #early exit without error control\n        if self.state is None: self.outputs[0] = 0.0\n        else: self.outputs[0] = self.inputs[self.state]",
          "bases": [
            "pathsim.blocks._block.Block"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, state=None):\n    super().__init__()\n\n    self.state = state",
              "signature": "(state = None)",
              "parameters": [
                {
                  "name": "state",
                  "type": null,
                  "default": "None",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "select",
              "description": "This method is unique to the `Switch` block and intended",
              "docstring_html": "<p>This method is unique to the <cite>Switch</cite> block and intended\nto be used from outside the simulation level for selecting\nthe input ports for the switch state.</p>\n<p>This can be achieved for example with the event management\nsystem and its callback/action functions.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>state <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int, None</span></dt>\n<dd>switch state / input port selection</dd>\n</dl>\n",
              "source": "def select(self, state=0):\n    \"\"\"\n    This method is unique to the `Switch` block and intended \n    to be used from outside the simulation level for selecting \n    the input ports for the switch state.\n\n    This can be achieved for example with the event management \n    system and its callback/action functions.\n\n    Parameters\n    ---------\n    state : int, None\n        switch state / input port selection\n    \"\"\"\n    self.state = state",
              "signature": "(state = 0)",
              "parameters": [
                {
                  "name": "state",
                  "type": null,
                  "default": "0",
                  "description": "switch state / input port selection"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "update",
              "description": "Update switch output depending on inputs and switch state.",
              "docstring_html": "<p>Update switch output depending on inputs and switch state.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time</dd>\n</dl>\n",
              "source": "def update(self, t):\n    \"\"\"Update switch output depending on inputs and switch state.\n\n    Parameters\n    ----------\n    t : float\n        evaluation time\n    \"\"\"\n\n    #early exit without error control\n    if self.state is None: self.outputs[0] = 0.0\n    else: self.outputs[0] = self.inputs[self.state]",
              "signature": "(t)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time"
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "_n_in_max",
              "description": "",
              "type": null,
              "value": "None"
            },
            {
              "name": "_n_out_max",
              "description": "",
              "type": null,
              "value": "1"
            },
            {
              "name": "_port_map_out",
              "description": "",
              "type": null,
              "value": "{'out': 0}"
            },
            {
              "name": "state",
              "description": "",
              "type": null,
              "value": "state"
            }
          ],
          "parameters": [
            {
              "name": "state",
              "type": null,
              "default": "None",
              "description": "state of the switch"
            }
          ]
        }
      ],
      "functions": []
    },
    "pathsim.blocks.wrapper": {
      "name": "pathsim.blocks.wrapper",
      "description": "",
      "docstring_html": "",
      "classes": [
        {
          "name": "Wrapper",
          "description": "Wrapper block for discrete implementation and external code integration.",
          "docstring_html": "<p>Wrapper block for discrete implementation and external code integration.</p>\n<p>The <cite>Wrapper</cite> class is designed to trigger the <cite>wrapped</cite> method at fixed intervals\nusing an internal scheduled event. This makes it particularly useful for wrapping\nexternal code or implementing discrete-time systems within the simulation framework.</p>\n<p>The block uses the <cite>Schedule</cite> class to periodically call the <cite>_run_wrapper</cite> method,\nwhich must be implemented by subclasses. The inputs and outputs of the block are\nhandled through the <cite>inputs</cite> and <cite>outputs</cite> registers, enabling seamless integration\nwith other blocks in the simulation.\n...</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>func <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">callable</span></dt>\n<dd>function that defines algebraic block IO behaviour</dd>\n<dt>T <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>sampling period for the wrapped function</dd>\n<dt>tau <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>delay time for the start time of the event</dd>\n</dl>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>Evt :</dt>\n<dd>internal event. Used for periodic sampling the wrapped method</dd>\n<dt>tau <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>delau time for the start time of the event</dd>\n<dt>T <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>sampling period for the event</dd>\n</dl>\n",
          "source": "class Wrapper(Block):\n    \"\"\"\n    Wrapper block for discrete implementation and external code integration.\n\n    The `Wrapper` class is designed to trigger the `wrapped` method at fixed intervals \n    using an internal scheduled event. This makes it particularly useful for wrapping \n    external code or implementing discrete-time systems within the simulation framework.\n\n    The block uses the `Schedule` class to periodically call the `_run_wrapper` method, \n    which must be implemented by subclasses. The inputs and outputs of the block are \n    handled through the `inputs` and `outputs` registers, enabling seamless integration \n    with other blocks in the simulation. \n    ...\n\n    Parameters\n    ----------\n    func : callable\n        function that defines algebraic block IO behaviour\n    T : float\n        sampling period for the wrapped function\n    tau : float\n        delay time for the start time of the event\n\n    Attributes\n    ----------\n    Evt : \n        internal event. Used for periodic sampling the wrapped method\n    tau : float\n        delau time for the start time of the event\n    T : float\n        sampling period for the event\n    \"\"\"\n\n    def __init__(self, func=None, T=1, tau=0):\n        super().__init__()\n        self._T   = T\n        self._tau = tau\n\n        #assign func to wrap (direct initialization)\n        if callable(func):\n            self.wrapped = func\n\n        def _sample(t):\n\n            #read current inputs\n            u = self.inputs.to_array()\n\n            #compute operator output\n            y = self.wrapped(*u)\n\n            #update block outputs\n            self.outputs.update_from_array(y)\n\n        #internal scheduled events\n        self.Evt = Schedule(\n                t_start=tau,\n                t_period=T,\n                func_act=_sample\n                )\n        self.events = [self.Evt]\n\n\n    def update(self, t):\n        \"\"\"Update system equation for fixed point loop.\n\n        Note\n        ----\n        No direct passthrough, the `Wrapper` block doesnt \n        implement the `update` method. The behavior is \n        defined by the `func` arg.\n\n        Parameters\n        ----------\n        t : float\n            evaluation time\n        \"\"\"\n        pass\n\n\n    @property\n    def tau(self):\n        \"\"\"Getter for tau\n\n        Returns\n        -------\n        tau : float\n              delay time for the Schedule event\n        \"\"\"\n        return self._tau\n\n    @tau.setter\n    def tau(self, value):\n        \"\"\"Setter for tau\n\n        Parameters\n        ----------\n        value : float\n                delay time\n        \"\"\"\n        if value < 0:\n            raise ValueError(\"tau must be non-negative\")\n        self._tau = value\n        self.Evt.t_start = value\n\n    @property\n    def T(self):\n        \"\"\"Get the sampling period of the block\n\n            Returns\n            -------\n            T: float\n                sampling period for the Schedule event\n        \"\"\"\n        return self._T\n\n    @T.setter\n    def T(self, value):\n        \"\"\"Set the sampling period of the block\n            Parameters\n            ----------\n            value : float\n                    sampling period\n        \"\"\"\n        if value <= 0:\n            raise ValueError(\"T must be positive\")\n        self._T = value\n        self.Evt.t_period = value\n\n    @classmethod\n    def dec(cls, T=1, tau=0):\n        \"\"\" decorator class for direct instance access from func\"\"\"\n        def decorator(func):\n            return cls(func, T, tau)\n        return decorator",
          "bases": [
            "pathsim.blocks._block.Block"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, func=None, T=1, tau=0):\n    super().__init__()\n    self._T   = T\n    self._tau = tau\n\n    #assign func to wrap (direct initialization)\n    if callable(func):\n        self.wrapped = func\n\n    def _sample(t):\n\n        #read current inputs\n        u = self.inputs.to_array()\n\n        #compute operator output\n        y = self.wrapped(*u)\n\n        #update block outputs\n        self.outputs.update_from_array(y)\n\n    #internal scheduled events\n    self.Evt = Schedule(\n            t_start=tau,\n            t_period=T,\n            func_act=_sample\n            )\n    self.events = [self.Evt]",
              "signature": "(func = None, T = 1, tau = 0)",
              "parameters": [
                {
                  "name": "func",
                  "type": null,
                  "default": "None",
                  "description": ""
                },
                {
                  "name": "T",
                  "type": null,
                  "default": "1",
                  "description": ""
                },
                {
                  "name": "tau",
                  "type": null,
                  "default": "0",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "update",
              "description": "Update system equation for fixed point loop.",
              "docstring_html": "<p>Update system equation for fixed point loop.</p>\n<div class=\"section\" id=\"note\">\n<h4>Note</h4>\n<p>No direct passthrough, the <cite>Wrapper</cite> block doesnt\nimplement the <cite>update</cite> method. The behavior is\ndefined by the <cite>func</cite> arg.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time</dd>\n</dl>\n</div>\n",
              "source": "def update(self, t):\n    \"\"\"Update system equation for fixed point loop.\n\n    Note\n    ----\n    No direct passthrough, the `Wrapper` block doesnt \n    implement the `update` method. The behavior is \n    defined by the `func` arg.\n\n    Parameters\n    ----------\n    t : float\n        evaluation time\n    \"\"\"\n    pass",
              "signature": "(t)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "dec",
              "description": "decorator class for direct instance access from func",
              "docstring_html": "<p>decorator class for direct instance access from func</p>\n",
              "source": "@classmethod\ndef dec(cls, T=1, tau=0):\n    \"\"\" decorator class for direct instance access from func\"\"\"\n    def decorator(func):\n        return cls(func, T, tau)\n    return decorator",
              "signature": "(cls, T = 1, tau = 0)",
              "parameters": [
                {
                  "name": "cls",
                  "type": null,
                  "default": null,
                  "description": ""
                },
                {
                  "name": "T",
                  "type": null,
                  "default": "1",
                  "description": ""
                },
                {
                  "name": "tau",
                  "type": null,
                  "default": "0",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "classmethod"
            }
          ],
          "attributes": [
            {
              "name": "_T",
              "description": "",
              "type": null,
              "value": "T"
            },
            {
              "name": "_tau",
              "description": "",
              "type": null,
              "value": "tau"
            },
            {
              "name": "wrapped",
              "description": "",
              "type": null,
              "value": "func"
            },
            {
              "name": "Evt",
              "description": "",
              "type": null,
              "value": "Schedule(t_start=tau, t_period=T, func_act=_sample)"
            },
            {
              "name": "events",
              "description": "",
              "type": null,
              "value": "[self.Evt]"
            },
            {
              "name": "tau",
              "description": "Getter for tau",
              "type": null,
              "value": null
            },
            {
              "name": "T",
              "description": "Get the sampling period of the block",
              "type": null,
              "value": null
            }
          ],
          "parameters": [
            {
              "name": "func",
              "type": null,
              "default": "None",
              "description": "function that defines algebraic block IO behaviour"
            },
            {
              "name": "T",
              "type": null,
              "default": "1",
              "description": "sampling period for the wrapped function"
            },
            {
              "name": "tau",
              "type": null,
              "default": "0",
              "description": "delay time for the start time of the event Attributes ----------"
            }
          ]
        }
      ],
      "functions": []
    },
    "pathsim.solvers._rungekutta": {
      "name": "pathsim.solvers._rungekutta",
      "description": "",
      "docstring_html": "",
      "classes": [
        {
          "name": "ExplicitRungeKutta",
          "description": "Base class for explicit Runge-Kutta integrators which implements",
          "docstring_html": "<p>Base class for explicit Runge-Kutta integrators which implements\nthe timestepping at intermediate stages and the error control if\nthe coefficients for the local truncation error estimate are defined.</p>\n<p><strong>Notes</strong></p>\n<p>This class is not intended to be used directly!!!</p>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>n <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>order of stepping integration scheme</dd>\n<dt>m <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>order of embedded integration scheme for error control</dd>\n<dt>s <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>numer of RK stages</dd>\n<dt>history <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">deque[numeric]</span></dt>\n<dd>internal history of past results</dd>\n<dt>beta <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>safety factor for error control</dd>\n<dt>Ks <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">dict</span></dt>\n<dd>slopes at RK stages</dd>\n<dt>BT <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">dict[int: None, list[float]], None</span></dt>\n<dd>butcher table</dd>\n<dt>TR <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">list[float]</span></dt>\n<dd>coefficients for truncation error estimate</dd>\n</dl>\n",
          "source": "class ExplicitRungeKutta(ExplicitSolver):\n    \"\"\"Base class for explicit Runge-Kutta integrators which implements \n    the timestepping at intermediate stages and the error control if \n    the coefficients for the local truncation error estimate are defined.        \n\n    Notes\n    -----\n    This class is not intended to be used directly!!!\n\n    Attributes\n    ----------\n    n : int \n        order of stepping integration scheme\n    m : int\n        order of embedded integration scheme for error control\n    s : int\n        numer of RK stages\n    history : deque[numeric]\n        internal history of past results\n    beta : float\n        safety factor for error control\n    Ks : dict\n        slopes at RK stages\n    BT : dict[int: None, list[float]], None\n        butcher table\n    TR : list[float]\n        coefficients for truncation error estimate\n    \"\"\"\n\n    def __init__(self, *solver_args, **solver_kwargs):\n        super().__init__(*solver_args, **solver_kwargs)\n\n        #order of the integration scheme and embedded method (if available)\n        self.n = 0\n        self.m = 0\n\n        #number of stages in RK scheme\n        self.s = 0\n\n        #safety factor for error controller (if available)\n        self.beta = SOL_BETA\n\n        #slope coefficients for stages\n        self.Ks = {}\n\n        #extended butcher tableau\n        self.BT = None\n\n        #coefficients for local truncation error estimate\n        self.TR = None\n\n\n    def error_controller(self, dt):\n        \"\"\"Compute scaling factor for adaptive timestep based on \n        absolute and relative local truncation error estimate, \n        also checks if the error tolerance is achieved and returns \n        a success metric.\n\n        Parameters\n        ----------\n        dt : float \n            integration timestep\n\n        Returns\n        -------\n        success : bool\n            timestep was successful\n        err : float\n            truncation error estimate\n        scale : float\n            timestep rescale from error controller\n        \"\"\"\n\n        #no error estimate or not last stage -> early exit\n        if self.TR is None or self.stage < self.s: \n            return True, 0.0, 1.0\n\n        #local truncation error slope (this is faster then 'sum' comprehension)\n        slope = 0.0\n        for i, b in enumerate(self.TR):\n            slope = slope + self.Ks[i] * b\n\n        #compute scaling factors (avoid division by zero)\n        scale = self.tolerance_lte_abs + self.tolerance_lte_rel * np.abs(self.x)\n\n        #compute scaled truncation error (element-wise)\n        scaled_error = np.abs(dt * slope) / scale\n\n        #compute the error norm and clip it\n        error_norm = np.clip(float(np.max(scaled_error)), TOLERANCE, None)\n\n        #determine if the error is acceptable\n        success = error_norm <= 1.0\n\n        #compute timestep scale factor using accuracy order of truncation error\n        timestep_rescale = self.beta / error_norm ** (1/(min(self.m, self.n) + 1)) \n\n        #clip the rescale factor to a reasonable range\n        timestep_rescale = np.clip(timestep_rescale, SOL_SCALE_MIN, SOL_SCALE_MAX)\n\n        return success, error_norm, timestep_rescale\n\n\n    def step(self, f, dt):\n        \"\"\"Performs the (explicit) timestep at the intermediate RK stages \n        for (t+dt) based on the state and input at (t)\n\n        Parameters\n        ----------\n        f : numeric, array[numeric]\n            evaluation of function\n        dt : float \n            integration timestep\n\n        Returns\n        -------\n        success : bool\n            timestep was successful\n        err : float\n            truncation error estimate\n        scale : float\n            timestep rescale from error controller        \n        \"\"\"\n\n        #buffer intermediate slope\n        self.Ks[self.stage] = f\n\n        #get current state from history\n        x_0 = self.history[0]\n\n        #compute slope at stage, faster then 'sum' comprehension\n        slope = 0.0\n        for i, b in enumerate(self.BT[self.stage]):\n            slope = slope + self.Ks[i] * b\n        self.x = x_0 + dt * slope\n\n        #increment stage counter\n        self.stage += 1\n\n        #compute truncation error estimate\n        return self.error_controller(dt)",
          "bases": [
            "pathsim.solvers._solver.ExplicitSolver"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, *solver_args, **solver_kwargs):\n    super().__init__(*solver_args, **solver_kwargs)\n\n    #order of the integration scheme and embedded method (if available)\n    self.n = 0\n    self.m = 0\n\n    #number of stages in RK scheme\n    self.s = 0\n\n    #safety factor for error controller (if available)\n    self.beta = SOL_BETA\n\n    #slope coefficients for stages\n    self.Ks = {}\n\n    #extended butcher tableau\n    self.BT = None\n\n    #coefficients for local truncation error estimate\n    self.TR = None",
              "signature": "(solver_args = (), solver_kwargs = {})",
              "parameters": [
                {
                  "name": "solver_args",
                  "type": null,
                  "default": "()",
                  "description": ""
                },
                {
                  "name": "solver_kwargs",
                  "type": null,
                  "default": "{}",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "error_controller",
              "description": "Compute scaling factor for adaptive timestep based on",
              "docstring_html": "<p>Compute scaling factor for adaptive timestep based on\nabsolute and relative local truncation error estimate,\nalso checks if the error tolerance is achieved and returns\na success metric.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>integration timestep</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>success <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>timestep was successful</dd>\n<dt>err <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>truncation error estimate</dd>\n<dt>scale <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>timestep rescale from error controller</dd>\n</dl>\n",
              "source": "def error_controller(self, dt):\n    \"\"\"Compute scaling factor for adaptive timestep based on \n    absolute and relative local truncation error estimate, \n    also checks if the error tolerance is achieved and returns \n    a success metric.\n\n    Parameters\n    ----------\n    dt : float \n        integration timestep\n\n    Returns\n    -------\n    success : bool\n        timestep was successful\n    err : float\n        truncation error estimate\n    scale : float\n        timestep rescale from error controller\n    \"\"\"\n\n    #no error estimate or not last stage -> early exit\n    if self.TR is None or self.stage < self.s: \n        return True, 0.0, 1.0\n\n    #local truncation error slope (this is faster then 'sum' comprehension)\n    slope = 0.0\n    for i, b in enumerate(self.TR):\n        slope = slope + self.Ks[i] * b\n\n    #compute scaling factors (avoid division by zero)\n    scale = self.tolerance_lte_abs + self.tolerance_lte_rel * np.abs(self.x)\n\n    #compute scaled truncation error (element-wise)\n    scaled_error = np.abs(dt * slope) / scale\n\n    #compute the error norm and clip it\n    error_norm = np.clip(float(np.max(scaled_error)), TOLERANCE, None)\n\n    #determine if the error is acceptable\n    success = error_norm <= 1.0\n\n    #compute timestep scale factor using accuracy order of truncation error\n    timestep_rescale = self.beta / error_norm ** (1/(min(self.m, self.n) + 1)) \n\n    #clip the rescale factor to a reasonable range\n    timestep_rescale = np.clip(timestep_rescale, SOL_SCALE_MIN, SOL_SCALE_MAX)\n\n    return success, error_norm, timestep_rescale",
              "signature": "(dt)",
              "parameters": [
                {
                  "name": "dt",
                  "type": null,
                  "default": null,
                  "description": "integration timestep"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "step",
              "description": "Performs the (explicit) timestep at the intermediate RK stages",
              "docstring_html": "<p>Performs the (explicit) timestep at the intermediate RK stages\nfor (t+dt) based on the state and input at (t)</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>f <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">numeric, array[numeric]</span></dt>\n<dd>evaluation of function</dd>\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>integration timestep</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>success <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>timestep was successful</dd>\n<dt>err <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>truncation error estimate</dd>\n<dt>scale <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>timestep rescale from error controller</dd>\n</dl>\n",
              "source": "def step(self, f, dt):\n    \"\"\"Performs the (explicit) timestep at the intermediate RK stages \n    for (t+dt) based on the state and input at (t)\n\n    Parameters\n    ----------\n    f : numeric, array[numeric]\n        evaluation of function\n    dt : float \n        integration timestep\n\n    Returns\n    -------\n    success : bool\n        timestep was successful\n    err : float\n        truncation error estimate\n    scale : float\n        timestep rescale from error controller        \n    \"\"\"\n\n    #buffer intermediate slope\n    self.Ks[self.stage] = f\n\n    #get current state from history\n    x_0 = self.history[0]\n\n    #compute slope at stage, faster then 'sum' comprehension\n    slope = 0.0\n    for i, b in enumerate(self.BT[self.stage]):\n        slope = slope + self.Ks[i] * b\n    self.x = x_0 + dt * slope\n\n    #increment stage counter\n    self.stage += 1\n\n    #compute truncation error estimate\n    return self.error_controller(dt)",
              "signature": "(f, dt)",
              "parameters": [
                {
                  "name": "f",
                  "type": null,
                  "default": null,
                  "description": "evaluation of function"
                },
                {
                  "name": "dt",
                  "type": null,
                  "default": null,
                  "description": "integration timestep"
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "n",
              "description": "",
              "type": null,
              "value": "0"
            },
            {
              "name": "m",
              "description": "",
              "type": null,
              "value": "0"
            },
            {
              "name": "s",
              "description": "",
              "type": null,
              "value": "0"
            },
            {
              "name": "beta",
              "description": "",
              "type": null,
              "value": "SOL_BETA"
            },
            {
              "name": "Ks",
              "description": "",
              "type": null,
              "value": "{}"
            },
            {
              "name": "BT",
              "description": "",
              "type": null,
              "value": "None"
            },
            {
              "name": "TR",
              "description": "",
              "type": null,
              "value": "None"
            }
          ],
          "parameters": [
            {
              "name": "solver_args",
              "type": null,
              "default": "()",
              "description": ""
            },
            {
              "name": "solver_kwargs",
              "type": null,
              "default": "{}",
              "description": ""
            }
          ]
        },
        {
          "name": "DiagonallyImplicitRungeKutta",
          "description": "Base class for diagonally implicit Runge-Kutta (DIRK) integrators",
          "docstring_html": "<p>Base class for diagonally implicit Runge-Kutta (DIRK) integrators\nwhich implements the timestepping at intermediate stages, involving\nthe numerical solution of the implicit update equation and the\nerror control if the coefficients for the local truncation error\nestimate are defined.</p>\n<p>Extensions and checks to also handle explicit first stages (ESDIRK)\nand additional final evaluation coefficients (not stiffly accurate)</p>\n<p><strong>Notes</strong></p>\n<p>This class is not intended to be used directly!!!</p>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>n <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>order of stepping integration scheme</dd>\n<dt>m <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>order of embedded integration scheme for error control</dd>\n<dt>s <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>numer of RK stages</dd>\n<dt>beta <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>safety factor for error control</dd>\n<dt>Ks <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">dict</span></dt>\n<dd>slopes at RK stages</dd>\n<dt>BT <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">dict[int: None, list[float]], None</span></dt>\n<dd>butcher table</dd>\n<dt>A <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">list[float], None</span></dt>\n<dd>coefficients for final solution evaluation</dd>\n<dt>TR <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">list[float]</span></dt>\n<dd>coefficients for truncation error estimate</dd>\n</dl>\n",
          "source": "class DiagonallyImplicitRungeKutta(ImplicitSolver):\n    \"\"\"Base class for diagonally implicit Runge-Kutta (DIRK) integrators \n    which implements the timestepping at intermediate stages, involving\n    the numerical solution of the implicit update equation and the \n    error control if the coefficients for the local truncation error \n    estimate are defined.\n\n    Extensions and checks to also handle explicit first stages (ESDIRK) \n    and additional final evaluation coefficients (not stiffly accurate)\n\n    Notes\n    -----\n    This class is not intended to be used directly!!!\n\n    Attributes\n    ----------\n    n : int \n        order of stepping integration scheme\n    m : int\n        order of embedded integration scheme for error control\n    s : int\n        numer of RK stages\n    beta : float\n        safety factor for error control\n    Ks : dict\n        slopes at RK stages\n    BT : dict[int: None, list[float]], None\n        butcher table\n    A : list[float], None\n        coefficients for final solution evaluation\n    TR : list[float]\n        coefficients for truncation error estimate\n\n    \"\"\"\n\n    def __init__(self, *solver_args, **solver_kwargs):\n        super().__init__(*solver_args, **solver_kwargs)\n\n        #order of the integration scheme and embedded method (if available)\n        self.n = 0\n        self.m = 0\n\n        #number of stages in RK scheme\n        self.s = 0\n\n        #safety factor for error controller (if available)\n        self.beta = SOL_BETA\n\n        #slope coefficients for stages\n        self.Ks = {}\n\n        #extended butcher tableau\n        self.BT = None\n\n        #final evaluation (if not stiffly accurate)\n        self.A = None\n\n        #coefficients for local truncation error estimate\n        self.TR = None\n\n\n    def error_controller(self, dt):\n        \"\"\"Compute scaling factor for adaptive timestep based on \n        absolute and relative local truncation error estimate, \n        also checks if the error tolerance is achieved and returns \n        a success metric.\n\n        Parameters\n        ----------\n        dt : float \n            integration timestep\n\n        Returns\n        -------\n        success : bool\n            timestep was successful\n        err : float\n            truncation error estimate\n        scale : float\n            timestep rescale from error controller\n        \"\"\"\n\n        #no error estimate or not last stage -> early exit\n        if self.TR is None or self.stage < self.s: \n            return True, 0.0, 1.0\n\n        #local truncation error slope (this is faster then 'sum' comprehension)\n        slope = 0.0\n        for i, b in enumerate(self.TR):\n            slope = slope + self.Ks[i] * b\n\n        #compute scaling factors (avoid division by zero)\n        scale = self.tolerance_lte_abs + self.tolerance_lte_rel * np.abs(self.x)\n\n        #compute scaled truncation error (element-wise)\n        scaled_error = np.abs(dt * slope) / scale\n\n        #compute the error norm and clip it#compute the error norm and clip it\n        error_norm = np.clip(float(np.max(scaled_error)), TOLERANCE, None)\n\n        #determine if the error is acceptable\n        success = error_norm <= 1.0\n\n        #compute timestep scale factor using accuracy order of truncation error\n        timestep_rescale = self.beta / error_norm ** (1/(min(self.m, self.n) + 1)) \n\n        #clip the rescale factor to a reasonable range\n        timestep_rescale = np.clip(timestep_rescale, SOL_SCALE_MIN, SOL_SCALE_MAX)\n\n        return success, error_norm, timestep_rescale\n\n\n    def solve(self, f, J, dt):\n        \"\"\"Solves the implicit update equation using the optimizer of the engine.\n\n        Parameters\n        ----------\n        f : array_like\n            evaluation of function\n        J : array_like\n            evaluation of jacobian of function\n        dt : float \n            integration timestep\n\n        Returns\n        -------\n        err : float\n            residual error of the fixed point update equation\n        \"\"\"\n\n        #first stage is explicit -> ESDIRK -> early exit\n        if self.stage == 0 and self.BT[self.stage] is None:\n            return 0.0\n\n        #update timestep weighted slope \n        self.Ks[self.stage] = f\n\n        #get past state from history\n        x_0 = self.history[0]\n\n        #compute slope (this is faster then 'sum' comprehension)\n        slope = 0.0\n        for i, a in enumerate(self.BT[self.stage]):\n            slope = slope + self.Ks[i] * a\n\n        #use the jacobian\n        if J is not None:\n\n            #most recent butcher coefficient\n            b = self.BT[self.stage][self.stage]\n\n            #optimizer step with block local jacobian\n            self.x, err = self.opt.step(self.x, x_0 + dt * slope, dt * b * J)\n\n        else:\n            #optimizer step (pure)\n            self.x, err = self.opt.step(self.x, x_0 + dt * slope, None)\n\n        #return the fixed-point residual\n        return err\n\n\n    def step(self, f, dt):\n        \"\"\"performs the (explicit) timestep at the intermediate RK stages \n        for (t+dt) based on the state and input at (t)\n\n        Parameters\n        ----------\n        f : array_like\n            evaluation of function\n        dt : float \n            integration timestep\n\n        Returns\n        -------\n        success : bool\n            timestep was successful\n        err : float\n            truncation error estimate\n        scale : float\n            timestep rescale from error controller\n        \"\"\"\n\n        #first stage is explicit -> ESDIRK\n        if self.stage == 0 and self.BT[self.stage] is None:\n            self.Ks[self.stage] = f\n\n        #increment stage counter\n        self.stage += 1\n\n        #compute final output if not stiffly accurate\n        if self.A is not None and self.stage == self.s:\n\n            #get past state from history\n            x_0 = self.history[0]\n\n            #compute slope (this is faster then 'sum' comprehension)\n            slope = 0.0\n            for i, a in enumerate(self.A):\n                slope = slope + self.Ks[i] * a\n            self.x = x_0 + dt * slope    \n\n        #compute truncation error estimate in final stage\n        return self.error_controller(dt)",
          "bases": [
            "pathsim.solvers._solver.ImplicitSolver"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, *solver_args, **solver_kwargs):\n    super().__init__(*solver_args, **solver_kwargs)\n\n    #order of the integration scheme and embedded method (if available)\n    self.n = 0\n    self.m = 0\n\n    #number of stages in RK scheme\n    self.s = 0\n\n    #safety factor for error controller (if available)\n    self.beta = SOL_BETA\n\n    #slope coefficients for stages\n    self.Ks = {}\n\n    #extended butcher tableau\n    self.BT = None\n\n    #final evaluation (if not stiffly accurate)\n    self.A = None\n\n    #coefficients for local truncation error estimate\n    self.TR = None",
              "signature": "(solver_args = (), solver_kwargs = {})",
              "parameters": [
                {
                  "name": "solver_args",
                  "type": null,
                  "default": "()",
                  "description": ""
                },
                {
                  "name": "solver_kwargs",
                  "type": null,
                  "default": "{}",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "error_controller",
              "description": "Compute scaling factor for adaptive timestep based on",
              "docstring_html": "<p>Compute scaling factor for adaptive timestep based on\nabsolute and relative local truncation error estimate,\nalso checks if the error tolerance is achieved and returns\na success metric.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>integration timestep</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>success <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>timestep was successful</dd>\n<dt>err <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>truncation error estimate</dd>\n<dt>scale <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>timestep rescale from error controller</dd>\n</dl>\n",
              "source": "def error_controller(self, dt):\n    \"\"\"Compute scaling factor for adaptive timestep based on \n    absolute and relative local truncation error estimate, \n    also checks if the error tolerance is achieved and returns \n    a success metric.\n\n    Parameters\n    ----------\n    dt : float \n        integration timestep\n\n    Returns\n    -------\n    success : bool\n        timestep was successful\n    err : float\n        truncation error estimate\n    scale : float\n        timestep rescale from error controller\n    \"\"\"\n\n    #no error estimate or not last stage -> early exit\n    if self.TR is None or self.stage < self.s: \n        return True, 0.0, 1.0\n\n    #local truncation error slope (this is faster then 'sum' comprehension)\n    slope = 0.0\n    for i, b in enumerate(self.TR):\n        slope = slope + self.Ks[i] * b\n\n    #compute scaling factors (avoid division by zero)\n    scale = self.tolerance_lte_abs + self.tolerance_lte_rel * np.abs(self.x)\n\n    #compute scaled truncation error (element-wise)\n    scaled_error = np.abs(dt * slope) / scale\n\n    #compute the error norm and clip it#compute the error norm and clip it\n    error_norm = np.clip(float(np.max(scaled_error)), TOLERANCE, None)\n\n    #determine if the error is acceptable\n    success = error_norm <= 1.0\n\n    #compute timestep scale factor using accuracy order of truncation error\n    timestep_rescale = self.beta / error_norm ** (1/(min(self.m, self.n) + 1)) \n\n    #clip the rescale factor to a reasonable range\n    timestep_rescale = np.clip(timestep_rescale, SOL_SCALE_MIN, SOL_SCALE_MAX)\n\n    return success, error_norm, timestep_rescale",
              "signature": "(dt)",
              "parameters": [
                {
                  "name": "dt",
                  "type": null,
                  "default": null,
                  "description": "integration timestep"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "solve",
              "description": "Solves the implicit update equation using the optimizer of the engine.",
              "docstring_html": "<p>Solves the implicit update equation using the optimizer of the engine.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>f <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array_like</span></dt>\n<dd>evaluation of function</dd>\n<dt>J <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array_like</span></dt>\n<dd>evaluation of jacobian of function</dd>\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>integration timestep</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>err <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>residual error of the fixed point update equation</dd>\n</dl>\n",
              "source": "def solve(self, f, J, dt):\n    \"\"\"Solves the implicit update equation using the optimizer of the engine.\n\n    Parameters\n    ----------\n    f : array_like\n        evaluation of function\n    J : array_like\n        evaluation of jacobian of function\n    dt : float \n        integration timestep\n\n    Returns\n    -------\n    err : float\n        residual error of the fixed point update equation\n    \"\"\"\n\n    #first stage is explicit -> ESDIRK -> early exit\n    if self.stage == 0 and self.BT[self.stage] is None:\n        return 0.0\n\n    #update timestep weighted slope \n    self.Ks[self.stage] = f\n\n    #get past state from history\n    x_0 = self.history[0]\n\n    #compute slope (this is faster then 'sum' comprehension)\n    slope = 0.0\n    for i, a in enumerate(self.BT[self.stage]):\n        slope = slope + self.Ks[i] * a\n\n    #use the jacobian\n    if J is not None:\n\n        #most recent butcher coefficient\n        b = self.BT[self.stage][self.stage]\n\n        #optimizer step with block local jacobian\n        self.x, err = self.opt.step(self.x, x_0 + dt * slope, dt * b * J)\n\n    else:\n        #optimizer step (pure)\n        self.x, err = self.opt.step(self.x, x_0 + dt * slope, None)\n\n    #return the fixed-point residual\n    return err",
              "signature": "(f, J, dt)",
              "parameters": [
                {
                  "name": "f",
                  "type": null,
                  "default": null,
                  "description": "evaluation of function"
                },
                {
                  "name": "J",
                  "type": null,
                  "default": null,
                  "description": "evaluation of jacobian of function"
                },
                {
                  "name": "dt",
                  "type": null,
                  "default": null,
                  "description": "integration timestep"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "step",
              "description": "performs the (explicit) timestep at the intermediate RK stages",
              "docstring_html": "<p>performs the (explicit) timestep at the intermediate RK stages\nfor (t+dt) based on the state and input at (t)</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>f <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array_like</span></dt>\n<dd>evaluation of function</dd>\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>integration timestep</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>success <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>timestep was successful</dd>\n<dt>err <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>truncation error estimate</dd>\n<dt>scale <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>timestep rescale from error controller</dd>\n</dl>\n",
              "source": "def step(self, f, dt):\n    \"\"\"performs the (explicit) timestep at the intermediate RK stages \n    for (t+dt) based on the state and input at (t)\n\n    Parameters\n    ----------\n    f : array_like\n        evaluation of function\n    dt : float \n        integration timestep\n\n    Returns\n    -------\n    success : bool\n        timestep was successful\n    err : float\n        truncation error estimate\n    scale : float\n        timestep rescale from error controller\n    \"\"\"\n\n    #first stage is explicit -> ESDIRK\n    if self.stage == 0 and self.BT[self.stage] is None:\n        self.Ks[self.stage] = f\n\n    #increment stage counter\n    self.stage += 1\n\n    #compute final output if not stiffly accurate\n    if self.A is not None and self.stage == self.s:\n\n        #get past state from history\n        x_0 = self.history[0]\n\n        #compute slope (this is faster then 'sum' comprehension)\n        slope = 0.0\n        for i, a in enumerate(self.A):\n            slope = slope + self.Ks[i] * a\n        self.x = x_0 + dt * slope    \n\n    #compute truncation error estimate in final stage\n    return self.error_controller(dt)",
              "signature": "(f, dt)",
              "parameters": [
                {
                  "name": "f",
                  "type": null,
                  "default": null,
                  "description": "evaluation of function"
                },
                {
                  "name": "dt",
                  "type": null,
                  "default": null,
                  "description": "integration timestep"
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "n",
              "description": "",
              "type": null,
              "value": "0"
            },
            {
              "name": "m",
              "description": "",
              "type": null,
              "value": "0"
            },
            {
              "name": "s",
              "description": "",
              "type": null,
              "value": "0"
            },
            {
              "name": "beta",
              "description": "",
              "type": null,
              "value": "SOL_BETA"
            },
            {
              "name": "Ks",
              "description": "",
              "type": null,
              "value": "{}"
            },
            {
              "name": "BT",
              "description": "",
              "type": null,
              "value": "None"
            },
            {
              "name": "A",
              "description": "",
              "type": null,
              "value": "None"
            },
            {
              "name": "TR",
              "description": "",
              "type": null,
              "value": "None"
            }
          ],
          "parameters": [
            {
              "name": "solver_args",
              "type": null,
              "default": "()",
              "description": ""
            },
            {
              "name": "solver_kwargs",
              "type": null,
              "default": "{}",
              "description": ""
            }
          ]
        }
      ],
      "functions": []
    },
    "pathsim.solvers._solver": {
      "name": "pathsim.solvers._solver",
      "description": "",
      "docstring_html": "",
      "classes": [
        {
          "name": "Solver",
          "description": "Base skeleton class for solver definition. Defines the basic solver methods and",
          "docstring_html": "<p>Base skeleton class for solver definition. Defines the basic solver methods and\nthe metadata.</p>\n<p>Specific solvers need to implement (some of) the base class methods defined here.\nThis depends on the type of solver (implicit/explicit, multistage, adaptive).</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>initial_value <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float, array</span></dt>\n<dd>initial condition / integration constant</dd>\n<dt>tolerance_lte_abs <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>absolute tolerance for local truncation error (for solvers with error estimate)</dd>\n<dt>tolerance_lte_rel <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>relative tolerance for local truncation error (for solvers with error estimate)</dd>\n</dl>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>x <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">numeric, array[numeric]</span></dt>\n<dd>internal 'working' state</dd>\n<dt>history <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">deque[numeric]</span></dt>\n<dd>internal history of past results</dd>\n<dt>n <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>order of integration scheme</dd>\n<dt>s <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>number of internal intermediate stages</dd>\n<dt>stage <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>counter for current intermediate stage</dd>\n<dt>eval_stages <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">list[float]</span></dt>\n<dd>rations for evaluation times of intermediate stages</dd>\n</dl>\n",
          "source": "class Solver:\n    \"\"\"Base skeleton class for solver definition. Defines the basic solver methods and \n    the metadata.\n\n    Specific solvers need to implement (some of) the base class methods defined here. \n    This depends on the type of solver (implicit/explicit, multistage, adaptive).\n\n    Parameters\n    ----------\n    initial_value : float, array\n        initial condition / integration constant\n    tolerance_lte_abs : float\n        absolute tolerance for local truncation error (for solvers with error estimate)\n    tolerance_lte_rel : float\n        relative tolerance for local truncation error (for solvers with error estimate)\n\n    Attributes\n    ----------\n    x : numeric, array[numeric]\n        internal 'working' state\n    history : deque[numeric]\n        internal history of past results\n    n : int\n        order of integration scheme\n    s : int\n        number of internal intermediate stages\n    stage : int\n        counter for current intermediate stage\n    eval_stages : list[float]\n        rations for evaluation times of intermediate stages\n    \"\"\"\n\n    def __init__(\n        self, \n        initial_value=0, \n        tolerance_lte_abs=SOL_TOLERANCE_LTE_ABS, \n        tolerance_lte_rel=SOL_TOLERANCE_LTE_REL\n        ):\n\n        #set state and initial condition    \n        self.x = self.initial_value = initial_value\n\n        #tolerances for local truncation error (for adaptive solvers)\n        self.tolerance_lte_abs = tolerance_lte_abs  \n        self.tolerance_lte_rel = tolerance_lte_rel  \n\n        #flag to identify adaptive/fixed timestep solvers\n        self.is_adaptive = False\n\n        #history of past solutions, default only one\n        self.history = deque([], maxlen=1)\n\n        #order of the integration scheme\n        self.n = 1\n\n        #number of stages\n        self.s = 1\n\n        #current evaluation stage for multistage solvers\n        self.stage = 0\n\n        #intermediate evaluation times as ratios between [t, t+dt]\n        self.eval_stages = [0.0]\n\n\n    def __str__(self):\n        return self.__class__.__name__\n\n\n    def __len__(self):\n        \"\"\"size of the internal state, i.e. the order\n\n        Returns\n        -------\n        size : int\n            size of the current internal state\n        \"\"\"\n        return len(np.atleast_1d(self.x))\n\n\n    def __bool__(self):\n        return True\n\n\n    def stages(self, t, dt):\n        \"\"\"Generator that yields the intermediate evaluation \n        time during the timestep 't + ratio * dt'.\n\n        Parameters\n        ----------\n        t : float \n            evaluation time\n        dt : float\n            integration timestep\n        \"\"\"\n        for ratio in self.eval_stages:\n            yield t + ratio * dt\n\n\n    def get(self):\n        \"\"\"Returns current internal state of the solver.\n\n        Returns\n        -------\n        x : numeric, array[numeric]\n            current internal state of the solver\n        \"\"\"\n        return self.x\n\n\n    def set(self, x):\n        \"\"\"Sets the internal state of the integration engine.\n\n        This method is required for event based simulations, \n        and to handle discontinuities in state variables.\n\n        Parameters\n        ----------\n        x : numeric, array[numeric]\n            new internal state of the solver\n\n        \"\"\"\n\n        #overwrite internal state with value\n        self.x = x\n\n        #reset stage counter\n        self.stage = 0\n\n\n    def reset(self):\n        \"\"\"\"Resets integration engine to initial value\"\"\"\n\n        #overwrite state with initial value\n        self.x = self.initial_value\n        self.history.clear()\n\n        #reset stage counter\n        self.stage = 0\n\n\n    def buffer(self, dt):\n        \"\"\"Saves the current state to an internal state buffer which \n        is especially relevant for multistage and implicit solvers.\n\n        Multistep solver implement rolling buffers for the states \n        and timesteps.\n\n        Resets the stage counter.\n\n        Parameters\n        ----------\n        dt : float\n            integration timestep\n\n        \"\"\"\n\n        #buffer internal state to history\n        self.history.appendleft(self.x)\n\n        #reset stage counter\n        self.stage = 0\n\n\n    @classmethod\n    def cast(cls, other, **solver_kwargs):\n        \"\"\"Cast the integration engine to the new type and initialize \n        with previous solver arguments so it can continue from where \n        the 'old' solver stopped.\n\n        Parameters\n        ----------\n        other : Solver\n            solver instance to cast to new solver type\n        solver_kwargs : dict\n            additional args for the new solver\n\n        Returns\n        -------\n        engine : Solver\n            new solver instance        \n        \"\"\"\n\n        if not isinstance(other, Solver):\n            raise ValueError(\"'other' must be instance of 'Solver' or child\")\n\n        #create new solver instance\n        engine = cls(\n            initial_value=other.initial_value, \n            tolerance_lte_rel=solver_kwargs.get(\"tolerance_lte_rel\", other.tolerance_lte_rel),\n            tolerance_lte_abs=solver_kwargs.get(\"tolerance_lte_abs\", other.tolerance_lte_abs)\n            )\n\n        #set internal state of new engine from other\n        engine.set(other.x)\n\n        return engine\n\n\n    # methods for adaptive timestep solvers --------------------------------------------\n\n    def error_controller(self):\n        \"\"\"Returns the estimated local truncation error (abs and rel) and scaling factor \n        for the timestep, only relevant for adaptive timestepping methods.\n\n        Returns \n        -------\n        success : bool\n            True if the timestep was successful\n        error : float\n            estimated error of the internal error controller\n        scale : float\n            estimated timestep rescale factor for error control\n        \"\"\"\n        return True, 0.0, 1.0\n\n\n    def revert(self):\n        \"\"\"Revert integration engine to previous timestep. \n\n        This is only relevant for adaptive methods where the simulation \n        timestep 'dt' is rescaled and the engine step is recomputed with \n        the smaller timestep.\n        \"\"\"\n\n        #reset internal state to previous state from history\n        self.x = self.history.popleft()\n\n        #reset stage counter\n        self.stage = 0   \n\n\n    # methods for timestepping ---------------------------------------------------------\n\n    def step(self, f, dt):\n        \"\"\"Performs the explicit timestep for (t+dt) based \n        on the state and input at (t).\n\n        Returns the local truncation error estimate and the \n        rescale factor for the timestep if the solver is adaptive.\n\n        Parameters\n        ----------\n        f : numeric, array[numeric]\n            evaluation of rhs function\n        dt : float \n            integration timestep\n\n        Returns \n        -------\n        success : bool\n            True if the timestep was successful\n        error : float\n            estimated error of the internal error controller\n        scale : float\n            estimated timestep rescale factor for error control\n        \"\"\"\n        return True, 0.0, 1.0\n\n\n    # methods for interpolation --------------------------------------------------------\n\n    def interpolate(self, r, dt):\n        \"\"\"Interpolate solution after successful timestep as a ratio \n        in the interval [t, t+dt].\n\n        This is especially relevant for Runge-Kutta solvers that \n        have a higher order interpolant. Otherwise this is just \n        linear interpolation using the buffered state.\n\n        Parameters\n        ----------\n        r : float\n            ration for interpolation within timestep\n        dt : float\n            integration timestep\n\n        Returns\n        -------\n        x : numeric, array[numeric]\n            interpolated state\n        \"\"\"\n        _r = np.clip(r, 0.0, 1.0)\n        return _r * self.x + (1.0 - _r) * self.x_0",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(\n    self, \n    initial_value=0, \n    tolerance_lte_abs=SOL_TOLERANCE_LTE_ABS, \n    tolerance_lte_rel=SOL_TOLERANCE_LTE_REL\n    ):\n\n    #set state and initial condition    \n    self.x = self.initial_value = initial_value\n\n    #tolerances for local truncation error (for adaptive solvers)\n    self.tolerance_lte_abs = tolerance_lte_abs  \n    self.tolerance_lte_rel = tolerance_lte_rel  \n\n    #flag to identify adaptive/fixed timestep solvers\n    self.is_adaptive = False\n\n    #history of past solutions, default only one\n    self.history = deque([], maxlen=1)\n\n    #order of the integration scheme\n    self.n = 1\n\n    #number of stages\n    self.s = 1\n\n    #current evaluation stage for multistage solvers\n    self.stage = 0\n\n    #intermediate evaluation times as ratios between [t, t+dt]\n    self.eval_stages = [0.0]",
              "signature": "(initial_value = 0, tolerance_lte_abs = SOL_TOLERANCE_LTE_ABS, tolerance_lte_rel = SOL_TOLERANCE_LTE_REL)",
              "parameters": [
                {
                  "name": "initial_value",
                  "type": null,
                  "default": "0",
                  "description": ""
                },
                {
                  "name": "tolerance_lte_abs",
                  "type": null,
                  "default": "SOL_TOLERANCE_LTE_ABS",
                  "description": ""
                },
                {
                  "name": "tolerance_lte_rel",
                  "type": null,
                  "default": "SOL_TOLERANCE_LTE_REL",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "stages",
              "description": "Generator that yields the intermediate evaluation",
              "docstring_html": "<p>Generator that yields the intermediate evaluation\ntime during the timestep 't + ratio * dt'.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time</dd>\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>integration timestep</dd>\n</dl>\n",
              "source": "def stages(self, t, dt):\n    \"\"\"Generator that yields the intermediate evaluation \n    time during the timestep 't + ratio * dt'.\n\n    Parameters\n    ----------\n    t : float \n        evaluation time\n    dt : float\n        integration timestep\n    \"\"\"\n    for ratio in self.eval_stages:\n        yield t + ratio * dt",
              "signature": "(t, dt)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time"
                },
                {
                  "name": "dt",
                  "type": null,
                  "default": null,
                  "description": "integration timestep"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "get",
              "description": "Returns current internal state of the solver.",
              "docstring_html": "<p>Returns current internal state of the solver.</p>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>x <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">numeric, array[numeric]</span></dt>\n<dd>current internal state of the solver</dd>\n</dl>\n",
              "source": "def get(self):\n    \"\"\"Returns current internal state of the solver.\n\n    Returns\n    -------\n    x : numeric, array[numeric]\n        current internal state of the solver\n    \"\"\"\n    return self.x",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "set",
              "description": "Sets the internal state of the integration engine.",
              "docstring_html": "<p>Sets the internal state of the integration engine.</p>\n<p>This method is required for event based simulations,\nand to handle discontinuities in state variables.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>x <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">numeric, array[numeric]</span></dt>\n<dd>new internal state of the solver</dd>\n</dl>\n",
              "source": "def set(self, x):\n    \"\"\"Sets the internal state of the integration engine.\n\n    This method is required for event based simulations, \n    and to handle discontinuities in state variables.\n\n    Parameters\n    ----------\n    x : numeric, array[numeric]\n        new internal state of the solver\n\n    \"\"\"\n\n    #overwrite internal state with value\n    self.x = x\n\n    #reset stage counter\n    self.stage = 0",
              "signature": "(x)",
              "parameters": [
                {
                  "name": "x",
                  "type": null,
                  "default": null,
                  "description": "new internal state of the solver"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "reset",
              "description": "\"Resets integration engine to initial value",
              "docstring_html": "<p>&quot;Resets integration engine to initial value</p>\n",
              "source": "def reset(self):\n    \"\"\"\"Resets integration engine to initial value\"\"\"\n\n    #overwrite state with initial value\n    self.x = self.initial_value\n    self.history.clear()\n\n    #reset stage counter\n    self.stage = 0",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "buffer",
              "description": "Saves the current state to an internal state buffer which",
              "docstring_html": "<p>Saves the current state to an internal state buffer which\nis especially relevant for multistage and implicit solvers.</p>\n<p>Multistep solver implement rolling buffers for the states\nand timesteps.</p>\n<p>Resets the stage counter.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>integration timestep</dd>\n</dl>\n",
              "source": "def buffer(self, dt):\n    \"\"\"Saves the current state to an internal state buffer which \n    is especially relevant for multistage and implicit solvers.\n\n    Multistep solver implement rolling buffers for the states \n    and timesteps.\n\n    Resets the stage counter.\n\n    Parameters\n    ----------\n    dt : float\n        integration timestep\n\n    \"\"\"\n\n    #buffer internal state to history\n    self.history.appendleft(self.x)\n\n    #reset stage counter\n    self.stage = 0",
              "signature": "(dt)",
              "parameters": [
                {
                  "name": "dt",
                  "type": null,
                  "default": null,
                  "description": "integration timestep"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "cast",
              "description": "Cast the integration engine to the new type and initialize",
              "docstring_html": "<p>Cast the integration engine to the new type and initialize\nwith previous solver arguments so it can continue from where\nthe 'old' solver stopped.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>other <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">Solver</span></dt>\n<dd>solver instance to cast to new solver type</dd>\n<dt>solver_kwargs <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">dict</span></dt>\n<dd>additional args for the new solver</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>engine <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">Solver</span></dt>\n<dd>new solver instance</dd>\n</dl>\n",
              "source": "@classmethod\ndef cast(cls, other, **solver_kwargs):\n    \"\"\"Cast the integration engine to the new type and initialize \n    with previous solver arguments so it can continue from where \n    the 'old' solver stopped.\n\n    Parameters\n    ----------\n    other : Solver\n        solver instance to cast to new solver type\n    solver_kwargs : dict\n        additional args for the new solver\n\n    Returns\n    -------\n    engine : Solver\n        new solver instance        \n    \"\"\"\n\n    if not isinstance(other, Solver):\n        raise ValueError(\"'other' must be instance of 'Solver' or child\")\n\n    #create new solver instance\n    engine = cls(\n        initial_value=other.initial_value, \n        tolerance_lte_rel=solver_kwargs.get(\"tolerance_lte_rel\", other.tolerance_lte_rel),\n        tolerance_lte_abs=solver_kwargs.get(\"tolerance_lte_abs\", other.tolerance_lte_abs)\n        )\n\n    #set internal state of new engine from other\n    engine.set(other.x)\n\n    return engine",
              "signature": "(cls, other, solver_kwargs = {})",
              "parameters": [
                {
                  "name": "cls",
                  "type": null,
                  "default": null,
                  "description": ""
                },
                {
                  "name": "other",
                  "type": null,
                  "default": null,
                  "description": "solver instance to cast to new solver type"
                },
                {
                  "name": "solver_kwargs",
                  "type": null,
                  "default": "{}",
                  "description": "additional args for the new solver"
                }
              ],
              "returns": null,
              "method_type": "classmethod"
            },
            {
              "name": "error_controller",
              "description": "Returns the estimated local truncation error (abs and rel) and scaling factor",
              "docstring_html": "<p>Returns the estimated local truncation error (abs and rel) and scaling factor\nfor the timestep, only relevant for adaptive timestepping methods.</p>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>success <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>True if the timestep was successful</dd>\n<dt>error <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>estimated error of the internal error controller</dd>\n<dt>scale <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>estimated timestep rescale factor for error control</dd>\n</dl>\n",
              "source": "def error_controller(self):\n    \"\"\"Returns the estimated local truncation error (abs and rel) and scaling factor \n    for the timestep, only relevant for adaptive timestepping methods.\n\n    Returns \n    -------\n    success : bool\n        True if the timestep was successful\n    error : float\n        estimated error of the internal error controller\n    scale : float\n        estimated timestep rescale factor for error control\n    \"\"\"\n    return True, 0.0, 1.0",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "revert",
              "description": "Revert integration engine to previous timestep.",
              "docstring_html": "<p>Revert integration engine to previous timestep.</p>\n<p>This is only relevant for adaptive methods where the simulation\ntimestep 'dt' is rescaled and the engine step is recomputed with\nthe smaller timestep.</p>\n",
              "source": "def revert(self):\n    \"\"\"Revert integration engine to previous timestep. \n\n    This is only relevant for adaptive methods where the simulation \n    timestep 'dt' is rescaled and the engine step is recomputed with \n    the smaller timestep.\n    \"\"\"\n\n    #reset internal state to previous state from history\n    self.x = self.history.popleft()\n\n    #reset stage counter\n    self.stage = 0",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "step",
              "description": "Performs the explicit timestep for (t+dt) based",
              "docstring_html": "<p>Performs the explicit timestep for (t+dt) based\non the state and input at (t).</p>\n<p>Returns the local truncation error estimate and the\nrescale factor for the timestep if the solver is adaptive.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>f <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">numeric, array[numeric]</span></dt>\n<dd>evaluation of rhs function</dd>\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>integration timestep</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>success <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>True if the timestep was successful</dd>\n<dt>error <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>estimated error of the internal error controller</dd>\n<dt>scale <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>estimated timestep rescale factor for error control</dd>\n</dl>\n",
              "source": "def step(self, f, dt):\n    \"\"\"Performs the explicit timestep for (t+dt) based \n    on the state and input at (t).\n\n    Returns the local truncation error estimate and the \n    rescale factor for the timestep if the solver is adaptive.\n\n    Parameters\n    ----------\n    f : numeric, array[numeric]\n        evaluation of rhs function\n    dt : float \n        integration timestep\n\n    Returns \n    -------\n    success : bool\n        True if the timestep was successful\n    error : float\n        estimated error of the internal error controller\n    scale : float\n        estimated timestep rescale factor for error control\n    \"\"\"\n    return True, 0.0, 1.0",
              "signature": "(f, dt)",
              "parameters": [
                {
                  "name": "f",
                  "type": null,
                  "default": null,
                  "description": "evaluation of rhs function"
                },
                {
                  "name": "dt",
                  "type": null,
                  "default": null,
                  "description": "integration timestep"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "interpolate",
              "description": "Interpolate solution after successful timestep as a ratio",
              "docstring_html": "<p>Interpolate solution after successful timestep as a ratio\nin the interval [t, t+dt].</p>\n<p>This is especially relevant for Runge-Kutta solvers that\nhave a higher order interpolant. Otherwise this is just\nlinear interpolation using the buffered state.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>r <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>ration for interpolation within timestep</dd>\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>integration timestep</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>x <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">numeric, array[numeric]</span></dt>\n<dd>interpolated state</dd>\n</dl>\n",
              "source": "def interpolate(self, r, dt):\n    \"\"\"Interpolate solution after successful timestep as a ratio \n    in the interval [t, t+dt].\n\n    This is especially relevant for Runge-Kutta solvers that \n    have a higher order interpolant. Otherwise this is just \n    linear interpolation using the buffered state.\n\n    Parameters\n    ----------\n    r : float\n        ration for interpolation within timestep\n    dt : float\n        integration timestep\n\n    Returns\n    -------\n    x : numeric, array[numeric]\n        interpolated state\n    \"\"\"\n    _r = np.clip(r, 0.0, 1.0)\n    return _r * self.x + (1.0 - _r) * self.x_0",
              "signature": "(r, dt)",
              "parameters": [
                {
                  "name": "r",
                  "type": null,
                  "default": null,
                  "description": "ration for interpolation within timestep"
                },
                {
                  "name": "dt",
                  "type": null,
                  "default": null,
                  "description": "integration timestep"
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "x",
              "description": "",
              "type": null,
              "value": "initial_value"
            },
            {
              "name": "initial_value",
              "description": "",
              "type": null,
              "value": "initial_value"
            },
            {
              "name": "tolerance_lte_abs",
              "description": "",
              "type": null,
              "value": "tolerance_lte_abs"
            },
            {
              "name": "tolerance_lte_rel",
              "description": "",
              "type": null,
              "value": "tolerance_lte_rel"
            },
            {
              "name": "is_adaptive",
              "description": "",
              "type": null,
              "value": "False"
            },
            {
              "name": "history",
              "description": "",
              "type": null,
              "value": "deque([], maxlen=1)"
            },
            {
              "name": "n",
              "description": "",
              "type": null,
              "value": "1"
            },
            {
              "name": "s",
              "description": "",
              "type": null,
              "value": "1"
            },
            {
              "name": "stage",
              "description": "",
              "type": null,
              "value": "0"
            },
            {
              "name": "eval_stages",
              "description": "",
              "type": null,
              "value": "[0.0]"
            }
          ],
          "parameters": [
            {
              "name": "initial_value",
              "type": null,
              "default": "0",
              "description": "initial condition / integration constant"
            },
            {
              "name": "tolerance_lte_abs",
              "type": null,
              "default": "SOL_TOLERANCE_LTE_ABS",
              "description": "absolute tolerance for local truncation error (for solvers with error estimate)"
            },
            {
              "name": "tolerance_lte_rel",
              "type": null,
              "default": "SOL_TOLERANCE_LTE_REL",
              "description": "relative tolerance for local truncation error (for solvers with error estimate)"
            }
          ]
        },
        {
          "name": "ExplicitSolver",
          "description": "Base class for explicit solver definition.",
          "docstring_html": "<p>Base class for explicit solver definition.</p>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>x_0 <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">numeric, array[numeric]</span></dt>\n<dd>internal 'working' initial value</dd>\n<dt>x <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">numeric, array[numeric]</span></dt>\n<dd>internal 'working' state</dd>\n<dt>n <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>order of integration scheme</dd>\n<dt>s <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>number of internal intermediate stages</dd>\n<dt>stage <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>counter for current intermediate stage</dd>\n<dt>eval_stages <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">list[float]</span></dt>\n<dd>rations for evaluation times of intermediate stages</dd>\n</dl>\n",
          "source": "class ExplicitSolver(Solver):\n    \"\"\"Base class for explicit solver definition.\n\n    Attributes\n    ----------\n    x_0 : numeric, array[numeric]\n        internal 'working' initial value\n    x : numeric, array[numeric]\n        internal 'working' state\n    n : int\n        order of integration scheme\n    s : int\n        number of internal intermediate stages\n    stage : int\n        counter for current intermediate stage\n    eval_stages : list[float]\n        rations for evaluation times of intermediate stages\n\n    \"\"\"\n\n    def __init__(self, *solver_args, **solver_kwargs):\n        super().__init__(*solver_args, **solver_kwargs)\n\n        #flag to identify implicit/explicit solvers\n        self.is_explicit = True\n        self.is_implicit = False\n\n        #intermediate evaluation times for multistage solvers as ratios between [t, t+dt]\n        self.eval_stages = [0.0]\n\n\n    # method for direct integration ----------------------------------------------------\n\n    def integrate_singlestep(self, func, time=0.0, dt=SIM_TIMESTEP):\n        \"\"\"Directly integrate the function for a single timestep 'dt' with \n        explicit solvers. This method is primarily intended for testing purposes.\n\n        Parameters\n        ----------  \n        func : callable\n            function to integrate f(x, t)\n        time : float\n            starting time for timestep\n        dt : float\n            integration timestep\n\n        Returns \n        -------\n        success : bool\n            True if the timestep was successful\n        error_norm : float\n            estimated error of the internal error controller\n        scale : float\n            estimated timestep rescale factor for error control\n        \"\"\"\n\n        #buffer current state\n        self.buffer(dt)\n\n        #iterate solver stages (explicit updates)\n        for t in self.stages(time, dt):\n            f = func(self.x, t)\n            success, error_norm, scale = self.step(f, dt)\n\n        return success, error_norm, scale\n\n\n    def integrate(\n        self, \n        func,\n        time_start=0.0, \n        time_end=1.0, \n        dt=SIM_TIMESTEP, \n        dt_min=SIM_TIMESTEP_MIN, \n        dt_max=SIM_TIMESTEP_MAX, \n        adaptive=True\n        ):\n        \"\"\"Directly integrate the function 'func' from 'time_start' \n        to 'time_end' with timestep 'dt' for explicit solvers. \n\n        This method is primarily intended for testing purposes or \n        for use as a standalone numerical integrator.\n\n        Example\n        -------\n\n        This is how to directly use the solver to integrate an ODE:\n\n        .. code-block:: python\n\n            #1st order linear ODE\n            def f(x, u, t):\n                return -x\n\n            #initial condition\n            x0 = 1\n\n            #initialize ODE solver\n            sol = Solver(x0)\n\n            #integrate from 0 to 5 with timestep 0.1\n            t, x = sol.integrate(f, time_end=5, dt=0.1)\n\n\n        Parameters\n        ----------\n        func : callable\n            function to integrate f(x, t)\n        time_start : float\n            starting time for integration\n        time_end : float\n            end time for integration\n        dt : float\n            timestep or initial timestep for adaptive solvers\n        dt_min : float\n            lower bound for timestep, default '0.0'\n        dt_max : float\n            upper bound for timestep, default 'None'\n        adaptive : bool\n            use adaptive timestepping if available\n\n        Returns\n        -------\n        outout_times : array[float]\n            time points of the solution\n        output_states : array[numeric], array[array[numeric]]\n            state values at solution time points\n        \"\"\"\n\n        #output lists with initial state\n        output_states = [self.x]\n        output_times = [time_start]\n\n        #integration starting time\n        time = time_start\n\n        #step until duration is reached\n        while time < time_end + dt:\n\n            #perform single timestep\n            success, _, scale = self.integrate_singlestep(func, time, dt)\n\n            #check if timestep was successful\n            if adaptive and not success:\n                self.revert()\n            else:\n                time += dt\n                output_states.append(self.x)\n                output_times.append(time)\n\n            #rescale and apply bounds to timestep\n            if adaptive:\n                if scale*dt < dt_min:\n                    raise RuntimeError(\"Error control requires timestep smaller 'dt_min'!\")\n                dt = np.clip(scale*dt, dt_min, dt_max)\n\n        #return the evaluation times and the states\n        return np.array(output_times), np.array(output_states)",
          "bases": [
            "pathsim.solvers._solver.Solver"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, *solver_args, **solver_kwargs):\n    super().__init__(*solver_args, **solver_kwargs)\n\n    #flag to identify implicit/explicit solvers\n    self.is_explicit = True\n    self.is_implicit = False\n\n    #intermediate evaluation times for multistage solvers as ratios between [t, t+dt]\n    self.eval_stages = [0.0]",
              "signature": "(solver_args = (), solver_kwargs = {})",
              "parameters": [
                {
                  "name": "solver_args",
                  "type": null,
                  "default": "()",
                  "description": ""
                },
                {
                  "name": "solver_kwargs",
                  "type": null,
                  "default": "{}",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "integrate_singlestep",
              "description": "Directly integrate the function for a single timestep 'dt' with",
              "docstring_html": "<p>Directly integrate the function for a single timestep 'dt' with\nexplicit solvers. This method is primarily intended for testing purposes.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>func <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">callable</span></dt>\n<dd>function to integrate f(x, t)</dd>\n<dt>time <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>starting time for timestep</dd>\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>integration timestep</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>success <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>True if the timestep was successful</dd>\n<dt>error_norm <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>estimated error of the internal error controller</dd>\n<dt>scale <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>estimated timestep rescale factor for error control</dd>\n</dl>\n",
              "source": "def integrate_singlestep(self, func, time=0.0, dt=SIM_TIMESTEP):\n    \"\"\"Directly integrate the function for a single timestep 'dt' with \n    explicit solvers. This method is primarily intended for testing purposes.\n\n    Parameters\n    ----------  \n    func : callable\n        function to integrate f(x, t)\n    time : float\n        starting time for timestep\n    dt : float\n        integration timestep\n\n    Returns \n    -------\n    success : bool\n        True if the timestep was successful\n    error_norm : float\n        estimated error of the internal error controller\n    scale : float\n        estimated timestep rescale factor for error control\n    \"\"\"\n\n    #buffer current state\n    self.buffer(dt)\n\n    #iterate solver stages (explicit updates)\n    for t in self.stages(time, dt):\n        f = func(self.x, t)\n        success, error_norm, scale = self.step(f, dt)\n\n    return success, error_norm, scale",
              "signature": "(func, time = 0.0, dt = SIM_TIMESTEP)",
              "parameters": [
                {
                  "name": "func",
                  "type": null,
                  "default": null,
                  "description": "function to integrate f(x, t)"
                },
                {
                  "name": "time",
                  "type": null,
                  "default": "0.0",
                  "description": "starting time for timestep"
                },
                {
                  "name": "dt",
                  "type": null,
                  "default": "SIM_TIMESTEP",
                  "description": "integration timestep"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "integrate",
              "description": "Directly integrate the function 'func' from 'time_start'",
              "docstring_html": "<p>Directly integrate the function 'func' from 'time_start'\nto 'time_end' with timestep 'dt' for explicit solvers.</p>\n<p>This method is primarily intended for testing purposes or\nfor use as a standalone numerical integrator.</p>\n<div class=\"section\" id=\"example\">\n<h4>Example</h4>\n<p>This is how to directly use the solver to integrate an ODE:</p>\n<pre class=\"code python literal-block\">\n<span class=\"c1\">#1st order linear ODE</span><span class=\"w\">\n</span><span class=\"k\">def</span><span class=\"w\"> </span><span class=\"nf\">f</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">u</span><span class=\"p\">,</span> <span class=\"n\">t</span><span class=\"p\">):</span><span class=\"w\">\n</span>    <span class=\"k\">return</span> <span class=\"o\">-</span><span class=\"n\">x</span><span class=\"w\">\n\n</span><span class=\"c1\">#initial condition</span><span class=\"w\">\n</span><span class=\"n\">x0</span> <span class=\"o\">=</span> <span class=\"mi\">1</span><span class=\"w\">\n\n</span><span class=\"c1\">#initialize ODE solver</span><span class=\"w\">\n</span><span class=\"n\">sol</span> <span class=\"o\">=</span> <span class=\"n\">Solver</span><span class=\"p\">(</span><span class=\"n\">x0</span><span class=\"p\">)</span><span class=\"w\">\n\n</span><span class=\"c1\">#integrate from 0 to 5 with timestep 0.1</span><span class=\"w\">\n</span><span class=\"n\">t</span><span class=\"p\">,</span> <span class=\"n\">x</span> <span class=\"o\">=</span> <span class=\"n\">sol</span><span class=\"o\">.</span><span class=\"n\">integrate</span><span class=\"p\">(</span><span class=\"n\">f</span><span class=\"p\">,</span> <span class=\"n\">time_end</span><span class=\"o\">=</span><span class=\"mi\">5</span><span class=\"p\">,</span> <span class=\"n\">dt</span><span class=\"o\">=</span><span class=\"mf\">0.1</span><span class=\"p\">)</span>\n</pre>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>func <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">callable</span></dt>\n<dd>function to integrate f(x, t)</dd>\n<dt>time_start <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>starting time for integration</dd>\n<dt>time_end <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>end time for integration</dd>\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>timestep or initial timestep for adaptive solvers</dd>\n<dt>dt_min <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>lower bound for timestep, default '0.0'</dd>\n<dt>dt_max <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>upper bound for timestep, default 'None'</dd>\n<dt>adaptive <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>use adaptive timestepping if available</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>outout_times <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array[float]</span></dt>\n<dd>time points of the solution</dd>\n<dt>output_states <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array[numeric], array[array[numeric]]</span></dt>\n<dd>state values at solution time points</dd>\n</dl>\n</div>\n",
              "source": "def integrate(\n    self, \n    func,\n    time_start=0.0, \n    time_end=1.0, \n    dt=SIM_TIMESTEP, \n    dt_min=SIM_TIMESTEP_MIN, \n    dt_max=SIM_TIMESTEP_MAX, \n    adaptive=True\n    ):\n    \"\"\"Directly integrate the function 'func' from 'time_start' \n    to 'time_end' with timestep 'dt' for explicit solvers. \n\n    This method is primarily intended for testing purposes or \n    for use as a standalone numerical integrator.\n\n    Example\n    -------\n\n    This is how to directly use the solver to integrate an ODE:\n\n    .. code-block:: python\n\n        #1st order linear ODE\n        def f(x, u, t):\n            return -x\n\n        #initial condition\n        x0 = 1\n\n        #initialize ODE solver\n        sol = Solver(x0)\n\n        #integrate from 0 to 5 with timestep 0.1\n        t, x = sol.integrate(f, time_end=5, dt=0.1)\n\n\n    Parameters\n    ----------\n    func : callable\n        function to integrate f(x, t)\n    time_start : float\n        starting time for integration\n    time_end : float\n        end time for integration\n    dt : float\n        timestep or initial timestep for adaptive solvers\n    dt_min : float\n        lower bound for timestep, default '0.0'\n    dt_max : float\n        upper bound for timestep, default 'None'\n    adaptive : bool\n        use adaptive timestepping if available\n\n    Returns\n    -------\n    outout_times : array[float]\n        time points of the solution\n    output_states : array[numeric], array[array[numeric]]\n        state values at solution time points\n    \"\"\"\n\n    #output lists with initial state\n    output_states = [self.x]\n    output_times = [time_start]\n\n    #integration starting time\n    time = time_start\n\n    #step until duration is reached\n    while time < time_end + dt:\n\n        #perform single timestep\n        success, _, scale = self.integrate_singlestep(func, time, dt)\n\n        #check if timestep was successful\n        if adaptive and not success:\n            self.revert()\n        else:\n            time += dt\n            output_states.append(self.x)\n            output_times.append(time)\n\n        #rescale and apply bounds to timestep\n        if adaptive:\n            if scale*dt < dt_min:\n                raise RuntimeError(\"Error control requires timestep smaller 'dt_min'!\")\n            dt = np.clip(scale*dt, dt_min, dt_max)\n\n    #return the evaluation times and the states\n    return np.array(output_times), np.array(output_states)",
              "signature": "(func, time_start = 0.0, time_end = 1.0, dt = SIM_TIMESTEP, dt_min = SIM_TIMESTEP_MIN, dt_max = SIM_TIMESTEP_MAX, adaptive = True)",
              "parameters": [
                {
                  "name": "func",
                  "type": null,
                  "default": null,
                  "description": "function to integrate f(x, t)"
                },
                {
                  "name": "time_start",
                  "type": null,
                  "default": "0.0",
                  "description": "starting time for integration"
                },
                {
                  "name": "time_end",
                  "type": null,
                  "default": "1.0",
                  "description": "end time for integration"
                },
                {
                  "name": "dt",
                  "type": null,
                  "default": "SIM_TIMESTEP",
                  "description": "timestep or initial timestep for adaptive solvers"
                },
                {
                  "name": "dt_min",
                  "type": null,
                  "default": "SIM_TIMESTEP_MIN",
                  "description": "lower bound for timestep, default '0.0'"
                },
                {
                  "name": "dt_max",
                  "type": null,
                  "default": "SIM_TIMESTEP_MAX",
                  "description": "upper bound for timestep, default 'None'"
                },
                {
                  "name": "adaptive",
                  "type": null,
                  "default": "True",
                  "description": "use adaptive timestepping if available"
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "is_explicit",
              "description": "",
              "type": null,
              "value": "True"
            },
            {
              "name": "is_implicit",
              "description": "",
              "type": null,
              "value": "False"
            },
            {
              "name": "eval_stages",
              "description": "",
              "type": null,
              "value": "[0.0]"
            }
          ],
          "parameters": [
            {
              "name": "solver_args",
              "type": null,
              "default": "()",
              "description": ""
            },
            {
              "name": "solver_kwargs",
              "type": null,
              "default": "{}",
              "description": ""
            }
          ]
        },
        {
          "name": "ImplicitSolver",
          "description": "Base class for implicit solver definition.",
          "docstring_html": "<p>Base class for implicit solver definition.</p>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>x_0 <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">numeric, array[numeric]</span></dt>\n<dd>internal 'working' initial value</dd>\n<dt>x <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">numeric, array[numeric]</span></dt>\n<dd>internal 'working' state</dd>\n<dt>n <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>order of integration scheme</dd>\n<dt>s <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>number of internal intermediate stages</dd>\n<dt>stage <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>counter for current intermediate stage</dd>\n<dt>eval_stages <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">list[float]</span></dt>\n<dd>rations for evaluation times of intermediate stages</dd>\n<dt>opt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">NewtonAnderson, Anderson, etc.</span></dt>\n<dd>optimizer instance to solve the implicit update equation</dd>\n</dl>\n",
          "source": "class ImplicitSolver(Solver):\n    \"\"\"\n    Base class for implicit solver definition.\n\n    Attributes\n    ----------\n    x_0 : numeric, array[numeric]\n        internal 'working' initial value\n    x : numeric, array[numeric]\n        internal 'working' state\n    n : int\n        order of integration scheme\n    s : int\n        number of internal intermediate stages\n    stage : int\n        counter for current intermediate stage\n    eval_stages : list[float]\n        rations for evaluation times of intermediate stages\n    opt : NewtonAnderson, Anderson, etc.\n        optimizer instance to solve the implicit update equation\n\n    \"\"\"\n\n    def __init__(self, *solver_args, **solver_kwargs):\n        super().__init__(*solver_args, **solver_kwargs)\n\n        #flag to identify implicit/explicit solvers\n        self.is_explicit = False\n        self.is_implicit = True\n\n        #intermediate evaluation times for multistage solvers as ratios between [t, t+dt]\n        self.eval_stages = [1.0]\n\n        #initialize optimizer for solving implicit update equation\n        self.opt = NewtonAnderson(m=5, restart=False)\n\n\n    def buffer(self, dt):\n        \"\"\"Saves the current state to an internal state buffer which \n        is especially relevant for multistage and implicit solvers.\n\n        Resets the stage counter and the optimizer of implicit methods.\n\n        Parameters\n        ----------\n        dt : float\n            integration timestep\n        \"\"\"\n\n        #buffer internal state to history\n        self.history.appendleft(self.x)\n\n        #reset stage counter\n        self.stage = 0\n\n        #reset optimizer\n        self.opt.reset()\n\n\n    # methods for timestepping ---------------------------------------------------------\n\n    def solve(self, j, J, dt):\n        \"\"\"Advances the solution of the implicit update equation of the solver \n        with the optimizer of the engine and tracks the evolution of the \n        solution by providing the residual norm of the fixed-point solution.\n\n        Parameters\n        ----------\n        f : numeric, array[numeric]\n            evaluation of rhs function\n        J : array[numeric]\n            evaluation of jacobian of rhs function \n        dt : float \n            integration timestep\n\n        Returns\n        -------\n        err : float\n            residual error of the fixed point update equation\n        \"\"\"\n        return 0.0\n\n\n    # method for direct integration ----------------------------------------------------\n\n    def integrate_singlestep(\n        self, \n        func,\n        jac,\n        time=0.0, \n        dt=SIM_TIMESTEP, \n        tolerance_fpi=SOL_TOLERANCE_FPI, \n        max_iterations=SOL_ITERATIONS_MAX\n        ):\n        \"\"\"\n        Directly integrate the function 'func' for a single timestep 'dt' with \n        implicit solvers. This method is primarily intended for testing purposes.\n\n        Parameters\n        ----------  \n        func : callable\n            function to integrate f(x, t)\n        jac : callable\n            jacobian of f w.r.t. x\n        time_start : float\n            starting time for timestep\n        dt : float\n            integration timestep\n        tolerance_fpi : float\n            convergence criterion for implicit update equation\n        max_iterations : int\n            maximum numer of iterations for optimizer to solve \n            implicit update equation\n\n        Returns \n        -------\n        success : bool\n            True if the timestep was successful\n        error_norm : float\n            estimated error of the internal error controller \n            or solver when not converged\n        scale : float\n            estimated timestep rescale factor for error control\n        \"\"\"\n\n        #buffer current state\n        self.buffer(dt)\n\n        #iterate solver stages (implicit updates)\n        for t in self.stages(time, dt):\n\n            #iteratively solve implicit update equation\n            for _ in range(max_iterations):\n                f, J = func(self.x, t), jac(self.x, t)\n                error_sol = self.solve(f, J, dt)\n                if error_sol < tolerance_fpi: \n                    break\n\n            #catch convergence error -> early exit, half timestep\n            if error_sol > tolerance_fpi:\n                return False, error_sol, 0.5\n\n            #perform explicit component of timestep\n            f = func(self.x, t)\n            success, error_norm, scale = self.step(f, dt)\n\n        return success, error_norm, scale \n\n\n    def integrate(\n        self, \n        func, \n        jac,\n        time_start=0.0, \n        time_end=1.0, \n        dt=SIM_TIMESTEP, \n        dt_min=SIM_TIMESTEP_MIN, \n        dt_max=SIM_TIMESTEP_MAX, \n        adaptive=True,\n        tolerance_fpi=SOL_TOLERANCE_FPI, \n        max_iterations=SOL_ITERATIONS_MAX\n        ):\n        \"\"\"Directly integrate the function 'func' from 'time_start' \n        to 'time_end' with timestep 'dt' for implicit solvers. \n\n        This method is primarily intended for testing purposes or \n        for use as a standalone numerical integrator.\n\n        Example\n        -------\n\n        This is how to directly use the solver to integrate an ODE:\n\n        .. code-block:: python\n\n            #1st order linear ODE\n            def f(x, t):\n                return -x\n\n            #initial condition\n            x0 = 1\n\n            #initialize ODE solver\n            sol = Solver(x0)\n\n            #integrate from 0 to 5 with timestep 0.1\n            t, x = sol.integrate(f, time_end=5, dt=0.1)\n\n        Parameters\n        ----------\n        func : callable\n            function to integrate f(x, t)\n        jac : callable\n            jacobian of f w.r.t. x\n        time_start : float\n            starting time for integration\n        time_end : float\n            end time for integration\n        dt : float\n            timestep or initial timestep for adaptive solvers\n        dt_min : float\n            lower bound for timestep, default '0.0'\n        dt_max : float\n            upper bound for timestep, default 'None'\n        adaptive : bool\n            use adaptive timestepping if available\n        tolerance_fpi : float\n            convergence criterion for implicit update equation\n        max_iterations : int\n            maximum numer of iterations for optimizer to solve \n            implicit update equation\n\n        Returns\n        -------\n        outout_times : array[float]\n            time points of the solution\n        output_states : array[numeric], array[array[numeric]]\n            state values at solution time points    \n        \"\"\"\n\n        #output lists with initial state\n        output_states = [self.x]\n        output_times = [time_start]\n\n        #integration starting time\n        time = time_start\n\n        #step until duration is reached\n        while time < time_end + dt:\n\n            #integrate for single timestep\n            success, _, scale = self.integrate_singlestep(\n                func, \n                jac,\n                time, \n                dt, \n                tolerance_fpi, \n                max_iterations\n                )\n\n\n            #check if timestep was successful and adaptive\n            if adaptive and not success:\n                self.revert()\n            else:\n                time += dt\n                output_states.append(self.x)\n                output_times.append(time)\n\n            #rescale and apply bounds to timestep\n            if adaptive:\n                if scale*dt < dt_min:\n                    raise RuntimeError(\"Error control requires timestep smaller 'dt_min'!\")\n                dt = np.clip(scale*dt, dt_min, dt_max)\n\n        #return the evaluation times and the states\n        return np.array(output_times), np.array(output_states)",
          "bases": [
            "pathsim.solvers._solver.Solver"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, *solver_args, **solver_kwargs):\n    super().__init__(*solver_args, **solver_kwargs)\n\n    #flag to identify implicit/explicit solvers\n    self.is_explicit = False\n    self.is_implicit = True\n\n    #intermediate evaluation times for multistage solvers as ratios between [t, t+dt]\n    self.eval_stages = [1.0]\n\n    #initialize optimizer for solving implicit update equation\n    self.opt = NewtonAnderson(m=5, restart=False)",
              "signature": "(solver_args = (), solver_kwargs = {})",
              "parameters": [
                {
                  "name": "solver_args",
                  "type": null,
                  "default": "()",
                  "description": ""
                },
                {
                  "name": "solver_kwargs",
                  "type": null,
                  "default": "{}",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "buffer",
              "description": "Saves the current state to an internal state buffer which",
              "docstring_html": "<p>Saves the current state to an internal state buffer which\nis especially relevant for multistage and implicit solvers.</p>\n<p>Resets the stage counter and the optimizer of implicit methods.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>integration timestep</dd>\n</dl>\n",
              "source": "def buffer(self, dt):\n    \"\"\"Saves the current state to an internal state buffer which \n    is especially relevant for multistage and implicit solvers.\n\n    Resets the stage counter and the optimizer of implicit methods.\n\n    Parameters\n    ----------\n    dt : float\n        integration timestep\n    \"\"\"\n\n    #buffer internal state to history\n    self.history.appendleft(self.x)\n\n    #reset stage counter\n    self.stage = 0\n\n    #reset optimizer\n    self.opt.reset()",
              "signature": "(dt)",
              "parameters": [
                {
                  "name": "dt",
                  "type": null,
                  "default": null,
                  "description": "integration timestep"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "solve",
              "description": "Advances the solution of the implicit update equation of the solver",
              "docstring_html": "<p>Advances the solution of the implicit update equation of the solver\nwith the optimizer of the engine and tracks the evolution of the\nsolution by providing the residual norm of the fixed-point solution.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>f <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">numeric, array[numeric]</span></dt>\n<dd>evaluation of rhs function</dd>\n<dt>J <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array[numeric]</span></dt>\n<dd>evaluation of jacobian of rhs function</dd>\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>integration timestep</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>err <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>residual error of the fixed point update equation</dd>\n</dl>\n",
              "source": "def solve(self, j, J, dt):\n    \"\"\"Advances the solution of the implicit update equation of the solver \n    with the optimizer of the engine and tracks the evolution of the \n    solution by providing the residual norm of the fixed-point solution.\n\n    Parameters\n    ----------\n    f : numeric, array[numeric]\n        evaluation of rhs function\n    J : array[numeric]\n        evaluation of jacobian of rhs function \n    dt : float \n        integration timestep\n\n    Returns\n    -------\n    err : float\n        residual error of the fixed point update equation\n    \"\"\"\n    return 0.0",
              "signature": "(j, J, dt)",
              "parameters": [
                {
                  "name": "j",
                  "type": null,
                  "default": null,
                  "description": ""
                },
                {
                  "name": "J",
                  "type": null,
                  "default": null,
                  "description": "evaluation of jacobian of rhs function"
                },
                {
                  "name": "dt",
                  "type": null,
                  "default": null,
                  "description": "integration timestep"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "integrate_singlestep",
              "description": "Directly integrate the function 'func' for a single timestep 'dt' with",
              "docstring_html": "<p>Directly integrate the function 'func' for a single timestep 'dt' with\nimplicit solvers. This method is primarily intended for testing purposes.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>func <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">callable</span></dt>\n<dd>function to integrate f(x, t)</dd>\n<dt>jac <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">callable</span></dt>\n<dd>jacobian of f w.r.t. x</dd>\n<dt>time_start <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>starting time for timestep</dd>\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>integration timestep</dd>\n<dt>tolerance_fpi <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>convergence criterion for implicit update equation</dd>\n<dt>max_iterations <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>maximum numer of iterations for optimizer to solve\nimplicit update equation</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>success <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>True if the timestep was successful</dd>\n<dt>error_norm <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>estimated error of the internal error controller\nor solver when not converged</dd>\n<dt>scale <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>estimated timestep rescale factor for error control</dd>\n</dl>\n",
              "source": "def integrate_singlestep(\n    self, \n    func,\n    jac,\n    time=0.0, \n    dt=SIM_TIMESTEP, \n    tolerance_fpi=SOL_TOLERANCE_FPI, \n    max_iterations=SOL_ITERATIONS_MAX\n    ):\n    \"\"\"\n    Directly integrate the function 'func' for a single timestep 'dt' with \n    implicit solvers. This method is primarily intended for testing purposes.\n\n    Parameters\n    ----------  \n    func : callable\n        function to integrate f(x, t)\n    jac : callable\n        jacobian of f w.r.t. x\n    time_start : float\n        starting time for timestep\n    dt : float\n        integration timestep\n    tolerance_fpi : float\n        convergence criterion for implicit update equation\n    max_iterations : int\n        maximum numer of iterations for optimizer to solve \n        implicit update equation\n\n    Returns \n    -------\n    success : bool\n        True if the timestep was successful\n    error_norm : float\n        estimated error of the internal error controller \n        or solver when not converged\n    scale : float\n        estimated timestep rescale factor for error control\n    \"\"\"\n\n    #buffer current state\n    self.buffer(dt)\n\n    #iterate solver stages (implicit updates)\n    for t in self.stages(time, dt):\n\n        #iteratively solve implicit update equation\n        for _ in range(max_iterations):\n            f, J = func(self.x, t), jac(self.x, t)\n            error_sol = self.solve(f, J, dt)\n            if error_sol < tolerance_fpi: \n                break\n\n        #catch convergence error -> early exit, half timestep\n        if error_sol > tolerance_fpi:\n            return False, error_sol, 0.5\n\n        #perform explicit component of timestep\n        f = func(self.x, t)\n        success, error_norm, scale = self.step(f, dt)\n\n    return success, error_norm, scale",
              "signature": "(func, jac, time = 0.0, dt = SIM_TIMESTEP, tolerance_fpi = SOL_TOLERANCE_FPI, max_iterations = SOL_ITERATIONS_MAX)",
              "parameters": [
                {
                  "name": "func",
                  "type": null,
                  "default": null,
                  "description": "function to integrate f(x, t)"
                },
                {
                  "name": "jac",
                  "type": null,
                  "default": null,
                  "description": "jacobian of f w.r.t. x"
                },
                {
                  "name": "time",
                  "type": null,
                  "default": "0.0",
                  "description": ""
                },
                {
                  "name": "dt",
                  "type": null,
                  "default": "SIM_TIMESTEP",
                  "description": "integration timestep"
                },
                {
                  "name": "tolerance_fpi",
                  "type": null,
                  "default": "SOL_TOLERANCE_FPI",
                  "description": "convergence criterion for implicit update equation"
                },
                {
                  "name": "max_iterations",
                  "type": null,
                  "default": "SOL_ITERATIONS_MAX",
                  "description": "maximum numer of iterations for optimizer to solve implicit update equation"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "integrate",
              "description": "Directly integrate the function 'func' from 'time_start'",
              "docstring_html": "<p>Directly integrate the function 'func' from 'time_start'\nto 'time_end' with timestep 'dt' for implicit solvers.</p>\n<p>This method is primarily intended for testing purposes or\nfor use as a standalone numerical integrator.</p>\n<div class=\"section\" id=\"example\">\n<h4>Example</h4>\n<p>This is how to directly use the solver to integrate an ODE:</p>\n<pre class=\"code python literal-block\">\n<span class=\"c1\">#1st order linear ODE</span><span class=\"w\">\n</span><span class=\"k\">def</span><span class=\"w\"> </span><span class=\"nf\">f</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">t</span><span class=\"p\">):</span><span class=\"w\">\n</span>    <span class=\"k\">return</span> <span class=\"o\">-</span><span class=\"n\">x</span><span class=\"w\">\n\n</span><span class=\"c1\">#initial condition</span><span class=\"w\">\n</span><span class=\"n\">x0</span> <span class=\"o\">=</span> <span class=\"mi\">1</span><span class=\"w\">\n\n</span><span class=\"c1\">#initialize ODE solver</span><span class=\"w\">\n</span><span class=\"n\">sol</span> <span class=\"o\">=</span> <span class=\"n\">Solver</span><span class=\"p\">(</span><span class=\"n\">x0</span><span class=\"p\">)</span><span class=\"w\">\n\n</span><span class=\"c1\">#integrate from 0 to 5 with timestep 0.1</span><span class=\"w\">\n</span><span class=\"n\">t</span><span class=\"p\">,</span> <span class=\"n\">x</span> <span class=\"o\">=</span> <span class=\"n\">sol</span><span class=\"o\">.</span><span class=\"n\">integrate</span><span class=\"p\">(</span><span class=\"n\">f</span><span class=\"p\">,</span> <span class=\"n\">time_end</span><span class=\"o\">=</span><span class=\"mi\">5</span><span class=\"p\">,</span> <span class=\"n\">dt</span><span class=\"o\">=</span><span class=\"mf\">0.1</span><span class=\"p\">)</span>\n</pre>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>func <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">callable</span></dt>\n<dd>function to integrate f(x, t)</dd>\n<dt>jac <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">callable</span></dt>\n<dd>jacobian of f w.r.t. x</dd>\n<dt>time_start <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>starting time for integration</dd>\n<dt>time_end <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>end time for integration</dd>\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>timestep or initial timestep for adaptive solvers</dd>\n<dt>dt_min <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>lower bound for timestep, default '0.0'</dd>\n<dt>dt_max <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>upper bound for timestep, default 'None'</dd>\n<dt>adaptive <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>use adaptive timestepping if available</dd>\n<dt>tolerance_fpi <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>convergence criterion for implicit update equation</dd>\n<dt>max_iterations <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>maximum numer of iterations for optimizer to solve\nimplicit update equation</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>outout_times <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array[float]</span></dt>\n<dd>time points of the solution</dd>\n<dt>output_states <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array[numeric], array[array[numeric]]</span></dt>\n<dd>state values at solution time points</dd>\n</dl>\n</div>\n",
              "source": "def integrate(\n    self, \n    func, \n    jac,\n    time_start=0.0, \n    time_end=1.0, \n    dt=SIM_TIMESTEP, \n    dt_min=SIM_TIMESTEP_MIN, \n    dt_max=SIM_TIMESTEP_MAX, \n    adaptive=True,\n    tolerance_fpi=SOL_TOLERANCE_FPI, \n    max_iterations=SOL_ITERATIONS_MAX\n    ):\n    \"\"\"Directly integrate the function 'func' from 'time_start' \n    to 'time_end' with timestep 'dt' for implicit solvers. \n\n    This method is primarily intended for testing purposes or \n    for use as a standalone numerical integrator.\n\n    Example\n    -------\n\n    This is how to directly use the solver to integrate an ODE:\n\n    .. code-block:: python\n\n        #1st order linear ODE\n        def f(x, t):\n            return -x\n\n        #initial condition\n        x0 = 1\n\n        #initialize ODE solver\n        sol = Solver(x0)\n\n        #integrate from 0 to 5 with timestep 0.1\n        t, x = sol.integrate(f, time_end=5, dt=0.1)\n\n    Parameters\n    ----------\n    func : callable\n        function to integrate f(x, t)\n    jac : callable\n        jacobian of f w.r.t. x\n    time_start : float\n        starting time for integration\n    time_end : float\n        end time for integration\n    dt : float\n        timestep or initial timestep for adaptive solvers\n    dt_min : float\n        lower bound for timestep, default '0.0'\n    dt_max : float\n        upper bound for timestep, default 'None'\n    adaptive : bool\n        use adaptive timestepping if available\n    tolerance_fpi : float\n        convergence criterion for implicit update equation\n    max_iterations : int\n        maximum numer of iterations for optimizer to solve \n        implicit update equation\n\n    Returns\n    -------\n    outout_times : array[float]\n        time points of the solution\n    output_states : array[numeric], array[array[numeric]]\n        state values at solution time points    \n    \"\"\"\n\n    #output lists with initial state\n    output_states = [self.x]\n    output_times = [time_start]\n\n    #integration starting time\n    time = time_start\n\n    #step until duration is reached\n    while time < time_end + dt:\n\n        #integrate for single timestep\n        success, _, scale = self.integrate_singlestep(\n            func, \n            jac,\n            time, \n            dt, \n            tolerance_fpi, \n            max_iterations\n            )\n\n\n        #check if timestep was successful and adaptive\n        if adaptive and not success:\n            self.revert()\n        else:\n            time += dt\n            output_states.append(self.x)\n            output_times.append(time)\n\n        #rescale and apply bounds to timestep\n        if adaptive:\n            if scale*dt < dt_min:\n                raise RuntimeError(\"Error control requires timestep smaller 'dt_min'!\")\n            dt = np.clip(scale*dt, dt_min, dt_max)\n\n    #return the evaluation times and the states\n    return np.array(output_times), np.array(output_states)",
              "signature": "(func, jac, time_start = 0.0, time_end = 1.0, dt = SIM_TIMESTEP, dt_min = SIM_TIMESTEP_MIN, dt_max = SIM_TIMESTEP_MAX, adaptive = True, tolerance_fpi = SOL_TOLERANCE_FPI, max_iterations = SOL_ITERATIONS_MAX)",
              "parameters": [
                {
                  "name": "func",
                  "type": null,
                  "default": null,
                  "description": "function to integrate f(x, t)"
                },
                {
                  "name": "jac",
                  "type": null,
                  "default": null,
                  "description": "jacobian of f w.r.t. x"
                },
                {
                  "name": "time_start",
                  "type": null,
                  "default": "0.0",
                  "description": "starting time for integration"
                },
                {
                  "name": "time_end",
                  "type": null,
                  "default": "1.0",
                  "description": "end time for integration"
                },
                {
                  "name": "dt",
                  "type": null,
                  "default": "SIM_TIMESTEP",
                  "description": "timestep or initial timestep for adaptive solvers"
                },
                {
                  "name": "dt_min",
                  "type": null,
                  "default": "SIM_TIMESTEP_MIN",
                  "description": "lower bound for timestep, default '0.0'"
                },
                {
                  "name": "dt_max",
                  "type": null,
                  "default": "SIM_TIMESTEP_MAX",
                  "description": "upper bound for timestep, default 'None'"
                },
                {
                  "name": "adaptive",
                  "type": null,
                  "default": "True",
                  "description": "use adaptive timestepping if available"
                },
                {
                  "name": "tolerance_fpi",
                  "type": null,
                  "default": "SOL_TOLERANCE_FPI",
                  "description": "convergence criterion for implicit update equation"
                },
                {
                  "name": "max_iterations",
                  "type": null,
                  "default": "SOL_ITERATIONS_MAX",
                  "description": "maximum numer of iterations for optimizer to solve implicit update equation"
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "is_explicit",
              "description": "",
              "type": null,
              "value": "False"
            },
            {
              "name": "is_implicit",
              "description": "",
              "type": null,
              "value": "True"
            },
            {
              "name": "eval_stages",
              "description": "",
              "type": null,
              "value": "[1.0]"
            },
            {
              "name": "opt",
              "description": "",
              "type": null,
              "value": "NewtonAnderson(m=5, restart=False)"
            }
          ],
          "parameters": [
            {
              "name": "solver_args",
              "type": null,
              "default": "()",
              "description": ""
            },
            {
              "name": "solver_kwargs",
              "type": null,
              "default": "{}",
              "description": ""
            }
          ]
        }
      ],
      "functions": []
    },
    "pathsim.solvers.bdf": {
      "name": "pathsim.solvers.bdf",
      "description": "",
      "docstring_html": "",
      "classes": [
        {
          "name": "BDF",
          "description": "Base class for the backward differentiation formula (BDF) integrators.",
          "docstring_html": "<p>Base class for the backward differentiation formula (BDF) integrators.</p>\n<p><strong>Notes</strong></p>\n<p>This solver class is not intended to be used directly</p>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>x <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">numeric, array[numeric]</span></dt>\n<dd>internal 'working' state</dd>\n<dt>n <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>order of integration scheme</dd>\n<dt>s <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>number of internal intermediate stages</dd>\n<dt>stage <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>counter for current intermediate stage</dd>\n<dt>eval_stages <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">list[float]</span></dt>\n<dd>rations for evaluation times of intermediate stages</dd>\n<dt>opt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">NewtonAnderson, Anderson, etc.</span></dt>\n<dd>optimizer instance to solve the implicit update equation</dd>\n<dt>K <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">dict[int: list[float]]</span></dt>\n<dd>bdf coefficients for the state buffer for each order</dd>\n<dt>F <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">dict[int: float]</span></dt>\n<dd>bdf coefficients for the function 'func' for each order</dd>\n<dt>history <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">deque[numeric]</span></dt>\n<dd>internal history of past results</dd>\n<dt>startup <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">Solver</span></dt>\n<dd>internal solver instance for startup (building history)\nof multistep methods (using 'DIRK3' for 'BDF' methods)</dd>\n</dl>\n",
          "source": "class BDF(ImplicitSolver):\n    \"\"\"Base class for the backward differentiation formula (BDF) integrators.\n\n    Notes\n    ----- \n    This solver class is not intended to be used directly\n\n    Attributes\n    ----------\n    x : numeric, array[numeric]\n        internal 'working' state\n    n : int\n        order of integration scheme\n    s : int\n        number of internal intermediate stages\n    stage : int\n        counter for current intermediate stage\n    eval_stages : list[float]\n        rations for evaluation times of intermediate stages\n    opt : NewtonAnderson, Anderson, etc.\n        optimizer instance to solve the implicit update equation\n    K : dict[int: list[float]]\n        bdf coefficients for the state buffer for each order\n    F : dict[int: float]\n        bdf coefficients for the function 'func' for each order\n    history : deque[numeric]\n        internal history of past results\n    startup : Solver\n        internal solver instance for startup (building history) \n        of multistep methods (using 'DIRK3' for 'BDF' methods)\n    \"\"\"\n\n    def __init__(self, *solver_args, **solver_kwargs):\n        super().__init__(*solver_args, **solver_kwargs)\n\n        #integration order\n        self.n = None\n\n        #bdf coefficients for orders 1 to 6\n        self.K = {1:[1.0], \n                  2:[4/3, -1/3], \n                  3:[18/11, -9/11, 2/11], \n                  4:[48/25, -36/25, 16/25, -3/25],\n                  5:[300/137, -300/137, 200/137, -75/137, 12/137],\n                  6:[ 360/147, -450/147, 400/147, -225/147, 72/147, -10/147]}\n        self.F = {1:1.0, 2:2/3, 3:6/11, 4:12/25, 5:60/137, 6:60/147}\n\n        #initialize startup solver from 'self' and flag\n        self._needs_startup = True\n        self.startup = DIRK3.cast(self)\n\n\n    def stages(self, t, dt):\n        \"\"\"Generator that yields the intermediate evaluation \n        time during the timestep 't + ratio * dt'.\n\n        Parameters\n        ----------\n        t : float \n            evaluation time\n        dt : float\n            integration timestep\n        \"\"\"\n\n        #not enough history for full order -> stages of startup method\n        if self._needs_startup:\n            for _t in self.startup.stages(t, dt):\n                yield _t\n        else:\n            for ratio in self.eval_stages:\n                yield t + ratio * dt\n\n\n    def reset(self):\n        \"\"\"\"Resets integration engine to initial state.\"\"\"\n\n        #clear history (BDF solution buffer)\n        self.history.clear()\n\n        #overwrite state with initial value\n        self.x = self.initial_value\n\n        #reset startup solver\n        self.startup.reset()\n\n\n    def buffer(self, dt):\n        \"\"\"buffer the state for the multistep method\n\n        Parameters\n        ----------\n        dt : float\n            integration timestep\n        \"\"\"\n\n        #reset optimizer\n        self.opt.reset()\n\n        #add current solution to history\n        self.history.appendleft(self.x)\n\n        #flag for startup method, not enough history\n        self._needs_startup = len(self.history) < self.n\n\n        #buffer with startup method\n        if self._needs_startup:\n            self.startup.buffer(dt)\n\n\n    def solve(self, f, J, dt):\n        \"\"\"Solves the implicit update equation using the optimizer of the engine.\n\n        Parameters\n        ----------\n        f : array_like\n            evaluation of function\n        J : array_like\n            evaluation of jacobian of function\n        dt : float \n            integration timestep\n\n        Returns\n        -------\n        err : float\n            residual error of the fixed point update equation\n        \"\"\"\n\n        #not enough history for full order -> solve with startup method\n        if self._needs_startup:\n            err = self.startup.solve(f, J, dt)\n            self.x = self.startup.get()\n            return err\n\n        #fixed-point function update\n        g = self.F[self.n] * dt * f\n        for b, k in zip(self.history, self.K[self.n]):\n            g = g + b * k\n\n        #use the jacobian\n        if J is not None:\n\n            #optimizer step with block local jacobian\n            self.x, err = self.opt.step(self.x, g, self.F[self.n] * dt * J)\n\n        else:\n            #optimizer step (pure)\n            self.x, err = self.opt.step(self.x, g, None)\n\n        #return the fixed-point residual\n        return err\n\n\n    def step(self, f, dt):\n        \"\"\"Performs the explicit timestep for (t+dt) based \n        on the state and input at (t).\n\n        Note\n        ----\n        This is only required for the startup solver.\n\n        Parameters\n        ----------\n        f : numeric, array[numeric]\n            evaluation of rhs function\n        dt : float \n            integration timestep\n\n        Returns \n        -------\n        success : bool\n            True if the timestep was successful\n        error : float\n            estimated error of the internal error controller\n        scale : float\n            estimated timestep rescale factor for error control\n        \"\"\"\n\n        #not enough histors -> step the startup solver\n        if self._needs_startup:\n            self.startup.step(f, dt)\n            self.x = self.startup.get()\n\n        return True, 0.0, 1.0",
          "bases": [
            "pathsim.solvers._solver.ImplicitSolver"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, *solver_args, **solver_kwargs):\n    super().__init__(*solver_args, **solver_kwargs)\n\n    #integration order\n    self.n = None\n\n    #bdf coefficients for orders 1 to 6\n    self.K = {1:[1.0], \n              2:[4/3, -1/3], \n              3:[18/11, -9/11, 2/11], \n              4:[48/25, -36/25, 16/25, -3/25],\n              5:[300/137, -300/137, 200/137, -75/137, 12/137],\n              6:[ 360/147, -450/147, 400/147, -225/147, 72/147, -10/147]}\n    self.F = {1:1.0, 2:2/3, 3:6/11, 4:12/25, 5:60/137, 6:60/147}\n\n    #initialize startup solver from 'self' and flag\n    self._needs_startup = True\n    self.startup = DIRK3.cast(self)",
              "signature": "(solver_args = (), solver_kwargs = {})",
              "parameters": [
                {
                  "name": "solver_args",
                  "type": null,
                  "default": "()",
                  "description": ""
                },
                {
                  "name": "solver_kwargs",
                  "type": null,
                  "default": "{}",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "stages",
              "description": "Generator that yields the intermediate evaluation",
              "docstring_html": "<p>Generator that yields the intermediate evaluation\ntime during the timestep 't + ratio * dt'.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time</dd>\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>integration timestep</dd>\n</dl>\n",
              "source": "def stages(self, t, dt):\n    \"\"\"Generator that yields the intermediate evaluation \n    time during the timestep 't + ratio * dt'.\n\n    Parameters\n    ----------\n    t : float \n        evaluation time\n    dt : float\n        integration timestep\n    \"\"\"\n\n    #not enough history for full order -> stages of startup method\n    if self._needs_startup:\n        for _t in self.startup.stages(t, dt):\n            yield _t\n    else:\n        for ratio in self.eval_stages:\n            yield t + ratio * dt",
              "signature": "(t, dt)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time"
                },
                {
                  "name": "dt",
                  "type": null,
                  "default": null,
                  "description": "integration timestep"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "reset",
              "description": "\"Resets integration engine to initial state.",
              "docstring_html": "<p>&quot;Resets integration engine to initial state.</p>\n",
              "source": "def reset(self):\n    \"\"\"\"Resets integration engine to initial state.\"\"\"\n\n    #clear history (BDF solution buffer)\n    self.history.clear()\n\n    #overwrite state with initial value\n    self.x = self.initial_value\n\n    #reset startup solver\n    self.startup.reset()",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "buffer",
              "description": "buffer the state for the multistep method",
              "docstring_html": "<p>buffer the state for the multistep method</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>integration timestep</dd>\n</dl>\n",
              "source": "def buffer(self, dt):\n    \"\"\"buffer the state for the multistep method\n\n    Parameters\n    ----------\n    dt : float\n        integration timestep\n    \"\"\"\n\n    #reset optimizer\n    self.opt.reset()\n\n    #add current solution to history\n    self.history.appendleft(self.x)\n\n    #flag for startup method, not enough history\n    self._needs_startup = len(self.history) < self.n\n\n    #buffer with startup method\n    if self._needs_startup:\n        self.startup.buffer(dt)",
              "signature": "(dt)",
              "parameters": [
                {
                  "name": "dt",
                  "type": null,
                  "default": null,
                  "description": "integration timestep"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "solve",
              "description": "Solves the implicit update equation using the optimizer of the engine.",
              "docstring_html": "<p>Solves the implicit update equation using the optimizer of the engine.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>f <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array_like</span></dt>\n<dd>evaluation of function</dd>\n<dt>J <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array_like</span></dt>\n<dd>evaluation of jacobian of function</dd>\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>integration timestep</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>err <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>residual error of the fixed point update equation</dd>\n</dl>\n",
              "source": "def solve(self, f, J, dt):\n    \"\"\"Solves the implicit update equation using the optimizer of the engine.\n\n    Parameters\n    ----------\n    f : array_like\n        evaluation of function\n    J : array_like\n        evaluation of jacobian of function\n    dt : float \n        integration timestep\n\n    Returns\n    -------\n    err : float\n        residual error of the fixed point update equation\n    \"\"\"\n\n    #not enough history for full order -> solve with startup method\n    if self._needs_startup:\n        err = self.startup.solve(f, J, dt)\n        self.x = self.startup.get()\n        return err\n\n    #fixed-point function update\n    g = self.F[self.n] * dt * f\n    for b, k in zip(self.history, self.K[self.n]):\n        g = g + b * k\n\n    #use the jacobian\n    if J is not None:\n\n        #optimizer step with block local jacobian\n        self.x, err = self.opt.step(self.x, g, self.F[self.n] * dt * J)\n\n    else:\n        #optimizer step (pure)\n        self.x, err = self.opt.step(self.x, g, None)\n\n    #return the fixed-point residual\n    return err",
              "signature": "(f, J, dt)",
              "parameters": [
                {
                  "name": "f",
                  "type": null,
                  "default": null,
                  "description": "evaluation of function"
                },
                {
                  "name": "J",
                  "type": null,
                  "default": null,
                  "description": "evaluation of jacobian of function"
                },
                {
                  "name": "dt",
                  "type": null,
                  "default": null,
                  "description": "integration timestep"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "step",
              "description": "Performs the explicit timestep for (t+dt) based",
              "docstring_html": "<p>Performs the explicit timestep for (t+dt) based\non the state and input at (t).</p>\n<div class=\"section\" id=\"note\">\n<h4>Note</h4>\n<p>This is only required for the startup solver.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>f <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">numeric, array[numeric]</span></dt>\n<dd>evaluation of rhs function</dd>\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>integration timestep</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>success <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>True if the timestep was successful</dd>\n<dt>error <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>estimated error of the internal error controller</dd>\n<dt>scale <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>estimated timestep rescale factor for error control</dd>\n</dl>\n</div>\n",
              "source": "def step(self, f, dt):\n    \"\"\"Performs the explicit timestep for (t+dt) based \n    on the state and input at (t).\n\n    Note\n    ----\n    This is only required for the startup solver.\n\n    Parameters\n    ----------\n    f : numeric, array[numeric]\n        evaluation of rhs function\n    dt : float \n        integration timestep\n\n    Returns \n    -------\n    success : bool\n        True if the timestep was successful\n    error : float\n        estimated error of the internal error controller\n    scale : float\n        estimated timestep rescale factor for error control\n    \"\"\"\n\n    #not enough histors -> step the startup solver\n    if self._needs_startup:\n        self.startup.step(f, dt)\n        self.x = self.startup.get()\n\n    return True, 0.0, 1.0",
              "signature": "(f, dt)",
              "parameters": [
                {
                  "name": "f",
                  "type": null,
                  "default": null,
                  "description": "evaluation of rhs function"
                },
                {
                  "name": "dt",
                  "type": null,
                  "default": null,
                  "description": "integration timestep"
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "n",
              "description": "",
              "type": null,
              "value": "None"
            },
            {
              "name": "K",
              "description": "",
              "type": null,
              "value": "{1: [1.0], 2: [4 / 3, -1 / 3], 3: [18 / 11, -9 / 11, 2 / 11], 4: [48 / 25, -36 / 25, 16 / 25, -3 / 25], 5: [300 / 137, -300 / 137, 200 / 137, -75 / 137, 12 / 137], 6: [360 / 147, -450 / 147, 400 / 147, -225 / 147, 72 / 147, -10 / 147]}"
            },
            {
              "name": "F",
              "description": "",
              "type": null,
              "value": "{1: 1.0, 2: 2 / 3, 3: 6 / 11, 4: 12 / 25, 5: 60 / 137, 6: 60 / 147}"
            },
            {
              "name": "_needs_startup",
              "description": "",
              "type": null,
              "value": "True"
            },
            {
              "name": "startup",
              "description": "",
              "type": null,
              "value": "DIRK3.cast(self)"
            }
          ],
          "parameters": [
            {
              "name": "solver_args",
              "type": null,
              "default": "()",
              "description": ""
            },
            {
              "name": "solver_kwargs",
              "type": null,
              "default": "{}",
              "description": ""
            }
          ]
        },
        {
          "name": "BDF2",
          "description": "Fixed-step 2nd order Backward Differentiation Formula (BDF).",
          "docstring_html": "<p>Fixed-step 2nd order Backward Differentiation Formula (BDF).</p>\n<p>Implicit linear multistep method. Uses the previous two solution points.\nA-stable, suitable for stiff problems. Uses BDF1 for the first step.</p>\n<dl class=\"docutils\">\n<dt>Characteristics:</dt>\n<dd><ul class=\"first last simple\">\n<li>Order: 2</li>\n<li>Implicit Multistep</li>\n<li>Fixed timestep only</li>\n<li>A-stable</li>\n</ul>\n</dd>\n</dl>\n",
          "source": "class BDF2(BDF):\n    \"\"\"Fixed-step 2nd order Backward Differentiation Formula (BDF).\n\n    Implicit linear multistep method. Uses the previous two solution points.\n    A-stable, suitable for stiff problems. Uses BDF1 for the first step.\n\n    Characteristics:\n        * Order: 2\n        * Implicit Multistep\n        * Fixed timestep only\n        * A-stable\n    \"\"\"\n\n    def __init__(self, *solver_args, **solver_kwargs):\n        super().__init__(*solver_args, **solver_kwargs)\n\n        #integration order (local)\n        self.n = 2\n\n        #longer history for BDF\n        self.history = deque([], maxlen=2)",
          "bases": [
            "pathsim.solvers.bdf.BDF"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, *solver_args, **solver_kwargs):\n    super().__init__(*solver_args, **solver_kwargs)\n\n    #integration order (local)\n    self.n = 2\n\n    #longer history for BDF\n    self.history = deque([], maxlen=2)",
              "signature": "(solver_args = (), solver_kwargs = {})",
              "parameters": [
                {
                  "name": "solver_args",
                  "type": null,
                  "default": "()",
                  "description": ""
                },
                {
                  "name": "solver_kwargs",
                  "type": null,
                  "default": "{}",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "n",
              "description": "",
              "type": null,
              "value": "2"
            },
            {
              "name": "history",
              "description": "",
              "type": null,
              "value": "deque([], maxlen=2)"
            }
          ],
          "parameters": [
            {
              "name": "solver_args",
              "type": null,
              "default": "()",
              "description": ""
            },
            {
              "name": "solver_kwargs",
              "type": null,
              "default": "{}",
              "description": ""
            }
          ]
        },
        {
          "name": "BDF3",
          "description": "Fixed-step 3rd order Backward Differentiation Formula (BDF).",
          "docstring_html": "<p>Fixed-step 3rd order Backward Differentiation Formula (BDF).</p>\n<p>Implicit linear multistep method. Uses the previous three solution points.\nA(alpha)-stable, suitable for stiff problems. Uses lower orders for startup.</p>\n<dl class=\"docutils\">\n<dt>Characteristics:</dt>\n<dd><ul class=\"first last simple\">\n<li>Order: 3</li>\n<li>Implicit Multistep</li>\n<li>Fixed timestep only</li>\n<li>A(alpha)-stable (<span class=\"math\">\\(\\alpha \\approx 86^\\circ\\)</span>)</li>\n</ul>\n</dd>\n</dl>\n",
          "source": "class BDF3(BDF):\n    \"\"\"Fixed-step 3rd order Backward Differentiation Formula (BDF).\n\n    Implicit linear multistep method. Uses the previous three solution points.\n    A(alpha)-stable, suitable for stiff problems. Uses lower orders for startup.\n\n    Characteristics:\n        * Order: 3\n        * Implicit Multistep\n        * Fixed timestep only\n        * A(alpha)-stable (:math:`\\\\alpha \\\\approx 86^\\\\circ`)\n    \"\"\"\n\n    def __init__(self, *solver_args, **solver_kwargs):\n        super().__init__(*solver_args, **solver_kwargs)\n\n        #integration order (local)\n        self.n = 3\n\n        #longer history for BDF\n        self.history = deque([], maxlen=3)",
          "bases": [
            "pathsim.solvers.bdf.BDF"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, *solver_args, **solver_kwargs):\n    super().__init__(*solver_args, **solver_kwargs)\n\n    #integration order (local)\n    self.n = 3\n\n    #longer history for BDF\n    self.history = deque([], maxlen=3)",
              "signature": "(solver_args = (), solver_kwargs = {})",
              "parameters": [
                {
                  "name": "solver_args",
                  "type": null,
                  "default": "()",
                  "description": ""
                },
                {
                  "name": "solver_kwargs",
                  "type": null,
                  "default": "{}",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "n",
              "description": "",
              "type": null,
              "value": "3"
            },
            {
              "name": "history",
              "description": "",
              "type": null,
              "value": "deque([], maxlen=3)"
            }
          ],
          "parameters": [
            {
              "name": "solver_args",
              "type": null,
              "default": "()",
              "description": ""
            },
            {
              "name": "solver_kwargs",
              "type": null,
              "default": "{}",
              "description": ""
            }
          ]
        },
        {
          "name": "BDF4",
          "description": "Fixed-step 4th order Backward Differentiation Formula (BDF).",
          "docstring_html": "<p>Fixed-step 4th order Backward Differentiation Formula (BDF).</p>\n<p>Implicit linear multistep method. Uses the previous four solution points.\nA(alpha)-stable, suitable for stiff problems. Uses lower orders for startup.</p>\n<dl class=\"docutils\">\n<dt>Characteristics:</dt>\n<dd><ul class=\"first last simple\">\n<li>Order: 4</li>\n<li>Implicit Multistep</li>\n<li>Fixed timestep only</li>\n<li>A(alpha)-stable (<span class=\"math\">\\(\\alpha \\approx 73^\\circ\\)</span>)</li>\n</ul>\n</dd>\n</dl>\n",
          "source": "class BDF4(BDF):\n    \"\"\"Fixed-step 4th order Backward Differentiation Formula (BDF).\n\n    Implicit linear multistep method. Uses the previous four solution points.\n    A(alpha)-stable, suitable for stiff problems. Uses lower orders for startup.\n\n    Characteristics:\n        * Order: 4\n        * Implicit Multistep\n        * Fixed timestep only\n        * A(alpha)-stable (:math:`\\\\alpha \\\\approx 73^\\\\circ`)\n    \"\"\"\n\n    def __init__(self, *solver_args, **solver_kwargs):\n        super().__init__(*solver_args, **solver_kwargs)\n\n        #integration order (local)\n        self.n = 4\n\n        #longer history for BDF\n        self.history = deque([], maxlen=4)",
          "bases": [
            "pathsim.solvers.bdf.BDF"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, *solver_args, **solver_kwargs):\n    super().__init__(*solver_args, **solver_kwargs)\n\n    #integration order (local)\n    self.n = 4\n\n    #longer history for BDF\n    self.history = deque([], maxlen=4)",
              "signature": "(solver_args = (), solver_kwargs = {})",
              "parameters": [
                {
                  "name": "solver_args",
                  "type": null,
                  "default": "()",
                  "description": ""
                },
                {
                  "name": "solver_kwargs",
                  "type": null,
                  "default": "{}",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "n",
              "description": "",
              "type": null,
              "value": "4"
            },
            {
              "name": "history",
              "description": "",
              "type": null,
              "value": "deque([], maxlen=4)"
            }
          ],
          "parameters": [
            {
              "name": "solver_args",
              "type": null,
              "default": "()",
              "description": ""
            },
            {
              "name": "solver_kwargs",
              "type": null,
              "default": "{}",
              "description": ""
            }
          ]
        },
        {
          "name": "BDF5",
          "description": "Fixed-step 5th order Backward Differentiation Formula (BDF).",
          "docstring_html": "<p>Fixed-step 5th order Backward Differentiation Formula (BDF).</p>\n<p>Implicit linear multistep method. Uses the previous five solution points.\nA(alpha)-stable, suitable for stiff problems. Uses lower orders for startup.</p>\n<dl class=\"docutils\">\n<dt>Characteristics:</dt>\n<dd><ul class=\"first last simple\">\n<li>Order: 5</li>\n<li>Implicit Multistep</li>\n<li>Fixed timestep only</li>\n<li>A(alpha)-stable (<span class=\"math\">\\(\\alpha \\approx 51^\\circ\\)</span>)</li>\n</ul>\n</dd>\n</dl>\n",
          "source": "class BDF5(BDF):\n    \"\"\"Fixed-step 5th order Backward Differentiation Formula (BDF).\n\n    Implicit linear multistep method. Uses the previous five solution points.\n    A(alpha)-stable, suitable for stiff problems. Uses lower orders for startup.\n\n    Characteristics:\n        * Order: 5\n        * Implicit Multistep\n        * Fixed timestep only\n        * A(alpha)-stable (:math:`\\\\alpha \\\\approx 51^\\\\circ`)\n    \"\"\"\n\n    def __init__(self, *solver_args, **solver_kwargs):\n        super().__init__(*solver_args, **solver_kwargs)\n\n        #integration order (local)\n        self.n = 5\n\n        #longer history for BDF\n        self.history = deque([], maxlen=5)",
          "bases": [
            "pathsim.solvers.bdf.BDF"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, *solver_args, **solver_kwargs):\n    super().__init__(*solver_args, **solver_kwargs)\n\n    #integration order (local)\n    self.n = 5\n\n    #longer history for BDF\n    self.history = deque([], maxlen=5)",
              "signature": "(solver_args = (), solver_kwargs = {})",
              "parameters": [
                {
                  "name": "solver_args",
                  "type": null,
                  "default": "()",
                  "description": ""
                },
                {
                  "name": "solver_kwargs",
                  "type": null,
                  "default": "{}",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "n",
              "description": "",
              "type": null,
              "value": "5"
            },
            {
              "name": "history",
              "description": "",
              "type": null,
              "value": "deque([], maxlen=5)"
            }
          ],
          "parameters": [
            {
              "name": "solver_args",
              "type": null,
              "default": "()",
              "description": ""
            },
            {
              "name": "solver_kwargs",
              "type": null,
              "default": "{}",
              "description": ""
            }
          ]
        },
        {
          "name": "BDF6",
          "description": "Fixed-step 6th order Backward Differentiation Formula (BDF).",
          "docstring_html": "<p>Fixed-step 6th order Backward Differentiation Formula (BDF).</p>\n<p>Implicit linear multistep method. Uses the previous six solution points.\nNot A-stable, stability region does not contain the entire left half-plane,\nlimiting its use for highly stiff problems compared to lower-order BDFs.\nUses lower orders for startup.</p>\n<dl class=\"docutils\">\n<dt>Characteristics:</dt>\n<dd><ul class=\"first last simple\">\n<li>Order: 6</li>\n<li>Implicit Multistep</li>\n<li>Fixed timestep only</li>\n<li>Not A-stable (stability angle approx <span class=\"math\">\\(18^\\circ\\)</span>)</li>\n</ul>\n</dd>\n</dl>\n",
          "source": "class BDF6(BDF):\n    \"\"\"Fixed-step 6th order Backward Differentiation Formula (BDF).\n\n    Implicit linear multistep method. Uses the previous six solution points.\n    Not A-stable, stability region does not contain the entire left half-plane,\n    limiting its use for highly stiff problems compared to lower-order BDFs.\n    Uses lower orders for startup.\n\n    Characteristics:\n        * Order: 6\n        * Implicit Multistep\n        * Fixed timestep only\n        * Not A-stable (stability angle approx :math:`18^\\\\circ`)\n    \"\"\"\n\n    def __init__(self, *solver_args, **solver_kwargs):\n        super().__init__(*solver_args, **solver_kwargs)\n\n        #integration order (local)\n        self.n = 6\n\n        #longer history for BDF\n        self.history = deque([], maxlen=6)",
          "bases": [
            "pathsim.solvers.bdf.BDF"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, *solver_args, **solver_kwargs):\n    super().__init__(*solver_args, **solver_kwargs)\n\n    #integration order (local)\n    self.n = 6\n\n    #longer history for BDF\n    self.history = deque([], maxlen=6)",
              "signature": "(solver_args = (), solver_kwargs = {})",
              "parameters": [
                {
                  "name": "solver_args",
                  "type": null,
                  "default": "()",
                  "description": ""
                },
                {
                  "name": "solver_kwargs",
                  "type": null,
                  "default": "{}",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "n",
              "description": "",
              "type": null,
              "value": "6"
            },
            {
              "name": "history",
              "description": "",
              "type": null,
              "value": "deque([], maxlen=6)"
            }
          ],
          "parameters": [
            {
              "name": "solver_args",
              "type": null,
              "default": "()",
              "description": ""
            },
            {
              "name": "solver_kwargs",
              "type": null,
              "default": "{}",
              "description": ""
            }
          ]
        }
      ],
      "functions": []
    },
    "pathsim.solvers.dirk2": {
      "name": "pathsim.solvers.dirk2",
      "description": "",
      "docstring_html": "",
      "classes": [
        {
          "name": "DIRK2",
          "description": "Two-stage, 2nd order, Diagonally Implicit Runge-Kutta (DIRK) method.",
          "docstring_html": "<p>Two-stage, 2nd order, Diagonally Implicit Runge-Kutta (DIRK) method.</p>\n<p>This specific method is SSP-optimal (largest radius of absolute monotonicity\nfor a 2-stage, 2nd order DIRK), symplectic, and A-stable. It's a robust choice\nfor moderately stiff problems where second-order accuracy is sufficient.</p>\n<dl class=\"docutils\">\n<dt>FROM:</dt>\n<dd>L. Ferracina and M.N. Spijker.\nStrong stability of singly-diagonally-implicit Runge-Kutta methods.\nApplied Numerical Mathematics, 58:1675–1686, 2008.</dd>\n<dt>Characteristics:</dt>\n<dd><ul class=\"first last simple\">\n<li>Order: 2</li>\n<li>Stages: 2 (Implicit)</li>\n<li>Implicit (DIRK)</li>\n<li>Fixed timestep only</li>\n<li>A-stable, SSP-optimal, Symplectic</li>\n</ul>\n</dd>\n</dl>\n",
          "source": "class DIRK2(DiagonallyImplicitRungeKutta):\n    \"\"\"Two-stage, 2nd order, Diagonally Implicit Runge-Kutta (DIRK) method.\n\n    This specific method is SSP-optimal (largest radius of absolute monotonicity\n    for a 2-stage, 2nd order DIRK), symplectic, and A-stable. It's a robust choice\n    for moderately stiff problems where second-order accuracy is sufficient.\n\n    FROM:\n        L. Ferracina and M.N. Spijker.\n        Strong stability of singly-diagonally-implicit Runge-Kutta methods.\n        Applied Numerical Mathematics, 58:1675–1686, 2008.\n\n    Characteristics:\n        * Order: 2\n        * Stages: 2 (Implicit)\n        * Implicit (DIRK)\n        * Fixed timestep only\n        * A-stable, SSP-optimal, Symplectic\n    \"\"\"\n\n    def __init__(self, *solver_args, **solver_kwargs):\n        super().__init__(*solver_args, **solver_kwargs)\n\n        #number of stages in RK scheme\n        self.s = 2\n\n        #order of scheme\n        self.n = 2\n\n        #intermediate evaluation times\n        self.eval_stages = [1/4, 3/4]\n\n        #butcher table\n        self.BT = {0:[1/4],\n                   1:[1/2, 1/4]}\n\n        #final evaluation\n        self.A = [1/2, 1/2]",
          "bases": [
            "pathsim.solvers._rungekutta.DiagonallyImplicitRungeKutta"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, *solver_args, **solver_kwargs):\n    super().__init__(*solver_args, **solver_kwargs)\n\n    #number of stages in RK scheme\n    self.s = 2\n\n    #order of scheme\n    self.n = 2\n\n    #intermediate evaluation times\n    self.eval_stages = [1/4, 3/4]\n\n    #butcher table\n    self.BT = {0:[1/4],\n               1:[1/2, 1/4]}\n\n    #final evaluation\n    self.A = [1/2, 1/2]",
              "signature": "(solver_args = (), solver_kwargs = {})",
              "parameters": [
                {
                  "name": "solver_args",
                  "type": null,
                  "default": "()",
                  "description": ""
                },
                {
                  "name": "solver_kwargs",
                  "type": null,
                  "default": "{}",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "s",
              "description": "",
              "type": null,
              "value": "2"
            },
            {
              "name": "n",
              "description": "",
              "type": null,
              "value": "2"
            },
            {
              "name": "eval_stages",
              "description": "",
              "type": null,
              "value": "[1 / 4, 3 / 4]"
            },
            {
              "name": "BT",
              "description": "",
              "type": null,
              "value": "{0: [1 / 4], 1: [1 / 2, 1 / 4]}"
            },
            {
              "name": "A",
              "description": "",
              "type": null,
              "value": "[1 / 2, 1 / 2]"
            }
          ],
          "parameters": [
            {
              "name": "solver_args",
              "type": null,
              "default": "()",
              "description": ""
            },
            {
              "name": "solver_kwargs",
              "type": null,
              "default": "{}",
              "description": ""
            }
          ]
        }
      ],
      "functions": []
    },
    "pathsim.solvers.dirk3": {
      "name": "pathsim.solvers.dirk3",
      "description": "",
      "docstring_html": "",
      "classes": [
        {
          "name": "DIRK3",
          "description": "Four-stage, 3rd order, L-stable Diagonally Implicit Runge-Kutta (DIRK) method.",
          "docstring_html": "<p>Four-stage, 3rd order, L-stable Diagonally Implicit Runge-Kutta (DIRK) method.</p>\n<p>L-stability (A-stability and stiffly accurate, i.e., <span class=\"math\">\\(|R(\\infty)| = 0\\)</span>) makes\nthis method suitable for stiff problems where damping of high-frequency components\nis desired.</p>\n<p>(Butcher tableau often attributed to Crouzeix, or Nørsett-Thomsen based on Wikipedia/Hairer).</p>\n<dl class=\"docutils\">\n<dt>Characteristics:</dt>\n<dd><ul class=\"first last simple\">\n<li>Order: 3</li>\n<li>Stages: 4 (Implicit)</li>\n<li>Implicit (DIRK)</li>\n<li>Fixed timestep only</li>\n<li>L-stable (and thus A-stable)</li>\n</ul>\n</dd>\n</dl>\n",
          "source": "class DIRK3(DiagonallyImplicitRungeKutta):\n    \"\"\"Four-stage, 3rd order, L-stable Diagonally Implicit Runge-Kutta (DIRK) method.\n\n    L-stability (A-stability and stiffly accurate, i.e., :math:`|R(\\\\infty)| = 0`) makes\n    this method suitable for stiff problems where damping of high-frequency components\n    is desired.\n\n    (Butcher tableau often attributed to Crouzeix, or Nørsett-Thomsen based on Wikipedia/Hairer).\n\n    Characteristics:\n        * Order: 3\n        * Stages: 4 (Implicit)\n        * Implicit (DIRK)\n        * Fixed timestep only\n        * L-stable (and thus A-stable)\n    \"\"\"\n\n    def __init__(self, *solver_args, **solver_kwargs):\n        super().__init__(*solver_args, **solver_kwargs)\n\n        #number of stages in RK scheme\n        self.s = 4\n\n        #order of scheme\n        self.n = 3\n\n        #intermediate evaluation times\n        self.eval_stages = [1/2, 2/3, 1/2, 1.0]\n\n        #butcher table\n        self.BT = {0:[1/2],\n                   1:[1/6, 1/2], \n                   2:[-1/2, 1/2, 1/2], \n                   3:[3/2, -3/2, 1/2, 1/2]}",
          "bases": [
            "pathsim.solvers._rungekutta.DiagonallyImplicitRungeKutta"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, *solver_args, **solver_kwargs):\n    super().__init__(*solver_args, **solver_kwargs)\n\n    #number of stages in RK scheme\n    self.s = 4\n\n    #order of scheme\n    self.n = 3\n\n    #intermediate evaluation times\n    self.eval_stages = [1/2, 2/3, 1/2, 1.0]\n\n    #butcher table\n    self.BT = {0:[1/2],\n               1:[1/6, 1/2], \n               2:[-1/2, 1/2, 1/2], \n               3:[3/2, -3/2, 1/2, 1/2]}",
              "signature": "(solver_args = (), solver_kwargs = {})",
              "parameters": [
                {
                  "name": "solver_args",
                  "type": null,
                  "default": "()",
                  "description": ""
                },
                {
                  "name": "solver_kwargs",
                  "type": null,
                  "default": "{}",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "s",
              "description": "",
              "type": null,
              "value": "4"
            },
            {
              "name": "n",
              "description": "",
              "type": null,
              "value": "3"
            },
            {
              "name": "eval_stages",
              "description": "",
              "type": null,
              "value": "[1 / 2, 2 / 3, 1 / 2, 1.0]"
            },
            {
              "name": "BT",
              "description": "",
              "type": null,
              "value": "{0: [1 / 2], 1: [1 / 6, 1 / 2], 2: [-1 / 2, 1 / 2, 1 / 2], 3: [3 / 2, -3 / 2, 1 / 2, 1 / 2]}"
            }
          ],
          "parameters": [
            {
              "name": "solver_args",
              "type": null,
              "default": "()",
              "description": ""
            },
            {
              "name": "solver_kwargs",
              "type": null,
              "default": "{}",
              "description": ""
            }
          ]
        }
      ],
      "functions": []
    },
    "pathsim.solvers.esdirk32": {
      "name": "pathsim.solvers.esdirk32",
      "description": "",
      "docstring_html": "",
      "classes": [
        {
          "name": "ESDIRK32",
          "description": "Four-stage, 3rd order Embedded Singly Diagonally Implicit Runge-Kutta (ESDIRK) method.",
          "docstring_html": "<p>Four-stage, 3rd order Embedded Singly Diagonally Implicit Runge-Kutta (ESDIRK) method.</p>\n<p>Features an embedded 2nd order method for adaptive step size control. The first stage\nis explicit (FSAL property not present in this specific implementation structure).\nDesigned to be applicable to index-2 Differential Algebraic Equations (DAEs).</p>\n<dl class=\"docutils\">\n<dt>FROM:</dt>\n<dd>Williams et al.</dd>\n<dt>Characteristics:</dt>\n<dd><ul class=\"first last simple\">\n<li>Order: 3</li>\n<li>Embedded Order: 2</li>\n<li>Stages: 4 (1 Explicit, 3 Implicit)</li>\n<li>Implicit (ESDIRK)</li>\n<li>Adaptive timestep</li>\n<li>A-stable</li>\n</ul>\n</dd>\n</dl>\n",
          "source": "class ESDIRK32(DiagonallyImplicitRungeKutta):\n    \"\"\"Four-stage, 3rd order Embedded Singly Diagonally Implicit Runge-Kutta (ESDIRK) method.\n\n    Features an embedded 2nd order method for adaptive step size control. The first stage\n    is explicit (FSAL property not present in this specific implementation structure).\n    Designed to be applicable to index-2 Differential Algebraic Equations (DAEs).\n\n    FROM: \n        Williams et al.\n\n    Characteristics:\n        * Order: 3\n        * Embedded Order: 2\n        * Stages: 4 (1 Explicit, 3 Implicit)\n        * Implicit (ESDIRK)\n        * Adaptive timestep\n        * A-stable \n    \"\"\"\n\n    def __init__(self, *solver_args, **solver_kwargs):\n        super().__init__(*solver_args, **solver_kwargs)\n\n        #number of stages in RK scheme\n        self.s = 4\n\n        #order of scheme and embedded method\n        self.n = 3\n        self.m = 2\n\n        #flag adaptive timestep solver\n        self.is_adaptive = True\n\n        #intermediate evaluation times\n        self.eval_stages = [0.0, 1.0, 3/2, 1.0]\n\n        #butcher table\n        self.BT = {0:None, #explicit first stage\n                   1:[1/2, 1/2],\n                   2:[5/8, 3/8, 1/2],\n                   3:[7/18, 1/3, -2/9, 1/2]}\n\n        #coefficients for truncation error estimate\n        self.TR = [-1/9, -1/6, -2/9, 1/2]",
          "bases": [
            "pathsim.solvers._rungekutta.DiagonallyImplicitRungeKutta"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, *solver_args, **solver_kwargs):\n    super().__init__(*solver_args, **solver_kwargs)\n\n    #number of stages in RK scheme\n    self.s = 4\n\n    #order of scheme and embedded method\n    self.n = 3\n    self.m = 2\n\n    #flag adaptive timestep solver\n    self.is_adaptive = True\n\n    #intermediate evaluation times\n    self.eval_stages = [0.0, 1.0, 3/2, 1.0]\n\n    #butcher table\n    self.BT = {0:None, #explicit first stage\n               1:[1/2, 1/2],\n               2:[5/8, 3/8, 1/2],\n               3:[7/18, 1/3, -2/9, 1/2]}\n\n    #coefficients for truncation error estimate\n    self.TR = [-1/9, -1/6, -2/9, 1/2]",
              "signature": "(solver_args = (), solver_kwargs = {})",
              "parameters": [
                {
                  "name": "solver_args",
                  "type": null,
                  "default": "()",
                  "description": ""
                },
                {
                  "name": "solver_kwargs",
                  "type": null,
                  "default": "{}",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "s",
              "description": "",
              "type": null,
              "value": "4"
            },
            {
              "name": "n",
              "description": "",
              "type": null,
              "value": "3"
            },
            {
              "name": "m",
              "description": "",
              "type": null,
              "value": "2"
            },
            {
              "name": "is_adaptive",
              "description": "",
              "type": null,
              "value": "True"
            },
            {
              "name": "eval_stages",
              "description": "",
              "type": null,
              "value": "[0.0, 1.0, 3 / 2, 1.0]"
            },
            {
              "name": "BT",
              "description": "",
              "type": null,
              "value": "{0: None, 1: [1 / 2, 1 / 2], 2: [5 / 8, 3 / 8, 1 / 2], 3: [7 / 18, 1 / 3, -2 / 9, 1 / 2]}"
            },
            {
              "name": "TR",
              "description": "",
              "type": null,
              "value": "[-1 / 9, -1 / 6, -2 / 9, 1 / 2]"
            }
          ],
          "parameters": [
            {
              "name": "solver_args",
              "type": null,
              "default": "()",
              "description": ""
            },
            {
              "name": "solver_kwargs",
              "type": null,
              "default": "{}",
              "description": ""
            }
          ]
        }
      ],
      "functions": []
    },
    "pathsim.solvers.esdirk4": {
      "name": "pathsim.solvers.esdirk4",
      "description": "",
      "docstring_html": "",
      "classes": [
        {
          "name": "ESDIRK4",
          "description": "Six-stage, 4th order Singly Diagonally Implicit Runge-Kutta (ESDIRK) method.",
          "docstring_html": "<p>Six-stage, 4th order Singly Diagonally Implicit Runge-Kutta (ESDIRK) method.</p>\n<p>Features an explicit first stage (making it ESDIRK). This specific tableau is often\ndesigned for handling stiff problems and potentially Differential Algebraic Equations (DAEs)\nof index up to two or three. Does not have an embedded method for error estimation in this\nimplementation (fixed step only).</p>\n<dl class=\"docutils\">\n<dt>Characteristics:</dt>\n<dd><ul class=\"first last simple\">\n<li>Order: 4</li>\n<li>Stages: 6 (1 Explicit, 5 Implicit)</li>\n<li>Implicit (ESDIRK)</li>\n<li>Fixed timestep only</li>\n<li>A-stable</li>\n</ul>\n</dd>\n</dl>\n",
          "source": "class ESDIRK4(DiagonallyImplicitRungeKutta):\n    \"\"\"Six-stage, 4th order Singly Diagonally Implicit Runge-Kutta (ESDIRK) method.\n\n    Features an explicit first stage (making it ESDIRK). This specific tableau is often\n    designed for handling stiff problems and potentially Differential Algebraic Equations (DAEs)\n    of index up to two or three. Does not have an embedded method for error estimation in this\n    implementation (fixed step only).\n\n    Characteristics:\n       * Order: 4\n       * Stages: 6 (1 Explicit, 5 Implicit)\n       * Implicit (ESDIRK)\n       * Fixed timestep only\n       * A-stable\n    \"\"\"\n\n    def __init__(self, *solver_args, **solver_kwargs):\n        super().__init__(*solver_args, **solver_kwargs)\n\n        #number of stages in RK scheme\n        self.s = 6\n\n        #order of scheme\n        self.n = 4\n\n        #intermediate evaluation times\n        self.eval_stages = [0.0, 1/2, 1/6, \n                            37/40, 1/2, 1.0]\n\n        #butcher table\n        self.BT = {0:None, #explicit first stage\n                   1:[1/4, 1/4],\n                   2:[-1/36, -1/18, 1/4],\n                   3:[-21283/32000, -5143/64000, \n                      90909/64000, 1/4],\n                   4:[46010759/749250000, -737693/40500000, \n                      10931269/45500000, -1140071/34090875, 1/4],\n                   5:[89/444, 89/804756, -27/364, -20000/171717, \n                      843750/1140071, 1/4]}",
          "bases": [
            "pathsim.solvers._rungekutta.DiagonallyImplicitRungeKutta"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, *solver_args, **solver_kwargs):\n    super().__init__(*solver_args, **solver_kwargs)\n\n    #number of stages in RK scheme\n    self.s = 6\n\n    #order of scheme\n    self.n = 4\n\n    #intermediate evaluation times\n    self.eval_stages = [0.0, 1/2, 1/6, \n                        37/40, 1/2, 1.0]\n\n    #butcher table\n    self.BT = {0:None, #explicit first stage\n               1:[1/4, 1/4],\n               2:[-1/36, -1/18, 1/4],\n               3:[-21283/32000, -5143/64000, \n                  90909/64000, 1/4],\n               4:[46010759/749250000, -737693/40500000, \n                  10931269/45500000, -1140071/34090875, 1/4],\n               5:[89/444, 89/804756, -27/364, -20000/171717, \n                  843750/1140071, 1/4]}",
              "signature": "(solver_args = (), solver_kwargs = {})",
              "parameters": [
                {
                  "name": "solver_args",
                  "type": null,
                  "default": "()",
                  "description": ""
                },
                {
                  "name": "solver_kwargs",
                  "type": null,
                  "default": "{}",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "s",
              "description": "",
              "type": null,
              "value": "6"
            },
            {
              "name": "n",
              "description": "",
              "type": null,
              "value": "4"
            },
            {
              "name": "eval_stages",
              "description": "",
              "type": null,
              "value": "[0.0, 1 / 2, 1 / 6, 37 / 40, 1 / 2, 1.0]"
            },
            {
              "name": "BT",
              "description": "",
              "type": null,
              "value": "{0: None, 1: [1 / 4, 1 / 4], 2: [-1 / 36, -1 / 18, 1 / 4], 3: [-21283 / 32000, -5143 / 64000, 90909 / 64000, 1 / 4], 4: [46010759 / 749250000, -737693 / 40500000, 10931269 / 45500000, -1140071 / 34090875, 1 / 4], 5: [89 / 444, 89 / 804756, -27 / 364, -20000 / 171717, 843750 / 1140071, 1 / 4]}"
            }
          ],
          "parameters": [
            {
              "name": "solver_args",
              "type": null,
              "default": "()",
              "description": ""
            },
            {
              "name": "solver_kwargs",
              "type": null,
              "default": "{}",
              "description": ""
            }
          ]
        }
      ],
      "functions": []
    },
    "pathsim.solvers.esdirk43": {
      "name": "pathsim.solvers.esdirk43",
      "description": "",
      "docstring_html": "",
      "classes": [
        {
          "name": "ESDIRK43",
          "description": "Six-stage, 4th order Embedded Singly Diagonally Implicit Runge-Kutta (ESDIRK) method.",
          "docstring_html": "<p>Six-stage, 4th order Embedded Singly Diagonally Implicit Runge-Kutta (ESDIRK) method.</p>\n<p>Features an embedded 3rd order method for adaptive step size control. The first stage is\nexplicit. Suitable for stiff problems requiring moderate accuracy.</p>\n<dl class=\"docutils\">\n<dt>Characteristics:</dt>\n<dd><ul class=\"first last simple\">\n<li>Order: 4</li>\n<li>Embedded Order: 3</li>\n<li>Stages: 6 (1 Explicit, 5 Implicit)</li>\n<li>Implicit (ESDIRK)</li>\n<li>Adaptive timestep</li>\n<li>L-stable</li>\n<li>Stiffy Accurate</li>\n</ul>\n</dd>\n</dl>\n",
          "source": "class ESDIRK43(DiagonallyImplicitRungeKutta):\n    \"\"\"Six-stage, 4th order Embedded Singly Diagonally Implicit Runge-Kutta (ESDIRK) method.\n\n    Features an embedded 3rd order method for adaptive step size control. The first stage is\n    explicit. Suitable for stiff problems requiring moderate accuracy.\n\n    Characteristics:\n        * Order: 4\n        * Embedded Order: 3\n        * Stages: 6 (1 Explicit, 5 Implicit)\n        * Implicit (ESDIRK)\n        * Adaptive timestep\n        * L-stable\n        * Stiffy Accurate\n    \"\"\"\n\n    def __init__(self, *solver_args, **solver_kwargs):\n        super().__init__(*solver_args, **solver_kwargs)\n\n        #number of stages in RK scheme\n        self.s = 6\n\n        #order of scheme and embedded method\n        self.n = 4\n        self.m = 3\n\n        #flag adaptive timestep solver\n        self.is_adaptive = True\n\n        #intermediate evaluation times\n        self.eval_stages = [0.0, 1/2, (2-np.sqrt(2))/4, 2012122486997/3467029789466, 1.0, 1.0]\n\n        #butcher table\n        self.BT = {0:None, # explicit first stage\n                   1:[1/4, 1/4],\n                   2:[-1356991263433/26208533697614, -1356991263433/26208533697614, 1/4],\n                   3:[-1778551891173/14697912885533, -1778551891173/14697912885533, \n                      7325038566068/12797657924939, 1/4],\n                   4:[-24076725932807/39344244018142, -24076725932807/39344244018142, \n                      9344023789330/6876721947151, 11302510524611/18374767399840, 1/4],\n                   5:[657241292721/9909463049845, 657241292721/9909463049845, \n                      1290772910128/5804808736437, 1103522341516/2197678446715, -3/28, 1/4]}\n\n        #coefficients for truncation error estimate\n        _A1 = [657241292721/9909463049845, 657241292721/9909463049845, \n               1290772910128/5804808736437, 1103522341516/2197678446715, -3/28, 1/4]\n        _A2 = [-71925161075/3900939759889, -71925161075/3900939759889, \n               2973346383745/8160025745289, 3972464885073/7694851252693, \n               -263368882881/4213126269514, 3295468053953/15064441987965]\n        self.TR = [a1 - a2 for a1, a2 in zip(_A1, _A2)]",
          "bases": [
            "pathsim.solvers._rungekutta.DiagonallyImplicitRungeKutta"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, *solver_args, **solver_kwargs):\n    super().__init__(*solver_args, **solver_kwargs)\n\n    #number of stages in RK scheme\n    self.s = 6\n\n    #order of scheme and embedded method\n    self.n = 4\n    self.m = 3\n\n    #flag adaptive timestep solver\n    self.is_adaptive = True\n\n    #intermediate evaluation times\n    self.eval_stages = [0.0, 1/2, (2-np.sqrt(2))/4, 2012122486997/3467029789466, 1.0, 1.0]\n\n    #butcher table\n    self.BT = {0:None, # explicit first stage\n               1:[1/4, 1/4],\n               2:[-1356991263433/26208533697614, -1356991263433/26208533697614, 1/4],\n               3:[-1778551891173/14697912885533, -1778551891173/14697912885533, \n                  7325038566068/12797657924939, 1/4],\n               4:[-24076725932807/39344244018142, -24076725932807/39344244018142, \n                  9344023789330/6876721947151, 11302510524611/18374767399840, 1/4],\n               5:[657241292721/9909463049845, 657241292721/9909463049845, \n                  1290772910128/5804808736437, 1103522341516/2197678446715, -3/28, 1/4]}\n\n    #coefficients for truncation error estimate\n    _A1 = [657241292721/9909463049845, 657241292721/9909463049845, \n           1290772910128/5804808736437, 1103522341516/2197678446715, -3/28, 1/4]\n    _A2 = [-71925161075/3900939759889, -71925161075/3900939759889, \n           2973346383745/8160025745289, 3972464885073/7694851252693, \n           -263368882881/4213126269514, 3295468053953/15064441987965]\n    self.TR = [a1 - a2 for a1, a2 in zip(_A1, _A2)]",
              "signature": "(solver_args = (), solver_kwargs = {})",
              "parameters": [
                {
                  "name": "solver_args",
                  "type": null,
                  "default": "()",
                  "description": ""
                },
                {
                  "name": "solver_kwargs",
                  "type": null,
                  "default": "{}",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "s",
              "description": "",
              "type": null,
              "value": "6"
            },
            {
              "name": "n",
              "description": "",
              "type": null,
              "value": "4"
            },
            {
              "name": "m",
              "description": "",
              "type": null,
              "value": "3"
            },
            {
              "name": "is_adaptive",
              "description": "",
              "type": null,
              "value": "True"
            },
            {
              "name": "eval_stages",
              "description": "",
              "type": null,
              "value": "[0.0, 1 / 2, (2 - np.sqrt(2)) / 4, 2012122486997 / 3467029789466, 1.0, 1.0]"
            },
            {
              "name": "BT",
              "description": "",
              "type": null,
              "value": "{0: None, 1: [1 / 4, 1 / 4], 2: [-1356991263433 / 26208533697614, -1356991263433 / 26208533697614, 1 / 4], 3: [-1778551891173 / 14697912885533, -1778551891173 / 14697912885533, 7325038566068 / 12797657924939, 1 / 4], 4: [-24076725932807 / 39344244018142, -24076725932807 / 39344244018142, 9344023789330 / 6876721947151, 11302510524611 / 18374767399840, 1 / 4], 5: [657241292721 / 9909463049845, 657241292721 / 9909463049845, 1290772910128 / 5804808736437, 1103522341516 / 2197678446715, -3 / 28, 1 / 4]}"
            },
            {
              "name": "TR",
              "description": "",
              "type": null,
              "value": "[(a1 - a2) for a1, a2 in (zip(_A1, _A2))]"
            }
          ],
          "parameters": [
            {
              "name": "solver_args",
              "type": null,
              "default": "()",
              "description": ""
            },
            {
              "name": "solver_kwargs",
              "type": null,
              "default": "{}",
              "description": ""
            }
          ]
        }
      ],
      "functions": []
    },
    "pathsim.solvers.esdirk54": {
      "name": "pathsim.solvers.esdirk54",
      "description": "",
      "docstring_html": "",
      "classes": [
        {
          "name": "ESDIRK54",
          "description": "Seven-stage, 5th order, L-stable, stiffly accurate Embedded Singly Diagonally",
          "docstring_html": "<p>Seven-stage, 5th order, L-stable, stiffly accurate Embedded Singly Diagonally\nImplicit Runge-Kutta (ESDIRK) method.</p>\n<p>Features an embedded 4th order method for adaptive step size control. The first stage is\nexplicit. Well-suited for moderately stiff problems requiring high accuracy.</p>\n<dl class=\"docutils\">\n<dt>FROM:</dt>\n<dd>Diagonally implicit Runge–Kutta methods for stiff ODEs\nChristopher A.Kennedy, Mark H.Carpenter\nApplied Numerical Mathematics, 2019\nMethod: ESDIRK5(4)7L[2]SA2</dd>\n<dt>Characteristics:</dt>\n<dd><ul class=\"first last simple\">\n<li>Order: 5</li>\n<li>Embedded Order: 4</li>\n<li>Stages: 7 (1 Explicit, 6 Implicit)</li>\n<li>Implicit (ESDIRK)</li>\n<li>Adaptive timestep</li>\n<li>L-stable, Stiffly Accurate</li>\n</ul>\n</dd>\n</dl>\n",
          "source": "class ESDIRK54(DiagonallyImplicitRungeKutta):\n    \"\"\"Seven-stage, 5th order, L-stable, stiffly accurate Embedded Singly Diagonally\n    Implicit Runge-Kutta (ESDIRK) method.\n\n    Features an embedded 4th order method for adaptive step size control. The first stage is\n    explicit. Well-suited for moderately stiff problems requiring high accuracy.\n\n    FROM:\n        Diagonally implicit Runge–Kutta methods for stiff ODEs\n        Christopher A.Kennedy, Mark H.Carpenter\n        Applied Numerical Mathematics, 2019\n        Method: ESDIRK5(4)7L[2]SA2\n\n    Characteristics:\n        * Order: 5\n        * Embedded Order: 4\n        * Stages: 7 (1 Explicit, 6 Implicit)\n        * Implicit (ESDIRK)\n        * Adaptive timestep\n        * L-stable, Stiffly Accurate\n    \"\"\"\n\n    def __init__(self, *solver_args, **solver_kwargs):\n        super().__init__(*solver_args, **solver_kwargs)\n\n        #number of stages in RK scheme\n        self.s = 7\n\n        #order of scheme and embedded method\n        self.n = 5\n        self.m = 4\n\n        #flag adaptive timestep solver\n        self.is_adaptive = True\n\n        #intermediate evaluation times\n        self.eval_stages = [0.0, 46/125, 7121331996143/11335814405378, 49/353, \n                            3706679970760/5295570149437, 347/382, 1.0]\n\n        #butcher table\n        self.BT = {0:None, #explicit first stage\n                   1:[23/125, 23/125], \n                   2:[791020047304/3561426431547, 791020047304/3561426431547, 23/125], \n                   3:[-158159076358/11257294102345, -158159076358/11257294102345, \n                      -85517644447/5003708988389, 23/125], \n                   4:[-1653327111580/4048416487981, -1653327111580/4048416487981, \n                      1514767744496/9099671765375, 14283835447591/12247432691556, 23/125],\n                   5:[-4540011970825/8418487046959, -4540011970825/8418487046959, \n                      -1790937573418/7393406387169, 10819093665085/7266595846747, \n                      4109463131231/7386972500302, 23/125],\n                   6:[-188593204321/4778616380481, -188593204321/4778616380481, \n                      2809310203510/10304234040467, 1021729336898/2364210264653, \n                      870612361811/2470410392208, -1307970675534/8059683598661, 23/125]}\n\n        #coefficients for truncation error estimate\n        _A1 = [-188593204321/4778616380481, -188593204321/4778616380481, \n               2809310203510/10304234040467, 1021729336898/2364210264653, \n               870612361811/2470410392208, -1307970675534/8059683598661, 23/125]\n        _A2 = [-582099335757/7214068459310, -582099335757/7214068459310, \n               615023338567/3362626566945, 3192122436311/6174152374399, \n               6156034052041/14430468657929, -1011318518279/9693750372484, \n               1914490192573/13754262428401]\n        self.TR = [_a1 - _a2 for _a1, _a2 in zip(_A1, _A2)]",
          "bases": [
            "pathsim.solvers._rungekutta.DiagonallyImplicitRungeKutta"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, *solver_args, **solver_kwargs):\n    super().__init__(*solver_args, **solver_kwargs)\n\n    #number of stages in RK scheme\n    self.s = 7\n\n    #order of scheme and embedded method\n    self.n = 5\n    self.m = 4\n\n    #flag adaptive timestep solver\n    self.is_adaptive = True\n\n    #intermediate evaluation times\n    self.eval_stages = [0.0, 46/125, 7121331996143/11335814405378, 49/353, \n                        3706679970760/5295570149437, 347/382, 1.0]\n\n    #butcher table\n    self.BT = {0:None, #explicit first stage\n               1:[23/125, 23/125], \n               2:[791020047304/3561426431547, 791020047304/3561426431547, 23/125], \n               3:[-158159076358/11257294102345, -158159076358/11257294102345, \n                  -85517644447/5003708988389, 23/125], \n               4:[-1653327111580/4048416487981, -1653327111580/4048416487981, \n                  1514767744496/9099671765375, 14283835447591/12247432691556, 23/125],\n               5:[-4540011970825/8418487046959, -4540011970825/8418487046959, \n                  -1790937573418/7393406387169, 10819093665085/7266595846747, \n                  4109463131231/7386972500302, 23/125],\n               6:[-188593204321/4778616380481, -188593204321/4778616380481, \n                  2809310203510/10304234040467, 1021729336898/2364210264653, \n                  870612361811/2470410392208, -1307970675534/8059683598661, 23/125]}\n\n    #coefficients for truncation error estimate\n    _A1 = [-188593204321/4778616380481, -188593204321/4778616380481, \n           2809310203510/10304234040467, 1021729336898/2364210264653, \n           870612361811/2470410392208, -1307970675534/8059683598661, 23/125]\n    _A2 = [-582099335757/7214068459310, -582099335757/7214068459310, \n           615023338567/3362626566945, 3192122436311/6174152374399, \n           6156034052041/14430468657929, -1011318518279/9693750372484, \n           1914490192573/13754262428401]\n    self.TR = [_a1 - _a2 for _a1, _a2 in zip(_A1, _A2)]",
              "signature": "(solver_args = (), solver_kwargs = {})",
              "parameters": [
                {
                  "name": "solver_args",
                  "type": null,
                  "default": "()",
                  "description": ""
                },
                {
                  "name": "solver_kwargs",
                  "type": null,
                  "default": "{}",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "s",
              "description": "",
              "type": null,
              "value": "7"
            },
            {
              "name": "n",
              "description": "",
              "type": null,
              "value": "5"
            },
            {
              "name": "m",
              "description": "",
              "type": null,
              "value": "4"
            },
            {
              "name": "is_adaptive",
              "description": "",
              "type": null,
              "value": "True"
            },
            {
              "name": "eval_stages",
              "description": "",
              "type": null,
              "value": "[0.0, 46 / 125, 7121331996143 / 11335814405378, 49 / 353, 3706679970760 / 5295570149437, 347 / 382, 1.0]"
            },
            {
              "name": "BT",
              "description": "",
              "type": null,
              "value": "{0: None, 1: [23 / 125, 23 / 125], 2: [791020047304 / 3561426431547, 791020047304 / 3561426431547, 23 / 125], 3: [-158159076358 / 11257294102345, -158159076358 / 11257294102345, -85517644447 / 5003708988389, 23 / 125], 4: [-1653327111580 / 4048416487981, -1653327111580 / 4048416487981, 1514767744496 / 9099671765375, 14283835447591 / 12247432691556, 23 / 125], 5: [-4540011970825 / 8418487046959, -4540011970825 / 8418487046959, -1790937573418 / 7393406387169, 10819093665085 / 7266595846747, 4109463131231 / 7386972500302, 23 / 125], 6: [-188593204321 / 4778616380481, -188593204321 / 4778616380481, 2809310203510 / 10304234040467, 1021729336898 / 2364210264653, 870612361811 / 2470410392208, -1307970675534 / 8059683598661, 23 / 125]}"
            },
            {
              "name": "TR",
              "description": "",
              "type": null,
              "value": "[(_a1 - _a2) for _a1, _a2 in (zip(_A1, _A2))]"
            }
          ],
          "parameters": [
            {
              "name": "solver_args",
              "type": null,
              "default": "()",
              "description": ""
            },
            {
              "name": "solver_kwargs",
              "type": null,
              "default": "{}",
              "description": ""
            }
          ]
        }
      ],
      "functions": []
    },
    "pathsim.solvers.esdirk85": {
      "name": "pathsim.solvers.esdirk85",
      "description": "",
      "docstring_html": "",
      "classes": [
        {
          "name": "ESDIRK85",
          "description": "Sixteen-stage, 8th order, L-stable, stiffly accurate Embedded Singly Diagonally",
          "docstring_html": "<p>Sixteen-stage, 8th order, L-stable, stiffly accurate Embedded Singly Diagonally\nImplicit Runge-Kutta (ESDIRK) method.</p>\n<p>Features an embedded 5th order method for adaptive step size control. The first stage is\nexplicit. Designed for very stiff problems requiring very high accuracy, but computationally\nexpensive due to the large number of stages.</p>\n<dl class=\"docutils\">\n<dt>FROM:</dt>\n<dd>VERY HIGH-ORDER A-STABLE STIFFLY ACCURATE DIAGONALLY\nIMPLICIT RUNGE-KUTTA METHODS WITH ERROR ESTIMATORS\nYOUSEF ALAMRI AND DAVID I. KETCHESON\nMethod: ESDIRK(16,8)[2]SAL-[(16,5)]</dd>\n<dt>Characteristics:</dt>\n<dd><ul class=\"first last simple\">\n<li>Order: 8</li>\n<li>Embedded Order: 5</li>\n<li>Stages: 16 (1 Explicit, 15 Implicit)</li>\n<li>Implicit (ESDIRK)</li>\n<li>Adaptive timestep</li>\n<li>L-stable, Stiffly Accurate</li>\n</ul>\n</dd>\n</dl>\n",
          "source": "class ESDIRK85(DiagonallyImplicitRungeKutta):\n    \"\"\"Sixteen-stage, 8th order, L-stable, stiffly accurate Embedded Singly Diagonally\n    Implicit Runge-Kutta (ESDIRK) method.\n\n    Features an embedded 5th order method for adaptive step size control. The first stage is\n    explicit. Designed for very stiff problems requiring very high accuracy, but computationally\n    expensive due to the large number of stages.\n\n    FROM:\n        VERY HIGH-ORDER A-STABLE STIFFLY ACCURATE DIAGONALLY\n        IMPLICIT RUNGE-KUTTA METHODS WITH ERROR ESTIMATORS\n        YOUSEF ALAMRI AND DAVID I. KETCHESON\n        Method: ESDIRK(16,8)[2]SAL-[(16,5)]\n\n    Characteristics:\n        * Order: 8\n        * Embedded Order: 5\n        * Stages: 16 (1 Explicit, 15 Implicit)\n        * Implicit (ESDIRK)\n        * Adaptive timestep\n        * L-stable, Stiffly Accurate\n    \"\"\"\n\n    def __init__(self, *solver_args, **solver_kwargs):\n        super().__init__(*solver_args, **solver_kwargs)\n\n        #number of stages in RK scheme\n        self.s = 16\n\n        #order of scheme and embedded method\n        self.n = 8\n        self.m = 5\n\n        #flag adaptive timestep solver\n        self.is_adaptive = True\n\n        #intermediate evaluation times as ratios\n        self.eval_stages = [0.0              , 0.234637638717043, 0.558545926594724,\n                            0.562667638694992, 0.697898381329126, 0.956146958839776,\n                            0.812903043340468, 0.148256733818785, 0.944650387704291,\n                            0.428471803715736, 0.984131639774509, 0.320412672954752,\n                            0.974077670791771, 0.852850433853921, 0.823320301074444,\n                            1.0]\n\n        #butcher table\n        self.BT = {0:None, #explicit first stage\n                   1:[0.117318819358521, 0.117318819358521],\n                   2:[0.0557014605974616, 0.385525646638742, 0.117318819358521],\n                   3:[0.063493276428895, 0.373556126263681, 0.0082994166438953,\n                      0.117318819358521],\n                   4:[0.0961351856230088, 0.335558324517178, 0.207077765910132,\n                      -0.0581917140797146, 0.117318819358521],\n                   5:[0.0497669214238319, 0.384288616546039, 0.0821728117583936,\n                      0.120337007107103, 0.202262782645888, 0.117318819358521],\n                   6:[0.00626710666809847, 0.496491452640725, -0.111303249827358,\n                      0.170478821683603, 0.166517073971103, -0.0328669811542241,\n                      0.117318819358521],\n                   7:[0.0463439767281591, 0.00306724391019652, -0.00816305222386205,\n                      -0.0353302599538294, 0.0139313601702569, -0.00992014507967429,\n                      0.0210087909090165, 0.117318819358521],\n                   8:[0.111574049232048, 0.467639166482209, 0.237773114804619,\n                      0.0798895699267508, 0.109580615914593, 0.0307353103825936,\n                      -0.0404391509541147, -0.16942110744293, 0.117318819358521],\n                   9:[-0.0107072484863877, -0.231376703354252, 0.017541113036611,\n                      0.144871527682418, -0.041855459769806, 0.0841832168332261,\n                      -0.0850020937282192, 0.486170343825899, -0.0526717116822739,\n                      0.117318819358521],\n                   10:[-0.0142238262314935, 0.14752923682514, 0.238235830732566,\n                       0.037950291904103, 0.252075123381518, 0.0474266904224567,\n                       -0.00363139069342027, 0.274081442388563, -0.0599166970745255,\n                       -0.0527138812389185, 0.117318819358521],\n                   11:[-0.11837020183211, -0.635712481821264, 0.239738832602538,\n                       0.330058936651707, -0.325784087988237, -0.0506514314589253,\n                       -0.281914404487009, 0.852596345144291, 0.651444614298805,\n                       -0.103476387303591, -0.354835880209975, 0.117318819358521],\n                   12:[-0.00458164025442349, 0.296219694015248, 0.322146049419995,\n                       0.15917778285238, 0.284864871688843, 0.185509526463076,\n                       -0.0784621067883274, 0.166312223692047, -0.284152486083397,\n                       -0.357125104338944, 0.078437074055306, 0.0884129667114481,\n                       0.117318819358521],\n                   13:[-0.0545561913848106, 0.675785423442753, 0.423066443201941,\n                       -0.000165300126841193, 0.104252994793763, -0.105763019303021,\n                       -0.15988308809318, 0.0515050001032011, 0.56013979290924,\n                       -0.45781539708603, -0.255870699752664, 0.026960254296416,\n                       -0.0721245985053681, 0.117318819358521],\n                   14:[0.0649253995775223, -0.0216056457922249, -0.073738139377975,\n                       0.0931033310077225, -0.0194339577299149, -0.0879623837313009,\n                       0.057125517179467, 0.205120850488097, 0.132576503537441,\n                       0.489416890627328, -0.1106765720501, -0.081038793996096,\n                       0.0606031613503788, -0.00241467937442272, 0.117318819358521],\n                   15:[0.0459979286336779, 0.0780075394482806, 0.015021874148058,\n                       0.195180277284195, -0.00246643310153235, 0.0473977117068314,\n                       -0.0682773558610363, 0.19568019123878, -0.0876765449323747,\n                       0.177874852409192, -0.337519251582222, -0.0123255553640736,\n                       0.311573291192553, 0.0458604327754991, 0.278352222645651,\n                       0.117318819358521]}\n\n        #coefficients for truncation error estimate (8th and 5th order solution)\n        _A1 = [0.0459979286336779, 0.0780075394482806, 0.015021874148058,\n               0.195180277284195, -0.00246643310153235, 0.0473977117068314,\n               -0.0682773558610363, 0.19568019123878, -0.0876765449323747,\n               0.177874852409192, -0.337519251582222, -0.0123255553640736,\n               0.311573291192553, 0.0458604327754991, 0.278352222645651,\n               0.117318819358521]\n        _A2 = [0.0603373529853206, 0.175453809423998, 0.0537707777611352,\n               0.195309248607308, 0.0135893741970232, -0.0221160259296707,\n               -0.00726526156430691, 0.102961059369124, 0.000900215457460583,\n               0.0547959465692338, -0.334995726863153, 0.0464409662093384,\n               0.301388101652194, 0.00524851570622031, 0.229538601845236,\n               0.124643044573514]\n        self.TR = [_a1 - _a2 for _a1, _a2 in zip(_A1, _A2)]",
          "bases": [
            "pathsim.solvers._rungekutta.DiagonallyImplicitRungeKutta"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, *solver_args, **solver_kwargs):\n    super().__init__(*solver_args, **solver_kwargs)\n\n    #number of stages in RK scheme\n    self.s = 16\n\n    #order of scheme and embedded method\n    self.n = 8\n    self.m = 5\n\n    #flag adaptive timestep solver\n    self.is_adaptive = True\n\n    #intermediate evaluation times as ratios\n    self.eval_stages = [0.0              , 0.234637638717043, 0.558545926594724,\n                        0.562667638694992, 0.697898381329126, 0.956146958839776,\n                        0.812903043340468, 0.148256733818785, 0.944650387704291,\n                        0.428471803715736, 0.984131639774509, 0.320412672954752,\n                        0.974077670791771, 0.852850433853921, 0.823320301074444,\n                        1.0]\n\n    #butcher table\n    self.BT = {0:None, #explicit first stage\n               1:[0.117318819358521, 0.117318819358521],\n               2:[0.0557014605974616, 0.385525646638742, 0.117318819358521],\n               3:[0.063493276428895, 0.373556126263681, 0.0082994166438953,\n                  0.117318819358521],\n               4:[0.0961351856230088, 0.335558324517178, 0.207077765910132,\n                  -0.0581917140797146, 0.117318819358521],\n               5:[0.0497669214238319, 0.384288616546039, 0.0821728117583936,\n                  0.120337007107103, 0.202262782645888, 0.117318819358521],\n               6:[0.00626710666809847, 0.496491452640725, -0.111303249827358,\n                  0.170478821683603, 0.166517073971103, -0.0328669811542241,\n                  0.117318819358521],\n               7:[0.0463439767281591, 0.00306724391019652, -0.00816305222386205,\n                  -0.0353302599538294, 0.0139313601702569, -0.00992014507967429,\n                  0.0210087909090165, 0.117318819358521],\n               8:[0.111574049232048, 0.467639166482209, 0.237773114804619,\n                  0.0798895699267508, 0.109580615914593, 0.0307353103825936,\n                  -0.0404391509541147, -0.16942110744293, 0.117318819358521],\n               9:[-0.0107072484863877, -0.231376703354252, 0.017541113036611,\n                  0.144871527682418, -0.041855459769806, 0.0841832168332261,\n                  -0.0850020937282192, 0.486170343825899, -0.0526717116822739,\n                  0.117318819358521],\n               10:[-0.0142238262314935, 0.14752923682514, 0.238235830732566,\n                   0.037950291904103, 0.252075123381518, 0.0474266904224567,\n                   -0.00363139069342027, 0.274081442388563, -0.0599166970745255,\n                   -0.0527138812389185, 0.117318819358521],\n               11:[-0.11837020183211, -0.635712481821264, 0.239738832602538,\n                   0.330058936651707, -0.325784087988237, -0.0506514314589253,\n                   -0.281914404487009, 0.852596345144291, 0.651444614298805,\n                   -0.103476387303591, -0.354835880209975, 0.117318819358521],\n               12:[-0.00458164025442349, 0.296219694015248, 0.322146049419995,\n                   0.15917778285238, 0.284864871688843, 0.185509526463076,\n                   -0.0784621067883274, 0.166312223692047, -0.284152486083397,\n                   -0.357125104338944, 0.078437074055306, 0.0884129667114481,\n                   0.117318819358521],\n               13:[-0.0545561913848106, 0.675785423442753, 0.423066443201941,\n                   -0.000165300126841193, 0.104252994793763, -0.105763019303021,\n                   -0.15988308809318, 0.0515050001032011, 0.56013979290924,\n                   -0.45781539708603, -0.255870699752664, 0.026960254296416,\n                   -0.0721245985053681, 0.117318819358521],\n               14:[0.0649253995775223, -0.0216056457922249, -0.073738139377975,\n                   0.0931033310077225, -0.0194339577299149, -0.0879623837313009,\n                   0.057125517179467, 0.205120850488097, 0.132576503537441,\n                   0.489416890627328, -0.1106765720501, -0.081038793996096,\n                   0.0606031613503788, -0.00241467937442272, 0.117318819358521],\n               15:[0.0459979286336779, 0.0780075394482806, 0.015021874148058,\n                   0.195180277284195, -0.00246643310153235, 0.0473977117068314,\n                   -0.0682773558610363, 0.19568019123878, -0.0876765449323747,\n                   0.177874852409192, -0.337519251582222, -0.0123255553640736,\n                   0.311573291192553, 0.0458604327754991, 0.278352222645651,\n                   0.117318819358521]}\n\n    #coefficients for truncation error estimate (8th and 5th order solution)\n    _A1 = [0.0459979286336779, 0.0780075394482806, 0.015021874148058,\n           0.195180277284195, -0.00246643310153235, 0.0473977117068314,\n           -0.0682773558610363, 0.19568019123878, -0.0876765449323747,\n           0.177874852409192, -0.337519251582222, -0.0123255553640736,\n           0.311573291192553, 0.0458604327754991, 0.278352222645651,\n           0.117318819358521]\n    _A2 = [0.0603373529853206, 0.175453809423998, 0.0537707777611352,\n           0.195309248607308, 0.0135893741970232, -0.0221160259296707,\n           -0.00726526156430691, 0.102961059369124, 0.000900215457460583,\n           0.0547959465692338, -0.334995726863153, 0.0464409662093384,\n           0.301388101652194, 0.00524851570622031, 0.229538601845236,\n           0.124643044573514]\n    self.TR = [_a1 - _a2 for _a1, _a2 in zip(_A1, _A2)]",
              "signature": "(solver_args = (), solver_kwargs = {})",
              "parameters": [
                {
                  "name": "solver_args",
                  "type": null,
                  "default": "()",
                  "description": ""
                },
                {
                  "name": "solver_kwargs",
                  "type": null,
                  "default": "{}",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "s",
              "description": "",
              "type": null,
              "value": "16"
            },
            {
              "name": "n",
              "description": "",
              "type": null,
              "value": "8"
            },
            {
              "name": "m",
              "description": "",
              "type": null,
              "value": "5"
            },
            {
              "name": "is_adaptive",
              "description": "",
              "type": null,
              "value": "True"
            },
            {
              "name": "eval_stages",
              "description": "",
              "type": null,
              "value": "[0.0, 0.234637638717043, 0.558545926594724, 0.562667638694992, 0.697898381329126, 0.956146958839776, 0.812903043340468, 0.148256733818785, 0.944650387704291, 0.428471803715736, 0.984131639774509, 0.320412672954752, 0.974077670791771, 0.852850433853921, 0.823320301074444, 1.0]"
            },
            {
              "name": "BT",
              "description": "",
              "type": null,
              "value": "{0: None, 1: [0.117318819358521, 0.117318819358521], 2: [0.0557014605974616, 0.385525646638742, 0.117318819358521], 3: [0.063493276428895, 0.373556126263681, 0.0082994166438953, 0.117318819358521], 4: [0.0961351856230088, 0.335558324517178, 0.207077765910132, -0.0581917140797146, 0.117318819358521], 5: [0.0497669214238319, 0.384288616546039, 0.0821728117583936, 0.120337007107103, 0.202262782645888, 0.117318819358521], 6: [0.00626710666809847, 0.496491452640725, -0.111303249827358, 0.170478821683603, 0.166517073971103, -0.0328669811542241, 0.117318819358521], 7: [0.0463439767281591, 0.00306724391019652, -0.00816305222386205, -0.0353302599538294, 0.0139313601702569, -0.00992014507967429, 0.0210087909090165, 0.117318819358521], 8: [0.111574049232048, 0.467639166482209, 0.237773114804619, 0.0798895699267508, 0.109580615914593, 0.0307353103825936, -0.0404391509541147, -0.16942110744293, 0.117318819358521], 9: [-0.0107072484863877, -0.231376703354252, 0.017541113036611, 0.144871527682418, -0.041855459769806, 0.0841832168332261, -0.0850020937282192, 0.486170343825899, -0.0526717116822739, 0.117318819358521], 10: [-0.0142238262314935, 0.14752923682514, 0.238235830732566, 0.037950291904103, 0.252075123381518, 0.0474266904224567, -0.00363139069342027, 0.274081442388563, -0.0599166970745255, -0.0527138812389185, 0.117318819358521], 11: [-0.11837020183211, -0.635712481821264, 0.239738832602538, 0.330058936651707, -0.325784087988237, -0.0506514314589253, -0.281914404487009, 0.852596345144291, 0.651444614298805, -0.103476387303591, -0.354835880209975, 0.117318819358521], 12: [-0.00458164025442349, 0.296219694015248, 0.322146049419995, 0.15917778285238, 0.284864871688843, 0.185509526463076, -0.0784621067883274, 0.166312223692047, -0.284152486083397, -0.357125104338944, 0.078437074055306, 0.0884129667114481, 0.117318819358521], 13: [-0.0545561913848106, 0.675785423442753, 0.423066443201941, -0.000165300126841193, 0.104252994793763, -0.105763019303021, -0.15988308809318, 0.0515050001032011, 0.56013979290924, -0.45781539708603, -0.255870699752664, 0.026960254296416, -0.0721245985053681, 0.117318819358521], 14: [0.0649253995775223, -0.0216056457922249, -0.073738139377975, 0.0931033310077225, -0.0194339577299149, -0.0879623837313009, 0.057125517179467, 0.205120850488097, 0.132576503537441, 0.489416890627328, -0.1106765720501, -0.081038793996096, 0.0606031613503788, -0.00241467937442272, 0.117318819358521], 15: [0.0459979286336779, 0.0780075394482806, 0.015021874148058, 0.195180277284195, -0.00246643310153235, 0.0473977117068314, -0.0682773558610363, 0.19568019123878, -0.0876765449323747, 0.177874852409192, -0.337519251582222, -0.0123255553640736, 0.311573291192553, 0.0458604327754991, 0.278352222645651, 0.117318819358521]}"
            },
            {
              "name": "TR",
              "description": "",
              "type": null,
              "value": "[(_a1 - _a2) for _a1, _a2 in (zip(_A1, _A2))]"
            }
          ],
          "parameters": [
            {
              "name": "solver_args",
              "type": null,
              "default": "()",
              "description": ""
            },
            {
              "name": "solver_kwargs",
              "type": null,
              "default": "{}",
              "description": ""
            }
          ]
        }
      ],
      "functions": []
    },
    "pathsim.solvers.euler": {
      "name": "pathsim.solvers.euler",
      "description": "",
      "docstring_html": "",
      "classes": [
        {
          "name": "EUF",
          "description": "Explicit Forward Euler (FE) integration method.",
          "docstring_html": "<p>Explicit Forward Euler (FE) integration method.</p>\n<p>This is the simplest explicit numerical integration method. It is first-order\naccurate (<span class=\"math\">\\(O(h)\\)</span>) and generally not suitable for stiff problems due to its\nlimited stability region.</p>\n<p>Method:</p>\n<div class=\"math\">\n\\begin{equation*}\nx_{n+1} = x_n + dt \\cdot f(x_n, t_n)\n\\end{equation*}\n</div>\n<p>Characteristics:</p>\n<blockquote>\n<ul class=\"simple\">\n<li>Order: 1</li>\n<li>Stages: 1</li>\n<li>Explicit</li>\n<li>Fixed timestep only</li>\n<li>Not A-stable</li>\n<li>Low accuracy and stability, but computationally very cheap.</li>\n</ul>\n</blockquote>\n<div class=\"section\" id=\"note\">\n<h4>Note</h4>\n<p>Use this only if the function to integrate is super smooth\nor multistep/multistage methods cant be used.</p>\n</div>\n",
          "source": "class EUF(ExplicitSolver):\n    \"\"\"Explicit Forward Euler (FE) integration method.\n\n    This is the simplest explicit numerical integration method. It is first-order\n    accurate (:math:`O(h)`) and generally not suitable for stiff problems due to its\n    limited stability region.\n\n    Method:\n\n    .. math::\n\n        x_{n+1} = x_n + dt \\\\cdot f(x_n, t_n)\n\n    Characteristics:\n\n        * Order: 1\n        * Stages: 1\n        * Explicit\n        * Fixed timestep only\n        * Not A-stable\n        * Low accuracy and stability, but computationally very cheap.\n\n    Note\n    ----\n    Use this only if the function to integrate is super smooth \n    or multistep/multistage methods cant be used. \n\n    \"\"\"\n\n    def step(self, f, dt):\n        \"\"\"performs the explicit forward timestep for (t+dt) \n        based on the state and input at (t)\n\n        Parameters\n        ----------\n        f : array_like\n            evaluation of function\n        dt : float \n            integration timestep\n\n        Returns\n        -------\n        success : bool\n            timestep was successful\n        err : float\n            truncation error estimate\n        scale : float\n            timestep rescale from error controller\n        \"\"\"\n\n        #get current state from history\n        x_0 = self.history[0]\n\n        #update state with euler step\n        self.x = x_0 + dt * f\n\n        #no error estimate available\n        return True, 0.0, 1.0",
          "bases": [
            "pathsim.solvers._solver.ExplicitSolver"
          ],
          "methods": [
            {
              "name": "step",
              "description": "performs the explicit forward timestep for (t+dt)",
              "docstring_html": "<p>performs the explicit forward timestep for (t+dt)\nbased on the state and input at (t)</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>f <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array_like</span></dt>\n<dd>evaluation of function</dd>\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>integration timestep</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>success <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>timestep was successful</dd>\n<dt>err <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>truncation error estimate</dd>\n<dt>scale <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>timestep rescale from error controller</dd>\n</dl>\n",
              "source": "def step(self, f, dt):\n    \"\"\"performs the explicit forward timestep for (t+dt) \n    based on the state and input at (t)\n\n    Parameters\n    ----------\n    f : array_like\n        evaluation of function\n    dt : float \n        integration timestep\n\n    Returns\n    -------\n    success : bool\n        timestep was successful\n    err : float\n        truncation error estimate\n    scale : float\n        timestep rescale from error controller\n    \"\"\"\n\n    #get current state from history\n    x_0 = self.history[0]\n\n    #update state with euler step\n    self.x = x_0 + dt * f\n\n    #no error estimate available\n    return True, 0.0, 1.0",
              "signature": "(f, dt)",
              "parameters": [
                {
                  "name": "f",
                  "type": null,
                  "default": null,
                  "description": "evaluation of function"
                },
                {
                  "name": "dt",
                  "type": null,
                  "default": null,
                  "description": "integration timestep"
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [],
          "parameters": []
        },
        {
          "name": "EUB",
          "description": "Implicit Backward Euler (BE) integration method.",
          "docstring_html": "<p>Implicit Backward Euler (BE) integration method.</p>\n<p>This is the simplest implicit numerical integration method. It is first-order\naccurate (<span class=\"math\">\\(O(h)\\)</span>) and is A-stable and L-stable, making it suitable for very\nstiff problems where stability is paramount, although its low order limits\naccuracy for non-stiff problems or when high precision is required.</p>\n<p>Method:</p>\n<div class=\"math\">\n\\begin{equation*}\nx_{n+1} = x_n + dt \\cdot f(x_{n+1}, t_{n+1})\n\\end{equation*}\n</div>\n<p>This implicit equation is solved iteratively using the internal optimizer.</p>\n<p>Characteristics:</p>\n<blockquote>\n<ul class=\"simple\">\n<li>Order: 1</li>\n<li>Stages: 1 (Implicit)</li>\n<li>Implicit</li>\n<li>Fixed timestep only</li>\n<li>A-stable, L-stable</li>\n<li>Very stable, suitable for stiff problems, but low accuracy.</li>\n</ul>\n</blockquote>\n",
          "source": "class EUB(ImplicitSolver):\n    \"\"\"Implicit Backward Euler (BE) integration method.\n\n    This is the simplest implicit numerical integration method. It is first-order\n    accurate (:math:`O(h)`) and is A-stable and L-stable, making it suitable for very\n    stiff problems where stability is paramount, although its low order limits\n    accuracy for non-stiff problems or when high precision is required.\n\n    Method:\n\n    .. math::\n\n        x_{n+1} = x_n + dt \\\\cdot f(x_{n+1}, t_{n+1})\n\n    This implicit equation is solved iteratively using the internal optimizer.\n\n    Characteristics:\n\n        * Order: 1\n        * Stages: 1 (Implicit)\n        * Implicit\n        * Fixed timestep only\n        * A-stable, L-stable\n        * Very stable, suitable for stiff problems, but low accuracy.\n\n    \"\"\"\n\n    def solve(self, f, J, dt):\n        \"\"\"Solves the implicit update equation \n        using the internal optimizer.\n\n        Parameters\n        ----------\n        f : array_like\n            evaluation of function\n        J : array_like\n            evaluation of jacobian of function\n        dt : float \n            integration timestep\n\n        Returns\n        -------\n        err : float\n            residual error of the fixed point update equation\n        \"\"\"\n\n        #get current state from history\n        x_0 = self.history[0]\n\n        #update the fixed point equation\n        g = x_0 + dt * f\n\n        #use the numerical jacobian\n        if J is not None:\n\n            #optimizer step with block local jacobian\n            self.x, err = self.opt.step(self.x, g, dt * J)\n\n        else:\n            #optimizer step (pure)\n            self.x, err = self.opt.step(self.x, g, None)\n\n        #return the fixed-point residual\n        return err",
          "bases": [
            "pathsim.solvers._solver.ImplicitSolver"
          ],
          "methods": [
            {
              "name": "solve",
              "description": "Solves the implicit update equation",
              "docstring_html": "<p>Solves the implicit update equation\nusing the internal optimizer.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>f <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array_like</span></dt>\n<dd>evaluation of function</dd>\n<dt>J <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array_like</span></dt>\n<dd>evaluation of jacobian of function</dd>\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>integration timestep</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>err <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>residual error of the fixed point update equation</dd>\n</dl>\n",
              "source": "def solve(self, f, J, dt):\n    \"\"\"Solves the implicit update equation \n    using the internal optimizer.\n\n    Parameters\n    ----------\n    f : array_like\n        evaluation of function\n    J : array_like\n        evaluation of jacobian of function\n    dt : float \n        integration timestep\n\n    Returns\n    -------\n    err : float\n        residual error of the fixed point update equation\n    \"\"\"\n\n    #get current state from history\n    x_0 = self.history[0]\n\n    #update the fixed point equation\n    g = x_0 + dt * f\n\n    #use the numerical jacobian\n    if J is not None:\n\n        #optimizer step with block local jacobian\n        self.x, err = self.opt.step(self.x, g, dt * J)\n\n    else:\n        #optimizer step (pure)\n        self.x, err = self.opt.step(self.x, g, None)\n\n    #return the fixed-point residual\n    return err",
              "signature": "(f, J, dt)",
              "parameters": [
                {
                  "name": "f",
                  "type": null,
                  "default": null,
                  "description": "evaluation of function"
                },
                {
                  "name": "J",
                  "type": null,
                  "default": null,
                  "description": "evaluation of jacobian of function"
                },
                {
                  "name": "dt",
                  "type": null,
                  "default": null,
                  "description": "integration timestep"
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [],
          "parameters": []
        }
      ],
      "functions": []
    },
    "pathsim.solvers.gear": {
      "name": "pathsim.solvers.gear",
      "description": "",
      "docstring_html": "",
      "classes": [
        {
          "name": "GEAR",
          "description": "Base class for GEAR-type integrators that defines the universal methods.",
          "docstring_html": "<p>Base class for GEAR-type integrators that defines the universal methods.</p>\n<p>Numerical integration method based on BDFs (linear multistep methods).\nUses n-th order BDF for timestepping and (n-1)-th order BDF coefficients\nto estimate a lower ordersolutuin for error control.</p>\n<p>The adaptive timestep BDF coefficients are dynamically computed at the\nbeginning of each timestep from the buffered previous timsteps.</p>\n<p><strong>Notes</strong></p>\n<p>Not to be used directly!</p>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>x <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">numeric, array[numeric]</span></dt>\n<dd>internal 'working' state</dd>\n<dt>n <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>order of integration scheme</dd>\n<dt>s <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>number of internal intermediate stages</dd>\n<dt>stage <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>counter for current intermediate stage</dd>\n<dt>eval_stages <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">list[float]</span></dt>\n<dd>rations for evaluation times of intermediate stages</dd>\n<dt>opt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">NewtonAnderson, Anderson, etc.</span></dt>\n<dd>optimizer instance to solve the implicit update equation</dd>\n<dt>K <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">dict[int: list[float]]</span></dt>\n<dd>bdf coefficients for the state buffer for each order</dd>\n<dt>F <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">dict[int: float]</span></dt>\n<dd>bdf coefficients for the function 'func' for each order</dd>\n<dt>history <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">deque[numeric]</span></dt>\n<dd>internal history of past results</dd>\n<dt>history_dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">deque[numeric]</span></dt>\n<dd>internal history of past timesteps</dd>\n<dt>startup <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">Solver</span></dt>\n<dd>internal solver instance for startup (building history)\nof multistep methods (using 'ESDIRK32' for 'GEAR' methods)</dd>\n</dl>\n",
          "source": "class GEAR(ImplicitSolver):\n    \"\"\"Base class for GEAR-type integrators that defines the universal methods.\n\n    Numerical integration method based on BDFs (linear multistep methods). \n    Uses n-th order BDF for timestepping and (n-1)-th order BDF coefficients \n    to estimate a lower ordersolutuin for error control. \n\n    The adaptive timestep BDF coefficients are dynamically computed at the \n    beginning of each timestep from the buffered previous timsteps.\n\n    Notes\n    -----\n    Not to be used directly!\n\n    Attributes\n    ----------\n    x : numeric, array[numeric]\n        internal 'working' state\n    n : int\n        order of integration scheme\n    s : int\n        number of internal intermediate stages\n    stage : int\n        counter for current intermediate stage\n    eval_stages : list[float]\n        rations for evaluation times of intermediate stages\n    opt : NewtonAnderson, Anderson, etc.\n        optimizer instance to solve the implicit update equation\n    K : dict[int: list[float]]\n        bdf coefficients for the state buffer for each order\n    F : dict[int: float]\n        bdf coefficients for the function 'func' for each order\n    history : deque[numeric]\n        internal history of past results\n    history_dt : deque[numeric]\n        internal history of past timesteps\n    startup : Solver\n        internal solver instance for startup (building history) \n        of multistep methods (using 'ESDIRK32' for 'GEAR' methods)\n    \"\"\"\n\n    def __init__(self, *solver_args, **solver_kwargs):\n        super().__init__(*solver_args, **solver_kwargs)\n\n        #integration order and order of secondary method\n        self.n = None\n        self.m = None\n\n        #safety factor for error controller (if available)\n        self.beta = SOL_BETA\n\n        #gear timestep buffer\n        self.history_dt = deque([], maxlen=1)\n\n        #flag adaptive timestep solver\n        self.is_adaptive = True\n\n        #initialize startup solver from 'self'\n        self._needs_startup = True\n        self.startup = ESDIRK32.cast(self)\n\n\n    def stages(self, t, dt):\n        \"\"\"Generator that yields the intermediate evaluation \n        time during the timestep 't + ratio * dt'.\n\n        Parameters\n        ----------\n        t : float \n            evaluation time\n        dt : float\n            integration timestep\n        \"\"\"\n\n        #not enough history for full order -> stages of startup method\n        if self._needs_startup:\n            for _t in self.startup.stages(t, dt):\n                yield _t\n        else:\n            for ratio in self.eval_stages:\n                yield t + ratio * dt\n\n\n    def reset(self):\n        \"\"\"\"Resets integration engine to initial state.\"\"\"\n\n        #clear buffers \n        self.history.clear()\n        self.history_dt.clear()\n\n        #overwrite state with initial value\n        self.x = self.initial_value\n\n        #reset startup solver\n        self.startup.reset()\n\n\n    def buffer(self, dt):\n        \"\"\"Buffer the state and timestep. Dynamically precompute \n        the variable timestep BDF coefficients on the fly for the \n        current timestep.\n\n        Parameters\n        ----------\n        dt : float\n            integration timestep\n        \"\"\"\n\n        #reset optimizer\n        self.opt.reset()\n\n        #add to histories (solution and timestep)            \n        self.history.appendleft(self.x)\n        self.history_dt.appendleft(dt)\n\n        #flag for startup method\n        self._needs_startup = len(self.history) < self.n\n\n        #buffer with startup method\n        if self._needs_startup:\n            self.startup.buffer(dt)\n\n        #precompute coefficients here, where buffers are available\n        self.F, self.K = {}, {}\n        for n, _ in enumerate(self.history_dt, 1):\n            self.F[n], self.K[n] = compute_bdf_coefficients(n, np.array(self.history_dt))\n\n\n    # methods for adaptive timestep solvers --------------------------------------------\n\n    def revert(self):\n        \"\"\"Revert integration engine to previous timestep, this is only \n        relevant for adaptive methods where the simulation timestep 'dt' \n        is rescaled and the engine step is recomputed with the smaller \n        timestep.\n        \"\"\"\n\n        #reset internal state to previous state from history\n        self.x = self.history.popleft() \n\n        #also remove latest timestep from timestep history\n        _ = self.history_dt.popleft()\n\n        #revert startup method\n        if self._needs_startup:\n            self.startup.revert()\n\n\n    def error_controller(self, tr):\n        \"\"\"Compute scaling factor for adaptive timestep based on absolute and \n        relative tolerances for local truncation error. \n\n        Checks if the error tolerance is achieved and returns a success metric.\n\n        Parameters\n        ----------\n        tr : array[float]\n            truncation error estimate \n\n        Returns \n        -------\n        success : bool\n            True if the timestep was successful\n        error : float\n            estimated error of the internal error controller\n        scale : float\n            estimated timestep rescale factor for error control\n        \"\"\"\n\n        #compute scaling factors (avoid division by zero)\n        scale = self.tolerance_lte_abs + self.tolerance_lte_rel * np.abs(self.x)\n\n        #compute scaled truncation error (element-wise)\n        scaled_error = np.abs(tr) / scale\n\n        #compute the error norm and clip it\n        error_norm = np.clip(float(np.max(scaled_error)), TOLERANCE, None)\n\n        #determine if the error is acceptable\n        success = error_norm <= 1.0\n\n        #compute timestep scale factor using accuracy order of truncation error\n        timestep_rescale = self.beta / error_norm ** (1/self.n)\n\n        #clip the rescale factor to a reasonable range\n        timestep_rescale = np.clip(timestep_rescale, SOL_SCALE_MIN, SOL_SCALE_MAX)\n\n        return success, error_norm, timestep_rescale\n\n\n    # methods for timestepping ---------------------------------------------------------\n\n    def solve(self, f, J, dt):\n        \"\"\"Solves the implicit update equation using the optimizer of the engine.\n\n        Parameters\n        ----------\n        f : array_like\n            evaluation of function\n        J : array_like\n            evaluation of jacobian of function\n        dt : float \n            integration timestep\n\n        Returns\n        -------\n        err : float\n            residual error of the fixed point update equation\n\n        \"\"\"\n\n        #not enough history for full order -> solve with startup method\n        if self._needs_startup:\n            err = self.startup.solve(f, J, dt)\n            self.x = self.startup.get()\n            return err\n\n        #fixed-point function update (faster then sum comprehension)\n        g = self.F[self.n] * dt * f\n        for b, k in zip(self.history, self.K[self.n]):\n            g = g + b * k\n\n        #use the jacobian\n        if J is not None:\n\n            #optimizer step with block local jacobian\n            self.x, err = self.opt.step(self.x, g, self.F[self.n] * dt * J)\n\n        else:\n            #optimizer step (pure)\n            self.x, err = self.opt.step(self.x, g, None)\n\n        #return the fixed-point residual\n        return err\n\n\n    def step(self, f, dt):\n        \"\"\"Finalizes the timestep by resetting the solver for the implicit \n        update equation and computing the lower order estimate of the \n        solution for error control.\n\n        Parameters\n        ----------\n        f : array_like\n            evaluation of function\n        dt : float \n            integration timestep\n\n        Returns \n        -------\n        success : bool\n            True if the timestep was successful\n        error : float\n            estimated error of the internal error controller\n        scale : float\n            estimated timestep rescale factor for error control\n        \"\"\"\n\n        #not enough history for full order -> step with startup method\n        if self._needs_startup:\n            suc, err, scl = self.startup.step(f, dt)\n            self.x = self.startup.get()\n            return suc, err, scl\n\n        #estimate truncation error from lower order solution\n        tr = self.x - self.F[self.m] * dt * f\n        for b, k in zip(self.history, self.K[self.m]):\n            tr = tr - b * k\n\n        #error control\n        return self.error_controller(tr)",
          "bases": [
            "pathsim.solvers._solver.ImplicitSolver"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, *solver_args, **solver_kwargs):\n    super().__init__(*solver_args, **solver_kwargs)\n\n    #integration order and order of secondary method\n    self.n = None\n    self.m = None\n\n    #safety factor for error controller (if available)\n    self.beta = SOL_BETA\n\n    #gear timestep buffer\n    self.history_dt = deque([], maxlen=1)\n\n    #flag adaptive timestep solver\n    self.is_adaptive = True\n\n    #initialize startup solver from 'self'\n    self._needs_startup = True\n    self.startup = ESDIRK32.cast(self)",
              "signature": "(solver_args = (), solver_kwargs = {})",
              "parameters": [
                {
                  "name": "solver_args",
                  "type": null,
                  "default": "()",
                  "description": ""
                },
                {
                  "name": "solver_kwargs",
                  "type": null,
                  "default": "{}",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "stages",
              "description": "Generator that yields the intermediate evaluation",
              "docstring_html": "<p>Generator that yields the intermediate evaluation\ntime during the timestep 't + ratio * dt'.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time</dd>\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>integration timestep</dd>\n</dl>\n",
              "source": "def stages(self, t, dt):\n    \"\"\"Generator that yields the intermediate evaluation \n    time during the timestep 't + ratio * dt'.\n\n    Parameters\n    ----------\n    t : float \n        evaluation time\n    dt : float\n        integration timestep\n    \"\"\"\n\n    #not enough history for full order -> stages of startup method\n    if self._needs_startup:\n        for _t in self.startup.stages(t, dt):\n            yield _t\n    else:\n        for ratio in self.eval_stages:\n            yield t + ratio * dt",
              "signature": "(t, dt)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time"
                },
                {
                  "name": "dt",
                  "type": null,
                  "default": null,
                  "description": "integration timestep"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "reset",
              "description": "\"Resets integration engine to initial state.",
              "docstring_html": "<p>&quot;Resets integration engine to initial state.</p>\n",
              "source": "def reset(self):\n    \"\"\"\"Resets integration engine to initial state.\"\"\"\n\n    #clear buffers \n    self.history.clear()\n    self.history_dt.clear()\n\n    #overwrite state with initial value\n    self.x = self.initial_value\n\n    #reset startup solver\n    self.startup.reset()",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "buffer",
              "description": "Buffer the state and timestep. Dynamically precompute",
              "docstring_html": "<p>Buffer the state and timestep. Dynamically precompute\nthe variable timestep BDF coefficients on the fly for the\ncurrent timestep.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>integration timestep</dd>\n</dl>\n",
              "source": "def buffer(self, dt):\n    \"\"\"Buffer the state and timestep. Dynamically precompute \n    the variable timestep BDF coefficients on the fly for the \n    current timestep.\n\n    Parameters\n    ----------\n    dt : float\n        integration timestep\n    \"\"\"\n\n    #reset optimizer\n    self.opt.reset()\n\n    #add to histories (solution and timestep)            \n    self.history.appendleft(self.x)\n    self.history_dt.appendleft(dt)\n\n    #flag for startup method\n    self._needs_startup = len(self.history) < self.n\n\n    #buffer with startup method\n    if self._needs_startup:\n        self.startup.buffer(dt)\n\n    #precompute coefficients here, where buffers are available\n    self.F, self.K = {}, {}\n    for n, _ in enumerate(self.history_dt, 1):\n        self.F[n], self.K[n] = compute_bdf_coefficients(n, np.array(self.history_dt))",
              "signature": "(dt)",
              "parameters": [
                {
                  "name": "dt",
                  "type": null,
                  "default": null,
                  "description": "integration timestep"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "revert",
              "description": "Revert integration engine to previous timestep, this is only",
              "docstring_html": "<p>Revert integration engine to previous timestep, this is only\nrelevant for adaptive methods where the simulation timestep 'dt'\nis rescaled and the engine step is recomputed with the smaller\ntimestep.</p>\n",
              "source": "def revert(self):\n    \"\"\"Revert integration engine to previous timestep, this is only \n    relevant for adaptive methods where the simulation timestep 'dt' \n    is rescaled and the engine step is recomputed with the smaller \n    timestep.\n    \"\"\"\n\n    #reset internal state to previous state from history\n    self.x = self.history.popleft() \n\n    #also remove latest timestep from timestep history\n    _ = self.history_dt.popleft()\n\n    #revert startup method\n    if self._needs_startup:\n        self.startup.revert()",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "error_controller",
              "description": "Compute scaling factor for adaptive timestep based on absolute and",
              "docstring_html": "<p>Compute scaling factor for adaptive timestep based on absolute and\nrelative tolerances for local truncation error.</p>\n<p>Checks if the error tolerance is achieved and returns a success metric.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>tr <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array[float]</span></dt>\n<dd>truncation error estimate</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>success <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>True if the timestep was successful</dd>\n<dt>error <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>estimated error of the internal error controller</dd>\n<dt>scale <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>estimated timestep rescale factor for error control</dd>\n</dl>\n",
              "source": "def error_controller(self, tr):\n    \"\"\"Compute scaling factor for adaptive timestep based on absolute and \n    relative tolerances for local truncation error. \n\n    Checks if the error tolerance is achieved and returns a success metric.\n\n    Parameters\n    ----------\n    tr : array[float]\n        truncation error estimate \n\n    Returns \n    -------\n    success : bool\n        True if the timestep was successful\n    error : float\n        estimated error of the internal error controller\n    scale : float\n        estimated timestep rescale factor for error control\n    \"\"\"\n\n    #compute scaling factors (avoid division by zero)\n    scale = self.tolerance_lte_abs + self.tolerance_lte_rel * np.abs(self.x)\n\n    #compute scaled truncation error (element-wise)\n    scaled_error = np.abs(tr) / scale\n\n    #compute the error norm and clip it\n    error_norm = np.clip(float(np.max(scaled_error)), TOLERANCE, None)\n\n    #determine if the error is acceptable\n    success = error_norm <= 1.0\n\n    #compute timestep scale factor using accuracy order of truncation error\n    timestep_rescale = self.beta / error_norm ** (1/self.n)\n\n    #clip the rescale factor to a reasonable range\n    timestep_rescale = np.clip(timestep_rescale, SOL_SCALE_MIN, SOL_SCALE_MAX)\n\n    return success, error_norm, timestep_rescale",
              "signature": "(tr)",
              "parameters": [
                {
                  "name": "tr",
                  "type": null,
                  "default": null,
                  "description": "truncation error estimate"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "solve",
              "description": "Solves the implicit update equation using the optimizer of the engine.",
              "docstring_html": "<p>Solves the implicit update equation using the optimizer of the engine.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>f <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array_like</span></dt>\n<dd>evaluation of function</dd>\n<dt>J <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array_like</span></dt>\n<dd>evaluation of jacobian of function</dd>\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>integration timestep</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>err <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>residual error of the fixed point update equation</dd>\n</dl>\n",
              "source": "def solve(self, f, J, dt):\n    \"\"\"Solves the implicit update equation using the optimizer of the engine.\n\n    Parameters\n    ----------\n    f : array_like\n        evaluation of function\n    J : array_like\n        evaluation of jacobian of function\n    dt : float \n        integration timestep\n\n    Returns\n    -------\n    err : float\n        residual error of the fixed point update equation\n\n    \"\"\"\n\n    #not enough history for full order -> solve with startup method\n    if self._needs_startup:\n        err = self.startup.solve(f, J, dt)\n        self.x = self.startup.get()\n        return err\n\n    #fixed-point function update (faster then sum comprehension)\n    g = self.F[self.n] * dt * f\n    for b, k in zip(self.history, self.K[self.n]):\n        g = g + b * k\n\n    #use the jacobian\n    if J is not None:\n\n        #optimizer step with block local jacobian\n        self.x, err = self.opt.step(self.x, g, self.F[self.n] * dt * J)\n\n    else:\n        #optimizer step (pure)\n        self.x, err = self.opt.step(self.x, g, None)\n\n    #return the fixed-point residual\n    return err",
              "signature": "(f, J, dt)",
              "parameters": [
                {
                  "name": "f",
                  "type": null,
                  "default": null,
                  "description": "evaluation of function"
                },
                {
                  "name": "J",
                  "type": null,
                  "default": null,
                  "description": "evaluation of jacobian of function"
                },
                {
                  "name": "dt",
                  "type": null,
                  "default": null,
                  "description": "integration timestep"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "step",
              "description": "Finalizes the timestep by resetting the solver for the implicit",
              "docstring_html": "<p>Finalizes the timestep by resetting the solver for the implicit\nupdate equation and computing the lower order estimate of the\nsolution for error control.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>f <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array_like</span></dt>\n<dd>evaluation of function</dd>\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>integration timestep</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>success <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>True if the timestep was successful</dd>\n<dt>error <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>estimated error of the internal error controller</dd>\n<dt>scale <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>estimated timestep rescale factor for error control</dd>\n</dl>\n",
              "source": "def step(self, f, dt):\n    \"\"\"Finalizes the timestep by resetting the solver for the implicit \n    update equation and computing the lower order estimate of the \n    solution for error control.\n\n    Parameters\n    ----------\n    f : array_like\n        evaluation of function\n    dt : float \n        integration timestep\n\n    Returns \n    -------\n    success : bool\n        True if the timestep was successful\n    error : float\n        estimated error of the internal error controller\n    scale : float\n        estimated timestep rescale factor for error control\n    \"\"\"\n\n    #not enough history for full order -> step with startup method\n    if self._needs_startup:\n        suc, err, scl = self.startup.step(f, dt)\n        self.x = self.startup.get()\n        return suc, err, scl\n\n    #estimate truncation error from lower order solution\n    tr = self.x - self.F[self.m] * dt * f\n    for b, k in zip(self.history, self.K[self.m]):\n        tr = tr - b * k\n\n    #error control\n    return self.error_controller(tr)",
              "signature": "(f, dt)",
              "parameters": [
                {
                  "name": "f",
                  "type": null,
                  "default": null,
                  "description": "evaluation of function"
                },
                {
                  "name": "dt",
                  "type": null,
                  "default": null,
                  "description": "integration timestep"
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "n",
              "description": "",
              "type": null,
              "value": "None"
            },
            {
              "name": "m",
              "description": "",
              "type": null,
              "value": "None"
            },
            {
              "name": "beta",
              "description": "",
              "type": null,
              "value": "SOL_BETA"
            },
            {
              "name": "history_dt",
              "description": "",
              "type": null,
              "value": "deque([], maxlen=1)"
            },
            {
              "name": "is_adaptive",
              "description": "",
              "type": null,
              "value": "True"
            },
            {
              "name": "_needs_startup",
              "description": "",
              "type": null,
              "value": "True"
            },
            {
              "name": "startup",
              "description": "",
              "type": null,
              "value": "ESDIRK32.cast(self)"
            }
          ],
          "parameters": [
            {
              "name": "solver_args",
              "type": null,
              "default": "()",
              "description": ""
            },
            {
              "name": "solver_kwargs",
              "type": null,
              "default": "{}",
              "description": ""
            }
          ]
        },
        {
          "name": "GEAR21",
          "description": "Adaptive-step GEAR integrator using 2nd order BDF for timestepping",
          "docstring_html": "<p>Adaptive-step GEAR integrator using 2nd order BDF for timestepping\nand 1st order BDF (Backward Euler) for truncation error estimation.</p>\n<p>Suitable for moderately stiff problems where variable timestepping is beneficial.</p>\n<dl class=\"docutils\">\n<dt>Characteristics:</dt>\n<dd><ul class=\"first last simple\">\n<li>Stepping Order: 2 (max)</li>\n<li>Error Estimation Order: 1</li>\n<li>Implicit Variable-Step Multistep</li>\n<li>Adaptive timestep</li>\n<li>A-stable (based on BDF2)</li>\n</ul>\n</dd>\n</dl>\n",
          "source": "class GEAR21(GEAR):\n    \"\"\"Adaptive-step GEAR integrator using 2nd order BDF for timestepping\n    and 1st order BDF (Backward Euler) for truncation error estimation.\n\n    Suitable for moderately stiff problems where variable timestepping is beneficial.\n\n    Characteristics:\n        * Stepping Order: 2 (max)\n        * Error Estimation Order: 1\n        * Implicit Variable-Step Multistep\n        * Adaptive timestep\n        * A-stable (based on BDF2)\n    \"\"\"\n\n    def __init__(self, *solver_args, **solver_kwargs):\n        super().__init__(*solver_args, **solver_kwargs)\n\n        #integration order and order of secondary method\n        self.n = 2\n        self.m = 1\n\n        #gear buffers, here 2\n        self.history = deque([], maxlen=2)\n        self.history_dt = deque([], maxlen=2)",
          "bases": [
            "pathsim.solvers.gear.GEAR"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, *solver_args, **solver_kwargs):\n    super().__init__(*solver_args, **solver_kwargs)\n\n    #integration order and order of secondary method\n    self.n = 2\n    self.m = 1\n\n    #gear buffers, here 2\n    self.history = deque([], maxlen=2)\n    self.history_dt = deque([], maxlen=2)",
              "signature": "(solver_args = (), solver_kwargs = {})",
              "parameters": [
                {
                  "name": "solver_args",
                  "type": null,
                  "default": "()",
                  "description": ""
                },
                {
                  "name": "solver_kwargs",
                  "type": null,
                  "default": "{}",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "n",
              "description": "",
              "type": null,
              "value": "2"
            },
            {
              "name": "m",
              "description": "",
              "type": null,
              "value": "1"
            },
            {
              "name": "history",
              "description": "",
              "type": null,
              "value": "deque([], maxlen=2)"
            },
            {
              "name": "history_dt",
              "description": "",
              "type": null,
              "value": "deque([], maxlen=2)"
            }
          ],
          "parameters": [
            {
              "name": "solver_args",
              "type": null,
              "default": "()",
              "description": ""
            },
            {
              "name": "solver_kwargs",
              "type": null,
              "default": "{}",
              "description": ""
            }
          ]
        },
        {
          "name": "GEAR32",
          "description": "Adaptive-step GEAR integrator using 3rd order BDF for timestepping",
          "docstring_html": "<p>Adaptive-step GEAR integrator using 3rd order BDF for timestepping\nand 2nd order BDF for truncation error estimation.</p>\n<p>Suitable for stiff problems requiring higher accuracy than GEAR21.</p>\n<dl class=\"docutils\">\n<dt>Characteristics:</dt>\n<dd><ul class=\"first last simple\">\n<li>Stepping Order: 3 (max)</li>\n<li>Error Estimation Order: 2</li>\n<li>Implicit Variable-Step Multistep</li>\n<li>Adaptive timestep</li>\n<li>A(alpha)-stable (based on BDF3)</li>\n</ul>\n</dd>\n</dl>\n",
          "source": "class GEAR32(GEAR):\n    \"\"\"Adaptive-step GEAR integrator using 3rd order BDF for timestepping\n    and 2nd order BDF for truncation error estimation.\n\n    Suitable for stiff problems requiring higher accuracy than GEAR21.\n\n    Characteristics:\n        * Stepping Order: 3 (max)\n        * Error Estimation Order: 2\n        * Implicit Variable-Step Multistep\n        * Adaptive timestep\n        * A(alpha)-stable (based on BDF3)\n    \"\"\"\n\n    def __init__(self, *solver_args, **solver_kwargs):\n        super().__init__(*solver_args, **solver_kwargs)\n\n        #integration order and order of secondary method\n        self.n = 3\n        self.m = 2\n\n        #gear buffers, here 3\n        self.history = deque([], maxlen=3)\n        self.history_dt = deque([], maxlen=3)",
          "bases": [
            "pathsim.solvers.gear.GEAR"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, *solver_args, **solver_kwargs):\n    super().__init__(*solver_args, **solver_kwargs)\n\n    #integration order and order of secondary method\n    self.n = 3\n    self.m = 2\n\n    #gear buffers, here 3\n    self.history = deque([], maxlen=3)\n    self.history_dt = deque([], maxlen=3)",
              "signature": "(solver_args = (), solver_kwargs = {})",
              "parameters": [
                {
                  "name": "solver_args",
                  "type": null,
                  "default": "()",
                  "description": ""
                },
                {
                  "name": "solver_kwargs",
                  "type": null,
                  "default": "{}",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "n",
              "description": "",
              "type": null,
              "value": "3"
            },
            {
              "name": "m",
              "description": "",
              "type": null,
              "value": "2"
            },
            {
              "name": "history",
              "description": "",
              "type": null,
              "value": "deque([], maxlen=3)"
            },
            {
              "name": "history_dt",
              "description": "",
              "type": null,
              "value": "deque([], maxlen=3)"
            }
          ],
          "parameters": [
            {
              "name": "solver_args",
              "type": null,
              "default": "()",
              "description": ""
            },
            {
              "name": "solver_kwargs",
              "type": null,
              "default": "{}",
              "description": ""
            }
          ]
        },
        {
          "name": "GEAR43",
          "description": "Adaptive-step GEAR integrator using 4th order BDF for timestepping",
          "docstring_html": "<p>Adaptive-step GEAR integrator using 4th order BDF for timestepping\nand 3rd order BDF for truncation error estimation.</p>\n<p>Suitable for stiff problems requiring good accuracy.</p>\n<dl class=\"docutils\">\n<dt>Characteristics:</dt>\n<dd><ul class=\"first last simple\">\n<li>Stepping Order: 4 (max)</li>\n<li>Error Estimation Order: 3</li>\n<li>Implicit Variable-Step Multistep</li>\n<li>Adaptive timestep</li>\n<li>A(alpha)-stable (based on BDF4)</li>\n</ul>\n</dd>\n</dl>\n",
          "source": "class GEAR43(GEAR):\n    \"\"\"Adaptive-step GEAR integrator using 4th order BDF for timestepping\n    and 3rd order BDF for truncation error estimation.\n\n    Suitable for stiff problems requiring good accuracy.\n\n    Characteristics:\n        * Stepping Order: 4 (max)\n        * Error Estimation Order: 3\n        * Implicit Variable-Step Multistep\n        * Adaptive timestep\n        * A(alpha)-stable (based on BDF4)\n    \"\"\"\n\n    def __init__(self, *solver_args, **solver_kwargs):\n        super().__init__(*solver_args, **solver_kwargs)\n\n        #integration order and order of secondary method\n        self.n = 4\n        self.m = 3\n\n        #gear buffers, here 4\n        self.history = deque([], maxlen=4)\n        self.history_dt = deque([], maxlen=4)",
          "bases": [
            "pathsim.solvers.gear.GEAR"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, *solver_args, **solver_kwargs):\n    super().__init__(*solver_args, **solver_kwargs)\n\n    #integration order and order of secondary method\n    self.n = 4\n    self.m = 3\n\n    #gear buffers, here 4\n    self.history = deque([], maxlen=4)\n    self.history_dt = deque([], maxlen=4)",
              "signature": "(solver_args = (), solver_kwargs = {})",
              "parameters": [
                {
                  "name": "solver_args",
                  "type": null,
                  "default": "()",
                  "description": ""
                },
                {
                  "name": "solver_kwargs",
                  "type": null,
                  "default": "{}",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "n",
              "description": "",
              "type": null,
              "value": "4"
            },
            {
              "name": "m",
              "description": "",
              "type": null,
              "value": "3"
            },
            {
              "name": "history",
              "description": "",
              "type": null,
              "value": "deque([], maxlen=4)"
            },
            {
              "name": "history_dt",
              "description": "",
              "type": null,
              "value": "deque([], maxlen=4)"
            }
          ],
          "parameters": [
            {
              "name": "solver_args",
              "type": null,
              "default": "()",
              "description": ""
            },
            {
              "name": "solver_kwargs",
              "type": null,
              "default": "{}",
              "description": ""
            }
          ]
        },
        {
          "name": "GEAR54",
          "description": "Adaptive-step GEAR integrator using 5th order BDF for timestepping",
          "docstring_html": "<p>Adaptive-step GEAR integrator using 5th order BDF for timestepping\nand 4th order BDF for truncation error estimation.</p>\n<p>Suitable for stiff problems requiring high accuracy, but stability region\nis smaller than lower-order GEAR methods.</p>\n<dl class=\"docutils\">\n<dt>Characteristics:</dt>\n<dd><ul class=\"first last simple\">\n<li>Stepping Order: 5 (max)</li>\n<li>Error Estimation Order: 4</li>\n<li>Implicit Variable-Step Multistep</li>\n<li>Adaptive timestep</li>\n<li>A(alpha)-stable (based on BDF5)</li>\n</ul>\n</dd>\n</dl>\n",
          "source": "class GEAR54(GEAR):\n    \"\"\"Adaptive-step GEAR integrator using 5th order BDF for timestepping\n    and 4th order BDF for truncation error estimation.\n\n    Suitable for stiff problems requiring high accuracy, but stability region\n    is smaller than lower-order GEAR methods.\n\n    Characteristics:\n        * Stepping Order: 5 (max)\n        * Error Estimation Order: 4\n        * Implicit Variable-Step Multistep\n        * Adaptive timestep\n        * A(alpha)-stable (based on BDF5)\n    \"\"\"\n\n    def __init__(self, *solver_args, **solver_kwargs):\n        super().__init__(*solver_args, **solver_kwargs)\n\n        #integration order and order of secondary method\n        self.n = 5\n        self.m = 4\n\n        #gear, here 5+1\n        self.history = deque([], maxlen=5)\n        self.history_dt = deque([], maxlen=5)",
          "bases": [
            "pathsim.solvers.gear.GEAR"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, *solver_args, **solver_kwargs):\n    super().__init__(*solver_args, **solver_kwargs)\n\n    #integration order and order of secondary method\n    self.n = 5\n    self.m = 4\n\n    #gear, here 5+1\n    self.history = deque([], maxlen=5)\n    self.history_dt = deque([], maxlen=5)",
              "signature": "(solver_args = (), solver_kwargs = {})",
              "parameters": [
                {
                  "name": "solver_args",
                  "type": null,
                  "default": "()",
                  "description": ""
                },
                {
                  "name": "solver_kwargs",
                  "type": null,
                  "default": "{}",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "n",
              "description": "",
              "type": null,
              "value": "5"
            },
            {
              "name": "m",
              "description": "",
              "type": null,
              "value": "4"
            },
            {
              "name": "history",
              "description": "",
              "type": null,
              "value": "deque([], maxlen=5)"
            },
            {
              "name": "history_dt",
              "description": "",
              "type": null,
              "value": "deque([], maxlen=5)"
            }
          ],
          "parameters": [
            {
              "name": "solver_args",
              "type": null,
              "default": "()",
              "description": ""
            },
            {
              "name": "solver_kwargs",
              "type": null,
              "default": "{}",
              "description": ""
            }
          ]
        },
        {
          "name": "GEAR52A",
          "description": "Adaptive-order, adaptive-stepsize GEAR integrator (Variable-Step Variable-Order BDF).",
          "docstring_html": "<p>Adaptive-order, adaptive-stepsize GEAR integrator (Variable-Step Variable-Order BDF).</p>\n<p>This method dynamically adjusts the BDF order used for timestepping (between 2 and 5)\nbased on error estimates from lower and higher order predictors. It aims to optimize\nstep size by using higher orders for smooth regions and lower, more stable orders\nfor stiff or rapidly changing regions.</p>\n<p>Error estimation compares the current order solution with predictions from\norder n-1 and n+1 formulas.</p>\n<dl class=\"docutils\">\n<dt>Characteristics:</dt>\n<dd><ul class=\"first last simple\">\n<li>Stepping Order: Variable (2 to 5)</li>\n<li>Error Estimation Orders: n-1 and n+1 (relative to current n)</li>\n<li>Implicit Variable-Step, Variable-Order Multistep</li>\n<li>Adaptive timestep and order</li>\n<li>Stability varies with the currently selected order (A-stable or A(alpha)-stable)</li>\n</ul>\n</dd>\n</dl>\n",
          "source": "class GEAR52A(GEAR):\n    \"\"\"Adaptive-order, adaptive-stepsize GEAR integrator (Variable-Step Variable-Order BDF).\n\n    This method dynamically adjusts the BDF order used for timestepping (between 2 and 5)\n    based on error estimates from lower and higher order predictors. It aims to optimize\n    step size by using higher orders for smooth regions and lower, more stable orders\n    for stiff or rapidly changing regions.\n\n    Error estimation compares the current order solution with predictions from\n    order n-1 and n+1 formulas.\n\n    Characteristics:\n        * Stepping Order: Variable (2 to 5)\n        * Error Estimation Orders: n-1 and n+1 (relative to current n)\n        * Implicit Variable-Step, Variable-Order Multistep\n        * Adaptive timestep and order\n        * Stability varies with the currently selected order (A-stable or A(alpha)-stable)\n    \"\"\"\n\n    def __init__(self, *solver_args, **solver_kwargs):\n        super().__init__(*solver_args, **solver_kwargs)\n\n        #initial integration order\n        self.n = 2\n\n        #minimum and maximum BDF order to select\n        self.n_min, self.n_max = 2, 5\n\n        #gear, here 6\n        self.history = deque([], maxlen=6)\n        self.history_dt = deque([], maxlen=6)\n\n\n    def buffer(self, dt):\n        \"\"\"Buffer the state and timestep. Dynamically precompute \n        the variable timestep BDF coefficients on the fly for the \n        current timestep.\n\n        Parameters\n        ----------\n        dt : float\n            integration timestep\n        \"\"\"\n\n        #reset optimizer\n        self.opt.reset()\n\n        #add to histories (solution and timestep)            \n        self.history.appendleft(self.x)\n        self.history_dt.appendleft(dt)\n\n        #flag for startup method\n        self._needs_startup = len(self.history) < 6\n\n        #buffer with startup method\n        if self._needs_startup:\n            self.startup.buffer(dt)\n\n        #precompute coefficients here, where buffers are available\n        self.F, self.K = {}, {}\n        for n, _ in enumerate(self.history_dt, 1):\n            self.F[n], self.K[n] = compute_bdf_coefficients(n, np.array(self.history_dt))\n\n\n    # def stages(self, t, dt):\n    #     \"\"\"Generator that yields the intermediate evaluation \n    #     time during the timestep 't + ratio * dt'.\n\n    #     Parameters\n    #     ----------\n    #     t : float \n    #         evaluation time\n    #     dt : float\n    #         integration timestep\n    #     \"\"\"\n\n    #     #not enough history for full order -> stages of startup method\n    #     if self._needs_startup:\n    #         for _t in self.startup.stages(t, dt):\n    #             yield _t\n    #     else:\n    #         for ratio in self.eval_stages:\n    #             yield t + ratio * dt\n\n\n    # methods for adaptive timestep solvers --------------------------------------------\n\n    # def revert(self):\n    #     \"\"\"Revert integration engine to previous timestep, this is only \n    #     relevant for adaptive methods where the simulation timestep 'dt' \n    #     is rescaled and the engine step is recomputed with the smaller \n    #     timestep.\n    #     \"\"\"\n\n    #     #revert startup method\n    #     if self._needs_startup:\n    #         self.startup.revert()\n\n    #     #reset internal state to previous state from history\n    #     self.x = self.history.popleft() \n\n    #     #also remove latest timestep from timestep history\n    #     self.history_dt.popleft()\n\n\n    def error_controller(self, tr_m, tr_p):\n        \"\"\"Compute scaling factor for adaptive timestep based on absolute and \n        relative tolerances of the local truncation error estimate obtained from \n        esimated lower and higher order solution. \n\n        Checks if the error tolerance is achieved and returns a success metric.\n\n        Adapts the stepping order such that the normalized error is minimized and \n        larger steps can be taken by the integrator.\n\n        Parameters\n        ----------\n        tr_m : array[float]\n            lower order truncation error estimate\n        tr_p : array[float]\n            higher order truncation error estimate\n\n        Returns \n        -------\n        success : bool\n            True if the timestep was successful\n        error : float\n            estimated error of the internal error controller\n        scale : float\n            estimated timestep rescale factor for error control\n        \"\"\"\n\n        #compute scaling factors (avoid division by zero)\n        scale = self.tolerance_lte_abs + self.tolerance_lte_rel * np.abs(self.x)\n\n        #compute scaled truncation error (element-wise)\n        scaled_error_m = np.abs(tr_m) / scale\n        scaled_error_p = np.abs(tr_p) / scale\n\n        #compute the error norm and clip it\n        error_norm_m = np.clip(float(np.max(scaled_error_m)), TOLERANCE, None)\n        error_norm_p = np.clip(float(np.max(scaled_error_p)), TOLERANCE, None)      \n\n        #success metric (use lower order estimate)\n        success = error_norm_m <= 1.0\n\n        #compute timestep scale factor using accuracy order of truncation error\n        timestep_rescale = self.beta / error_norm_m ** (1/self.n)  \n\n        #clip the rescale factor to a reasonable range\n        timestep_rescale = np.clip(timestep_rescale, SOL_SCALE_MIN, SOL_SCALE_MAX)\n\n        #decrease the order if smaller order is more accurate (stability)\n        if error_norm_m < error_norm_p:\n            self.n = max(self.n-1, self.n_min)\n\n        #increase the order if larger order is more accurate (accuracy -> larger steps)\n        else:\n            self.n = min(self.n+1, self.n_max)\n\n        return success, error_norm_p, timestep_rescale\n\n\n    # methods for timestepping ---------------------------------------------------------\n\n    def solve(self, f, J, dt):\n        \"\"\"Solves the implicit update equation using the optimizer of the engine.\n\n        Parameters\n        ----------\n        f : array_like\n            evaluation of function\n        J : array_like\n            evaluation of jacobian of function\n        dt : float \n            integration timestep\n\n        Returns\n        -------\n        err : float\n            residual error of the fixed point update equation\n\n        \"\"\"\n\n        #not enough history for full order -> solve with startup method\n        if self._needs_startup:\n            err = self.startup.solve(f, J, dt)\n            self.x = self.startup.get()\n            return err\n\n        #fixed-point function update (faster then sum comprehension)\n        g = self.F[self.n] * dt * f\n        for b, k in zip(self.history, self.K[self.n]):\n            g = g + b * k\n\n        #use the jacobian\n        if J is not None:\n\n            #optimizer step with block local jacobian\n            self.x, err = self.opt.step(self.x, g, self.F[self.n] * dt * J)\n\n        else:\n            #optimizer step (pure)\n            self.x, err = self.opt.step(self.x, g, None)\n\n        #return the fixed-point residual\n        return err\n\n\n    def step(self, f, dt):\n        \"\"\"Finalizes the timestep by resetting the solver for the implicit \n        update equation and computing the lower and higher order estimate \n        of the solution. \n\n        Then calls the error controller.\n\n        Parameters\n        ----------\n        f : array_like\n            evaluation of function\n        dt : float \n            integration timestep\n\n        Returns \n        -------\n        success : bool\n            True if the timestep was successful\n        error : float\n            estimated error of the internal error controller\n        scale : float\n            estimated timestep rescale factor for error control\n        \"\"\"\n\n        #not enough history for full order -> step with startup method\n        if self._needs_startup:\n            suc, err, scl = self.startup.step(f, dt)\n            self.x = self.startup.get()\n            return suc, err, scl\n\n        #lower and higher order\n        n_m, n_p = self.n - 1, self.n + 1 \n\n        #estimate truncation error from lower order solution\n        tr_m = self.x - self.F[n_m] * dt * f\n        for b, k in zip(self.history, self.K[n_m]):\n            tr_m = tr_m - b * k\n\n        #estimate truncation error from higher order solution\n        tr_p = self.x - self.F[n_p] * dt * f\n        for b, k in zip(self.history, self.K[n_p]):\n            tr_p = tr_p - b * k\n\n        return self.error_controller(tr_m, tr_p)",
          "bases": [
            "pathsim.solvers.gear.GEAR"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, *solver_args, **solver_kwargs):\n    super().__init__(*solver_args, **solver_kwargs)\n\n    #initial integration order\n    self.n = 2\n\n    #minimum and maximum BDF order to select\n    self.n_min, self.n_max = 2, 5\n\n    #gear, here 6\n    self.history = deque([], maxlen=6)\n    self.history_dt = deque([], maxlen=6)",
              "signature": "(solver_args = (), solver_kwargs = {})",
              "parameters": [
                {
                  "name": "solver_args",
                  "type": null,
                  "default": "()",
                  "description": ""
                },
                {
                  "name": "solver_kwargs",
                  "type": null,
                  "default": "{}",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "buffer",
              "description": "Buffer the state and timestep. Dynamically precompute",
              "docstring_html": "<p>Buffer the state and timestep. Dynamically precompute\nthe variable timestep BDF coefficients on the fly for the\ncurrent timestep.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>integration timestep</dd>\n</dl>\n",
              "source": "def buffer(self, dt):\n    \"\"\"Buffer the state and timestep. Dynamically precompute \n    the variable timestep BDF coefficients on the fly for the \n    current timestep.\n\n    Parameters\n    ----------\n    dt : float\n        integration timestep\n    \"\"\"\n\n    #reset optimizer\n    self.opt.reset()\n\n    #add to histories (solution and timestep)            \n    self.history.appendleft(self.x)\n    self.history_dt.appendleft(dt)\n\n    #flag for startup method\n    self._needs_startup = len(self.history) < 6\n\n    #buffer with startup method\n    if self._needs_startup:\n        self.startup.buffer(dt)\n\n    #precompute coefficients here, where buffers are available\n    self.F, self.K = {}, {}\n    for n, _ in enumerate(self.history_dt, 1):\n        self.F[n], self.K[n] = compute_bdf_coefficients(n, np.array(self.history_dt))",
              "signature": "(dt)",
              "parameters": [
                {
                  "name": "dt",
                  "type": null,
                  "default": null,
                  "description": "integration timestep"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "error_controller",
              "description": "Compute scaling factor for adaptive timestep based on absolute and",
              "docstring_html": "<p>Compute scaling factor for adaptive timestep based on absolute and\nrelative tolerances of the local truncation error estimate obtained from\nesimated lower and higher order solution.</p>\n<p>Checks if the error tolerance is achieved and returns a success metric.</p>\n<p>Adapts the stepping order such that the normalized error is minimized and\nlarger steps can be taken by the integrator.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>tr_m <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array[float]</span></dt>\n<dd>lower order truncation error estimate</dd>\n<dt>tr_p <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array[float]</span></dt>\n<dd>higher order truncation error estimate</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>success <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>True if the timestep was successful</dd>\n<dt>error <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>estimated error of the internal error controller</dd>\n<dt>scale <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>estimated timestep rescale factor for error control</dd>\n</dl>\n",
              "source": "def error_controller(self, tr_m, tr_p):\n    \"\"\"Compute scaling factor for adaptive timestep based on absolute and \n    relative tolerances of the local truncation error estimate obtained from \n    esimated lower and higher order solution. \n\n    Checks if the error tolerance is achieved and returns a success metric.\n\n    Adapts the stepping order such that the normalized error is minimized and \n    larger steps can be taken by the integrator.\n\n    Parameters\n    ----------\n    tr_m : array[float]\n        lower order truncation error estimate\n    tr_p : array[float]\n        higher order truncation error estimate\n\n    Returns \n    -------\n    success : bool\n        True if the timestep was successful\n    error : float\n        estimated error of the internal error controller\n    scale : float\n        estimated timestep rescale factor for error control\n    \"\"\"\n\n    #compute scaling factors (avoid division by zero)\n    scale = self.tolerance_lte_abs + self.tolerance_lte_rel * np.abs(self.x)\n\n    #compute scaled truncation error (element-wise)\n    scaled_error_m = np.abs(tr_m) / scale\n    scaled_error_p = np.abs(tr_p) / scale\n\n    #compute the error norm and clip it\n    error_norm_m = np.clip(float(np.max(scaled_error_m)), TOLERANCE, None)\n    error_norm_p = np.clip(float(np.max(scaled_error_p)), TOLERANCE, None)      \n\n    #success metric (use lower order estimate)\n    success = error_norm_m <= 1.0\n\n    #compute timestep scale factor using accuracy order of truncation error\n    timestep_rescale = self.beta / error_norm_m ** (1/self.n)  \n\n    #clip the rescale factor to a reasonable range\n    timestep_rescale = np.clip(timestep_rescale, SOL_SCALE_MIN, SOL_SCALE_MAX)\n\n    #decrease the order if smaller order is more accurate (stability)\n    if error_norm_m < error_norm_p:\n        self.n = max(self.n-1, self.n_min)\n\n    #increase the order if larger order is more accurate (accuracy -> larger steps)\n    else:\n        self.n = min(self.n+1, self.n_max)\n\n    return success, error_norm_p, timestep_rescale",
              "signature": "(tr_m, tr_p)",
              "parameters": [
                {
                  "name": "tr_m",
                  "type": null,
                  "default": null,
                  "description": "lower order truncation error estimate"
                },
                {
                  "name": "tr_p",
                  "type": null,
                  "default": null,
                  "description": "higher order truncation error estimate"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "solve",
              "description": "Solves the implicit update equation using the optimizer of the engine.",
              "docstring_html": "<p>Solves the implicit update equation using the optimizer of the engine.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>f <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array_like</span></dt>\n<dd>evaluation of function</dd>\n<dt>J <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array_like</span></dt>\n<dd>evaluation of jacobian of function</dd>\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>integration timestep</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>err <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>residual error of the fixed point update equation</dd>\n</dl>\n",
              "source": "def solve(self, f, J, dt):\n    \"\"\"Solves the implicit update equation using the optimizer of the engine.\n\n    Parameters\n    ----------\n    f : array_like\n        evaluation of function\n    J : array_like\n        evaluation of jacobian of function\n    dt : float \n        integration timestep\n\n    Returns\n    -------\n    err : float\n        residual error of the fixed point update equation\n\n    \"\"\"\n\n    #not enough history for full order -> solve with startup method\n    if self._needs_startup:\n        err = self.startup.solve(f, J, dt)\n        self.x = self.startup.get()\n        return err\n\n    #fixed-point function update (faster then sum comprehension)\n    g = self.F[self.n] * dt * f\n    for b, k in zip(self.history, self.K[self.n]):\n        g = g + b * k\n\n    #use the jacobian\n    if J is not None:\n\n        #optimizer step with block local jacobian\n        self.x, err = self.opt.step(self.x, g, self.F[self.n] * dt * J)\n\n    else:\n        #optimizer step (pure)\n        self.x, err = self.opt.step(self.x, g, None)\n\n    #return the fixed-point residual\n    return err",
              "signature": "(f, J, dt)",
              "parameters": [
                {
                  "name": "f",
                  "type": null,
                  "default": null,
                  "description": "evaluation of function"
                },
                {
                  "name": "J",
                  "type": null,
                  "default": null,
                  "description": "evaluation of jacobian of function"
                },
                {
                  "name": "dt",
                  "type": null,
                  "default": null,
                  "description": "integration timestep"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "step",
              "description": "Finalizes the timestep by resetting the solver for the implicit",
              "docstring_html": "<p>Finalizes the timestep by resetting the solver for the implicit\nupdate equation and computing the lower and higher order estimate\nof the solution.</p>\n<p>Then calls the error controller.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>f <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array_like</span></dt>\n<dd>evaluation of function</dd>\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>integration timestep</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>success <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>True if the timestep was successful</dd>\n<dt>error <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>estimated error of the internal error controller</dd>\n<dt>scale <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>estimated timestep rescale factor for error control</dd>\n</dl>\n",
              "source": "def step(self, f, dt):\n    \"\"\"Finalizes the timestep by resetting the solver for the implicit \n    update equation and computing the lower and higher order estimate \n    of the solution. \n\n    Then calls the error controller.\n\n    Parameters\n    ----------\n    f : array_like\n        evaluation of function\n    dt : float \n        integration timestep\n\n    Returns \n    -------\n    success : bool\n        True if the timestep was successful\n    error : float\n        estimated error of the internal error controller\n    scale : float\n        estimated timestep rescale factor for error control\n    \"\"\"\n\n    #not enough history for full order -> step with startup method\n    if self._needs_startup:\n        suc, err, scl = self.startup.step(f, dt)\n        self.x = self.startup.get()\n        return suc, err, scl\n\n    #lower and higher order\n    n_m, n_p = self.n - 1, self.n + 1 \n\n    #estimate truncation error from lower order solution\n    tr_m = self.x - self.F[n_m] * dt * f\n    for b, k in zip(self.history, self.K[n_m]):\n        tr_m = tr_m - b * k\n\n    #estimate truncation error from higher order solution\n    tr_p = self.x - self.F[n_p] * dt * f\n    for b, k in zip(self.history, self.K[n_p]):\n        tr_p = tr_p - b * k\n\n    return self.error_controller(tr_m, tr_p)",
              "signature": "(f, dt)",
              "parameters": [
                {
                  "name": "f",
                  "type": null,
                  "default": null,
                  "description": "evaluation of function"
                },
                {
                  "name": "dt",
                  "type": null,
                  "default": null,
                  "description": "integration timestep"
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "n",
              "description": "",
              "type": null,
              "value": "2"
            },
            {
              "name": "history",
              "description": "",
              "type": null,
              "value": "deque([], maxlen=6)"
            },
            {
              "name": "history_dt",
              "description": "",
              "type": null,
              "value": "deque([], maxlen=6)"
            }
          ],
          "parameters": [
            {
              "name": "solver_args",
              "type": null,
              "default": "()",
              "description": ""
            },
            {
              "name": "solver_kwargs",
              "type": null,
              "default": "{}",
              "description": ""
            }
          ]
        }
      ],
      "functions": [
        {
          "name": "compute_bdf_coefficients",
          "description": "Computes the coefficients for backward differentiation formulas for a given order.",
          "docstring_html": "<p>Computes the coefficients for backward differentiation formulas for a given order.\nThe timesteps can be specified for variable timestep BDF methods.</p>\n<dl class=\"docutils\">\n<dt>For m-th order BDF we have for the n-th timestep:</dt>\n<dd>sum(alpha_i * x_i; i=n-m,...,n) = h_n * f_n(x_n, t_n)</dd>\n<dt>or</dt>\n<dd>x_n = beta * h_n * f_n(x_n, t_n) - sum(alpha_j * x_{n-1-j}; j=0,...,order-1)</dd>\n</dl>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>order <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>order of the integration scheme</dd>\n<dt>timesteps <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array[float]</span></dt>\n<dd>timestep buffer (h_{n-j}; j=0,...,order-1)</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>beta <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>weight for function</dd>\n<dt>alpha <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array[float]</span></dt>\n<dd>weights for previous solutions</dd>\n</dl>\n",
          "source": "def compute_bdf_coefficients(order, timesteps):\n    \"\"\"Computes the coefficients for backward differentiation formulas for a given order.\n    The timesteps can be specified for variable timestep BDF methods. \n\n    For m-th order BDF we have for the n-th timestep:\n        sum(alpha_i * x_i; i=n-m,...,n) = h_n * f_n(x_n, t_n)\n    or \n        x_n = beta * h_n * f_n(x_n, t_n) - sum(alpha_j * x_{n-1-j}; j=0,...,order-1)\n\n    Parameters\n    ----------\n    order : int\n        order of the integration scheme\n    timesteps : array[float]\n        timestep buffer (h_{n-j}; j=0,...,order-1)\n\n    Returns\n    ------- \n    beta : float\n        weight for function\n    alpha : array[float]\n        weights for previous solutions\n    \"\"\"\n\n    #check if valid order\n    if order < 1:\n        raise RuntimeError(f\"BDF coefficients of order '{order}' not possible!\")\n\n    #quit early for no buffer (euler backward)\n    if len(timesteps) < 2:\n        return 1.0, [1.0]\n\n    # Compute timestep ratios rho_j = h_{n-j} / h_n\n    rho = timesteps[1:] / timesteps[0]\n\n    # Compute normalized time differences theta_j\n    theta = -np.ones(order + 1)\n    theta[0] = 0\n    for j in range(2, order + 1):\n        theta[j] -= sum(rho[:j - 1])\n\n    # Set up the linear system (p + 1 equations)\n    A = np.zeros((order + 1, order + 1))\n    b = np.zeros(order + 1)\n    b[1] = 1 \n    for m in range(order + 1):\n        A[m, :] = theta ** m \n\n    # Solve the linear system A * alpha = b\n    alphas = np.linalg.solve(A, b)\n\n    #return function and buffer weights\n    return 1 / alphas[0], -alphas[1:] / alphas[0]",
          "signature": "(order, timesteps)",
          "parameters": [
            {
              "name": "order",
              "type": null,
              "default": null,
              "description": "order of the integration scheme"
            },
            {
              "name": "timesteps",
              "type": null,
              "default": null,
              "description": "timestep buffer (h_{n-j}; j=0,...,order-1)"
            }
          ],
          "returns": null
        }
      ]
    },
    "pathsim.solvers.rk4": {
      "name": "pathsim.solvers.rk4",
      "description": "",
      "docstring_html": "",
      "classes": [
        {
          "name": "RK4",
          "description": "Classical four-stage, 4th order explicit Runge-Kutta method.",
          "docstring_html": "<p>Classical four-stage, 4th order explicit Runge-Kutta method.</p>\n<p>The most well-known Runge-Kutta method. It provides a good balance\nbetween accuracy and computational cost for non-stiff problems. Not SSP.</p>\n<dl class=\"docutils\">\n<dt>Characteristics:</dt>\n<dd><ul class=\"first last simple\">\n<li>Order: 4</li>\n<li>Stages: 4</li>\n<li>Explicit</li>\n<li>Fixed timestep only</li>\n<li>Widely used, good general-purpose explicit solver.</li>\n</ul>\n</dd>\n</dl>\n",
          "source": "class RK4(ExplicitRungeKutta):\n    \"\"\"Classical four-stage, 4th order explicit Runge-Kutta method.\n\n    The most well-known Runge-Kutta method. It provides a good balance \n    between accuracy and computational cost for non-stiff problems. Not SSP.\n\n    Characteristics:\n        * Order: 4\n        * Stages: 4\n        * Explicit\n        * Fixed timestep only\n        * Widely used, good general-purpose explicit solver.\n    \"\"\"\n\n    def __init__(self, *solver_args, **solver_kwargs):\n        super().__init__(*solver_args, **solver_kwargs)\n\n        #number of stages in RK scheme\n        self.s = 4\n\n        #order of scheme\n        self.n = 4\n\n        #intermediate evaluation times\n        self.eval_stages = [0.0, 0.5, 0.5, 1.0]\n\n        #butcher table\n        self.BT = {0:[1/2],\n                   1:[0.0, 1/2],\n                   2:[0.0, 0.0, 1.0], \n                   3:[1/6, 2/6, 2/6, 1/6]}\n\n\n    def interpolate(self, r, dt):\n        k1, k2, k3, k4 = self.K[0], self.K[1], self.K[2], self.K[3]\n        b1, b2, b3, b4 = r*(1-r)**2/6, r**2*(2-3*r)/2, r**2*(3*r-4)/2, r**3/6\n        return self.x_0 + dt*(b1 * k1 + b2 * k2 + b3 * k3 + b4 * k4)",
          "bases": [
            "pathsim.solvers._rungekutta.ExplicitRungeKutta"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, *solver_args, **solver_kwargs):\n    super().__init__(*solver_args, **solver_kwargs)\n\n    #number of stages in RK scheme\n    self.s = 4\n\n    #order of scheme\n    self.n = 4\n\n    #intermediate evaluation times\n    self.eval_stages = [0.0, 0.5, 0.5, 1.0]\n\n    #butcher table\n    self.BT = {0:[1/2],\n               1:[0.0, 1/2],\n               2:[0.0, 0.0, 1.0], \n               3:[1/6, 2/6, 2/6, 1/6]}",
              "signature": "(solver_args = (), solver_kwargs = {})",
              "parameters": [
                {
                  "name": "solver_args",
                  "type": null,
                  "default": "()",
                  "description": ""
                },
                {
                  "name": "solver_kwargs",
                  "type": null,
                  "default": "{}",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "interpolate",
              "description": "",
              "docstring_html": "",
              "source": "def interpolate(self, r, dt):\n    k1, k2, k3, k4 = self.K[0], self.K[1], self.K[2], self.K[3]\n    b1, b2, b3, b4 = r*(1-r)**2/6, r**2*(2-3*r)/2, r**2*(3*r-4)/2, r**3/6\n    return self.x_0 + dt*(b1 * k1 + b2 * k2 + b3 * k3 + b4 * k4)",
              "signature": "(r, dt)",
              "parameters": [
                {
                  "name": "r",
                  "type": null,
                  "default": null,
                  "description": ""
                },
                {
                  "name": "dt",
                  "type": null,
                  "default": null,
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "s",
              "description": "",
              "type": null,
              "value": "4"
            },
            {
              "name": "n",
              "description": "",
              "type": null,
              "value": "4"
            },
            {
              "name": "eval_stages",
              "description": "",
              "type": null,
              "value": "[0.0, 0.5, 0.5, 1.0]"
            },
            {
              "name": "BT",
              "description": "",
              "type": null,
              "value": "{0: [1 / 2], 1: [0.0, 1 / 2], 2: [0.0, 0.0, 1.0], 3: [1 / 6, 2 / 6, 2 / 6, 1 / 6]}"
            }
          ],
          "parameters": [
            {
              "name": "solver_args",
              "type": null,
              "default": "()",
              "description": ""
            },
            {
              "name": "solver_kwargs",
              "type": null,
              "default": "{}",
              "description": ""
            }
          ]
        }
      ],
      "functions": []
    },
    "pathsim.solvers.rkbs32": {
      "name": "pathsim.solvers.rkbs32",
      "description": "",
      "docstring_html": "",
      "classes": [
        {
          "name": "RKBS32",
          "description": "Four-stage, 3rd order explicit Runge-Kutta method by Bogacki and Shampine.",
          "docstring_html": "<p>Four-stage, 3rd order explicit Runge-Kutta method by Bogacki and Shampine.</p>\n<p>Features an embedded 2nd order method for adaptive step size control (FSAL property -\nFirst Same As Last). The 3rd order result is used for propagation. Commonly used in\nsoftware packages (e.g., MATLAB's ode23). Good for problems requiring low to moderate\naccuracy with efficiency.</p>\n<dl class=\"docutils\">\n<dt>Characteristics:</dt>\n<dd><ul class=\"first last simple\">\n<li>Order: 3 (Propagating solution)</li>\n<li>Embedded Order: 2 (Error estimation)</li>\n<li>Stages: 4 (3 effective due to FSAL)</li>\n<li>Explicit</li>\n<li>Adaptive timestep</li>\n<li>Efficient low-to-moderate accuracy solver.</li>\n</ul>\n</dd>\n</dl>\n",
          "source": "class RKBS32(ExplicitRungeKutta):\n    \"\"\"Four-stage, 3rd order explicit Runge-Kutta method by Bogacki and Shampine.\n\n    Features an embedded 2nd order method for adaptive step size control (FSAL property -\n    First Same As Last). The 3rd order result is used for propagation. Commonly used in\n    software packages (e.g., MATLAB's ode23). Good for problems requiring low to moderate\n    accuracy with efficiency.\n\n    Characteristics:\n        * Order: 3 (Propagating solution)\n        * Embedded Order: 2 (Error estimation)\n        * Stages: 4 (3 effective due to FSAL)\n        * Explicit\n        * Adaptive timestep\n        * Efficient low-to-moderate accuracy solver.\n    \"\"\"\n\n    def __init__(self, *solver_args, **solver_kwargs):\n        super().__init__(*solver_args, **solver_kwargs)\n\n        #number of stages in RK scheme\n        self.s = 4\n\n        #order of scheme and embedded method\n        self.n = 3\n        self.m = 2\n\n        #flag adaptive timestep solver\n        self.is_adaptive = True\n\n        #intermediate evaluation times\n        self.eval_stages = [0.0, 1/2, 3/4, 1.0]\n\n        #extended butcher table\n        self.BT = {0:[1/2],\n                   1:[0.0 , 3/4],\n                   2:[2/9 , 1/3, 4/9],\n                   3:[2/9 , 1/3, 4/9]}\n\n        #coefficients for truncation error estimate\n        self.TR = [-5/72, 1/12, 1/9, -1/8]",
          "bases": [
            "pathsim.solvers._rungekutta.ExplicitRungeKutta"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, *solver_args, **solver_kwargs):\n    super().__init__(*solver_args, **solver_kwargs)\n\n    #number of stages in RK scheme\n    self.s = 4\n\n    #order of scheme and embedded method\n    self.n = 3\n    self.m = 2\n\n    #flag adaptive timestep solver\n    self.is_adaptive = True\n\n    #intermediate evaluation times\n    self.eval_stages = [0.0, 1/2, 3/4, 1.0]\n\n    #extended butcher table\n    self.BT = {0:[1/2],\n               1:[0.0 , 3/4],\n               2:[2/9 , 1/3, 4/9],\n               3:[2/9 , 1/3, 4/9]}\n\n    #coefficients for truncation error estimate\n    self.TR = [-5/72, 1/12, 1/9, -1/8]",
              "signature": "(solver_args = (), solver_kwargs = {})",
              "parameters": [
                {
                  "name": "solver_args",
                  "type": null,
                  "default": "()",
                  "description": ""
                },
                {
                  "name": "solver_kwargs",
                  "type": null,
                  "default": "{}",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "s",
              "description": "",
              "type": null,
              "value": "4"
            },
            {
              "name": "n",
              "description": "",
              "type": null,
              "value": "3"
            },
            {
              "name": "m",
              "description": "",
              "type": null,
              "value": "2"
            },
            {
              "name": "is_adaptive",
              "description": "",
              "type": null,
              "value": "True"
            },
            {
              "name": "eval_stages",
              "description": "",
              "type": null,
              "value": "[0.0, 1 / 2, 3 / 4, 1.0]"
            },
            {
              "name": "BT",
              "description": "",
              "type": null,
              "value": "{0: [1 / 2], 1: [0.0, 3 / 4], 2: [2 / 9, 1 / 3, 4 / 9], 3: [2 / 9, 1 / 3, 4 / 9]}"
            },
            {
              "name": "TR",
              "description": "",
              "type": null,
              "value": "[-5 / 72, 1 / 12, 1 / 9, -1 / 8]"
            }
          ],
          "parameters": [
            {
              "name": "solver_args",
              "type": null,
              "default": "()",
              "description": ""
            },
            {
              "name": "solver_kwargs",
              "type": null,
              "default": "{}",
              "description": ""
            }
          ]
        }
      ],
      "functions": []
    },
    "pathsim.solvers.rkck54": {
      "name": "pathsim.solvers.rkck54",
      "description": "",
      "docstring_html": "",
      "classes": [
        {
          "name": "RKCK54",
          "description": "Six-stage, 5th order explicit Runge-Kutta method by Cash and Karp.",
          "docstring_html": "<p>Six-stage, 5th order explicit Runge-Kutta method by Cash and Karp.</p>\n<p>Features an embedded 4th order method. The difference between the 5th and 4th order\nresults provides a 5th order error estimate, typically used to control the step size\nwhile propagating the 5th order solution (local extrapolation). Known for good stability\nproperties compared to RKF45.</p>\n<dl class=\"docutils\">\n<dt>Characteristics:</dt>\n<dd><ul class=\"first last simple\">\n<li>Order: 5 (Propagating solution)</li>\n<li>Embedded Order: 4</li>\n<li>Stages: 6</li>\n<li>Explicit</li>\n<li>Adaptive timestep</li>\n<li>Good stability, suitable for moderate accuracy requirements.</li>\n</ul>\n</dd>\n</dl>\n",
          "source": "class RKCK54(ExplicitRungeKutta):\n    \"\"\"Six-stage, 5th order explicit Runge-Kutta method by Cash and Karp.\n\n    Features an embedded 4th order method. The difference between the 5th and 4th order\n    results provides a 5th order error estimate, typically used to control the step size\n    while propagating the 5th order solution (local extrapolation). Known for good stability\n    properties compared to RKF45.\n\n    Characteristics:\n        * Order: 5 (Propagating solution)\n        * Embedded Order: 4\n        * Stages: 6\n        * Explicit\n        * Adaptive timestep\n        * Good stability, suitable for moderate accuracy requirements.\n    \"\"\"\n\n    def __init__(self, *solver_args, **solver_kwargs):\n        super().__init__(*solver_args, **solver_kwargs)\n\n        #number of stages in RK scheme\n        self.s = 6\n\n        #order of scheme and embedded method\n        self.n = 5\n        self.m = 4\n\n        #flag adaptive timestep solver\n        self.is_adaptive = True\n\n        #intermediate evaluation times\n        self.eval_stages = [0.0, 1/5, 3/10, 3/5, 1, 7/8]\n\n        #extended butcher table \n        self.BT = {0:[       1/5],\n                   1:[      3/40,    9/40],\n                   2:[      3/10,   -9/10,       6/5],\n                   3:[    -11/54,     5/2,    -70/27,        35/27],\n                   4:[1631/55296, 175/512, 575/13824, 44275/110592, 253/4096],\n                   5:[    37/378,       0,   250/621,      125/594,        0, 512/1771]}\n\n        #coefficients for local truncation error estimate\n        self.TR = [-277/64512, 0, 6925/370944, -6925/202752, -277/14336, 277/7084]",
          "bases": [
            "pathsim.solvers._rungekutta.ExplicitRungeKutta"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, *solver_args, **solver_kwargs):\n    super().__init__(*solver_args, **solver_kwargs)\n\n    #number of stages in RK scheme\n    self.s = 6\n\n    #order of scheme and embedded method\n    self.n = 5\n    self.m = 4\n\n    #flag adaptive timestep solver\n    self.is_adaptive = True\n\n    #intermediate evaluation times\n    self.eval_stages = [0.0, 1/5, 3/10, 3/5, 1, 7/8]\n\n    #extended butcher table \n    self.BT = {0:[       1/5],\n               1:[      3/40,    9/40],\n               2:[      3/10,   -9/10,       6/5],\n               3:[    -11/54,     5/2,    -70/27,        35/27],\n               4:[1631/55296, 175/512, 575/13824, 44275/110592, 253/4096],\n               5:[    37/378,       0,   250/621,      125/594,        0, 512/1771]}\n\n    #coefficients for local truncation error estimate\n    self.TR = [-277/64512, 0, 6925/370944, -6925/202752, -277/14336, 277/7084]",
              "signature": "(solver_args = (), solver_kwargs = {})",
              "parameters": [
                {
                  "name": "solver_args",
                  "type": null,
                  "default": "()",
                  "description": ""
                },
                {
                  "name": "solver_kwargs",
                  "type": null,
                  "default": "{}",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "s",
              "description": "",
              "type": null,
              "value": "6"
            },
            {
              "name": "n",
              "description": "",
              "type": null,
              "value": "5"
            },
            {
              "name": "m",
              "description": "",
              "type": null,
              "value": "4"
            },
            {
              "name": "is_adaptive",
              "description": "",
              "type": null,
              "value": "True"
            },
            {
              "name": "eval_stages",
              "description": "",
              "type": null,
              "value": "[0.0, 1 / 5, 3 / 10, 3 / 5, 1, 7 / 8]"
            },
            {
              "name": "BT",
              "description": "",
              "type": null,
              "value": "{0: [1 / 5], 1: [3 / 40, 9 / 40], 2: [3 / 10, -9 / 10, 6 / 5], 3: [-11 / 54, 5 / 2, -70 / 27, 35 / 27], 4: [1631 / 55296, 175 / 512, 575 / 13824, 44275 / 110592, 253 / 4096], 5: [37 / 378, 0, 250 / 621, 125 / 594, 0, 512 / 1771]}"
            },
            {
              "name": "TR",
              "description": "",
              "type": null,
              "value": "[-277 / 64512, 0, 6925 / 370944, -6925 / 202752, -277 / 14336, 277 / 7084]"
            }
          ],
          "parameters": [
            {
              "name": "solver_args",
              "type": null,
              "default": "()",
              "description": ""
            },
            {
              "name": "solver_kwargs",
              "type": null,
              "default": "{}",
              "description": ""
            }
          ]
        }
      ],
      "functions": []
    },
    "pathsim.solvers.rkdp54": {
      "name": "pathsim.solvers.rkdp54",
      "description": "",
      "docstring_html": "",
      "classes": [
        {
          "name": "RKDP54",
          "description": "Seven-stage, 5th order explicit Runge-Kutta method by Dormand and Prince (DOPRI5(4)).",
          "docstring_html": "<p>Seven-stage, 5th order explicit Runge-Kutta method by Dormand and Prince (DOPRI5(4)).</p>\n<p>Features an embedded 4th order method. Widely considered one of the most efficient\ngeneral-purpose adaptive step size solvers for non-stiff problems requiring moderate\nto high accuracy. The 5th order result is used for propagation. Used as the basis for\nMATLAB's ode45. FSAL property (not available in this implementation).</p>\n<dl class=\"docutils\">\n<dt>Characteristics:</dt>\n<dd><ul class=\"first last simple\">\n<li>Order: 5 (Propagating solution)</li>\n<li>Embedded Order: 4</li>\n<li>Stages: 7 (6 effective due to FSAL, not here though)</li>\n<li>Explicit</li>\n<li>Adaptive timestep</li>\n</ul>\n</dd>\n</dl>\n",
          "source": "class RKDP54(ExplicitRungeKutta):\n    \"\"\"Seven-stage, 5th order explicit Runge-Kutta method by Dormand and Prince (DOPRI5(4)).\n\n    Features an embedded 4th order method. Widely considered one of the most efficient\n    general-purpose adaptive step size solvers for non-stiff problems requiring moderate\n    to high accuracy. The 5th order result is used for propagation. Used as the basis for\n    MATLAB's ode45. FSAL property (not available in this implementation).\n\n    Characteristics:\n        * Order: 5 (Propagating solution)\n        * Embedded Order: 4\n        * Stages: 7 (6 effective due to FSAL, not here though)\n        * Explicit\n        * Adaptive timestep\n    \"\"\"\n\n    def __init__(self, *solver_args, **solver_kwargs):\n        super().__init__(*solver_args, **solver_kwargs)\n\n        #number of stages in RK scheme\n        self.s = 7\n\n        #order of scheme and embedded method\n        self.n = 5\n        self.m = 4\n\n        #flag adaptive timestep solver\n        self.is_adaptive = True\n\n        #intermediate evaluation times\n        self.eval_stages = [0.0, 1/5, 3/10, 4/5, 8/9, 1.0, 1.0]\n\n        #extended butcher table\n        self.BT = {0:[       1/5],\n                   1:[      3/40,        9/40],\n                   2:[     44/45,      -56/15,       32/9], \n                   3:[19372/6561, -25360/2187, 64448/6561, -212/729],\n                   4:[ 9017/3168,     -355/33, 46732/5247,   49/176, -5103/18656],\n                   5:[    35/384,           0,   500/1113,  125/192,  -2187/6784, 11/84],\n                   6:[    35/384,           0,   500/1113,  125/192,  -2187/6784, 11/84]}\n\n        #coefficients for local truncation error estimate\n        self.TR = [71/57600, 0, - 71/16695, 71/1920, -17253/339200, 22/525, -1/40]",
          "bases": [
            "pathsim.solvers._rungekutta.ExplicitRungeKutta"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, *solver_args, **solver_kwargs):\n    super().__init__(*solver_args, **solver_kwargs)\n\n    #number of stages in RK scheme\n    self.s = 7\n\n    #order of scheme and embedded method\n    self.n = 5\n    self.m = 4\n\n    #flag adaptive timestep solver\n    self.is_adaptive = True\n\n    #intermediate evaluation times\n    self.eval_stages = [0.0, 1/5, 3/10, 4/5, 8/9, 1.0, 1.0]\n\n    #extended butcher table\n    self.BT = {0:[       1/5],\n               1:[      3/40,        9/40],\n               2:[     44/45,      -56/15,       32/9], \n               3:[19372/6561, -25360/2187, 64448/6561, -212/729],\n               4:[ 9017/3168,     -355/33, 46732/5247,   49/176, -5103/18656],\n               5:[    35/384,           0,   500/1113,  125/192,  -2187/6784, 11/84],\n               6:[    35/384,           0,   500/1113,  125/192,  -2187/6784, 11/84]}\n\n    #coefficients for local truncation error estimate\n    self.TR = [71/57600, 0, - 71/16695, 71/1920, -17253/339200, 22/525, -1/40]",
              "signature": "(solver_args = (), solver_kwargs = {})",
              "parameters": [
                {
                  "name": "solver_args",
                  "type": null,
                  "default": "()",
                  "description": ""
                },
                {
                  "name": "solver_kwargs",
                  "type": null,
                  "default": "{}",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "s",
              "description": "",
              "type": null,
              "value": "7"
            },
            {
              "name": "n",
              "description": "",
              "type": null,
              "value": "5"
            },
            {
              "name": "m",
              "description": "",
              "type": null,
              "value": "4"
            },
            {
              "name": "is_adaptive",
              "description": "",
              "type": null,
              "value": "True"
            },
            {
              "name": "eval_stages",
              "description": "",
              "type": null,
              "value": "[0.0, 1 / 5, 3 / 10, 4 / 5, 8 / 9, 1.0, 1.0]"
            },
            {
              "name": "BT",
              "description": "",
              "type": null,
              "value": "{0: [1 / 5], 1: [3 / 40, 9 / 40], 2: [44 / 45, -56 / 15, 32 / 9], 3: [19372 / 6561, -25360 / 2187, 64448 / 6561, -212 / 729], 4: [9017 / 3168, -355 / 33, 46732 / 5247, 49 / 176, -5103 / 18656], 5: [35 / 384, 0, 500 / 1113, 125 / 192, -2187 / 6784, 11 / 84], 6: [35 / 384, 0, 500 / 1113, 125 / 192, -2187 / 6784, 11 / 84]}"
            },
            {
              "name": "TR",
              "description": "",
              "type": null,
              "value": "[71 / 57600, 0, -71 / 16695, 71 / 1920, -17253 / 339200, 22 / 525, -1 / 40]"
            }
          ],
          "parameters": [
            {
              "name": "solver_args",
              "type": null,
              "default": "()",
              "description": ""
            },
            {
              "name": "solver_kwargs",
              "type": null,
              "default": "{}",
              "description": ""
            }
          ]
        }
      ],
      "functions": []
    },
    "pathsim.solvers.rkdp87": {
      "name": "pathsim.solvers.rkdp87",
      "description": "",
      "docstring_html": "",
      "classes": [
        {
          "name": "RKDP87",
          "description": "Thirteen-stage, 8th order explicit Runge-Kutta method by Dormand and Prince (DOP8(7)).",
          "docstring_html": "<p>Thirteen-stage, 8th order explicit Runge-Kutta method by Dormand and Prince (DOP8(7)).</p>\n<p>Features an embedded 7th order method for adaptive step size control. Designed for\nproblems requiring very high accuracy. FSAL property (not available in this implementation).</p>\n<dl class=\"docutils\">\n<dt>Characteristics:</dt>\n<dd><ul class=\"first last simple\">\n<li>Order: 8 (Propagating solution)</li>\n<li>Embedded Order: 7</li>\n<li>Stages: 13 (12 effective due to FSAL)</li>\n<li>Explicit</li>\n<li>Adaptive timestep</li>\n</ul>\n</dd>\n</dl>\n",
          "source": "class RKDP87(ExplicitRungeKutta):\n    \"\"\"Thirteen-stage, 8th order explicit Runge-Kutta method by Dormand and Prince (DOP8(7)).\n\n    Features an embedded 7th order method for adaptive step size control. Designed for\n    problems requiring very high accuracy. FSAL property (not available in this implementation).\n\n    Characteristics:\n        * Order: 8 (Propagating solution)\n        * Embedded Order: 7\n        * Stages: 13 (12 effective due to FSAL)\n        * Explicit\n        * Adaptive timestep\n    \"\"\"\n\n    def __init__(self, *solver_args, **solver_kwargs):\n        super().__init__(*solver_args, **solver_kwargs)\n\n        #number of stages in RK scheme\n        self.s = 13\n\n        #order of scheme and embedded method\n        self.n = 8\n        self.m = 7\n\n        #flag adaptive timestep solver\n        self.is_adaptive = True\n\n        #intermediate evaluation times\n        self.eval_stages = [0.0, 1/18, 1/12, 1/8, 5/16, 3/8, 59/400, 93/200, 5490023248/9719169821, 13/20, 1201146811/1299019798, 1.0, 1.0]\n\n        #extended butcher table \n        self.BT = {0:[1/18],\n                   1:[1/48, 1/16],\n                   2:[1/32, 0, 3/32],\n                   3:[5/16, 0, -75/64, 75/64],\n                   4:[3/80, 0, 0, 3/16, 3/20],\n                   5:[29443841/614563906, 0, 0, 77736538/692538347, -28693883/1125000000, 23124283/1800000000],\n                   6:[16016141/946692911, 0, 0, 61564180/158732637, 22789713/633445777, 545815736/2771057229, -180193667/1043307555],\n                   7:[39632708/573591083, 0, 0, -433636366/683701615, -421739975/2616292301, 100302831/723423059, 790204164/839813087, 800635310/3783071287],\n                   8:[246121993/1340847787, 0, 0, -37695042795/15268766246, -309121744/1061227803, -12992083/490766935, 6005943493/2108947869, 393006217/1396673457, 123872331/1001029789],\n                   9:[-1028468189/846180014, 0, 0, 8478235783/508512852, 1311729495/1432422823, -10304129995/1701304382, -48777925059/3047939560, 15336726248/1032824649, -45442868181/3398467696, 3065993473/597172653],\n                   10:[185892177/718116043, 0, 0, -3185094517/667107341, -477755414/1098053517, -703635378/230739211, 5731566787/1027545527, 5232866602/850066563, -4093664535/808688257, 3962137247/1805957418, 65686358/487910083],\n                   11:[403863854/491063109, 0, 0, -5068492393/434740067, -411421997/543043805, 652783627/914296604, 11173962825/925320556, -13158990841/6184727034, 3936647629/1978049680, -160528059/685178525, 248638103/1413531060, 0],\n                   12:[14005451/335480064, 0, 0, 0, 0, -59238493/1068277825, 181606767/758867731, 561292985/797845732, -1041891430/1371343529, 760417239/1151165299, 118820643/751138087, -528747749/2220607170, 1/4]}\n\n        #coefficients for lower order solution evaluation\n        bh = [13451932/455176623, 0, 0, 0, 0, -808719846/976000145, 1757004468/5645159321, 656045339/265891186, -3867574721/1518517206, 465885868/322736535, 53011238/667516719, 2/45, 0]\n\n        #coefficients for truncation error\n        self.TR = [a-b for a, b in zip(self.BT[12], bh)]",
          "bases": [
            "pathsim.solvers._rungekutta.ExplicitRungeKutta"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, *solver_args, **solver_kwargs):\n    super().__init__(*solver_args, **solver_kwargs)\n\n    #number of stages in RK scheme\n    self.s = 13\n\n    #order of scheme and embedded method\n    self.n = 8\n    self.m = 7\n\n    #flag adaptive timestep solver\n    self.is_adaptive = True\n\n    #intermediate evaluation times\n    self.eval_stages = [0.0, 1/18, 1/12, 1/8, 5/16, 3/8, 59/400, 93/200, 5490023248/9719169821, 13/20, 1201146811/1299019798, 1.0, 1.0]\n\n    #extended butcher table \n    self.BT = {0:[1/18],\n               1:[1/48, 1/16],\n               2:[1/32, 0, 3/32],\n               3:[5/16, 0, -75/64, 75/64],\n               4:[3/80, 0, 0, 3/16, 3/20],\n               5:[29443841/614563906, 0, 0, 77736538/692538347, -28693883/1125000000, 23124283/1800000000],\n               6:[16016141/946692911, 0, 0, 61564180/158732637, 22789713/633445777, 545815736/2771057229, -180193667/1043307555],\n               7:[39632708/573591083, 0, 0, -433636366/683701615, -421739975/2616292301, 100302831/723423059, 790204164/839813087, 800635310/3783071287],\n               8:[246121993/1340847787, 0, 0, -37695042795/15268766246, -309121744/1061227803, -12992083/490766935, 6005943493/2108947869, 393006217/1396673457, 123872331/1001029789],\n               9:[-1028468189/846180014, 0, 0, 8478235783/508512852, 1311729495/1432422823, -10304129995/1701304382, -48777925059/3047939560, 15336726248/1032824649, -45442868181/3398467696, 3065993473/597172653],\n               10:[185892177/718116043, 0, 0, -3185094517/667107341, -477755414/1098053517, -703635378/230739211, 5731566787/1027545527, 5232866602/850066563, -4093664535/808688257, 3962137247/1805957418, 65686358/487910083],\n               11:[403863854/491063109, 0, 0, -5068492393/434740067, -411421997/543043805, 652783627/914296604, 11173962825/925320556, -13158990841/6184727034, 3936647629/1978049680, -160528059/685178525, 248638103/1413531060, 0],\n               12:[14005451/335480064, 0, 0, 0, 0, -59238493/1068277825, 181606767/758867731, 561292985/797845732, -1041891430/1371343529, 760417239/1151165299, 118820643/751138087, -528747749/2220607170, 1/4]}\n\n    #coefficients for lower order solution evaluation\n    bh = [13451932/455176623, 0, 0, 0, 0, -808719846/976000145, 1757004468/5645159321, 656045339/265891186, -3867574721/1518517206, 465885868/322736535, 53011238/667516719, 2/45, 0]\n\n    #coefficients for truncation error\n    self.TR = [a-b for a, b in zip(self.BT[12], bh)]",
              "signature": "(solver_args = (), solver_kwargs = {})",
              "parameters": [
                {
                  "name": "solver_args",
                  "type": null,
                  "default": "()",
                  "description": ""
                },
                {
                  "name": "solver_kwargs",
                  "type": null,
                  "default": "{}",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "s",
              "description": "",
              "type": null,
              "value": "13"
            },
            {
              "name": "n",
              "description": "",
              "type": null,
              "value": "8"
            },
            {
              "name": "m",
              "description": "",
              "type": null,
              "value": "7"
            },
            {
              "name": "is_adaptive",
              "description": "",
              "type": null,
              "value": "True"
            },
            {
              "name": "eval_stages",
              "description": "",
              "type": null,
              "value": "[0.0, 1 / 18, 1 / 12, 1 / 8, 5 / 16, 3 / 8, 59 / 400, 93 / 200, 5490023248 / 9719169821, 13 / 20, 1201146811 / 1299019798, 1.0, 1.0]"
            },
            {
              "name": "BT",
              "description": "",
              "type": null,
              "value": "{0: [1 / 18], 1: [1 / 48, 1 / 16], 2: [1 / 32, 0, 3 / 32], 3: [5 / 16, 0, -75 / 64, 75 / 64], 4: [3 / 80, 0, 0, 3 / 16, 3 / 20], 5: [29443841 / 614563906, 0, 0, 77736538 / 692538347, -28693883 / 1125000000, 23124283 / 1800000000], 6: [16016141 / 946692911, 0, 0, 61564180 / 158732637, 22789713 / 633445777, 545815736 / 2771057229, -180193667 / 1043307555], 7: [39632708 / 573591083, 0, 0, -433636366 / 683701615, -421739975 / 2616292301, 100302831 / 723423059, 790204164 / 839813087, 800635310 / 3783071287], 8: [246121993 / 1340847787, 0, 0, -37695042795 / 15268766246, -309121744 / 1061227803, -12992083 / 490766935, 6005943493 / 2108947869, 393006217 / 1396673457, 123872331 / 1001029789], 9: [-1028468189 / 846180014, 0, 0, 8478235783 / 508512852, 1311729495 / 1432422823, -10304129995 / 1701304382, -48777925059 / 3047939560, 15336726248 / 1032824649, -45442868181 / 3398467696, 3065993473 / 597172653], 10: [185892177 / 718116043, 0, 0, -3185094517 / 667107341, -477755414 / 1098053517, -703635378 / 230739211, 5731566787 / 1027545527, 5232866602 / 850066563, -4093664535 / 808688257, 3962137247 / 1805957418, 65686358 / 487910083], 11: [403863854 / 491063109, 0, 0, -5068492393 / 434740067, -411421997 / 543043805, 652783627 / 914296604, 11173962825 / 925320556, -13158990841 / 6184727034, 3936647629 / 1978049680, -160528059 / 685178525, 248638103 / 1413531060, 0], 12: [14005451 / 335480064, 0, 0, 0, 0, -59238493 / 1068277825, 181606767 / 758867731, 561292985 / 797845732, -1041891430 / 1371343529, 760417239 / 1151165299, 118820643 / 751138087, -528747749 / 2220607170, 1 / 4]}"
            },
            {
              "name": "TR",
              "description": "",
              "type": null,
              "value": "[(a - b) for a, b in (zip(self.BT[12], bh))]"
            }
          ],
          "parameters": [
            {
              "name": "solver_args",
              "type": null,
              "default": "()",
              "description": ""
            },
            {
              "name": "solver_kwargs",
              "type": null,
              "default": "{}",
              "description": ""
            }
          ]
        }
      ],
      "functions": []
    },
    "pathsim.solvers.rkf21": {
      "name": "pathsim.solvers.rkf21",
      "description": "",
      "docstring_html": "",
      "classes": [
        {
          "name": "RKF21",
          "description": "3-stage 2-nd order embedded Runge-Kutta-Fehlberg method",
          "docstring_html": "<p>3-stage 2-nd order embedded Runge-Kutta-Fehlberg method\nwith 2-nd order truncation error estimate that can be used to\nadaptively control the timestep.</p>\n<p>This is an absolute classic, the three stages make it relatively\ncheap, but its only second order and the error estimate is not that\naccurate. However, if you need some kind of adaptive integrator, and\nthe timestep is not limited by the local truncation error, this solver\nmight be a good choice.</p>\n",
          "source": "class RKF21(ExplicitRungeKutta):\n    \"\"\"3-stage 2-nd order embedded Runge-Kutta-Fehlberg method \n    with 2-nd order truncation error estimate that can be used to \n    adaptively control the timestep.\n\n    This is an absolute classic, the three stages make it relatively \n    cheap, but its only second order and the error estimate is not that \n    accurate. However, if you need some kind of adaptive integrator, and \n    the timestep is not limited by the local truncation error, this solver \n    might be a good choice.\n\n    \"\"\"\n\n    def __init__(self, *solver_args, **solver_kwargs):\n        super().__init__(*solver_args, **solver_kwargs)\n\n        #number of stages in RK scheme\n        self.s = 3\n\n        #order of scheme and embedded method\n        self.n = 2\n        self.m = 1\n\n        #flag adaptive timestep solver\n        self.is_adaptive = True\n\n        #intermediate evaluation times\n        self.eval_stages = [0.0, 1/2, 1]\n\n        #extended butcher table \n        self.BT = {0:[  1/2],\n                   1:[1/256, 255/256],\n                   2:[1/512, 255/256, 1/512]}\n\n        #coefficients for local truncation error estimate\n        self.TR = [1/512, 0, -1/512]",
          "bases": [
            "pathsim.solvers._rungekutta.ExplicitRungeKutta"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, *solver_args, **solver_kwargs):\n    super().__init__(*solver_args, **solver_kwargs)\n\n    #number of stages in RK scheme\n    self.s = 3\n\n    #order of scheme and embedded method\n    self.n = 2\n    self.m = 1\n\n    #flag adaptive timestep solver\n    self.is_adaptive = True\n\n    #intermediate evaluation times\n    self.eval_stages = [0.0, 1/2, 1]\n\n    #extended butcher table \n    self.BT = {0:[  1/2],\n               1:[1/256, 255/256],\n               2:[1/512, 255/256, 1/512]}\n\n    #coefficients for local truncation error estimate\n    self.TR = [1/512, 0, -1/512]",
              "signature": "(solver_args = (), solver_kwargs = {})",
              "parameters": [
                {
                  "name": "solver_args",
                  "type": null,
                  "default": "()",
                  "description": ""
                },
                {
                  "name": "solver_kwargs",
                  "type": null,
                  "default": "{}",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "s",
              "description": "",
              "type": null,
              "value": "3"
            },
            {
              "name": "n",
              "description": "",
              "type": null,
              "value": "2"
            },
            {
              "name": "m",
              "description": "",
              "type": null,
              "value": "1"
            },
            {
              "name": "is_adaptive",
              "description": "",
              "type": null,
              "value": "True"
            },
            {
              "name": "eval_stages",
              "description": "",
              "type": null,
              "value": "[0.0, 1 / 2, 1]"
            },
            {
              "name": "BT",
              "description": "",
              "type": null,
              "value": "{0: [1 / 2], 1: [1 / 256, 255 / 256], 2: [1 / 512, 255 / 256, 1 / 512]}"
            },
            {
              "name": "TR",
              "description": "",
              "type": null,
              "value": "[1 / 512, 0, -1 / 512]"
            }
          ],
          "parameters": [
            {
              "name": "solver_args",
              "type": null,
              "default": "()",
              "description": ""
            },
            {
              "name": "solver_kwargs",
              "type": null,
              "default": "{}",
              "description": ""
            }
          ]
        }
      ],
      "functions": []
    },
    "pathsim.solvers.rkf45": {
      "name": "pathsim.solvers.rkf45",
      "description": "",
      "docstring_html": "",
      "classes": [
        {
          "name": "RKF45",
          "description": "Six-stage, 4th order explicit Runge-Kutta method by Fehlberg.",
          "docstring_html": "<p>Six-stage, 4th order explicit Runge-Kutta method by Fehlberg.</p>\n<p>Features an embedded 5th order method. The difference between the 5th and 4th order\nresults provides a 5th order error estimate. Typically, the 4th order solution is\npropagated. A classic adaptive step size method, though often superseded in efficiency\nby Dormand-Prince methods.</p>\n<dl class=\"docutils\">\n<dt>Characteristics:</dt>\n<dd><ul class=\"first last simple\">\n<li>Order: 4 (Propagating solution)</li>\n<li>Embedded Order: 5 (Error estimation)</li>\n<li>Stages: 6</li>\n<li>Explicit</li>\n<li>Adaptive timestep</li>\n<li>Classic adaptive method, good for moderate accuracy.</li>\n</ul>\n</dd>\n</dl>\n",
          "source": "class RKF45(ExplicitRungeKutta):\n    \"\"\"Six-stage, 4th order explicit Runge-Kutta method by Fehlberg.\n\n    Features an embedded 5th order method. The difference between the 5th and 4th order\n    results provides a 5th order error estimate. Typically, the 4th order solution is\n    propagated. A classic adaptive step size method, though often superseded in efficiency\n    by Dormand-Prince methods.\n\n    Characteristics:\n        * Order: 4 (Propagating solution)\n        * Embedded Order: 5 (Error estimation)\n        * Stages: 6\n        * Explicit\n        * Adaptive timestep\n        * Classic adaptive method, good for moderate accuracy.\n    \"\"\"\n\n    def __init__(self, *solver_args, **solver_kwargs):\n        super().__init__(*solver_args, **solver_kwargs)\n\n        #number of stages in RK scheme\n        self.s = 6\n\n        #order of scheme and embedded method\n        self.n = 5\n        self.m = 4\n\n        #flag adaptive timestep solver\n        self.is_adaptive = True\n\n        #intermediate evaluation times\n        self.eval_stages = [0.0, 1/4, 3/8, 12/13, 1, 1/2]\n\n        #extended butcher table \n        self.BT = {0:[      1/4],\n                   1:[     3/32,       9/32],\n                   2:[1932/2197, -7200/2197,  7296/2197],\n                   3:[  439/216,         -8,   3680/513, -845/4104],\n                   4:[    -8/27,          2, -3554/2565, 1859/4104, -11/40],\n                   5:[   25/216,          0,  1408/2565, 2197/4104,   -1/5, 0]}\n\n        #coefficients for local truncation error estimate\n        self.TR = [1/360, 0, -128/4275, -2197/75240, 1/50, 2/55]",
          "bases": [
            "pathsim.solvers._rungekutta.ExplicitRungeKutta"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, *solver_args, **solver_kwargs):\n    super().__init__(*solver_args, **solver_kwargs)\n\n    #number of stages in RK scheme\n    self.s = 6\n\n    #order of scheme and embedded method\n    self.n = 5\n    self.m = 4\n\n    #flag adaptive timestep solver\n    self.is_adaptive = True\n\n    #intermediate evaluation times\n    self.eval_stages = [0.0, 1/4, 3/8, 12/13, 1, 1/2]\n\n    #extended butcher table \n    self.BT = {0:[      1/4],\n               1:[     3/32,       9/32],\n               2:[1932/2197, -7200/2197,  7296/2197],\n               3:[  439/216,         -8,   3680/513, -845/4104],\n               4:[    -8/27,          2, -3554/2565, 1859/4104, -11/40],\n               5:[   25/216,          0,  1408/2565, 2197/4104,   -1/5, 0]}\n\n    #coefficients for local truncation error estimate\n    self.TR = [1/360, 0, -128/4275, -2197/75240, 1/50, 2/55]",
              "signature": "(solver_args = (), solver_kwargs = {})",
              "parameters": [
                {
                  "name": "solver_args",
                  "type": null,
                  "default": "()",
                  "description": ""
                },
                {
                  "name": "solver_kwargs",
                  "type": null,
                  "default": "{}",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "s",
              "description": "",
              "type": null,
              "value": "6"
            },
            {
              "name": "n",
              "description": "",
              "type": null,
              "value": "5"
            },
            {
              "name": "m",
              "description": "",
              "type": null,
              "value": "4"
            },
            {
              "name": "is_adaptive",
              "description": "",
              "type": null,
              "value": "True"
            },
            {
              "name": "eval_stages",
              "description": "",
              "type": null,
              "value": "[0.0, 1 / 4, 3 / 8, 12 / 13, 1, 1 / 2]"
            },
            {
              "name": "BT",
              "description": "",
              "type": null,
              "value": "{0: [1 / 4], 1: [3 / 32, 9 / 32], 2: [1932 / 2197, -7200 / 2197, 7296 / 2197], 3: [439 / 216, -8, 3680 / 513, -845 / 4104], 4: [-8 / 27, 2, -3554 / 2565, 1859 / 4104, -11 / 40], 5: [25 / 216, 0, 1408 / 2565, 2197 / 4104, -1 / 5, 0]}"
            },
            {
              "name": "TR",
              "description": "",
              "type": null,
              "value": "[1 / 360, 0, -128 / 4275, -2197 / 75240, 1 / 50, 2 / 55]"
            }
          ],
          "parameters": [
            {
              "name": "solver_args",
              "type": null,
              "default": "()",
              "description": ""
            },
            {
              "name": "solver_kwargs",
              "type": null,
              "default": "{}",
              "description": ""
            }
          ]
        }
      ],
      "functions": []
    },
    "pathsim.solvers.rkf78": {
      "name": "pathsim.solvers.rkf78",
      "description": "",
      "docstring_html": "",
      "classes": [
        {
          "name": "RKF78",
          "description": "Thirteen-stage, 8th order explicit Runge-Kutta method by Fehlberg.",
          "docstring_html": "<p>Thirteen-stage, 8th order explicit Runge-Kutta method by Fehlberg.</p>\n<p>Features an embedded 7th order method. The difference provides an 8th order error\nestimate. The 7th order solution is typically propagated. Designed for high accuracy\nrequirements.</p>\n<dl class=\"docutils\">\n<dt>Characteristics:</dt>\n<dd><ul class=\"first last simple\">\n<li>Order: 7 (Propagating solution)</li>\n<li>Embedded Order: 8 (Error estimation)</li>\n<li>Stages: 13</li>\n<li>Explicit</li>\n<li>Adaptive timestep</li>\n<li>Suitable for high-precision computations, nearly symplectic.</li>\n</ul>\n</dd>\n</dl>\n",
          "source": "class RKF78(ExplicitRungeKutta):\n    \"\"\"Thirteen-stage, 8th order explicit Runge-Kutta method by Fehlberg.\n\n    Features an embedded 7th order method. The difference provides an 8th order error\n    estimate. The 7th order solution is typically propagated. Designed for high accuracy\n    requirements.\n\n    Characteristics:\n        * Order: 7 (Propagating solution)\n        * Embedded Order: 8 (Error estimation)\n        * Stages: 13\n        * Explicit\n        * Adaptive timestep\n        * Suitable for high-precision computations, nearly symplectic.\n    \"\"\"\n\n    def __init__(self, *solver_args, **solver_kwargs):\n        super().__init__(*solver_args, **solver_kwargs)\n\n        #number of stages in RK scheme\n        self.s = 13\n\n        #order of scheme and embedded method\n        self.n = 7\n        self.m = 8\n\n        #flag adaptive timestep solver\n        self.is_adaptive = True\n\n        #intermediate evaluation times\n        self.eval_stages = [0, 2/27, 1/9, 1/6, 5/12, 1/2, 5/6, 1/6, 2/3, 1/3, 1, 0, 1]\n\n        #extended butcher table \n        self.BT = {0: [      2/27],\n                   1: [      1/36, 1/12],\n                   2: [      1/24,    0,    1/8],\n                   3: [      5/12,    0, -25/16,    25/16],\n                   4: [      1/20,    0,      0,      1/4,       1/5],\n                   5: [   -25/108,    0,      0,  125/108,    -65/27,  125/54],\n                   6: [    31/300,    0,      0,        0,    61/225,    -2/9,    13/900],\n                   7: [         2,    0,      0,    -53/6,    704/45,  -107/9,     67/90,     3],\n                   8: [   -91/108,    0,      0,   23/108,  -976/135,  311/54,    -19/60,  17/6,  -1/12],\n                   9: [ 2383/4100,    0,      0, -341/164, 4496/1025, -301/82, 2133/4100, 45/82, 45/164, 18/41],\n                   10:[     3/205,    0,      0,        0,         0,   -6/41,    -3/205, -3/41,   3/41,  6/41],\n                   11:[-1777/4100,    0,      0, -341/164, 4496/1025, -289/82, 2193/4100, 51/82, 33/164, 12/41,   0, 1],\n                   12:[    41/840,    0,      0,        0,         0,  34/105,      9/35,  9/35,  9/280, 9/280, 41/840]}\n\n        #coefficients for local truncation error estimate\n        self.TR = [41/840, 0, 0, 0, 0, 0, 0, 0, 0, 0, 41/840, -41/840, -41/840]",
          "bases": [
            "pathsim.solvers._rungekutta.ExplicitRungeKutta"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, *solver_args, **solver_kwargs):\n    super().__init__(*solver_args, **solver_kwargs)\n\n    #number of stages in RK scheme\n    self.s = 13\n\n    #order of scheme and embedded method\n    self.n = 7\n    self.m = 8\n\n    #flag adaptive timestep solver\n    self.is_adaptive = True\n\n    #intermediate evaluation times\n    self.eval_stages = [0, 2/27, 1/9, 1/6, 5/12, 1/2, 5/6, 1/6, 2/3, 1/3, 1, 0, 1]\n\n    #extended butcher table \n    self.BT = {0: [      2/27],\n               1: [      1/36, 1/12],\n               2: [      1/24,    0,    1/8],\n               3: [      5/12,    0, -25/16,    25/16],\n               4: [      1/20,    0,      0,      1/4,       1/5],\n               5: [   -25/108,    0,      0,  125/108,    -65/27,  125/54],\n               6: [    31/300,    0,      0,        0,    61/225,    -2/9,    13/900],\n               7: [         2,    0,      0,    -53/6,    704/45,  -107/9,     67/90,     3],\n               8: [   -91/108,    0,      0,   23/108,  -976/135,  311/54,    -19/60,  17/6,  -1/12],\n               9: [ 2383/4100,    0,      0, -341/164, 4496/1025, -301/82, 2133/4100, 45/82, 45/164, 18/41],\n               10:[     3/205,    0,      0,        0,         0,   -6/41,    -3/205, -3/41,   3/41,  6/41],\n               11:[-1777/4100,    0,      0, -341/164, 4496/1025, -289/82, 2193/4100, 51/82, 33/164, 12/41,   0, 1],\n               12:[    41/840,    0,      0,        0,         0,  34/105,      9/35,  9/35,  9/280, 9/280, 41/840]}\n\n    #coefficients for local truncation error estimate\n    self.TR = [41/840, 0, 0, 0, 0, 0, 0, 0, 0, 0, 41/840, -41/840, -41/840]",
              "signature": "(solver_args = (), solver_kwargs = {})",
              "parameters": [
                {
                  "name": "solver_args",
                  "type": null,
                  "default": "()",
                  "description": ""
                },
                {
                  "name": "solver_kwargs",
                  "type": null,
                  "default": "{}",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "s",
              "description": "",
              "type": null,
              "value": "13"
            },
            {
              "name": "n",
              "description": "",
              "type": null,
              "value": "7"
            },
            {
              "name": "m",
              "description": "",
              "type": null,
              "value": "8"
            },
            {
              "name": "is_adaptive",
              "description": "",
              "type": null,
              "value": "True"
            },
            {
              "name": "eval_stages",
              "description": "",
              "type": null,
              "value": "[0, 2 / 27, 1 / 9, 1 / 6, 5 / 12, 1 / 2, 5 / 6, 1 / 6, 2 / 3, 1 / 3, 1, 0, 1]"
            },
            {
              "name": "BT",
              "description": "",
              "type": null,
              "value": "{0: [2 / 27], 1: [1 / 36, 1 / 12], 2: [1 / 24, 0, 1 / 8], 3: [5 / 12, 0, -25 / 16, 25 / 16], 4: [1 / 20, 0, 0, 1 / 4, 1 / 5], 5: [-25 / 108, 0, 0, 125 / 108, -65 / 27, 125 / 54], 6: [31 / 300, 0, 0, 0, 61 / 225, -2 / 9, 13 / 900], 7: [2, 0, 0, -53 / 6, 704 / 45, -107 / 9, 67 / 90, 3], 8: [-91 / 108, 0, 0, 23 / 108, -976 / 135, 311 / 54, -19 / 60, 17 / 6, -1 / 12], 9: [2383 / 4100, 0, 0, -341 / 164, 4496 / 1025, -301 / 82, 2133 / 4100, 45 / 82, 45 / 164, 18 / 41], 10: [3 / 205, 0, 0, 0, 0, -6 / 41, -3 / 205, -3 / 41, 3 / 41, 6 / 41], 11: [-1777 / 4100, 0, 0, -341 / 164, 4496 / 1025, -289 / 82, 2193 / 4100, 51 / 82, 33 / 164, 12 / 41, 0, 1], 12: [41 / 840, 0, 0, 0, 0, 34 / 105, 9 / 35, 9 / 35, 9 / 280, 9 / 280, 41 / 840]}"
            },
            {
              "name": "TR",
              "description": "",
              "type": null,
              "value": "[41 / 840, 0, 0, 0, 0, 0, 0, 0, 0, 0, 41 / 840, -41 / 840, -41 / 840]"
            }
          ],
          "parameters": [
            {
              "name": "solver_args",
              "type": null,
              "default": "()",
              "description": ""
            },
            {
              "name": "solver_kwargs",
              "type": null,
              "default": "{}",
              "description": ""
            }
          ]
        }
      ],
      "functions": []
    },
    "pathsim.solvers.rkv65": {
      "name": "pathsim.solvers.rkv65",
      "description": "",
      "docstring_html": "",
      "classes": [
        {
          "name": "RKV65",
          "description": "9-stage 6-th order with embedded 5-th order Runge-Kutta method from Verner",
          "docstring_html": "<p>9-stage 6-th order with embedded 5-th order Runge-Kutta method from Verner\nwith 6-th order truncation error estimate.</p>\n<p>This is the 'most robust' 9, 6(5) pair of Jim Verner's Refuge for Runge-Kutta Pairs\nURL: <a class=\"reference external\" href=\"https://www.sfu.ca/~jverner/\">https://www.sfu.ca/~jverner/</a></p>\n<p>Characteristics:\n* Order: 6 (Propagating solution)\n* Embedded Order: 5\n* Stages: 9\n* Explicit\n* Adaptive timestep\n* Efficient high-order method for non-stiff problems.</p>\n",
          "source": "class RKV65(ExplicitRungeKutta):\n    \"\"\"9-stage 6-th order with embedded 5-th order Runge-Kutta method from Verner \n    with 6-th order truncation error estimate.\n\n    This is the 'most robust' 9, 6(5) pair of Jim Verner's Refuge for Runge-Kutta Pairs\n    URL: https://www.sfu.ca/~jverner/\n\n    Characteristics:\n    * Order: 6 (Propagating solution)\n    * Embedded Order: 5\n    * Stages: 9\n    * Explicit\n    * Adaptive timestep\n    * Efficient high-order method for non-stiff problems.\n\n    \"\"\"\n\n    def __init__(self, *solver_args, **solver_kwargs):\n        super().__init__(*solver_args, **solver_kwargs)\n\n        #number of stages in RK scheme\n        self.s = 9\n\n        #order of scheme and embedded method\n        self.n = 6\n        self.m = 5\n\n        #flag adaptive timestep solver\n        self.is_adaptive = True\n\n        #intermediate evaluation times\n        self.eval_stages = [0.0, 9/50, 1/6, 1/4, 53/100, 3/5, 4/5, 1.0, 1.0]\n\n        #extended butcher table \n        self.BT = {0:[             9/50],\n                   1:[           29/324, 25/324],\n                   2:[             1/16,      0,           3/16],\n                   3:[     79129/250000,      0, -261237/250000,      19663/15625],\n                   4:[  1336883/4909125,      0,   -25476/30875,    194159/185250,       8225/78546],\n                   5:[-2459386/14727375,      0,    19504/30875, 2377474/13615875, -6157250/5773131,   902/735],\n                   6:[        2699/7410,      0,      -252/1235, -1393253/3993990,     236875/72618,   -135/49,   15/22], \n                   7:[           11/144,      0,              0,          256/693,                0,   125/504, 125/528,        5/72], \n                   8:[           11/144,      0,              0,          256/693,                0,   125/504, 125/528,        5/72]}\n\n        #compute coefficients for truncation error\n        _A1 = [11/144, 0, 0, 256/693,              0,   125/504, 125/528,        5/72, 0]\n        _A2 = [28/477, 0, 0, 212/441, -312500/366177, 2125/1764,       0, -2105/35532, 2995/17766]        \n        self.TR = [a-b for a, b in zip(_A1, _A2)]",
          "bases": [
            "pathsim.solvers._rungekutta.ExplicitRungeKutta"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, *solver_args, **solver_kwargs):\n    super().__init__(*solver_args, **solver_kwargs)\n\n    #number of stages in RK scheme\n    self.s = 9\n\n    #order of scheme and embedded method\n    self.n = 6\n    self.m = 5\n\n    #flag adaptive timestep solver\n    self.is_adaptive = True\n\n    #intermediate evaluation times\n    self.eval_stages = [0.0, 9/50, 1/6, 1/4, 53/100, 3/5, 4/5, 1.0, 1.0]\n\n    #extended butcher table \n    self.BT = {0:[             9/50],\n               1:[           29/324, 25/324],\n               2:[             1/16,      0,           3/16],\n               3:[     79129/250000,      0, -261237/250000,      19663/15625],\n               4:[  1336883/4909125,      0,   -25476/30875,    194159/185250,       8225/78546],\n               5:[-2459386/14727375,      0,    19504/30875, 2377474/13615875, -6157250/5773131,   902/735],\n               6:[        2699/7410,      0,      -252/1235, -1393253/3993990,     236875/72618,   -135/49,   15/22], \n               7:[           11/144,      0,              0,          256/693,                0,   125/504, 125/528,        5/72], \n               8:[           11/144,      0,              0,          256/693,                0,   125/504, 125/528,        5/72]}\n\n    #compute coefficients for truncation error\n    _A1 = [11/144, 0, 0, 256/693,              0,   125/504, 125/528,        5/72, 0]\n    _A2 = [28/477, 0, 0, 212/441, -312500/366177, 2125/1764,       0, -2105/35532, 2995/17766]        \n    self.TR = [a-b for a, b in zip(_A1, _A2)]",
              "signature": "(solver_args = (), solver_kwargs = {})",
              "parameters": [
                {
                  "name": "solver_args",
                  "type": null,
                  "default": "()",
                  "description": ""
                },
                {
                  "name": "solver_kwargs",
                  "type": null,
                  "default": "{}",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "s",
              "description": "",
              "type": null,
              "value": "9"
            },
            {
              "name": "n",
              "description": "",
              "type": null,
              "value": "6"
            },
            {
              "name": "m",
              "description": "",
              "type": null,
              "value": "5"
            },
            {
              "name": "is_adaptive",
              "description": "",
              "type": null,
              "value": "True"
            },
            {
              "name": "eval_stages",
              "description": "",
              "type": null,
              "value": "[0.0, 9 / 50, 1 / 6, 1 / 4, 53 / 100, 3 / 5, 4 / 5, 1.0, 1.0]"
            },
            {
              "name": "BT",
              "description": "",
              "type": null,
              "value": "{0: [9 / 50], 1: [29 / 324, 25 / 324], 2: [1 / 16, 0, 3 / 16], 3: [79129 / 250000, 0, -261237 / 250000, 19663 / 15625], 4: [1336883 / 4909125, 0, -25476 / 30875, 194159 / 185250, 8225 / 78546], 5: [-2459386 / 14727375, 0, 19504 / 30875, 2377474 / 13615875, -6157250 / 5773131, 902 / 735], 6: [2699 / 7410, 0, -252 / 1235, -1393253 / 3993990, 236875 / 72618, -135 / 49, 15 / 22], 7: [11 / 144, 0, 0, 256 / 693, 0, 125 / 504, 125 / 528, 5 / 72], 8: [11 / 144, 0, 0, 256 / 693, 0, 125 / 504, 125 / 528, 5 / 72]}"
            },
            {
              "name": "TR",
              "description": "",
              "type": null,
              "value": "[(a - b) for a, b in (zip(_A1, _A2))]"
            }
          ],
          "parameters": [
            {
              "name": "solver_args",
              "type": null,
              "default": "()",
              "description": ""
            },
            {
              "name": "solver_kwargs",
              "type": null,
              "default": "{}",
              "description": ""
            }
          ]
        }
      ],
      "functions": []
    },
    "pathsim.solvers.ssprk22": {
      "name": "pathsim.solvers.ssprk22",
      "description": "",
      "docstring_html": "",
      "classes": [
        {
          "name": "SSPRK22",
          "description": "Two-stage, 2nd order, Strong Stability Preserving (SSP) explicit Runge-Kutta method.",
          "docstring_html": "<p>Two-stage, 2nd order, Strong Stability Preserving (SSP) explicit Runge-Kutta method.</p>\n<p>Also known as the explicit midpoint method or Heun's method. SSP methods are designed\nto preserve stability properties (like total variation diminishing - TVD) when solving\nhyperbolic PDEs, but are also effective general-purpose low-order explicit methods.</p>\n<dl class=\"docutils\">\n<dt>Characteristics:</dt>\n<dd><ul class=\"first last simple\">\n<li>Order: 2</li>\n<li>Stages: 2</li>\n<li>Explicit (SSP)</li>\n<li>Fixed timestep only</li>\n<li>Good balance of simplicity, cost, and stability (for an explicit method).</li>\n</ul>\n</dd>\n</dl>\n",
          "source": "class SSPRK22(ExplicitRungeKutta):\n    \"\"\"Two-stage, 2nd order, Strong Stability Preserving (SSP) explicit Runge-Kutta method.\n\n    Also known as the explicit midpoint method or Heun's method. SSP methods are designed\n    to preserve stability properties (like total variation diminishing - TVD) when solving\n    hyperbolic PDEs, but are also effective general-purpose low-order explicit methods.\n\n    Characteristics:\n        * Order: 2\n        * Stages: 2\n        * Explicit (SSP)\n        * Fixed timestep only\n        * Good balance of simplicity, cost, and stability (for an explicit method).\n    \"\"\"\n\n    def __init__(self, *solver_args, **solver_kwargs):\n        super().__init__(*solver_args, **solver_kwargs)\n\n        #number of stages in RK scheme\n        self.s = 2\n\n        #order of scheme\n        self.n = 2\n\n        #intermediate evaluation times\n        self.eval_stages = [0.0, 1.0]\n\n        #butcher table\n        self.BT = {0:[1.0],\n                   1:[1/2, 1/2]}\n\n\n    def interpolate(self, r, dt):\n        k1, k2 = self.K[0], self.K[1]\n        b1, b2 = r*(2-r)/2, r**2/2\n        return self.x_0 + dt*(b1 * k1 + b2 * k2)",
          "bases": [
            "pathsim.solvers._rungekutta.ExplicitRungeKutta"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, *solver_args, **solver_kwargs):\n    super().__init__(*solver_args, **solver_kwargs)\n\n    #number of stages in RK scheme\n    self.s = 2\n\n    #order of scheme\n    self.n = 2\n\n    #intermediate evaluation times\n    self.eval_stages = [0.0, 1.0]\n\n    #butcher table\n    self.BT = {0:[1.0],\n               1:[1/2, 1/2]}",
              "signature": "(solver_args = (), solver_kwargs = {})",
              "parameters": [
                {
                  "name": "solver_args",
                  "type": null,
                  "default": "()",
                  "description": ""
                },
                {
                  "name": "solver_kwargs",
                  "type": null,
                  "default": "{}",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "interpolate",
              "description": "",
              "docstring_html": "",
              "source": "def interpolate(self, r, dt):\n    k1, k2 = self.K[0], self.K[1]\n    b1, b2 = r*(2-r)/2, r**2/2\n    return self.x_0 + dt*(b1 * k1 + b2 * k2)",
              "signature": "(r, dt)",
              "parameters": [
                {
                  "name": "r",
                  "type": null,
                  "default": null,
                  "description": ""
                },
                {
                  "name": "dt",
                  "type": null,
                  "default": null,
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "s",
              "description": "",
              "type": null,
              "value": "2"
            },
            {
              "name": "n",
              "description": "",
              "type": null,
              "value": "2"
            },
            {
              "name": "eval_stages",
              "description": "",
              "type": null,
              "value": "[0.0, 1.0]"
            },
            {
              "name": "BT",
              "description": "",
              "type": null,
              "value": "{0: [1.0], 1: [1 / 2, 1 / 2]}"
            }
          ],
          "parameters": [
            {
              "name": "solver_args",
              "type": null,
              "default": "()",
              "description": ""
            },
            {
              "name": "solver_kwargs",
              "type": null,
              "default": "{}",
              "description": ""
            }
          ]
        }
      ],
      "functions": []
    },
    "pathsim.solvers.ssprk33": {
      "name": "pathsim.solvers.ssprk33",
      "description": "",
      "docstring_html": "",
      "classes": [
        {
          "name": "SSPRK33",
          "description": "Three-stage, 3rd order, Strong Stability Preserving (SSP) explicit",
          "docstring_html": "<p>Three-stage, 3rd order, Strong Stability Preserving (SSP) explicit\nRunge-Kutta method.</p>\n<p>Offers higher accuracy than SSPRK22 while maintaining the SSP property.\nA popular choice for problems where TVD properties are important or when\na simple, stable 3rd order explicit method is needed.</p>\n<dl class=\"docutils\">\n<dt>Characteristics:</dt>\n<dd><ul class=\"first last simple\">\n<li>Order: 3</li>\n<li>Stages: 3</li>\n<li>Explicit (SSP)</li>\n<li>Fixed timestep only</li>\n<li>Good stability properties for an explicit 3rd order method.</li>\n</ul>\n</dd>\n</dl>\n",
          "source": "class SSPRK33(ExplicitRungeKutta):\n    \"\"\"Three-stage, 3rd order, Strong Stability Preserving (SSP) explicit \n    Runge-Kutta method.\n\n    Offers higher accuracy than SSPRK22 while maintaining the SSP property. \n    A popular choice for problems where TVD properties are important or when \n    a simple, stable 3rd order explicit method is needed.\n\n    Characteristics:\n        * Order: 3\n        * Stages: 3\n        * Explicit (SSP)\n        * Fixed timestep only\n        * Good stability properties for an explicit 3rd order method.\n    \"\"\"\n\n    def __init__(self, *solver_args, **solver_kwargs):\n        super().__init__(*solver_args, **solver_kwargs)\n\n        #number of stages in RK scheme\n        self.s = 3\n\n        #order of scheme\n        self.n = 3\n\n        #intermediate evaluation times\n        self.eval_stages = [0.0, 1.0, 0.5]\n\n        #butcher table\n        self.BT = {0:[1.0],\n                   1:[1/4, 1/4],\n                   2:[1/6, 1/6, 2/3]}\n\n    def interpolate(self, r, dt):\n        k1, k2, k3 = self.K[0], self.K[1], self.K[2]\n        b1, b2, b3 = r*(2-r)**2/2, r**2*(3-2*r)/2, r**3\n        return self.x_0 + dt*(b1 * k1 + b2 * k2 + b3 * k3)",
          "bases": [
            "pathsim.solvers._rungekutta.ExplicitRungeKutta"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, *solver_args, **solver_kwargs):\n    super().__init__(*solver_args, **solver_kwargs)\n\n    #number of stages in RK scheme\n    self.s = 3\n\n    #order of scheme\n    self.n = 3\n\n    #intermediate evaluation times\n    self.eval_stages = [0.0, 1.0, 0.5]\n\n    #butcher table\n    self.BT = {0:[1.0],\n               1:[1/4, 1/4],\n               2:[1/6, 1/6, 2/3]}",
              "signature": "(solver_args = (), solver_kwargs = {})",
              "parameters": [
                {
                  "name": "solver_args",
                  "type": null,
                  "default": "()",
                  "description": ""
                },
                {
                  "name": "solver_kwargs",
                  "type": null,
                  "default": "{}",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "interpolate",
              "description": "",
              "docstring_html": "",
              "source": "def interpolate(self, r, dt):\n    k1, k2, k3 = self.K[0], self.K[1], self.K[2]\n    b1, b2, b3 = r*(2-r)**2/2, r**2*(3-2*r)/2, r**3\n    return self.x_0 + dt*(b1 * k1 + b2 * k2 + b3 * k3)",
              "signature": "(r, dt)",
              "parameters": [
                {
                  "name": "r",
                  "type": null,
                  "default": null,
                  "description": ""
                },
                {
                  "name": "dt",
                  "type": null,
                  "default": null,
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "s",
              "description": "",
              "type": null,
              "value": "3"
            },
            {
              "name": "n",
              "description": "",
              "type": null,
              "value": "3"
            },
            {
              "name": "eval_stages",
              "description": "",
              "type": null,
              "value": "[0.0, 1.0, 0.5]"
            },
            {
              "name": "BT",
              "description": "",
              "type": null,
              "value": "{0: [1.0], 1: [1 / 4, 1 / 4], 2: [1 / 6, 1 / 6, 2 / 3]}"
            }
          ],
          "parameters": [
            {
              "name": "solver_args",
              "type": null,
              "default": "()",
              "description": ""
            },
            {
              "name": "solver_kwargs",
              "type": null,
              "default": "{}",
              "description": ""
            }
          ]
        }
      ],
      "functions": []
    },
    "pathsim.solvers.ssprk34": {
      "name": "pathsim.solvers.ssprk34",
      "description": "",
      "docstring_html": "",
      "classes": [
        {
          "name": "SSPRK34",
          "description": "Four-stage, 3rd order, Strong Stability Preserving (SSP) explicit Runge-Kutta method.",
          "docstring_html": "<p>Four-stage, 3rd order, Strong Stability Preserving (SSP) explicit Runge-Kutta method.</p>\n<p>Provides a larger stability region compared to SSPRK33, particularly along the negative\nreal axis, at the cost of an additional stage. Useful when stability is more critical\nthan computational cost for a 3rd order explicit method.</p>\n<dl class=\"docutils\">\n<dt>Characteristics:</dt>\n<dd><ul class=\"first last simple\">\n<li>Order: 3</li>\n<li>Stages: 4</li>\n<li>Explicit (SSP)</li>\n<li>Fixed timestep only</li>\n<li>Enhanced stability compared to SSPRK33.</li>\n</ul>\n</dd>\n</dl>\n",
          "source": "class SSPRK34(ExplicitRungeKutta):\n    \"\"\"Four-stage, 3rd order, Strong Stability Preserving (SSP) explicit Runge-Kutta method.\n\n    Provides a larger stability region compared to SSPRK33, particularly along the negative\n    real axis, at the cost of an additional stage. Useful when stability is more critical\n    than computational cost for a 3rd order explicit method.\n\n    Characteristics:\n        * Order: 3\n        * Stages: 4\n        * Explicit (SSP)\n        * Fixed timestep only\n        * Enhanced stability compared to SSPRK33.\n    \"\"\"\n\n    def __init__(self, *solver_args, **solver_kwargs):\n        super().__init__(*solver_args, **solver_kwargs)\n\n        #number of stages in RK scheme\n        self.s = 4\n\n        #order of scheme\n        self.n = 3\n\n        #intermediate evaluation times\n        self.eval_stages = [0.0, 1/2, 1, 1/2]\n\n        #butcher table\n        self.BT = {0:[1/2],\n                   1:[1/2, 1/2],\n                   2:[1/6, 1/6, 1/6],\n                   3:[1/6, 1/6, 1/6, 1/2]}",
          "bases": [
            "pathsim.solvers._rungekutta.ExplicitRungeKutta"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, *solver_args, **solver_kwargs):\n    super().__init__(*solver_args, **solver_kwargs)\n\n    #number of stages in RK scheme\n    self.s = 4\n\n    #order of scheme\n    self.n = 3\n\n    #intermediate evaluation times\n    self.eval_stages = [0.0, 1/2, 1, 1/2]\n\n    #butcher table\n    self.BT = {0:[1/2],\n               1:[1/2, 1/2],\n               2:[1/6, 1/6, 1/6],\n               3:[1/6, 1/6, 1/6, 1/2]}",
              "signature": "(solver_args = (), solver_kwargs = {})",
              "parameters": [
                {
                  "name": "solver_args",
                  "type": null,
                  "default": "()",
                  "description": ""
                },
                {
                  "name": "solver_kwargs",
                  "type": null,
                  "default": "{}",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "s",
              "description": "",
              "type": null,
              "value": "4"
            },
            {
              "name": "n",
              "description": "",
              "type": null,
              "value": "3"
            },
            {
              "name": "eval_stages",
              "description": "",
              "type": null,
              "value": "[0.0, 1 / 2, 1, 1 / 2]"
            },
            {
              "name": "BT",
              "description": "",
              "type": null,
              "value": "{0: [1 / 2], 1: [1 / 2, 1 / 2], 2: [1 / 6, 1 / 6, 1 / 6], 3: [1 / 6, 1 / 6, 1 / 6, 1 / 2]}"
            }
          ],
          "parameters": [
            {
              "name": "solver_args",
              "type": null,
              "default": "()",
              "description": ""
            },
            {
              "name": "solver_kwargs",
              "type": null,
              "default": "{}",
              "description": ""
            }
          ]
        }
      ],
      "functions": []
    },
    "pathsim.solvers.steadystate": {
      "name": "pathsim.solvers.steadystate",
      "description": "",
      "docstring_html": "",
      "classes": [
        {
          "name": "SteadyState",
          "description": "Pseudo-solver that finds the time-independent steady-state solution (DC operating point).",
          "docstring_html": "<p>Pseudo-solver that finds the time-independent steady-state solution (DC operating point).</p>\n<p>This works by modifying the fixed-point iteration target. Instead of solving\n<span class=\"math\">\\(x_{n+1} = G(x_{n+1})\\)</span> for an implicit step, it aims to solve the algebraic equation\n<span class=\"math\">\\(f(x, u, t_{steady}) = 0\\)</span> by finding the fixed point of <span class=\"math\">\\(x = x + f(x, u, t_{steady})\\)</span>.\nIt uses the same internal optimizer (e.g., NewtonAnderson) as other implicit solvers.</p>\n<dl class=\"docutils\">\n<dt>Characteristics:</dt>\n<dd><ul class=\"first last simple\">\n<li>Purpose: Find steady-state (<span class=\"math\">\\(dx/dt = 0\\)</span>)</li>\n<li>Implicit (uses optimizer)</li>\n<li>Not a time-stepping method.</li>\n</ul>\n</dd>\n</dl>\n",
          "source": "class SteadyState(ImplicitSolver):\n    \"\"\"Pseudo-solver that finds the time-independent steady-state solution (DC operating point).\n\n    This works by modifying the fixed-point iteration target. Instead of solving\n    :math:`x_{n+1} = G(x_{n+1})` for an implicit step, it aims to solve the algebraic equation\n    :math:`f(x, u, t_{steady}) = 0` by finding the fixed point of :math:`x = x + f(x, u, t_{steady})`.\n    It uses the same internal optimizer (e.g., NewtonAnderson) as other implicit solvers.\n\n    Characteristics:\n        * Purpose: Find steady-state (:math:`dx/dt = 0`)\n        * Implicit (uses optimizer)\n        * Not a time-stepping method.\n    \"\"\"\n\n    def solve(self, f, J, dt):\n        \"\"\"Solve for steady state by finding x where f(x,u,t) = 0\n        using the fixed point equation x = x + f(x,u,t).\n\n        Parameters\n        ----------\n        f : array_like\n            evaluation of function\n        J : array_like\n            evaluation of jacobian of function\n        dt : float \n            integration timestep\n\n        Returns\n        -------\n        err : float\n            residual error of the fixed point update equation\n        \"\"\"\n\n        #fixed point equation g(x) = x + f(x,u,t)\n        g = self.x + f\n\n        if J is not None:\n\n            #jacobian of g is I + df/dx\n            jac_g = np.eye(len(self.x)) + J\n\n            #optimizer step with block local jacobian\n            self.x, err = self.opt.step(self.x, g, jac_g)\n\n        else:\n\n            #optimizer step without jacobian\n            self.x, err = self.opt.step(self.x, g)\n\n        return err",
          "bases": [
            "pathsim.solvers._solver.ImplicitSolver"
          ],
          "methods": [
            {
              "name": "solve",
              "description": "Solve for steady state by finding x where f(x,u,t) = 0",
              "docstring_html": "<p>Solve for steady state by finding x where f(x,u,t) = 0\nusing the fixed point equation x = x + f(x,u,t).</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>f <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array_like</span></dt>\n<dd>evaluation of function</dd>\n<dt>J <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array_like</span></dt>\n<dd>evaluation of jacobian of function</dd>\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>integration timestep</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>err <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>residual error of the fixed point update equation</dd>\n</dl>\n",
              "source": "def solve(self, f, J, dt):\n    \"\"\"Solve for steady state by finding x where f(x,u,t) = 0\n    using the fixed point equation x = x + f(x,u,t).\n\n    Parameters\n    ----------\n    f : array_like\n        evaluation of function\n    J : array_like\n        evaluation of jacobian of function\n    dt : float \n        integration timestep\n\n    Returns\n    -------\n    err : float\n        residual error of the fixed point update equation\n    \"\"\"\n\n    #fixed point equation g(x) = x + f(x,u,t)\n    g = self.x + f\n\n    if J is not None:\n\n        #jacobian of g is I + df/dx\n        jac_g = np.eye(len(self.x)) + J\n\n        #optimizer step with block local jacobian\n        self.x, err = self.opt.step(self.x, g, jac_g)\n\n    else:\n\n        #optimizer step without jacobian\n        self.x, err = self.opt.step(self.x, g)\n\n    return err",
              "signature": "(f, J, dt)",
              "parameters": [
                {
                  "name": "f",
                  "type": null,
                  "default": null,
                  "description": "evaluation of function"
                },
                {
                  "name": "J",
                  "type": null,
                  "default": null,
                  "description": "evaluation of jacobian of function"
                },
                {
                  "name": "dt",
                  "type": null,
                  "default": null,
                  "description": "integration timestep"
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [],
          "parameters": []
        }
      ],
      "functions": []
    },
    "pathsim.events._event": {
      "name": "pathsim.events._event",
      "description": "",
      "docstring_html": "",
      "classes": [
        {
          "name": "Event",
          "description": "This is the base class of the event handling system.",
          "docstring_html": "<p>This is the base class of the event handling system.</p>\n<p>Monitors system state by evaluating an event function (func_evt) with scalar output.</p>\n<pre class=\"code literal-block\">\nfunc_evt(time) -&gt; event?\n</pre>\n<p>If an event is detected, some action (func_act) is performed on the states of the blocks.</p>\n<pre class=\"code literal-block\">\nfunc_evt(time) == True -&gt; event -&gt; func_act(time)\n</pre>\n<p>The methods are structured such that event detection can be separated from event\nresolution. This is required for adaptive timestep solvers to approach the event\nand only resolve it when the event tolerance ('tolerance') is satisfied.</p>\n<p>If no action function (func_act) is specified, the event will only be detected but other\nthan that, no action will be triggered. For general state monitoring.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>func_evt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">callable</span></dt>\n<dd>event function, where zeros are events</dd>\n<dt>func_act <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">callable</span></dt>\n<dd>action function for event resolution</dd>\n<dt>tolerance <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>tolerance to check if detection is close to actual event</dd>\n</dl>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>_history <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">tuple[None, float], tuple[float, float], tuple[bool, float]</span></dt>\n<dd>history of event function evaluation after buffering</dd>\n<dt>_times <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">list[float]</span></dt>\n<dd>tracking the event times</dd>\n<dt>_active <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>flag that sets event active or inactive</dd>\n</dl>\n",
          "source": "class Event(Serializable):\n    \"\"\"This is the base class of the event handling system.\n\n    Monitors system state by evaluating an event function (func_evt) with scalar output.\n\n    .. code-block::\n\n        func_evt(time) -> event?\n\n    If an event is detected, some action (func_act) is performed on the states of the blocks.\n\n    .. code-block::\n\n        func_evt(time) == True -> event -> func_act(time)\n\n    The methods are structured such that event detection can be separated from event \n    resolution. This is required for adaptive timestep solvers to approach the event \n    and only resolve it when the event tolerance ('tolerance') is satisfied.\n\n    If no action function (func_act) is specified, the event will only be detected but other \n    than that, no action will be triggered. For general state monitoring.    \n\n    Parameters\n    ----------\n    func_evt : callable\n        event function, where zeros are events\n    func_act : callable\n        action function for event resolution \n    tolerance : float\n        tolerance to check if detection is close to actual event\n\n    Attributes\n    ----------\n    _history : tuple[None, float], tuple[float, float], tuple[bool, float]\n        history of event function evaluation after buffering\n    _times : list[float]\n        tracking the event times\n    _active : bool\n        flag that sets event active or inactive\n    \"\"\"\n\n    def __init__(\n        self, \n        func_evt=None, \n        func_act=None, \n        tolerance=EVT_TOLERANCE\n        ):\n\n        #event detection function\n        self.func_evt = func_evt\n\n        #event action function -> event resolution (must not be callable)\n        self.func_act = func_act\n\n        #tolerance for checking if close to actual event\n        self.tolerance = tolerance\n\n        #event function evaluation and evaluation time history (eval, time)\n        self._history = None, 0.0\n\n        #recording the event times\n        self._times = []\n\n        #flag for active event checking\n        self._active = True\n\n\n    def __len__(self):\n        \"\"\"\n        Return the number of detected (or rather resolved) events.\n\n        Returns\n        -------\n        length : int\n            number of events detected\n\n        \"\"\"\n        return len(self._times)\n\n\n    def __iter__(self):\n        \"\"\"\n        Yields the recorded times at which events are detected.\n        \"\"\"\n        for t in self._times:\n            yield t\n\n\n    def __bool__(self):\n        return self._active\n\n\n    # external methods ------------------------------------------------------------------\n\n    def on(self): self._active = True\n    def off(self): self._active = False\n\n\n    def reset(self):\n        \"\"\"\n        Reset the recorded event times. Resetting the history is not \n        required because of the 'buffer' method. Reactivates event tracking.\n        \"\"\"\n        self._history = None, 0.0\n        self._times = []\n        self._active = True\n\n\n    def buffer(self, t):\n        \"\"\"Buffer the event function evaluation before the timestep is \n        taken and the evaluation time. \n\n        Parameters\n        ----------\n        t : float\n            evaluation time for buffering history\n        \"\"\"\n        if self.func_evt is not None:\n            self._history = self.func_evt(t), t\n\n\n    def estimate(self, t):\n        \"\"\"Estimate the time of the next event, based on history or internal schedule.\n\n        This improves simulation performance by estimating events before the simulation \n        step such that fewer steps have to be rejected for event location. \n\n        Parameters\n        ----------\n        t : float \n            evaluation time for estimation \n\n        Returns\n        -------\n        float | None\n            estimated time until next event\n        \"\"\"\n        return None\n\n\n    def detect(self, t):\n        \"\"\"Evaluate the event function and decide if an event has occured. \n        Can also use the history of the event function evaluation from \n        before the timestep.\n\n        Notes\n        -----\n        This does nothing and needs to be implemented for specific events!!!\n\n        Parameters\n        ----------\n        t : float\n            evaluation time for detection \n\n        Returns\n        -------\n        detected : bool\n            was an event detected?\n        close : bool\n            are we close to the event?\n        ratio : float\n            interpolated event location as ratio of timestep\n        \"\"\"\n\n        return False, False, 1.0\n\n\n    def resolve(self, t):\n        \"\"\"Resolve the event and record the time (t) at which it occurs. \n\n        Resolves event using the action function (func_act) if it is defined. \n\n        Otherwise this just marks the location of the event in time.\n\n        Parameters\n        ----------\n        t : float\n            evaluation time for event resolution \n        \"\"\"\n\n        #save the time of event resolution\n        self._times.append(t)\n\n        #action function for event resolution\n        if self.func_act is not None:\n            self.func_act(t)",
          "bases": [
            "pathsim.utils.serialization.Serializable"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(\n    self, \n    func_evt=None, \n    func_act=None, \n    tolerance=EVT_TOLERANCE\n    ):\n\n    #event detection function\n    self.func_evt = func_evt\n\n    #event action function -> event resolution (must not be callable)\n    self.func_act = func_act\n\n    #tolerance for checking if close to actual event\n    self.tolerance = tolerance\n\n    #event function evaluation and evaluation time history (eval, time)\n    self._history = None, 0.0\n\n    #recording the event times\n    self._times = []\n\n    #flag for active event checking\n    self._active = True",
              "signature": "(func_evt = None, func_act = None, tolerance = EVT_TOLERANCE)",
              "parameters": [
                {
                  "name": "func_evt",
                  "type": null,
                  "default": "None",
                  "description": ""
                },
                {
                  "name": "func_act",
                  "type": null,
                  "default": "None",
                  "description": ""
                },
                {
                  "name": "tolerance",
                  "type": null,
                  "default": "EVT_TOLERANCE",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "on",
              "description": "",
              "docstring_html": "",
              "source": "def on(self): self._active = True",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "off",
              "description": "",
              "docstring_html": "",
              "source": "def off(self): self._active = False",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "reset",
              "description": "Reset the recorded event times. Resetting the history is not",
              "docstring_html": "<p>Reset the recorded event times. Resetting the history is not\nrequired because of the 'buffer' method. Reactivates event tracking.</p>\n",
              "source": "def reset(self):\n    \"\"\"\n    Reset the recorded event times. Resetting the history is not \n    required because of the 'buffer' method. Reactivates event tracking.\n    \"\"\"\n    self._history = None, 0.0\n    self._times = []\n    self._active = True",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "buffer",
              "description": "Buffer the event function evaluation before the timestep is",
              "docstring_html": "<p>Buffer the event function evaluation before the timestep is\ntaken and the evaluation time.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time for buffering history</dd>\n</dl>\n",
              "source": "def buffer(self, t):\n    \"\"\"Buffer the event function evaluation before the timestep is \n    taken and the evaluation time. \n\n    Parameters\n    ----------\n    t : float\n        evaluation time for buffering history\n    \"\"\"\n    if self.func_evt is not None:\n        self._history = self.func_evt(t), t",
              "signature": "(t)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time for buffering history"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "estimate",
              "description": "Estimate the time of the next event, based on history or internal schedule.",
              "docstring_html": "<p>Estimate the time of the next event, based on history or internal schedule.</p>\n<p>This improves simulation performance by estimating events before the simulation\nstep such that fewer steps have to be rejected for event location.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time for estimation</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>float | None</dt>\n<dd>estimated time until next event</dd>\n</dl>\n",
              "source": "def estimate(self, t):\n    \"\"\"Estimate the time of the next event, based on history or internal schedule.\n\n    This improves simulation performance by estimating events before the simulation \n    step such that fewer steps have to be rejected for event location. \n\n    Parameters\n    ----------\n    t : float \n        evaluation time for estimation \n\n    Returns\n    -------\n    float | None\n        estimated time until next event\n    \"\"\"\n    return None",
              "signature": "(t)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time for estimation"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "detect",
              "description": "Evaluate the event function and decide if an event has occured.",
              "docstring_html": "<p>Evaluate the event function and decide if an event has occured.\nCan also use the history of the event function evaluation from\nbefore the timestep.</p>\n<p><strong>Notes</strong></p>\n<p>This does nothing and needs to be implemented for specific events!!!</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time for detection</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>detected <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>was an event detected?</dd>\n<dt>close <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>are we close to the event?</dd>\n<dt>ratio <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>interpolated event location as ratio of timestep</dd>\n</dl>\n",
              "source": "def detect(self, t):\n    \"\"\"Evaluate the event function and decide if an event has occured. \n    Can also use the history of the event function evaluation from \n    before the timestep.\n\n    Notes\n    -----\n    This does nothing and needs to be implemented for specific events!!!\n\n    Parameters\n    ----------\n    t : float\n        evaluation time for detection \n\n    Returns\n    -------\n    detected : bool\n        was an event detected?\n    close : bool\n        are we close to the event?\n    ratio : float\n        interpolated event location as ratio of timestep\n    \"\"\"\n\n    return False, False, 1.0",
              "signature": "(t)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time for detection"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "resolve",
              "description": "Resolve the event and record the time (t) at which it occurs.",
              "docstring_html": "<p>Resolve the event and record the time (t) at which it occurs.</p>\n<p>Resolves event using the action function (func_act) if it is defined.</p>\n<p>Otherwise this just marks the location of the event in time.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time for event resolution</dd>\n</dl>\n",
              "source": "def resolve(self, t):\n    \"\"\"Resolve the event and record the time (t) at which it occurs. \n\n    Resolves event using the action function (func_act) if it is defined. \n\n    Otherwise this just marks the location of the event in time.\n\n    Parameters\n    ----------\n    t : float\n        evaluation time for event resolution \n    \"\"\"\n\n    #save the time of event resolution\n    self._times.append(t)\n\n    #action function for event resolution\n    if self.func_act is not None:\n        self.func_act(t)",
              "signature": "(t)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time for event resolution"
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "func_evt",
              "description": "",
              "type": null,
              "value": "func_evt"
            },
            {
              "name": "func_act",
              "description": "",
              "type": null,
              "value": "func_act"
            },
            {
              "name": "tolerance",
              "description": "",
              "type": null,
              "value": "tolerance"
            },
            {
              "name": "_history",
              "description": "",
              "type": null,
              "value": "(None, 0.0)"
            },
            {
              "name": "_times",
              "description": "",
              "type": null,
              "value": "[]"
            },
            {
              "name": "_active",
              "description": "",
              "type": null,
              "value": "True"
            }
          ],
          "parameters": [
            {
              "name": "func_evt",
              "type": null,
              "default": "None",
              "description": "event function, where zeros are events"
            },
            {
              "name": "func_act",
              "type": null,
              "default": "None",
              "description": "action function for event resolution"
            },
            {
              "name": "tolerance",
              "type": null,
              "default": "EVT_TOLERANCE",
              "description": "tolerance to check if detection is close to actual event"
            }
          ]
        }
      ],
      "functions": []
    },
    "pathsim.events.condition": {
      "name": "pathsim.events.condition",
      "description": "",
      "docstring_html": "",
      "classes": [
        {
          "name": "Condition",
          "description": "Subclass of base 'Event' that triggers if the event function evaluates to 'True',",
          "docstring_html": "<p>Subclass of base 'Event' that triggers if the event function evaluates to 'True',\ni.e. the condition is satisfied.</p>\n<p>Monitors system state by evaluating an event function (func_evt) with boolean output.\nThe event is considered detected when the event function evaluates to 'True' for the\nfirst time. Subsequent evaluations to 'True' are not considered unless the event is reset.</p>\n<pre class=\"code literal-block\">\nfunc_evt(time) -&gt; event?\n</pre>\n<p>If an event is detected, some action (func_act) is performed on the system state.</p>\n<pre class=\"code literal-block\">\nfunc_evt(time) == True -&gt; event -&gt; func_act(time)\n</pre>\n<div class=\"section\" id=\"note\">\n<h4>Note</h4>\n<p>Condition event functions evaluate to boolean and are therefore not smooth.\nTherefore uses bisection method for event location instead of secant method.</p>\n</div>\n<div class=\"section\" id=\"example\">\n<h4>Example</h4>\n<p>Initialize a conditional event handler like this:</p>\n<pre class=\"code python literal-block\">\n<span class=\"c1\">#define the event function</span><span class=\"w\">\n</span><span class=\"k\">def</span><span class=\"w\"> </span><span class=\"nf\">evt</span><span class=\"p\">(</span><span class=\"n\">t</span><span class=\"p\">):</span><span class=\"w\">\n</span>    <span class=\"k\">return</span> <span class=\"n\">t</span> <span class=\"o\">&gt;</span> <span class=\"mi\">10</span><span class=\"w\">\n\n</span><span class=\"c1\">#define the action function (callback)</span><span class=\"w\">\n</span><span class=\"k\">def</span><span class=\"w\"> </span><span class=\"nf\">act</span><span class=\"p\">(</span><span class=\"n\">t</span><span class=\"p\">):</span><span class=\"w\">\n</span>    <span class=\"c1\">#do something at event resolution</span><span class=\"w\">\n</span>    <span class=\"k\">pass</span><span class=\"w\">\n\n</span><span class=\"c1\">#initialize the event manager</span><span class=\"w\">\n</span><span class=\"n\">E</span> <span class=\"o\">=</span> <span class=\"n\">Condition</span><span class=\"p\">(</span><span class=\"w\">\n</span>    <span class=\"n\">func_evt</span><span class=\"o\">=</span><span class=\"n\">evt</span><span class=\"p\">,</span>  <span class=\"c1\">#the event function</span><span class=\"w\">\n</span>    <span class=\"n\">func_act</span><span class=\"o\">=</span><span class=\"n\">act</span>   <span class=\"c1\">#the action function</span><span class=\"w\">\n</span>    <span class=\"p\">)</span>\n</pre>\n</div>\n",
          "source": "class Condition(Event):\n    \"\"\"Subclass of base 'Event' that triggers if the event function evaluates to 'True', \n    i.e. the condition is satisfied.\n\n    Monitors system state by evaluating an event function (func_evt) with boolean output. \n    The event is considered detected when the event function evaluates to 'True' for the \n    first time. Subsequent evaluations to 'True' are not considered unless the event is reset.\n\n    .. code-block::\n\n        func_evt(time) -> event?\n\n    If an event is detected, some action (func_act) is performed on the system state.\n\n    .. code-block::\n\n        func_evt(time) == True -> event -> func_act(time)\n\n    Note\n    ----\n    Condition event functions evaluate to boolean and are therefore not smooth. \n    Therefore uses bisection method for event location instead of secant method.\n\n    Example\n    -------\n    Initialize a conditional event handler like this:\n\n    .. code-block:: python\n\n        #define the event function\n        def evt(t):\n            return t > 10\n\n        #define the action function (callback)\n        def act(t):\n            #do something at event resolution\n            pass\n\n        #initialize the event manager\n        E = Condition(\n            func_evt=evt,  #the event function\n            func_act=act   #the action function\n            )    \n\n    \"\"\"\n\n    def detect(self, t):\n        \"\"\"\n        Evaluate the event function and check if condition is satisfied. \n\n        The event function is not differentiable, so we use bisection to \n        narrow down its location to some tolerance.\n\n        Parameters\n        ----------\n        t : float\n            evaluation time for detection \n\n        Returns\n        -------\n        detected : bool\n            was an event detected?\n        close : bool\n            are we close to the event?\n        ratio : float\n            adjust timestep to locate event\n        \"\"\"\n\n        #unpack history\n        _result, _t = self._history\n\n        #evaluate event function\n        result = self.func_evt(t)\n\n        #check if interval narrowed down sufficiently\n        close = result and (t - _t) < self.tolerance\n\n        #close enough to event\n        if close: return True, True, 1.0\n\n        #half the stepsize to creep closer to event (bisection)\n        return result, False, 0.5\n\n\n    def resolve(self, t):\n        \"\"\"Resolve the event and record the time (t) at which it occurs. \n        Resolves event using the action function (func_act) if it is defined. \n\n        Deactivates the event tracking upon first resolution.\n\n        Parameters\n        ----------\n        t : float\n            evaluation time for event resolution \n        \"\"\"\n\n        #save the time of event resolution\n        self._times.append(t)\n\n        #action function for event resolution\n        if self.func_act is not None:\n            self.func_act(t)\n\n        #deactivate condition tracking\n        self.off()",
          "bases": [
            "pathsim.events._event.Event"
          ],
          "methods": [
            {
              "name": "detect",
              "description": "Evaluate the event function and check if condition is satisfied.",
              "docstring_html": "<p>Evaluate the event function and check if condition is satisfied.</p>\n<p>The event function is not differentiable, so we use bisection to\nnarrow down its location to some tolerance.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time for detection</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>detected <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>was an event detected?</dd>\n<dt>close <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>are we close to the event?</dd>\n<dt>ratio <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>adjust timestep to locate event</dd>\n</dl>\n",
              "source": "def detect(self, t):\n    \"\"\"\n    Evaluate the event function and check if condition is satisfied. \n\n    The event function is not differentiable, so we use bisection to \n    narrow down its location to some tolerance.\n\n    Parameters\n    ----------\n    t : float\n        evaluation time for detection \n\n    Returns\n    -------\n    detected : bool\n        was an event detected?\n    close : bool\n        are we close to the event?\n    ratio : float\n        adjust timestep to locate event\n    \"\"\"\n\n    #unpack history\n    _result, _t = self._history\n\n    #evaluate event function\n    result = self.func_evt(t)\n\n    #check if interval narrowed down sufficiently\n    close = result and (t - _t) < self.tolerance\n\n    #close enough to event\n    if close: return True, True, 1.0\n\n    #half the stepsize to creep closer to event (bisection)\n    return result, False, 0.5",
              "signature": "(t)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time for detection"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "resolve",
              "description": "Resolve the event and record the time (t) at which it occurs.",
              "docstring_html": "<p>Resolve the event and record the time (t) at which it occurs.\nResolves event using the action function (func_act) if it is defined.</p>\n<p>Deactivates the event tracking upon first resolution.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time for event resolution</dd>\n</dl>\n",
              "source": "def resolve(self, t):\n    \"\"\"Resolve the event and record the time (t) at which it occurs. \n    Resolves event using the action function (func_act) if it is defined. \n\n    Deactivates the event tracking upon first resolution.\n\n    Parameters\n    ----------\n    t : float\n        evaluation time for event resolution \n    \"\"\"\n\n    #save the time of event resolution\n    self._times.append(t)\n\n    #action function for event resolution\n    if self.func_act is not None:\n        self.func_act(t)\n\n    #deactivate condition tracking\n    self.off()",
              "signature": "(t)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time for event resolution"
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [],
          "parameters": []
        }
      ],
      "functions": []
    },
    "pathsim.events.schedule": {
      "name": "pathsim.events.schedule",
      "description": "",
      "docstring_html": "",
      "classes": [
        {
          "name": "Schedule",
          "description": "Subclass of base 'Event' that triggers dependent on the evaluation time.",
          "docstring_html": "<p>Subclass of base 'Event' that triggers dependent on the evaluation time.</p>\n<p>Monitors time in every timestep and triggers periodically (period). This event\ndoes not have an event function as the event condition only depends on time.</p>\n<pre class=\"code literal-block\">\ntime == next_schedule_time -&gt; event\n</pre>\n<div class=\"section\" id=\"example\">\n<h4>Example</h4>\n<p>Initialize a scheduled event handler like this:</p>\n<pre class=\"code python literal-block\">\n<span class=\"c1\">#define the action function (callback)</span><span class=\"w\">\n</span><span class=\"k\">def</span><span class=\"w\"> </span><span class=\"nf\">act</span><span class=\"p\">(</span><span class=\"n\">t</span><span class=\"p\">):</span><span class=\"w\">\n</span>    <span class=\"c1\">#do something at event resolution</span><span class=\"w\">\n</span>    <span class=\"k\">pass</span><span class=\"w\">\n\n</span><span class=\"c1\">#initialize the event manager</span><span class=\"w\">\n</span><span class=\"n\">E</span> <span class=\"o\">=</span> <span class=\"n\">Schedule</span><span class=\"p\">(</span><span class=\"w\">\n</span>    <span class=\"n\">t_start</span><span class=\"o\">=</span><span class=\"mi\">0</span><span class=\"p\">,</span>    <span class=\"c1\">#starting at t=0</span><span class=\"w\">\n</span>    <span class=\"n\">t_end</span><span class=\"o\">=</span><span class=\"kc\">None</span><span class=\"p\">,</span>   <span class=\"c1\">#never ending</span><span class=\"w\">\n</span>    <span class=\"n\">t_period</span><span class=\"o\">=</span><span class=\"mi\">3</span><span class=\"p\">,</span>   <span class=\"c1\">#triggering every 3 time units</span><span class=\"w\">\n</span>    <span class=\"n\">func_act</span><span class=\"o\">=</span><span class=\"n\">act</span>  <span class=\"c1\">#resulting in a callback</span><span class=\"w\">\n</span>    <span class=\"p\">)</span>\n</pre>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t_start <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>starting time for schedule</dd>\n<dt>t_end <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>termination time for schedule</dd>\n<dt>t_period <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>time period of schedule, when events are triggered</dd>\n<dt>func_act <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">callable</span></dt>\n<dd>action function for event resolution</dd>\n<dt>tolerance <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>tolerance to check if detection is close to actual event</dd>\n</dl>\n</div>\n",
          "source": "class Schedule(Event):\n    \"\"\"Subclass of base 'Event' that triggers dependent on the evaluation time. \n\n    Monitors time in every timestep and triggers periodically (period). This event\n    does not have an event function as the event condition only depends on time.\n\n    .. code-block::\n\n        time == next_schedule_time -> event\n\n    Example\n    -------\n    Initialize a scheduled event handler like this:\n\n    .. code-block:: python\n\n        #define the action function (callback)\n        def act(t):\n            #do something at event resolution\n            pass\n\n        #initialize the event manager\n        E = Schedule(\n            t_start=0,    #starting at t=0\n            t_end=None,   #never ending\n            t_period=3,   #triggering every 3 time units\n            func_act=act  #resulting in a callback\n            )   \n\n    Parameters\n    ----------\n    t_start : float\n        starting time for schedule\n    t_end : float\n        termination time for schedule\n    t_period : float\n        time period of schedule, when events are triggered\n    func_act : callable\n        action function for event resolution \n    tolerance : float\n        tolerance to check if detection is close to actual event\n    \"\"\"\n\n    def __init__(\n        self, \n        t_start=0, \n        t_end=None, \n        t_period=1, \n        func_act=None,      \n        tolerance=TOLERANCE\n        ):\n        super().__init__(None, func_act, tolerance)\n\n        #schedule times\n        self.t_start = t_start\n        self.t_period = t_period        \n        self.t_end = t_end\n\n\n    def _next(self):\n        \"\"\"\n        return the next period break\n        \"\"\"\n        return self.t_start + len(self._times) * self.t_period\n\n\n    def estimate(self, t):\n        \"\"\"Estimate the time until the next scheduled event.\n\n        Parameters\n        ----------\n        t : float \n            evaluation time for estimation \n\n        Returns\n        -------\n        float\n            estimated time until next event\n        \"\"\"\n        return self._next() - t\n\n\n    def buffer(self, t):\n        \"\"\"Buffer the current time to history\n\n        Parameters\n        ----------\n        t : float\n            buffer time\n        \"\"\"\n        self._history = None, t\n\n\n    def detect(self, t):\n        \"\"\"Check if the event condition is satisfied, i.e. if the \n        time period switch is within the current timestep.\n\n        Parameters\n        ----------\n        t : float\n            evaluation time for detection \n\n        Returns\n        -------\n        detected : bool\n            was an event detected?\n        close : bool\n            are we close to the event?\n        ratio : float\n            interpolated event location ratio in timestep\n        \"\"\"\n\n        #get next period break\n        t_next = self._next()\n\n        #end time reached? -> deactivate event, quit early\n        if self.t_end is not None and t_next > self.t_end:\n            self.off()\n            return False, False, 1.0\n\n        #no event -> quit early\n        if t_next > t:\n            return False, False, 1.0\n\n        #are we close enough to the scheduled event?\n        if abs(t_next - t) <= self.tolerance:\n            return True, True, 0.0 \n\n        #unpack history\n        _, _t = self._history\n\n        #have we already passed the event -> first timestep\n        if _t >= t_next:\n            return True, True, 0.0        \n\n        #whats the timestep ratio?\n        ratio = (t_next - _t) / np.clip(t - _t, TOLERANCE, None)\n\n        return True, False, ratio",
          "bases": [
            "pathsim.events._event.Event"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(\n    self, \n    t_start=0, \n    t_end=None, \n    t_period=1, \n    func_act=None,      \n    tolerance=TOLERANCE\n    ):\n    super().__init__(None, func_act, tolerance)\n\n    #schedule times\n    self.t_start = t_start\n    self.t_period = t_period        \n    self.t_end = t_end",
              "signature": "(t_start = 0, t_end = None, t_period = 1, func_act = None, tolerance = TOLERANCE)",
              "parameters": [
                {
                  "name": "t_start",
                  "type": null,
                  "default": "0",
                  "description": ""
                },
                {
                  "name": "t_end",
                  "type": null,
                  "default": "None",
                  "description": ""
                },
                {
                  "name": "t_period",
                  "type": null,
                  "default": "1",
                  "description": ""
                },
                {
                  "name": "func_act",
                  "type": null,
                  "default": "None",
                  "description": ""
                },
                {
                  "name": "tolerance",
                  "type": null,
                  "default": "TOLERANCE",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "_next",
              "description": "return the next period break",
              "docstring_html": "<p>return the next period break</p>\n",
              "source": "def _next(self):\n    \"\"\"\n    return the next period break\n    \"\"\"\n    return self.t_start + len(self._times) * self.t_period",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "estimate",
              "description": "Estimate the time until the next scheduled event.",
              "docstring_html": "<p>Estimate the time until the next scheduled event.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time for estimation</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>float</dt>\n<dd>estimated time until next event</dd>\n</dl>\n",
              "source": "def estimate(self, t):\n    \"\"\"Estimate the time until the next scheduled event.\n\n    Parameters\n    ----------\n    t : float \n        evaluation time for estimation \n\n    Returns\n    -------\n    float\n        estimated time until next event\n    \"\"\"\n    return self._next() - t",
              "signature": "(t)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time for estimation"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "buffer",
              "description": "Buffer the current time to history",
              "docstring_html": "<p>Buffer the current time to history</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>buffer time</dd>\n</dl>\n",
              "source": "def buffer(self, t):\n    \"\"\"Buffer the current time to history\n\n    Parameters\n    ----------\n    t : float\n        buffer time\n    \"\"\"\n    self._history = None, t",
              "signature": "(t)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "buffer time"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "detect",
              "description": "Check if the event condition is satisfied, i.e. if the",
              "docstring_html": "<p>Check if the event condition is satisfied, i.e. if the\ntime period switch is within the current timestep.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time for detection</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>detected <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>was an event detected?</dd>\n<dt>close <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>are we close to the event?</dd>\n<dt>ratio <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>interpolated event location ratio in timestep</dd>\n</dl>\n",
              "source": "def detect(self, t):\n    \"\"\"Check if the event condition is satisfied, i.e. if the \n    time period switch is within the current timestep.\n\n    Parameters\n    ----------\n    t : float\n        evaluation time for detection \n\n    Returns\n    -------\n    detected : bool\n        was an event detected?\n    close : bool\n        are we close to the event?\n    ratio : float\n        interpolated event location ratio in timestep\n    \"\"\"\n\n    #get next period break\n    t_next = self._next()\n\n    #end time reached? -> deactivate event, quit early\n    if self.t_end is not None and t_next > self.t_end:\n        self.off()\n        return False, False, 1.0\n\n    #no event -> quit early\n    if t_next > t:\n        return False, False, 1.0\n\n    #are we close enough to the scheduled event?\n    if abs(t_next - t) <= self.tolerance:\n        return True, True, 0.0 \n\n    #unpack history\n    _, _t = self._history\n\n    #have we already passed the event -> first timestep\n    if _t >= t_next:\n        return True, True, 0.0        \n\n    #whats the timestep ratio?\n    ratio = (t_next - _t) / np.clip(t - _t, TOLERANCE, None)\n\n    return True, False, ratio",
              "signature": "(t)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time for detection"
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "t_start",
              "description": "",
              "type": null,
              "value": "t_start"
            },
            {
              "name": "t_period",
              "description": "",
              "type": null,
              "value": "t_period"
            },
            {
              "name": "t_end",
              "description": "",
              "type": null,
              "value": "t_end"
            }
          ],
          "parameters": [
            {
              "name": "t_start",
              "type": null,
              "default": "0",
              "description": "starting time for schedule"
            },
            {
              "name": "t_end",
              "type": null,
              "default": "None",
              "description": "termination time for schedule"
            },
            {
              "name": "t_period",
              "type": null,
              "default": "1",
              "description": "time period of schedule, when events are triggered"
            },
            {
              "name": "func_act",
              "type": null,
              "default": "None",
              "description": "action function for event resolution"
            },
            {
              "name": "tolerance",
              "type": null,
              "default": "TOLERANCE",
              "description": "tolerance to check if detection is close to actual event"
            }
          ]
        },
        {
          "name": "ScheduleList",
          "description": "Subclass of base 'Schedule' that triggers dependent on the evaluation time.",
          "docstring_html": "<p>Subclass of base 'Schedule' that triggers dependent on the evaluation time.</p>\n<p>Monitors time in every timestep and triggers at the next event time from the\ntime list. This event does not have an event function as the event condition\nonly depends on time.</p>\n<pre class=\"code literal-block\">\ntime == next_scheduled_time -&gt; event\n</pre>\n<div class=\"section\" id=\"example\">\n<h4>Example</h4>\n<p>Initialize a scheduled event handler like this:</p>\n<pre class=\"code python literal-block\">\n<span class=\"c1\">#define the action function (callback)</span><span class=\"w\">\n</span><span class=\"k\">def</span><span class=\"w\"> </span><span class=\"nf\">act</span><span class=\"p\">(</span><span class=\"n\">t</span><span class=\"p\">):</span><span class=\"w\">\n</span>    <span class=\"c1\">#do something at event resolution</span><span class=\"w\">\n</span>    <span class=\"k\">pass</span><span class=\"w\">\n\n</span><span class=\"c1\">#initialize the event manager</span><span class=\"w\">\n</span><span class=\"n\">E</span> <span class=\"o\">=</span> <span class=\"n\">ScheduleList</span><span class=\"p\">(</span><span class=\"w\">\n</span>    <span class=\"n\">times_evt</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">5</span><span class=\"p\">,</span> <span class=\"mi\">12</span><span class=\"p\">,</span> <span class=\"mi\">300</span><span class=\"p\">],</span>  <span class=\"c1\">#event times where to trigger</span><span class=\"w\">\n</span>    <span class=\"n\">func_act</span><span class=\"o\">=</span><span class=\"n\">act</span>                <span class=\"c1\">#resulting in a callback</span><span class=\"w\">\n</span>    <span class=\"p\">)</span>\n</pre>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>times_evt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">list[float]</span></dt>\n<dd>list of event times in ascending order</dd>\n<dt>func_act <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">callable</span></dt>\n<dd>action function for event resolution</dd>\n<dt>tolerance <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>tolerance to check if detection is close to actual event</dd>\n</dl>\n</div>\n",
          "source": "class ScheduleList(Schedule):\n    \"\"\"Subclass of base 'Schedule' that triggers dependent on the evaluation time. \n\n    Monitors time in every timestep and triggers at the next event time from the \n    time list. This event does not have an event function as the event condition \n    only depends on time.\n\n    .. code-block::\n\n        time == next_scheduled_time -> event\n\n    Example\n    -------\n    Initialize a scheduled event handler like this:\n\n    .. code-block:: python\n\n        #define the action function (callback)\n        def act(t):\n            #do something at event resolution\n            pass\n\n        #initialize the event manager\n        E = ScheduleList(\n            times_evt=[1, 5, 12, 300],  #event times where to trigger\n            func_act=act                #resulting in a callback\n            )   \n\n    Parameters\n    ----------\n    times_evt : list[float]\n        list of event times in ascending order\n    func_act : callable\n        action function for event resolution \n    tolerance : float\n        tolerance to check if detection is close to actual event\n    \"\"\"\n\n    def __init__(\n        self, \n        times_evt=[], \n        func_act=None,      \n        tolerance=TOLERANCE\n        ):\n        super().__init__(None, func_act, tolerance)\n\n        #input validation for times\n        if not times_evt:\n            raise ValueError(\"'times_evt' are empty!\")\n        if len(times_evt) > 1 and np.any(np.diff(times_evt) <= 0.0):\n            raise ValueError(\"'times_evt' need to be in ascending order!\")\n\n        #schedule times\n        self.times_evt = times_evt\n\n\n    def _next(self):\n        \"\"\"return the next event from the event time list by index\"\"\"\n        _n = len(self._times)\n        if _n < len(self.times_evt): \n            return self.times_evt[_n]\n        return self.times_evt[-1]\n\n\n    def detect(self, t):\n        \"\"\"Check if the event condition is satisfied, i.e. if the \n        time period switch is within the current timestep.\n\n        Parameters\n        ----------\n        t : float\n            evaluation time for detection \n\n        Returns\n        -------\n        detected : bool\n            was an event detected?\n        close : bool\n            are we close to the event?\n        ratio : float\n            interpolated event location ratio in timestep\n        \"\"\"\n\n        #check if out of bounds\n        _n = len(self._times)\n        if _n >= len(self.times_evt): \n            self.off()\n            return False, False, 1.0\n\n        #get next event time\n        t_next = self._next()\n\n        #no event -> quit early\n        if t_next > t:\n            return False, False, 1.0\n\n        #are we close enough to the scheduled event?\n        if abs(t_next - t) <= self.tolerance:\n            return True, True, 0.0 \n\n        #unpack history\n        _, _t = self._history\n\n        #have we already passed the event -> first timestep\n        if _t >= t_next:\n            return True, True, 0.0        \n\n        #whats the timestep ratio?\n        ratio = (t_next - _t) / np.clip(t - _t, TOLERANCE, None)\n\n        return True, False, ratio",
          "bases": [
            "pathsim.events.schedule.Schedule"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(\n    self, \n    times_evt=[], \n    func_act=None,      \n    tolerance=TOLERANCE\n    ):\n    super().__init__(None, func_act, tolerance)\n\n    #input validation for times\n    if not times_evt:\n        raise ValueError(\"'times_evt' are empty!\")\n    if len(times_evt) > 1 and np.any(np.diff(times_evt) <= 0.0):\n        raise ValueError(\"'times_evt' need to be in ascending order!\")\n\n    #schedule times\n    self.times_evt = times_evt",
              "signature": "(times_evt = [], func_act = None, tolerance = TOLERANCE)",
              "parameters": [
                {
                  "name": "times_evt",
                  "type": null,
                  "default": "[]",
                  "description": ""
                },
                {
                  "name": "func_act",
                  "type": null,
                  "default": "None",
                  "description": ""
                },
                {
                  "name": "tolerance",
                  "type": null,
                  "default": "TOLERANCE",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "_next",
              "description": "return the next event from the event time list by index",
              "docstring_html": "<p>return the next event from the event time list by index</p>\n",
              "source": "def _next(self):\n    \"\"\"return the next event from the event time list by index\"\"\"\n    _n = len(self._times)\n    if _n < len(self.times_evt): \n        return self.times_evt[_n]\n    return self.times_evt[-1]",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "detect",
              "description": "Check if the event condition is satisfied, i.e. if the",
              "docstring_html": "<p>Check if the event condition is satisfied, i.e. if the\ntime period switch is within the current timestep.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time for detection</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>detected <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>was an event detected?</dd>\n<dt>close <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>are we close to the event?</dd>\n<dt>ratio <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>interpolated event location ratio in timestep</dd>\n</dl>\n",
              "source": "def detect(self, t):\n    \"\"\"Check if the event condition is satisfied, i.e. if the \n    time period switch is within the current timestep.\n\n    Parameters\n    ----------\n    t : float\n        evaluation time for detection \n\n    Returns\n    -------\n    detected : bool\n        was an event detected?\n    close : bool\n        are we close to the event?\n    ratio : float\n        interpolated event location ratio in timestep\n    \"\"\"\n\n    #check if out of bounds\n    _n = len(self._times)\n    if _n >= len(self.times_evt): \n        self.off()\n        return False, False, 1.0\n\n    #get next event time\n    t_next = self._next()\n\n    #no event -> quit early\n    if t_next > t:\n        return False, False, 1.0\n\n    #are we close enough to the scheduled event?\n    if abs(t_next - t) <= self.tolerance:\n        return True, True, 0.0 \n\n    #unpack history\n    _, _t = self._history\n\n    #have we already passed the event -> first timestep\n    if _t >= t_next:\n        return True, True, 0.0        \n\n    #whats the timestep ratio?\n    ratio = (t_next - _t) / np.clip(t - _t, TOLERANCE, None)\n\n    return True, False, ratio",
              "signature": "(t)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time for detection"
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "times_evt",
              "description": "",
              "type": null,
              "value": "times_evt"
            }
          ],
          "parameters": [
            {
              "name": "times_evt",
              "type": null,
              "default": "[]",
              "description": "list of event times in ascending order"
            },
            {
              "name": "func_act",
              "type": null,
              "default": "None",
              "description": "action function for event resolution"
            },
            {
              "name": "tolerance",
              "type": null,
              "default": "TOLERANCE",
              "description": "tolerance to check if detection is close to actual event"
            }
          ]
        }
      ],
      "functions": []
    },
    "pathsim.events.zerocrossing": {
      "name": "pathsim.events.zerocrossing",
      "description": "",
      "docstring_html": "",
      "classes": [
        {
          "name": "ZeroCrossing",
          "description": "Subclass of base 'Event' that triggers if the event function crosses zero.",
          "docstring_html": "<p>Subclass of base 'Event' that triggers if the event function crosses zero.\nThis is a bidirectional zero-crossing detector.</p>\n<p>Monitors system state by evaluating an event function (func_evt) with scalar output and\ntesting for zero crossings (sign changes).</p>\n<pre class=\"code literal-block\">\nfunc_evt(time) -&gt; event?\n</pre>\n<p>If an event is detected, some action (func_act) is performed on the system state.</p>\n<pre class=\"code literal-block\">\nfunc_evt(time) == 0 -&gt; event -&gt; func_act(time)\n</pre>\n<div class=\"section\" id=\"example\">\n<h4>Example</h4>\n<p>Initialize a zero-crossing event handler like this:</p>\n<pre class=\"code python literal-block\">\n<span class=\"c1\">#define the event function</span><span class=\"w\">\n</span><span class=\"k\">def</span><span class=\"w\"> </span><span class=\"nf\">evt</span><span class=\"p\">(</span><span class=\"n\">t</span><span class=\"p\">):</span><span class=\"w\">\n</span>    <span class=\"c1\">#here we have a zero-crossing at 't==10'</span><span class=\"w\">\n</span>    <span class=\"k\">return</span> <span class=\"n\">t</span> <span class=\"o\">-</span> <span class=\"mi\">10</span><span class=\"w\">\n\n</span><span class=\"c1\">#define the action function (callback)</span><span class=\"w\">\n</span><span class=\"k\">def</span><span class=\"w\"> </span><span class=\"nf\">act</span><span class=\"p\">(</span><span class=\"n\">t</span><span class=\"p\">):</span><span class=\"w\">\n</span>    <span class=\"c1\">#do something at event resolution</span><span class=\"w\">\n</span>    <span class=\"k\">pass</span><span class=\"w\">\n\n</span><span class=\"c1\">#initialize the event manager</span><span class=\"w\">\n</span><span class=\"n\">E</span> <span class=\"o\">=</span> <span class=\"n\">ZeroCrossing</span><span class=\"p\">(</span><span class=\"w\">\n</span>    <span class=\"n\">func_evt</span><span class=\"o\">=</span><span class=\"n\">evt</span><span class=\"p\">,</span>  <span class=\"c1\">#the event function</span><span class=\"w\">\n</span>    <span class=\"n\">func_act</span><span class=\"o\">=</span><span class=\"n\">act</span>   <span class=\"c1\">#the action function</span><span class=\"w\">\n</span>    <span class=\"p\">)</span>\n</pre>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>func_evt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">callable</span></dt>\n<dd>event function, where zeros are events</dd>\n<dt>func_act <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">callable</span></dt>\n<dd>action function for event resolution</dd>\n<dt>tolerance <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>tolerance to check if detection is close to actual event</dd>\n</dl>\n</div>\n",
          "source": "class ZeroCrossing(Event):\n    \"\"\"Subclass of base 'Event' that triggers if the event function crosses zero. \n    This is a bidirectional zero-crossing detector. \n\n    Monitors system state by evaluating an event function (func_evt) with scalar output and \n    testing for zero crossings (sign changes). \n\n    .. code-block::\n\n        func_evt(time) -> event?\n\n    If an event is detected, some action (func_act) is performed on the system state.\n\n    .. code-block::\n\n        func_evt(time) == 0 -> event -> func_act(time)\n\n    Example\n    -------\n    Initialize a zero-crossing event handler like this:\n\n    .. code-block:: python\n\n        #define the event function\n        def evt(t):\n            #here we have a zero-crossing at 't==10'\n            return t - 10\n\n        #define the action function (callback)\n        def act(t):\n            #do something at event resolution\n            pass\n\n        #initialize the event manager\n        E = ZeroCrossing(\n            func_evt=evt,  #the event function\n            func_act=act   #the action function\n            )    \n\n    Parameters\n    ----------\n    func_evt : callable\n        event function, where zeros are events\n    func_act : callable\n        action function for event resolution \n    tolerance : float\n        tolerance to check if detection is close to actual event\n    \"\"\"\n\n    def detect(self, t):\n        \"\"\"Evaluate the event function and check for zero-crossings\n\n        Parameters\n        ----------\n        t : float\n            evaluation time for detection \n\n        Returns\n        -------\n        detected : bool\n            was an event detected?\n        close : bool\n            are we close to the event?\n        ratio : float\n            interpolated event location as ratio of timestep\n        \"\"\"\n\n        #evaluate event function\n        result = self.func_evt(t)\n\n        #are we close to the actual event?\n        close = abs(result) <= self.tolerance\n\n        #unpack history\n        _result, _t = self._history\n\n        #no history -> no zero crossing\n        if _result is None:\n            return False, False, 1.0\n\n        #check for zero crossing (sign change)\n        is_event = np.sign(result * _result) < 0 \n\n        #definitely no event detected -> quit early\n        if not is_event:\n            return False, False, 1.0\n\n        #linear interpolation to find event time ratio (secant crosses x-axis)\n        ratio = abs(_result) / np.clip(abs(_result - result), TOLERANCE, None)\n\n        return True, close, float(ratio)",
          "bases": [
            "pathsim.events._event.Event"
          ],
          "methods": [
            {
              "name": "detect",
              "description": "Evaluate the event function and check for zero-crossings",
              "docstring_html": "<p>Evaluate the event function and check for zero-crossings</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time for detection</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>detected <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>was an event detected?</dd>\n<dt>close <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>are we close to the event?</dd>\n<dt>ratio <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>interpolated event location as ratio of timestep</dd>\n</dl>\n",
              "source": "def detect(self, t):\n    \"\"\"Evaluate the event function and check for zero-crossings\n\n    Parameters\n    ----------\n    t : float\n        evaluation time for detection \n\n    Returns\n    -------\n    detected : bool\n        was an event detected?\n    close : bool\n        are we close to the event?\n    ratio : float\n        interpolated event location as ratio of timestep\n    \"\"\"\n\n    #evaluate event function\n    result = self.func_evt(t)\n\n    #are we close to the actual event?\n    close = abs(result) <= self.tolerance\n\n    #unpack history\n    _result, _t = self._history\n\n    #no history -> no zero crossing\n    if _result is None:\n        return False, False, 1.0\n\n    #check for zero crossing (sign change)\n    is_event = np.sign(result * _result) < 0 \n\n    #definitely no event detected -> quit early\n    if not is_event:\n        return False, False, 1.0\n\n    #linear interpolation to find event time ratio (secant crosses x-axis)\n    ratio = abs(_result) / np.clip(abs(_result - result), TOLERANCE, None)\n\n    return True, close, float(ratio)",
              "signature": "(t)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time for detection"
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [],
          "parameters": []
        },
        {
          "name": "ZeroCrossingUp",
          "description": "Modification of standard 'ZeroCrossing' event where events are only triggered",
          "docstring_html": "<p>Modification of standard 'ZeroCrossing' event where events are only triggered\nif the event function changes sign from negative to positive (up). Also called\nunidirectional zero-crossing.</p>\n",
          "source": "class ZeroCrossingUp(Event):\n    \"\"\"Modification of standard 'ZeroCrossing' event where events are only triggered \n    if the event function changes sign from negative to positive (up). Also called\n    unidirectional zero-crossing.\n    \"\"\"\n\n    def detect(self, t):\n        \"\"\"Evaluate the event function and check for zero-crossings\n\n        Parameters\n        ----------\n        t : float\n            evaluation time for detection \n\n        Returns\n        -------\n        detected : bool\n            was an event detected?\n        close : bool\n            are we close to the event?\n        ratio : float\n            interpolated event location as ratio of timestep\n        \"\"\"\n\n        #evaluate event function\n        result = self.func_evt(t)\n\n        #are we close to the actual event?\n        close = abs(result) <= self.tolerance\n\n        #unpack history\n        _result, _t = self._history\n\n        #no history -> no zero crossing\n        if _result is None:\n            return False, False, 1.0\n\n        #check for zero crossing (sign change)\n        is_event = np.sign(result * _result) < 0 and result > _result\n\n        #no event detected or wrong direction -> quit early\n        if not is_event or _result >= 0:\n            return False, False, 1.0\n\n        #linear interpolation to find event time ratio (secant crosses x-axis)\n        ratio = abs(_result) / np.clip(abs(_result - result), TOLERANCE, None)\n\n        return True, close, float(ratio)",
          "bases": [
            "pathsim.events._event.Event"
          ],
          "methods": [
            {
              "name": "detect",
              "description": "Evaluate the event function and check for zero-crossings",
              "docstring_html": "<p>Evaluate the event function and check for zero-crossings</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time for detection</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>detected <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>was an event detected?</dd>\n<dt>close <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>are we close to the event?</dd>\n<dt>ratio <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>interpolated event location as ratio of timestep</dd>\n</dl>\n",
              "source": "def detect(self, t):\n    \"\"\"Evaluate the event function and check for zero-crossings\n\n    Parameters\n    ----------\n    t : float\n        evaluation time for detection \n\n    Returns\n    -------\n    detected : bool\n        was an event detected?\n    close : bool\n        are we close to the event?\n    ratio : float\n        interpolated event location as ratio of timestep\n    \"\"\"\n\n    #evaluate event function\n    result = self.func_evt(t)\n\n    #are we close to the actual event?\n    close = abs(result) <= self.tolerance\n\n    #unpack history\n    _result, _t = self._history\n\n    #no history -> no zero crossing\n    if _result is None:\n        return False, False, 1.0\n\n    #check for zero crossing (sign change)\n    is_event = np.sign(result * _result) < 0 and result > _result\n\n    #no event detected or wrong direction -> quit early\n    if not is_event or _result >= 0:\n        return False, False, 1.0\n\n    #linear interpolation to find event time ratio (secant crosses x-axis)\n    ratio = abs(_result) / np.clip(abs(_result - result), TOLERANCE, None)\n\n    return True, close, float(ratio)",
              "signature": "(t)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time for detection"
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [],
          "parameters": []
        },
        {
          "name": "ZeroCrossingDown",
          "description": "Modification of standard 'ZeroCrossing' event where events are only triggered",
          "docstring_html": "<p>Modification of standard 'ZeroCrossing' event where events are only triggered\nif the event function changes sign from positive to negative (down). Also called\nunidirectional zero-crossing.</p>\n",
          "source": "class ZeroCrossingDown(Event):\n    \"\"\"Modification of standard 'ZeroCrossing' event where events are only triggered \n    if the event function changes sign from positive to negative (down). Also called\n    unidirectional zero-crossing.\n    \"\"\"\n\n    def detect(self, t):\n        \"\"\"Evaluate the event function and check for zero-crossings\n\n        Parameters\n        ----------\n        t : float\n            evaluation time for detection \n\n        Returns\n        -------\n        detected : bool\n            was an event detected?\n        close : bool\n            are we close to the event?\n        ratio : float\n            interpolated event location as ratio of timestep\n        \"\"\"\n\n        #evaluate event function\n        result = self.func_evt(t)\n\n        #are we close to the actual event?\n        close = abs(result) <= self.tolerance\n\n        #unpack history\n        _result, _t = self._history\n\n        #no history -> no zero crossing\n        if _result is None:\n            return False, False, 1.0\n\n        #check for zero crossing (sign change)\n        is_event = np.sign(result * _result) < 0 and result < _result\n\n        #no event detected or wrong direction -> quit early\n        if not is_event or _result <= 0:\n            return False, False, 1.0\n\n        #linear interpolation to find event time ratio (secant crosses x-axis)\n        ratio = abs(_result) / np.clip(abs(_result - result), TOLERANCE, None)\n\n        return True, close, float(ratio)",
          "bases": [
            "pathsim.events._event.Event"
          ],
          "methods": [
            {
              "name": "detect",
              "description": "Evaluate the event function and check for zero-crossings",
              "docstring_html": "<p>Evaluate the event function and check for zero-crossings</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time for detection</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>detected <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>was an event detected?</dd>\n<dt>close <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>are we close to the event?</dd>\n<dt>ratio <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>interpolated event location as ratio of timestep</dd>\n</dl>\n",
              "source": "def detect(self, t):\n    \"\"\"Evaluate the event function and check for zero-crossings\n\n    Parameters\n    ----------\n    t : float\n        evaluation time for detection \n\n    Returns\n    -------\n    detected : bool\n        was an event detected?\n    close : bool\n        are we close to the event?\n    ratio : float\n        interpolated event location as ratio of timestep\n    \"\"\"\n\n    #evaluate event function\n    result = self.func_evt(t)\n\n    #are we close to the actual event?\n    close = abs(result) <= self.tolerance\n\n    #unpack history\n    _result, _t = self._history\n\n    #no history -> no zero crossing\n    if _result is None:\n        return False, False, 1.0\n\n    #check for zero crossing (sign change)\n    is_event = np.sign(result * _result) < 0 and result < _result\n\n    #no event detected or wrong direction -> quit early\n    if not is_event or _result <= 0:\n        return False, False, 1.0\n\n    #linear interpolation to find event time ratio (secant crosses x-axis)\n    ratio = abs(_result) / np.clip(abs(_result - result), TOLERANCE, None)\n\n    return True, close, float(ratio)",
              "signature": "(t)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time for detection"
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [],
          "parameters": []
        }
      ],
      "functions": []
    },
    "pathsim.optim.anderson": {
      "name": "pathsim.optim.anderson",
      "description": "",
      "docstring_html": "",
      "classes": [
        {
          "name": "Anderson",
          "description": "Class for accelerated fixed-point iteration through anderson acceleration.",
          "docstring_html": "<p>Class for accelerated fixed-point iteration through anderson acceleration.\nSolves a nonlinear set of equations given in the fixed-point form:</p>\n<blockquote>\nx = g(x)</blockquote>\n<p>Anderson Accelerstion tracks the evolution of the solution from the previous\niterations. The next step in the iteration is computed as a linear combination\nof the previous iterates. The coefficients are computed to minimize the least\nsquares error of the fixed-point problem.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>m <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>buffer length</dd>\n<dt>restart <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>clear buffer when full</dd>\n</dl>\n",
          "source": "class Anderson:\n    \"\"\"Class for accelerated fixed-point iteration through anderson acceleration. \n    Solves a nonlinear set of equations given in the fixed-point form:\n\n        x = g(x)\n\n    Anderson Accelerstion tracks the evolution of the solution from the previous \n    iterations. The next step in the iteration is computed as a linear combination \n    of the previous iterates. The coefficients are computed to minimize the least \n    squares error of the fixed-point problem.\n\n    Parameters\n    ----------\n    m : int\n        buffer length\n    restart : bool\n        clear buffer when full\n    \"\"\"\n\n    def __init__(self, m=5, restart=False):\n\n        #length of buffer for next estimate\n        self.m = m\n\n        #restart after buffer length is reached?\n        self.restart = restart\n\n        #rolling difference buffers\n        self.dx_buffer = deque(maxlen=self.m)\n        self.dr_buffer = deque(maxlen=self.m)\n\n        #prvious values\n        self.x_prev = None\n        self.r_prev = None\n\n\n    def __bool__(self):\n        return True\n\n\n    def solve(self, func, x0, iterations_max=100, tolerance=1e-6):\n        \"\"\"Solve the function 'func' with initial \n        value 'x0' up to a certain tolerance.\n\n        Parameters\n        ----------\n        func : callable\n            function to solve\n        x0 : numeric\n            starting value for solution\n        iterations_max : int\n            maximum number of solver iterations\n        tolerance : float\n            convergence condition\n\n        Returns\n        -------\n        x : numeric\n            solution\n        res : float\n            residual\n        i : int\n            iteration count\n        \"\"\"\n\n        _x = x0.copy()\n        for i in range(iterations_max):\n            _x, _res = self.step(_x, func(_x)+_x)\n            if _res < tolerance:\n                return _x, _res, i\n\n        raise RuntimeError(f\"did not converge in {iterations_max} steps\")\n\n\n    def reset(self):\n        \"\"\"reset the anderson accelerator\"\"\"\n\n        #clear difference buffers\n        self.dx_buffer.clear()\n        self.dr_buffer.clear()\n\n        #clear previous values\n        self.x_prev = None\n        self.r_prev = None\n\n\n    def step(self, x, g):\n        \"\"\"Perform one iteration on the fixed-point solution.\n\n        Parameters\n        ----------\n        x : float, array\n            current solution\n        g : float, array\n            current evaluation of g(x)\n\n        Returns\n        -------\n        x : float, array\n            new solution\n        res : float\n            residual norm, fixed point error\n        \"\"\"\n\n        #make numeric if value\n        _x = Value.numeric(x)\n        _g = Value.numeric(g)\n\n        #residual (this gets minimized)\n        _res = _g - _x\n\n        #fallback to regular fpi if 'm == 0'\n        if self.m == 0:\n            return g, np.linalg.norm(_res)\n\n        #if no buffer, regular fixed-point update\n        if self.x_prev is None:\n\n            #save values for next iteration\n            self.x_prev = _x\n            self.r_prev = _res\n\n            return g, np.linalg.norm(_res)\n\n        #append to difference buffer\n        self.dx_buffer.append(_x - self.x_prev)\n        self.dr_buffer.append(_res - self.r_prev)\n\n        #save values for next iteration\n        self.x_prev = _x\n        self.r_prev = _res\n\n        #if buffer size 'm' reached, restart\n        if self.restart and len(self.dx_buffer) >= self.m:\n            self.reset()\n            return g, np.linalg.norm(_res)\n\n        #get difference matrices \n        dX = np.array(self.dx_buffer)\n        dR = np.array(self.dr_buffer)\n\n        #exit for scalar values\n        if np.isscalar(_res):\n\n            #delta squared norm\n            dR2 = np.dot(dR, dR)\n\n            #catch division by zero\n            if dR2 <= 1e-14:\n                return g, abs(_res)\n\n            #new solution and residual\n            return x - _res * np.dot(dR, dX) / dR2, abs(_res)\n\n        #compute coefficients from least squares problem\n        C, *_ = np.linalg.lstsq(dR.T, _res, rcond=None)\n\n        #new solution and residual norm\n        return x - C @ dX, np.linalg.norm(_res)",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, m=5, restart=False):\n\n    #length of buffer for next estimate\n    self.m = m\n\n    #restart after buffer length is reached?\n    self.restart = restart\n\n    #rolling difference buffers\n    self.dx_buffer = deque(maxlen=self.m)\n    self.dr_buffer = deque(maxlen=self.m)\n\n    #prvious values\n    self.x_prev = None\n    self.r_prev = None",
              "signature": "(m = 5, restart = False)",
              "parameters": [
                {
                  "name": "m",
                  "type": null,
                  "default": "5",
                  "description": ""
                },
                {
                  "name": "restart",
                  "type": null,
                  "default": "False",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "solve",
              "description": "Solve the function 'func' with initial",
              "docstring_html": "<p>Solve the function 'func' with initial\nvalue 'x0' up to a certain tolerance.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>func <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">callable</span></dt>\n<dd>function to solve</dd>\n<dt>x0 <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">numeric</span></dt>\n<dd>starting value for solution</dd>\n<dt>iterations_max <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>maximum number of solver iterations</dd>\n<dt>tolerance <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>convergence condition</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>x <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">numeric</span></dt>\n<dd>solution</dd>\n<dt>res <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>residual</dd>\n<dt>i <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>iteration count</dd>\n</dl>\n",
              "source": "def solve(self, func, x0, iterations_max=100, tolerance=1e-6):\n    \"\"\"Solve the function 'func' with initial \n    value 'x0' up to a certain tolerance.\n\n    Parameters\n    ----------\n    func : callable\n        function to solve\n    x0 : numeric\n        starting value for solution\n    iterations_max : int\n        maximum number of solver iterations\n    tolerance : float\n        convergence condition\n\n    Returns\n    -------\n    x : numeric\n        solution\n    res : float\n        residual\n    i : int\n        iteration count\n    \"\"\"\n\n    _x = x0.copy()\n    for i in range(iterations_max):\n        _x, _res = self.step(_x, func(_x)+_x)\n        if _res < tolerance:\n            return _x, _res, i\n\n    raise RuntimeError(f\"did not converge in {iterations_max} steps\")",
              "signature": "(func, x0, iterations_max = 100, tolerance = 1e-06)",
              "parameters": [
                {
                  "name": "func",
                  "type": null,
                  "default": null,
                  "description": "function to solve"
                },
                {
                  "name": "x0",
                  "type": null,
                  "default": null,
                  "description": "starting value for solution"
                },
                {
                  "name": "iterations_max",
                  "type": null,
                  "default": "100",
                  "description": "maximum number of solver iterations"
                },
                {
                  "name": "tolerance",
                  "type": null,
                  "default": "1e-06",
                  "description": "convergence condition"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "reset",
              "description": "reset the anderson accelerator",
              "docstring_html": "<p>reset the anderson accelerator</p>\n",
              "source": "def reset(self):\n    \"\"\"reset the anderson accelerator\"\"\"\n\n    #clear difference buffers\n    self.dx_buffer.clear()\n    self.dr_buffer.clear()\n\n    #clear previous values\n    self.x_prev = None\n    self.r_prev = None",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "step",
              "description": "Perform one iteration on the fixed-point solution.",
              "docstring_html": "<p>Perform one iteration on the fixed-point solution.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>x <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float, array</span></dt>\n<dd>current solution</dd>\n<dt>g <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float, array</span></dt>\n<dd>current evaluation of g(x)</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>x <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float, array</span></dt>\n<dd>new solution</dd>\n<dt>res <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>residual norm, fixed point error</dd>\n</dl>\n",
              "source": "def step(self, x, g):\n    \"\"\"Perform one iteration on the fixed-point solution.\n\n    Parameters\n    ----------\n    x : float, array\n        current solution\n    g : float, array\n        current evaluation of g(x)\n\n    Returns\n    -------\n    x : float, array\n        new solution\n    res : float\n        residual norm, fixed point error\n    \"\"\"\n\n    #make numeric if value\n    _x = Value.numeric(x)\n    _g = Value.numeric(g)\n\n    #residual (this gets minimized)\n    _res = _g - _x\n\n    #fallback to regular fpi if 'm == 0'\n    if self.m == 0:\n        return g, np.linalg.norm(_res)\n\n    #if no buffer, regular fixed-point update\n    if self.x_prev is None:\n\n        #save values for next iteration\n        self.x_prev = _x\n        self.r_prev = _res\n\n        return g, np.linalg.norm(_res)\n\n    #append to difference buffer\n    self.dx_buffer.append(_x - self.x_prev)\n    self.dr_buffer.append(_res - self.r_prev)\n\n    #save values for next iteration\n    self.x_prev = _x\n    self.r_prev = _res\n\n    #if buffer size 'm' reached, restart\n    if self.restart and len(self.dx_buffer) >= self.m:\n        self.reset()\n        return g, np.linalg.norm(_res)\n\n    #get difference matrices \n    dX = np.array(self.dx_buffer)\n    dR = np.array(self.dr_buffer)\n\n    #exit for scalar values\n    if np.isscalar(_res):\n\n        #delta squared norm\n        dR2 = np.dot(dR, dR)\n\n        #catch division by zero\n        if dR2 <= 1e-14:\n            return g, abs(_res)\n\n        #new solution and residual\n        return x - _res * np.dot(dR, dX) / dR2, abs(_res)\n\n    #compute coefficients from least squares problem\n    C, *_ = np.linalg.lstsq(dR.T, _res, rcond=None)\n\n    #new solution and residual norm\n    return x - C @ dX, np.linalg.norm(_res)",
              "signature": "(x, g)",
              "parameters": [
                {
                  "name": "x",
                  "type": null,
                  "default": null,
                  "description": "current solution"
                },
                {
                  "name": "g",
                  "type": null,
                  "default": null,
                  "description": "current evaluation of g(x)"
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "m",
              "description": "",
              "type": null,
              "value": "m"
            },
            {
              "name": "restart",
              "description": "",
              "type": null,
              "value": "restart"
            },
            {
              "name": "dx_buffer",
              "description": "",
              "type": null,
              "value": "deque(maxlen=(self.m))"
            },
            {
              "name": "dr_buffer",
              "description": "",
              "type": null,
              "value": "deque(maxlen=(self.m))"
            },
            {
              "name": "x_prev",
              "description": "",
              "type": null,
              "value": "None"
            },
            {
              "name": "r_prev",
              "description": "",
              "type": null,
              "value": "None"
            }
          ],
          "parameters": [
            {
              "name": "m",
              "type": null,
              "default": "5",
              "description": "Anderson Accelerstion tracks the evolution of the solution from the previous iterations. The next step in the iteration is computed as a linear combination of the previous iterates. The coefficients are computed to minimize the least squares error of the fixed-point problem."
            },
            {
              "name": "restart",
              "type": null,
              "default": "False",
              "description": "clear buffer when full"
            }
          ]
        },
        {
          "name": "NewtonAnderson",
          "description": "Modified class for hybrid anderson acceleration that can use a jacobian 'jac' of",
          "docstring_html": "<p>Modified class for hybrid anderson acceleration that can use a jacobian 'jac' of\nthe function 'g' for a newton step before the fixed point step for the initial\nestimate before applying the anderson acceleration.</p>\n<p>If a jacobian 'jac' is available, this significantly improves the convergence\n(speed and robustness) of the solution.</p>\n",
          "source": "class NewtonAnderson(Anderson):\n    \"\"\"Modified class for hybrid anderson acceleration that can use a jacobian 'jac' of \n    the function 'g' for a newton step before the fixed point step for the initial \n    estimate before applying the anderson acceleration.\n\n    If a jacobian 'jac' is available, this significantly improves the convergence \n    (speed and robustness) of the solution.\n    \"\"\"\n\n\n    def solve(self, func, x0, jac=None, iterations_max=100, tolerance=1e-6):\n        \"\"\"Solve the function 'func' with initial value 'x0' up to a certain tolerance.\n\n        Parameters\n        ----------\n        func : callable\n            function to solve\n        x0 : numeric\n            starting value for solution\n        jac : callable\n            jacobian of 'func'\n        iterations_max : int\n            maximum number of solver iterations\n        tolerance : float\n            convergence condition\n\n        Returns\n        -------\n        x : numeric\n            solution\n        res : float\n            residual\n        i : int\n            iteration count\n        \"\"\"\n\n        _x = x0.copy()\n        for i in range(iterations_max):\n            _x, _res = self.step(_x, func(_x)+_x, None if jac is None else jac(_x))\n            if _res < tolerance:\n                return _x, _res, i\n\n        raise RuntimeError(f\"did not converge in {iterations_max} steps\")\n\n\n    def _newton(self, x, g, jac):\n        \"\"\"Newton step on solution, where 'f=g-x' is the \n        residual and 'jac' is the jacobian of 'g'.\n\n        Parameters\n        ----------\n        x : float, array\n            current solution\n        g : float, array\n            current evaluation of g(x)\n        jac : array\n            evaluation of jacobian of 'g'\n\n        Returns\n        -------\n        x : float, array\n            new solution\n        res : float\n            residual norm\n        \"\"\"\n\n        #make numeric if value\n        _x   = Value.numeric(x)\n        _g   = Value.numeric(g)\n        _jac = Value.numeric(jac)\n\n        #compute residual\n        _res = _g - _x\n\n        #early exit for scalar or purely vectorial values\n        if np.isscalar(_res) or np.ndim(_jac) == 1:\n\n            return x - _res / (_jac - 1.0), np.linalg.norm(_res)\n\n        #vectorial values (newton raphson)\n        return x - np.linalg.solve(_jac - np.eye(len(_res)), _res), np.linalg.norm(_res)\n\n\n    def step(self, x, g, jac=None):\n        \"\"\"Perform one iteration on the fixed-point solution. \n\n        If the jacobian of g 'jac' is provided, a newton step \n        is performed previous to anderson acceleration.\n\n        Parameters\n        ----------\n        x : float, array\n            current solution\n        g : float, array\n            current evaluation of g(x)\n        jac : array\n            evaluation of jacobian of 'g'\n\n        Returns\n        -------\n        x : float, array\n            new solution\n        res : float\n            residual norm\n        \"\"\"\n\n        #newton step if jacobian available\n        if jac is None: \n\n            #regular anderson step with residual\n            return super().step(x, g)\n        else: \n            #newton step with residual\n            _x, res_norm = self._newton(x, g, jac)\n\n            #anderson step with no residual\n            y, _ = super().step(_x, g)\n\n            return y, res_norm",
          "bases": [
            "pathsim.optim.anderson.Anderson"
          ],
          "methods": [
            {
              "name": "solve",
              "description": "Solve the function 'func' with initial value 'x0' up to a certain tolerance.",
              "docstring_html": "<p>Solve the function 'func' with initial value 'x0' up to a certain tolerance.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>func <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">callable</span></dt>\n<dd>function to solve</dd>\n<dt>x0 <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">numeric</span></dt>\n<dd>starting value for solution</dd>\n<dt>jac <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">callable</span></dt>\n<dd>jacobian of 'func'</dd>\n<dt>iterations_max <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>maximum number of solver iterations</dd>\n<dt>tolerance <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>convergence condition</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>x <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">numeric</span></dt>\n<dd>solution</dd>\n<dt>res <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>residual</dd>\n<dt>i <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>iteration count</dd>\n</dl>\n",
              "source": "def solve(self, func, x0, jac=None, iterations_max=100, tolerance=1e-6):\n    \"\"\"Solve the function 'func' with initial value 'x0' up to a certain tolerance.\n\n    Parameters\n    ----------\n    func : callable\n        function to solve\n    x0 : numeric\n        starting value for solution\n    jac : callable\n        jacobian of 'func'\n    iterations_max : int\n        maximum number of solver iterations\n    tolerance : float\n        convergence condition\n\n    Returns\n    -------\n    x : numeric\n        solution\n    res : float\n        residual\n    i : int\n        iteration count\n    \"\"\"\n\n    _x = x0.copy()\n    for i in range(iterations_max):\n        _x, _res = self.step(_x, func(_x)+_x, None if jac is None else jac(_x))\n        if _res < tolerance:\n            return _x, _res, i\n\n    raise RuntimeError(f\"did not converge in {iterations_max} steps\")",
              "signature": "(func, x0, jac = None, iterations_max = 100, tolerance = 1e-06)",
              "parameters": [
                {
                  "name": "func",
                  "type": null,
                  "default": null,
                  "description": "function to solve"
                },
                {
                  "name": "x0",
                  "type": null,
                  "default": null,
                  "description": "starting value for solution"
                },
                {
                  "name": "jac",
                  "type": null,
                  "default": "None",
                  "description": "jacobian of 'func'"
                },
                {
                  "name": "iterations_max",
                  "type": null,
                  "default": "100",
                  "description": "maximum number of solver iterations"
                },
                {
                  "name": "tolerance",
                  "type": null,
                  "default": "1e-06",
                  "description": "convergence condition"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "_newton",
              "description": "Newton step on solution, where 'f=g-x' is the",
              "docstring_html": "<p>Newton step on solution, where 'f=g-x' is the\nresidual and 'jac' is the jacobian of 'g'.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>x <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float, array</span></dt>\n<dd>current solution</dd>\n<dt>g <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float, array</span></dt>\n<dd>current evaluation of g(x)</dd>\n<dt>jac <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array</span></dt>\n<dd>evaluation of jacobian of 'g'</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>x <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float, array</span></dt>\n<dd>new solution</dd>\n<dt>res <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>residual norm</dd>\n</dl>\n",
              "source": "def _newton(self, x, g, jac):\n    \"\"\"Newton step on solution, where 'f=g-x' is the \n    residual and 'jac' is the jacobian of 'g'.\n\n    Parameters\n    ----------\n    x : float, array\n        current solution\n    g : float, array\n        current evaluation of g(x)\n    jac : array\n        evaluation of jacobian of 'g'\n\n    Returns\n    -------\n    x : float, array\n        new solution\n    res : float\n        residual norm\n    \"\"\"\n\n    #make numeric if value\n    _x   = Value.numeric(x)\n    _g   = Value.numeric(g)\n    _jac = Value.numeric(jac)\n\n    #compute residual\n    _res = _g - _x\n\n    #early exit for scalar or purely vectorial values\n    if np.isscalar(_res) or np.ndim(_jac) == 1:\n\n        return x - _res / (_jac - 1.0), np.linalg.norm(_res)\n\n    #vectorial values (newton raphson)\n    return x - np.linalg.solve(_jac - np.eye(len(_res)), _res), np.linalg.norm(_res)",
              "signature": "(x, g, jac)",
              "parameters": [
                {
                  "name": "x",
                  "type": null,
                  "default": null,
                  "description": "current solution"
                },
                {
                  "name": "g",
                  "type": null,
                  "default": null,
                  "description": "current evaluation of g(x)"
                },
                {
                  "name": "jac",
                  "type": null,
                  "default": null,
                  "description": "evaluation of jacobian of 'g'"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "step",
              "description": "Perform one iteration on the fixed-point solution.",
              "docstring_html": "<p>Perform one iteration on the fixed-point solution.</p>\n<p>If the jacobian of g 'jac' is provided, a newton step\nis performed previous to anderson acceleration.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>x <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float, array</span></dt>\n<dd>current solution</dd>\n<dt>g <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float, array</span></dt>\n<dd>current evaluation of g(x)</dd>\n<dt>jac <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array</span></dt>\n<dd>evaluation of jacobian of 'g'</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>x <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float, array</span></dt>\n<dd>new solution</dd>\n<dt>res <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>residual norm</dd>\n</dl>\n",
              "source": "def step(self, x, g, jac=None):\n    \"\"\"Perform one iteration on the fixed-point solution. \n\n    If the jacobian of g 'jac' is provided, a newton step \n    is performed previous to anderson acceleration.\n\n    Parameters\n    ----------\n    x : float, array\n        current solution\n    g : float, array\n        current evaluation of g(x)\n    jac : array\n        evaluation of jacobian of 'g'\n\n    Returns\n    -------\n    x : float, array\n        new solution\n    res : float\n        residual norm\n    \"\"\"\n\n    #newton step if jacobian available\n    if jac is None: \n\n        #regular anderson step with residual\n        return super().step(x, g)\n    else: \n        #newton step with residual\n        _x, res_norm = self._newton(x, g, jac)\n\n        #anderson step with no residual\n        y, _ = super().step(_x, g)\n\n        return y, res_norm",
              "signature": "(x, g, jac = None)",
              "parameters": [
                {
                  "name": "x",
                  "type": null,
                  "default": null,
                  "description": "current solution"
                },
                {
                  "name": "g",
                  "type": null,
                  "default": null,
                  "description": "current evaluation of g(x)"
                },
                {
                  "name": "jac",
                  "type": null,
                  "default": "None",
                  "description": "evaluation of jacobian of 'g'"
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [],
          "parameters": []
        }
      ],
      "functions": []
    },
    "pathsim.optim.numerical": {
      "name": "pathsim.optim.numerical",
      "description": "",
      "docstring_html": "",
      "classes": [],
      "functions": [
        {
          "name": "num_jac",
          "description": "Numerically computes the jacobian of the function 'func'",
          "docstring_html": "<p>Numerically computes the jacobian of the function 'func'\nby central differences.</p>\n<p>The stepsize 'h' is adaptively computed as a relative perturbation\n'r' with a small offset to avoid division by zero.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>func <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">callable</span></dt>\n<dd>function to compute jacobian for</dd>\n<dt>x <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float, array[float]</span></dt>\n<dd>value for function at which the jacobian is evaluated</dd>\n<dt>r <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>relative perturbation</dd>\n<dt>tol <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>tolerance for division by zero clipping</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>jac <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array[array[float]]</span></dt>\n<dd>2d jacobian array</dd>\n</dl>\n",
          "source": "def num_jac(func, x, r=1e-3, tol=TOLERANCE):\n    \"\"\"Numerically computes the jacobian of the function 'func' \n    by central differences. \n\n    The stepsize 'h' is adaptively computed as a relative perturbation \n    'r' with a small offset to avoid division by zero.\n\n    Parameters\n    ----------\n    func : callable\n        function to compute jacobian for\n    x : float, array[float] \n        value for function at which the jacobian is evaluated\n    r : float\n        relative perturbation\n    tol : float\n        tolerance for division by zero clipping\n\n    Returns\n    -------\n    jac : array[array[float]]\n        2d jacobian array\n    \"\"\"\n\n    #stepsize relative to value with clipping\n    H = np.clip(abs(r*x), tol, None)\n\n    #catch scalar case (gradient)\n    if np.isscalar(x):\n        return 0.5 * (func(x + H) - func(x - H)) / H\n\n    #perturbation matrix and jacobian\n    return 0.5 * np.array(\n        [(func(x + hv) - func(x - hv)) / h \n            for hv, h in zip(np.diag(H), H)]\n        ).T",
          "signature": "(func, x, r = 0.001, tol = TOLERANCE)",
          "parameters": [
            {
              "name": "func",
              "type": null,
              "default": null,
              "description": "function to compute jacobian for"
            },
            {
              "name": "x",
              "type": null,
              "default": null,
              "description": "value for function at which the jacobian is evaluated"
            },
            {
              "name": "r",
              "type": null,
              "default": "0.001",
              "description": "relative perturbation"
            },
            {
              "name": "tol",
              "type": null,
              "default": "TOLERANCE",
              "description": "tolerance for division by zero clipping"
            }
          ],
          "returns": null
        },
        {
          "name": "num_autojac",
          "description": "Wraps a function object such that it computes the jacobian",
          "docstring_html": "<p>Wraps a function object such that it computes the jacobian\nof the function with respect to the first argument.</p>\n<p>This is intended to compute the jacobian 'jac(x, u, t)' of\nthe right hand side function 'func(x, u, t)' of numerical\nintegrators with respect to 'x'.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>func <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">callable</span></dt>\n<dd>function to wrap for jacobian</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>wrap_func <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">callable</span></dt>\n<dd>wrapped funtion as numerical jacobian of 'func'</dd>\n</dl>\n",
          "source": "def num_autojac(func):\n    \"\"\"Wraps a function object such that it computes the jacobian \n    of the function with respect to the first argument.\n\n    This is intended to compute the jacobian 'jac(x, u, t)' of \n    the right hand side function 'func(x, u, t)' of numerical \n    integrators with respect to 'x'.\n\n    Parameters\n    ----------\n    func : callable\n        function to wrap for jacobian \n\n    Returns\n    -------\n    wrap_func : callable\n        wrapped funtion as numerical jacobian of 'func'\n    \"\"\"\n    def wrap_func(*args):\n        _x, *_args = args\n        return num_jac(lambda x: func(x, *_args), _x)\n    return wrap_func",
          "signature": "(func)",
          "parameters": [
            {
              "name": "func",
              "type": null,
              "default": null,
              "description": "function to wrap for jacobian"
            }
          ],
          "returns": null
        }
      ]
    },
    "pathsim.optim.operator": {
      "name": "pathsim.optim.operator",
      "description": "",
      "docstring_html": "",
      "classes": [
        {
          "name": "Operator",
          "description": "Operator class for function evaluation and linearization.",
          "docstring_html": "<p>Operator class for function evaluation and linearization.</p>\n<p>This class wraps a function to provide both direct evaluation and linear approximation\ncapabilities. When linearized around a point x0, subsequent calls use the first-order\nTaylor approximation</p>\n<div class=\"math\">\n\\begin{equation*}\nf(x) \\approx f(x_0) + \\mathbf{J}(x_0) (x - x_0)\n\\end{equation*}\n</div>\n<p>instead of evaluating the function.</p>\n<p>The class supports multiple methods for Jacobian computation: user-provided analytical\nJacobians, automatic differentiation via the Value class, and numerical differentiation\nas a fallback.</p>\n<div class=\"section\" id=\"example\">\n<h4>Example</h4>\n<p>Basic usage with automatic differentiation:</p>\n<pre class=\"code python literal-block\">\n<span class=\"k\">def</span><span class=\"w\"> </span><span class=\"nf\">f</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">):</span><span class=\"w\">\n</span>    <span class=\"k\">return</span> <span class=\"n\">x</span><span class=\"o\">**</span><span class=\"mi\">2</span> <span class=\"o\">+</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">sin</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span><span class=\"w\">\n\n</span><span class=\"n\">op</span> <span class=\"o\">=</span> <span class=\"n\">Operator</span><span class=\"p\">(</span><span class=\"n\">f</span><span class=\"p\">)</span><span class=\"w\">\n\n</span><span class=\"c1\"># Direct function evaluation</span><span class=\"w\">\n</span><span class=\"n\">y1</span> <span class=\"o\">=</span> <span class=\"n\">op</span><span class=\"p\">(</span><span class=\"mf\">2.0</span><span class=\"p\">)</span><span class=\"w\">\n\n</span><span class=\"c1\"># Linearize at current point</span><span class=\"w\">\n</span><span class=\"n\">op</span><span class=\"o\">.</span><span class=\"n\">linearize</span><span class=\"p\">(</span><span class=\"mf\">2.0</span><span class=\"p\">)</span><span class=\"w\">\n\n</span><span class=\"c1\"># Use linear approximation</span><span class=\"w\">\n</span><span class=\"n\">y2</span> <span class=\"o\">=</span> <span class=\"n\">op</span><span class=\"p\">(</span><span class=\"mf\">2.1</span><span class=\"p\">)</span>  <span class=\"c1\"># Returns f(2.0) + J(2.0) (2.1-2.0)</span>\n</pre>\n<p>With user-provided Jacobian:</p>\n<pre class=\"code python literal-block\">\n<span class=\"k\">def</span><span class=\"w\"> </span><span class=\"nf\">f</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">):</span><span class=\"w\">\n</span>    <span class=\"k\">return</span> <span class=\"n\">x</span><span class=\"o\">**</span><span class=\"mi\">2</span> <span class=\"o\">+</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">sin</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span><span class=\"w\">\n\n</span><span class=\"k\">def</span><span class=\"w\"> </span><span class=\"nf\">df_dx</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">):</span><span class=\"w\">\n</span>    <span class=\"k\">return</span> <span class=\"mi\">2</span><span class=\"o\">*</span><span class=\"n\">x</span> <span class=\"o\">+</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">cos</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span><span class=\"w\">\n\n</span><span class=\"n\">op</span> <span class=\"o\">=</span> <span class=\"n\">Operator</span><span class=\"p\">(</span><span class=\"n\">f</span><span class=\"p\">,</span> <span class=\"n\">jac</span><span class=\"o\">=</span><span class=\"n\">df_dx</span><span class=\"p\">)</span><span class=\"w\">\n\n</span><span class=\"n\">op</span><span class=\"o\">.</span><span class=\"n\">linearize</span><span class=\"p\">(</span><span class=\"mf\">2.0</span><span class=\"p\">)</span>  <span class=\"c1\"># Uses df_dx for Jacobian</span>\n</pre>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>func <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">callable</span></dt>\n<dd>The function to wrap</dd>\n<dt>jac <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">callable, optional</span></dt>\n<dd>Optional analytical Jacobian of func. If None, automatic or numerical\ndifferentiation will be used.</dd>\n</dl>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>f0 <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array_like</span></dt>\n<dd>function evaluation at operating point</dd>\n<dt>x0 <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array_like</span></dt>\n<dd>operating point</dd>\n<dt>J <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array_like</span></dt>\n<dd>jacobian matrix at operating point</dd>\n</dl>\n</div>\n",
          "source": "class Operator(object):\n    \"\"\"Operator class for function evaluation and linearization.\n\n    This class wraps a function to provide both direct evaluation and linear approximation\n    capabilities. When linearized around a point x0, subsequent calls use the first-order\n    Taylor approximation \n\n    .. math::\n\n        f(x) \\\\approx f(x_0) + \\\\mathbf{J}(x_0) (x - x_0)\n\n\n    instead of evaluating the function.\n\n    The class supports multiple methods for Jacobian computation: user-provided analytical\n    Jacobians, automatic differentiation via the Value class, and numerical differentiation\n    as a fallback.\n\n    Example\n    -------\n    Basic usage with automatic differentiation:\n\n    .. code-block:: python\n\n        def f(x):\n            return x**2 + np.sin(x)\n\n        op = Operator(f)\n\n        # Direct function evaluation\n        y1 = op(2.0)\n\n        # Linearize at current point\n        op.linearize(2.0)\n\n        # Use linear approximation\n        y2 = op(2.1)  # Returns f(2.0) + J(2.0) (2.1-2.0)\n\n    With user-provided Jacobian:\n\n    .. code-block:: python\n\n        def f(x):\n            return x**2 + np.sin(x)\n\n        def df_dx(x):\n            return 2*x + np.cos(x)\n\n        op = Operator(f, jac=df_dx)\n\n        op.linearize(2.0)  # Uses df_dx for Jacobian\n\n    Parameters\n    ----------\n    func : callable\n        The function to wrap\n    jac : callable, optional\n        Optional analytical Jacobian of func. If None, automatic or numerical\n        differentiation will be used.\n\n    Attributes\n    ----------\n    f0 : array_like\n        function evaluation at operating point\n    x0 : array_like\n        operating point\n    J : array_like\n        jacobian matrix at operating point\n\n    \"\"\"\n\n    def __init__(self, func, jac=None):\n        self._func = func\n        self._jac = jac\n        self.f0 = None\n        self.x0 = None\n        self.J = None\n\n\n    def __bool__(self):\n        return True\n\n\n    def __call__(self, x):\n        \"\"\"Evaluate the function or its linear approximation.\n\n        If the operator has been linearized (f0 is not None), returns the linear\n        approximation \n\n        .. math::\n\n            f(x_0) + \\\\mathbf{J}(x_0) (x - x_0)\n\n\n        otherwise, returns f(x) directly.\n\n        Parameters\n        ----------\n        x : array_like\n            Point at which to evaluate\n\n        Returns\n        -------\n        value : array_like\n            Function value or linear approximation\n        \"\"\"\n        if self.f0 is None: \n            return self._func(x)\n        dx = np.atleast_1d(x - self.x0)\n        return self.f0 + np.dot(self.J, dx)\n\n\n    def jac(self, x):\n        \"\"\"Compute the Jacobian matrix at point x.\n\n        Uses the following methods in order of preference:\n        1. User-provided analytical Jacobian if available\n        2. Automatic differentiation via Value class\n        3. Numerical differentiation as fallback\n\n        Parameters\n        ----------\n        x : array_like\n            Point at which to evaluate the Jacobian\n\n        Returns\n        -------\n        jacobian : ndarray\n            Jacobian matrix at x\n        \"\"\"\n        if self._jac is None:\n            try:\n                # Try automatic differentiation\n                _x = Value.array(x)\n                return Value.jac(self._func(_x), _x)\n            except:\n                # Fallback to numerical differentiation\n                return num_jac(self._func, x)\n        else:\n            # Use analytical jacobian\n            return self._jac(x)\n\n\n    def linearize(self, x):\n        \"\"\"Linearize the function at point x.\n\n        Computes and stores both the function value and its Jacobian at x.\n        After linearization, calls to the operator will use the linear\n        approximation until reset() is called.\n\n        Parameters\n        ----------\n        x : array_like\n            Point at which to linearize the function\n        \"\"\"\n        self.x0, self.f0, self.J = x, self._func(x), self.jac(x)\n\n\n    def reset(self):\n        \"\"\"Reset the linearization.\n\n        Clears the stored linearization point and Jacobian, causing the\n        operator to evaluate the function directly on subsequent calls.\n        \"\"\"\n        self.x0, self.f0, self.J = None, None, None",
          "bases": [
            "object"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, func, jac=None):\n    self._func = func\n    self._jac = jac\n    self.f0 = None\n    self.x0 = None\n    self.J = None",
              "signature": "(func, jac = None)",
              "parameters": [
                {
                  "name": "func",
                  "type": null,
                  "default": null,
                  "description": ""
                },
                {
                  "name": "jac",
                  "type": null,
                  "default": "None",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "jac",
              "description": "Compute the Jacobian matrix at point x.",
              "docstring_html": "<p>Compute the Jacobian matrix at point x.</p>\n<p>Uses the following methods in order of preference:\n1. User-provided analytical Jacobian if available\n2. Automatic differentiation via Value class\n3. Numerical differentiation as fallback</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>x <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array_like</span></dt>\n<dd>Point at which to evaluate the Jacobian</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>jacobian <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">ndarray</span></dt>\n<dd>Jacobian matrix at x</dd>\n</dl>\n",
              "source": "def jac(self, x):\n    \"\"\"Compute the Jacobian matrix at point x.\n\n    Uses the following methods in order of preference:\n    1. User-provided analytical Jacobian if available\n    2. Automatic differentiation via Value class\n    3. Numerical differentiation as fallback\n\n    Parameters\n    ----------\n    x : array_like\n        Point at which to evaluate the Jacobian\n\n    Returns\n    -------\n    jacobian : ndarray\n        Jacobian matrix at x\n    \"\"\"\n    if self._jac is None:\n        try:\n            # Try automatic differentiation\n            _x = Value.array(x)\n            return Value.jac(self._func(_x), _x)\n        except:\n            # Fallback to numerical differentiation\n            return num_jac(self._func, x)\n    else:\n        # Use analytical jacobian\n        return self._jac(x)",
              "signature": "(x)",
              "parameters": [
                {
                  "name": "x",
                  "type": null,
                  "default": null,
                  "description": "Point at which to evaluate the Jacobian Returns -------"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "linearize",
              "description": "Linearize the function at point x.",
              "docstring_html": "<p>Linearize the function at point x.</p>\n<p>Computes and stores both the function value and its Jacobian at x.\nAfter linearization, calls to the operator will use the linear\napproximation until reset() is called.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>x <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array_like</span></dt>\n<dd>Point at which to linearize the function</dd>\n</dl>\n",
              "source": "def linearize(self, x):\n    \"\"\"Linearize the function at point x.\n\n    Computes and stores both the function value and its Jacobian at x.\n    After linearization, calls to the operator will use the linear\n    approximation until reset() is called.\n\n    Parameters\n    ----------\n    x : array_like\n        Point at which to linearize the function\n    \"\"\"\n    self.x0, self.f0, self.J = x, self._func(x), self.jac(x)",
              "signature": "(x)",
              "parameters": [
                {
                  "name": "x",
                  "type": null,
                  "default": null,
                  "description": "Point at which to linearize the function"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "reset",
              "description": "Reset the linearization.",
              "docstring_html": "<p>Reset the linearization.</p>\n<p>Clears the stored linearization point and Jacobian, causing the\noperator to evaluate the function directly on subsequent calls.</p>\n",
              "source": "def reset(self):\n    \"\"\"Reset the linearization.\n\n    Clears the stored linearization point and Jacobian, causing the\n    operator to evaluate the function directly on subsequent calls.\n    \"\"\"\n    self.x0, self.f0, self.J = None, None, None",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "_func",
              "description": "",
              "type": null,
              "value": "func"
            },
            {
              "name": "_jac",
              "description": "",
              "type": null,
              "value": "jac"
            },
            {
              "name": "f0",
              "description": "",
              "type": null,
              "value": "None"
            },
            {
              "name": "x0",
              "description": "",
              "type": null,
              "value": "None"
            },
            {
              "name": "J",
              "description": "",
              "type": null,
              "value": "None"
            }
          ],
          "parameters": [
            {
              "name": "func",
              "type": null,
              "default": null,
              "description": "The function to wrap"
            },
            {
              "name": "jac",
              "type": null,
              "default": "None",
              "description": "Optional analytical Jacobian of func. If None, automatic or numerical differentiation will be used."
            }
          ]
        },
        {
          "name": "DynamicOperator",
          "description": "Operator class for dynamic system function evaluation and linearization.",
          "docstring_html": "<p>Operator class for dynamic system function evaluation and linearization.</p>\n<p>This class wraps a dynamic system function with signature f(x, u, t) to provide\nboth direct evaluation and linear approximation capabilities. When linearized\naround operating points (x0, u0), subsequent calls use the first-order Taylor\napproximation</p>\n<div class=\"math\">\n\\begin{equation*}\nf(x, u, t) \\approx f(x_0, u_0, t) + J_x(x_0, u_0, t) (x - x_0) + J_u(x_0, u_0, t) (u - u_0)\n\\end{equation*}\n</div>\n<p>instead of evaluating the function.</p>\n<p>The class supports multiple methods for Jacobian computation: user-provided analytical\nJacobians, automatic differentiation via the Value class, and numerical differentiation\nas a fallback.</p>\n<div class=\"section\" id=\"example\">\n<h4>Example</h4>\n<p>Basic usage with automatic differentiation:</p>\n<pre class=\"code python literal-block\">\n<span class=\"k\">def</span><span class=\"w\"> </span><span class=\"nf\">system</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">u</span><span class=\"p\">,</span> <span class=\"n\">t</span><span class=\"p\">):</span><span class=\"w\">\n</span>    <span class=\"k\">return</span> <span class=\"o\">-</span><span class=\"mf\">0.5</span><span class=\"o\">*</span><span class=\"n\">x</span> <span class=\"o\">+</span> <span class=\"mi\">2</span><span class=\"o\">*</span><span class=\"n\">u</span><span class=\"w\">\n\n</span><span class=\"n\">op</span> <span class=\"o\">=</span> <span class=\"n\">Operator</span><span class=\"p\">(</span><span class=\"n\">system</span><span class=\"p\">)</span><span class=\"w\">\n\n</span><span class=\"c1\"># Direct function evaluation</span><span class=\"w\">\n</span><span class=\"n\">y1</span> <span class=\"o\">=</span> <span class=\"n\">op</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"o\">=</span><span class=\"mf\">1.0</span><span class=\"p\">,</span> <span class=\"n\">u</span><span class=\"o\">=</span><span class=\"mf\">0.5</span><span class=\"p\">,</span> <span class=\"n\">t</span><span class=\"o\">=</span><span class=\"mf\">0.0</span><span class=\"p\">)</span><span class=\"w\">\n\n</span><span class=\"c1\"># Linearize at current point</span><span class=\"w\">\n</span><span class=\"n\">op</span><span class=\"o\">.</span><span class=\"n\">linearize</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"o\">=</span><span class=\"mf\">1.0</span><span class=\"p\">,</span> <span class=\"n\">u</span><span class=\"o\">=</span><span class=\"mf\">0.5</span><span class=\"p\">,</span> <span class=\"n\">t</span><span class=\"o\">=</span><span class=\"mf\">0.0</span><span class=\"p\">)</span><span class=\"w\">\n\n</span><span class=\"c1\"># Use linear approximation</span><span class=\"w\">\n</span><span class=\"n\">y2</span> <span class=\"o\">=</span> <span class=\"n\">op</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"o\">=</span><span class=\"mf\">1.1</span><span class=\"p\">,</span> <span class=\"n\">u</span><span class=\"o\">=</span><span class=\"mf\">0.6</span><span class=\"p\">,</span> <span class=\"n\">t</span><span class=\"o\">=</span><span class=\"mf\">0.1</span><span class=\"p\">)</span>\n</pre>\n<p>With user-provided Jacobians:</p>\n<pre class=\"code python literal-block\">\n<span class=\"k\">def</span><span class=\"w\"> </span><span class=\"nf\">system</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">u</span><span class=\"p\">,</span> <span class=\"n\">t</span><span class=\"p\">):</span><span class=\"w\">\n</span>    <span class=\"k\">return</span> <span class=\"o\">-</span><span class=\"mf\">0.5</span><span class=\"o\">*</span><span class=\"n\">x</span> <span class=\"o\">+</span> <span class=\"mi\">2</span><span class=\"o\">*</span><span class=\"n\">u</span><span class=\"w\">\n\n</span><span class=\"k\">def</span><span class=\"w\"> </span><span class=\"nf\">jac_x</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">u</span><span class=\"p\">,</span> <span class=\"n\">t</span><span class=\"p\">):</span><span class=\"w\">\n</span>    <span class=\"k\">return</span> <span class=\"o\">-</span><span class=\"mf\">0.5</span><span class=\"w\">\n\n</span><span class=\"k\">def</span><span class=\"w\"> </span><span class=\"nf\">jac_u</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">u</span><span class=\"p\">,</span> <span class=\"n\">t</span><span class=\"p\">):</span><span class=\"w\">\n</span>    <span class=\"k\">return</span> <span class=\"mf\">2.0</span><span class=\"w\">\n\n</span><span class=\"n\">op</span> <span class=\"o\">=</span> <span class=\"n\">Operator</span><span class=\"p\">(</span><span class=\"n\">system</span><span class=\"p\">,</span> <span class=\"n\">jac_x</span><span class=\"o\">=</span><span class=\"n\">jac_x</span><span class=\"p\">,</span> <span class=\"n\">jac_u</span><span class=\"o\">=</span><span class=\"n\">jac_u</span><span class=\"p\">)</span><span class=\"w\">\n\n</span><span class=\"n\">op</span><span class=\"o\">.</span><span class=\"n\">linearize</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"o\">=</span><span class=\"mf\">1.0</span><span class=\"p\">,</span> <span class=\"n\">u</span><span class=\"o\">=</span><span class=\"mf\">0.5</span><span class=\"p\">,</span> <span class=\"n\">t</span><span class=\"o\">=</span><span class=\"mf\">0.0</span><span class=\"p\">)</span>\n</pre>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>func <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">callable</span></dt>\n<dd>The function to wrap with signature func(x, u, t)</dd>\n<dt>jac_x <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">callable, optional</span></dt>\n<dd>Optional analytical Jacobian with respect to x. If None, automatic or\nnumerical differentiation will be used.</dd>\n<dt>jac_u <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">callable, optional</span></dt>\n<dd>Optional analytical Jacobian with respect to u. If None, automatic or\nnumerical differentiation will be used.</dd>\n</dl>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>f0 <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array_like</span></dt>\n<dd>Function evaluation at operating point</dd>\n<dt>x0 <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array_like</span></dt>\n<dd>State operating point</dd>\n<dt>u0 <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array_like</span></dt>\n<dd>Input operating point</dd>\n<dt>Jx <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array_like</span></dt>\n<dd>Jacobian matrix with respect to x at operating point</dd>\n<dt>Ju <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array_like</span></dt>\n<dd>Jacobian matrix with respect to u at operating point</dd>\n</dl>\n</div>\n",
          "source": "class DynamicOperator(object):\n    \"\"\"Operator class for dynamic system function evaluation and linearization.\n\n    This class wraps a dynamic system function with signature f(x, u, t) to provide \n    both direct evaluation and linear approximation capabilities. When linearized \n    around operating points (x0, u0), subsequent calls use the first-order Taylor \n    approximation \n\n    .. math::\n\n        f(x, u, t) \\\\approx f(x_0, u_0, t) + J_x(x_0, u_0, t) (x - x_0) + J_u(x_0, u_0, t) (u - u_0)\n\n    instead of evaluating the function.\n\n    The class supports multiple methods for Jacobian computation: user-provided analytical\n    Jacobians, automatic differentiation via the Value class, and numerical differentiation\n    as a fallback.\n\n    Example\n    -------\n    Basic usage with automatic differentiation:\n\n    .. code-block:: python\n\n        def system(x, u, t):\n            return -0.5*x + 2*u\n\n        op = Operator(system)\n\n        # Direct function evaluation\n        y1 = op(x=1.0, u=0.5, t=0.0)\n\n        # Linearize at current point\n        op.linearize(x=1.0, u=0.5, t=0.0)\n\n        # Use linear approximation\n        y2 = op(x=1.1, u=0.6, t=0.1)\n\n    With user-provided Jacobians:\n\n    .. code-block:: python\n\n        def system(x, u, t):\n            return -0.5*x + 2*u\n\n        def jac_x(x, u, t):\n            return -0.5\n\n        def jac_u(x, u, t):\n            return 2.0\n\n        op = Operator(system, jac_x=jac_x, jac_u=jac_u)\n\n        op.linearize(x=1.0, u=0.5, t=0.0)\n\n    Parameters\n    ----------\n    func : callable\n        The function to wrap with signature func(x, u, t)\n    jac_x : callable, optional\n        Optional analytical Jacobian with respect to x. If None, automatic or \n        numerical differentiation will be used.\n    jac_u : callable, optional\n        Optional analytical Jacobian with respect to u. If None, automatic or \n        numerical differentiation will be used.\n\n    Attributes\n    ----------\n    f0 : array_like\n        Function evaluation at operating point\n    x0 : array_like\n        State operating point\n    u0 : array_like\n        Input operating point\n    Jx : array_like\n        Jacobian matrix with respect to x at operating point\n    Ju : array_like\n        Jacobian matrix with respect to u at operating point\n    \"\"\"\n\n    def __init__(self, func, jac_x=None, jac_u=None):\n\n        self._func = func\n\n        self._jac_x = jac_x\n        self._jac_u = jac_u\n\n        self.f0 = None\n        self.x0 = None\n        self.u0 = None\n        self.Jx = None\n        self.Ju = None\n\n\n    def __bool__(self):\n        return True\n\n\n    def __call__(self, x, u, t):\n        \"\"\"Evaluate the function or its linear approximation.\n\n        If the operator has been linearized (f0 is not None), returns the linear\n        approximation \n\n        .. math::\n\n            f(x_0, u_0, t_0) + J_x(x_0, u_0, t_0) (x - x_0) + J_u(x_0, u_0, t_0) (u - u_0)\n\n        otherwise, returns f(x, u, t) directly.\n\n        Parameters\n        ----------\n        x : array_like\n            State vector\n        u : array_like\n            Input vector\n        t : float\n            Time\n\n        Returns\n        -------\n        value : array_like\n            Function value or linear approximation\n        \"\"\"\n        #no linearization available\n        if self.f0 is None:\n            return self._func(x, u, t)\n\n        #linearization in x available\n        if self.x0 is None: _fx = 0.0\n        else: _fx = np.dot(self.Jx, np.atleast_1d(x - self.x0))\n\n        #linearization in u available\n        if self.u0 is None: _fu = 0.0\n        else: _fu = np.dot(self.Ju, np.atleast_1d(u - self.u0))\n\n        return self.f0 + _fx + _fu\n\n\n    def jac_x(self, x, u, t):\n        \"\"\"Compute the Jacobian matrix with respect to x.\n\n        Uses the following methods in order of preference:\n        1. User-provided analytical Jacobian if available\n        2. Automatic differentiation via Value class\n        3. Numerical differentiation as fallback\n\n        Parameters\n        ----------\n        x : array_like\n            State vector\n        u : array_like\n            Input vector\n        t : float\n            Time\n\n        Returns\n        -------\n        jacobian : ndarray\n            Jacobian matrix with respect to x\n        \"\"\"\n        if self._jac_x is None:\n            # Keep u and t as is\n            def func_x(_x):\n                return self._func(_x, u, t)\n\n            try:\n                # Try automatic differentiation\n                _x = Value.array(x)\n                return Value.jac(func_x(_x), _x)\n            except:\n                # Fallback to numerical differentiation\n                return num_jac(func_x, x)\n        else:\n            # Use analytical jacobian\n            return self._jac_x(x, u, t)\n\n\n    def jac_u(self, x, u, t):\n        \"\"\"Compute the Jacobian matrix with respect to u.\n\n        Uses the following methods in order of preference:\n        1. User-provided analytical Jacobian if available\n        2. Automatic differentiation via Value class\n        3. Numerical differentiation as fallback\n\n        Parameters\n        ----------\n        x : array_like\n            State vector\n        u : array_like\n            Input vector\n        t : float\n            Time\n\n        Returns\n        -------\n        jacobian : ndarray\n            Jacobian matrix with respect to u\n        \"\"\"\n        if self._jac_u is None:\n            # Keep x and t as is\n            def func_u(_u):\n                return self._func(x, _u, t)\n\n            try:\n                # Try automatic differentiation\n                _u = Value.array(u)\n                return Value.jac(func_u(_u), _u)\n            except:\n                # Fallback to numerical differentiation\n                return num_jac(func_u, u)\n        else:\n            # Use analytical jacobian\n            return self._jac_u(x, u, t)\n\n\n    def linearize(self, x, u, t):\n        \"\"\"Linearize the function at point (x, u, t).\n\n        Computes and stores the function value and Jacobians at the operating point.\n        After linearization, calls to the operator will use the linear\n        approximation until reset() is called.\n\n        Parameters\n        ----------\n        x : array_like\n            State vector\n        u : array_like\n            Input vector\n        t : float\n            Time\n        \"\"\"\n        self.f0 = self._func(x, u, t)\n        if x is not None:\n            self.x0, self.Jx = np.atleast_1d(x), self.jac_x(x, u, t)\n        if u is not None:\n            self.u0, self.Ju = np.atleast_1d(u), self.jac_u(x, u, t)\n\n\n    def reset(self):\n        \"\"\"Reset the linearization.\n\n        Clears the stored linearization points and Jacobians, causing the\n        operator to evaluate the function directly on subsequent calls.\n        \"\"\"\n        self.f0 = None\n        self.x0, self.Jx = None, None\n        self.u0, self.Ju = None, None",
          "bases": [
            "object"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, func, jac_x=None, jac_u=None):\n\n    self._func = func\n\n    self._jac_x = jac_x\n    self._jac_u = jac_u\n\n    self.f0 = None\n    self.x0 = None\n    self.u0 = None\n    self.Jx = None\n    self.Ju = None",
              "signature": "(func, jac_x = None, jac_u = None)",
              "parameters": [
                {
                  "name": "func",
                  "type": null,
                  "default": null,
                  "description": ""
                },
                {
                  "name": "jac_x",
                  "type": null,
                  "default": "None",
                  "description": ""
                },
                {
                  "name": "jac_u",
                  "type": null,
                  "default": "None",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "jac_x",
              "description": "Compute the Jacobian matrix with respect to x.",
              "docstring_html": "<p>Compute the Jacobian matrix with respect to x.</p>\n<p>Uses the following methods in order of preference:\n1. User-provided analytical Jacobian if available\n2. Automatic differentiation via Value class\n3. Numerical differentiation as fallback</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>x <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array_like</span></dt>\n<dd>State vector</dd>\n<dt>u <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array_like</span></dt>\n<dd>Input vector</dd>\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>Time</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>jacobian <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">ndarray</span></dt>\n<dd>Jacobian matrix with respect to x</dd>\n</dl>\n",
              "source": "def jac_x(self, x, u, t):\n    \"\"\"Compute the Jacobian matrix with respect to x.\n\n    Uses the following methods in order of preference:\n    1. User-provided analytical Jacobian if available\n    2. Automatic differentiation via Value class\n    3. Numerical differentiation as fallback\n\n    Parameters\n    ----------\n    x : array_like\n        State vector\n    u : array_like\n        Input vector\n    t : float\n        Time\n\n    Returns\n    -------\n    jacobian : ndarray\n        Jacobian matrix with respect to x\n    \"\"\"\n    if self._jac_x is None:\n        # Keep u and t as is\n        def func_x(_x):\n            return self._func(_x, u, t)\n\n        try:\n            # Try automatic differentiation\n            _x = Value.array(x)\n            return Value.jac(func_x(_x), _x)\n        except:\n            # Fallback to numerical differentiation\n            return num_jac(func_x, x)\n    else:\n        # Use analytical jacobian\n        return self._jac_x(x, u, t)",
              "signature": "(x, u, t)",
              "parameters": [
                {
                  "name": "x",
                  "type": null,
                  "default": null,
                  "description": "State vector"
                },
                {
                  "name": "u",
                  "type": null,
                  "default": null,
                  "description": "Input vector"
                },
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "Time Returns -------"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "jac_u",
              "description": "Compute the Jacobian matrix with respect to u.",
              "docstring_html": "<p>Compute the Jacobian matrix with respect to u.</p>\n<p>Uses the following methods in order of preference:\n1. User-provided analytical Jacobian if available\n2. Automatic differentiation via Value class\n3. Numerical differentiation as fallback</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>x <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array_like</span></dt>\n<dd>State vector</dd>\n<dt>u <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array_like</span></dt>\n<dd>Input vector</dd>\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>Time</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>jacobian <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">ndarray</span></dt>\n<dd>Jacobian matrix with respect to u</dd>\n</dl>\n",
              "source": "def jac_u(self, x, u, t):\n    \"\"\"Compute the Jacobian matrix with respect to u.\n\n    Uses the following methods in order of preference:\n    1. User-provided analytical Jacobian if available\n    2. Automatic differentiation via Value class\n    3. Numerical differentiation as fallback\n\n    Parameters\n    ----------\n    x : array_like\n        State vector\n    u : array_like\n        Input vector\n    t : float\n        Time\n\n    Returns\n    -------\n    jacobian : ndarray\n        Jacobian matrix with respect to u\n    \"\"\"\n    if self._jac_u is None:\n        # Keep x and t as is\n        def func_u(_u):\n            return self._func(x, _u, t)\n\n        try:\n            # Try automatic differentiation\n            _u = Value.array(u)\n            return Value.jac(func_u(_u), _u)\n        except:\n            # Fallback to numerical differentiation\n            return num_jac(func_u, u)\n    else:\n        # Use analytical jacobian\n        return self._jac_u(x, u, t)",
              "signature": "(x, u, t)",
              "parameters": [
                {
                  "name": "x",
                  "type": null,
                  "default": null,
                  "description": "State vector"
                },
                {
                  "name": "u",
                  "type": null,
                  "default": null,
                  "description": "Input vector"
                },
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "Time Returns -------"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "linearize",
              "description": "Linearize the function at point (x, u, t).",
              "docstring_html": "<p>Linearize the function at point (x, u, t).</p>\n<p>Computes and stores the function value and Jacobians at the operating point.\nAfter linearization, calls to the operator will use the linear\napproximation until reset() is called.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>x <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array_like</span></dt>\n<dd>State vector</dd>\n<dt>u <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array_like</span></dt>\n<dd>Input vector</dd>\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>Time</dd>\n</dl>\n",
              "source": "def linearize(self, x, u, t):\n    \"\"\"Linearize the function at point (x, u, t).\n\n    Computes and stores the function value and Jacobians at the operating point.\n    After linearization, calls to the operator will use the linear\n    approximation until reset() is called.\n\n    Parameters\n    ----------\n    x : array_like\n        State vector\n    u : array_like\n        Input vector\n    t : float\n        Time\n    \"\"\"\n    self.f0 = self._func(x, u, t)\n    if x is not None:\n        self.x0, self.Jx = np.atleast_1d(x), self.jac_x(x, u, t)\n    if u is not None:\n        self.u0, self.Ju = np.atleast_1d(u), self.jac_u(x, u, t)",
              "signature": "(x, u, t)",
              "parameters": [
                {
                  "name": "x",
                  "type": null,
                  "default": null,
                  "description": "State vector"
                },
                {
                  "name": "u",
                  "type": null,
                  "default": null,
                  "description": "Input vector"
                },
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "Time"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "reset",
              "description": "Reset the linearization.",
              "docstring_html": "<p>Reset the linearization.</p>\n<p>Clears the stored linearization points and Jacobians, causing the\noperator to evaluate the function directly on subsequent calls.</p>\n",
              "source": "def reset(self):\n    \"\"\"Reset the linearization.\n\n    Clears the stored linearization points and Jacobians, causing the\n    operator to evaluate the function directly on subsequent calls.\n    \"\"\"\n    self.f0 = None\n    self.x0, self.Jx = None, None\n    self.u0, self.Ju = None, None",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "_func",
              "description": "",
              "type": null,
              "value": "func"
            },
            {
              "name": "_jac_x",
              "description": "",
              "type": null,
              "value": "jac_x"
            },
            {
              "name": "_jac_u",
              "description": "",
              "type": null,
              "value": "jac_u"
            },
            {
              "name": "f0",
              "description": "",
              "type": null,
              "value": "None"
            },
            {
              "name": "x0",
              "description": "",
              "type": null,
              "value": "None"
            },
            {
              "name": "u0",
              "description": "",
              "type": null,
              "value": "None"
            },
            {
              "name": "Jx",
              "description": "",
              "type": null,
              "value": "None"
            },
            {
              "name": "Ju",
              "description": "",
              "type": null,
              "value": "None"
            }
          ],
          "parameters": [
            {
              "name": "func",
              "type": null,
              "default": null,
              "description": "The function to wrap with signature func(x, u, t)"
            },
            {
              "name": "jac_x",
              "type": null,
              "default": "None",
              "description": "Optional analytical Jacobian with respect to x. If None, automatic or numerical differentiation will be used."
            },
            {
              "name": "jac_u",
              "type": null,
              "default": "None",
              "description": "Optional analytical Jacobian with respect to u. If None, automatic or numerical differentiation will be used."
            }
          ]
        }
      ],
      "functions": []
    },
    "pathsim.optim.value": {
      "name": "pathsim.optim.value",
      "description": "",
      "docstring_html": "",
      "classes": [
        {
          "name": "Value",
          "description": "Dual number 'Value' definition for small autograd framework.",
          "docstring_html": "<p>Dual number 'Value' definition for small autograd framework.</p>\n<p>The dunder methods of the 'Value' class are overloaded to simultaneously compute\nthe partial derivatives with respect to the instance itself and other instances\nof the value class.</p>\n<p>This is realized by a dictionary that handles the reference tracking via the id\nof the 'Value' instances.</p>\n<div class=\"section\" id=\"example\">\n<h4>Example</h4>\n<p>Automatic differentiation of numpy functions:</p>\n<pre class=\"code python literal-block\">\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"nn\">numpy</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"nn\">np</span><span class=\"w\">\n\n</span><span class=\"n\">v</span> <span class=\"o\">=</span> <span class=\"n\">Value</span><span class=\"p\">(</span><span class=\"mi\">3</span><span class=\"p\">)</span><span class=\"w\">\n\n</span><span class=\"c1\">#AD</span><span class=\"w\">\n</span><span class=\"n\">w</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">sin</span><span class=\"p\">(</span><span class=\"n\">v</span><span class=\"p\">)</span><span class=\"w\">\n\n</span><span class=\"c1\">#reference</span><span class=\"w\">\n</span><span class=\"n\">dw_dv</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">cos</span><span class=\"p\">(</span><span class=\"n\">v</span><span class=\"p\">)</span><span class=\"w\">\n\n</span><span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">dw_dv</span> <span class=\"o\">==</span> <span class=\"n\">w</span><span class=\"p\">(</span><span class=\"n\">v</span><span class=\"p\">))</span><span class=\"w\">\n</span><span class=\"c1\">#True</span>\n</pre>\n<p>Automatic differentiation of concatenations:</p>\n<pre class=\"code python literal-block\">\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"nn\">numpy</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"nn\">np</span><span class=\"w\">\n\n</span><span class=\"n\">v</span> <span class=\"o\">=</span> <span class=\"n\">Value</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">)</span><span class=\"w\">\n\n</span><span class=\"c1\">#AD</span><span class=\"w\">\n</span><span class=\"n\">w</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">exp</span><span class=\"p\">(</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">sin</span><span class=\"p\">(</span><span class=\"n\">v</span><span class=\"p\">)</span> <span class=\"o\">+</span> <span class=\"n\">v</span><span class=\"o\">**</span><span class=\"mi\">3</span><span class=\"p\">)</span><span class=\"w\">\n\n</span><span class=\"c1\">#reference</span><span class=\"w\">\n</span><span class=\"n\">dw_dv</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">exp</span><span class=\"p\">(</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">sin</span><span class=\"p\">(</span><span class=\"n\">v</span><span class=\"p\">)</span> <span class=\"o\">+</span> <span class=\"n\">v</span><span class=\"o\">**</span><span class=\"mi\">3</span><span class=\"p\">)</span> <span class=\"o\">*</span> <span class=\"p\">(</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">cos</span><span class=\"p\">(</span><span class=\"n\">v</span><span class=\"p\">)</span> <span class=\"o\">+</span> <span class=\"mi\">3</span><span class=\"o\">*</span><span class=\"n\">v</span><span class=\"o\">**</span><span class=\"mi\">2</span><span class=\"p\">)</span><span class=\"w\">\n\n</span><span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">dw_dv</span> <span class=\"o\">==</span> <span class=\"n\">w</span><span class=\"p\">(</span><span class=\"n\">v</span><span class=\"p\">))</span><span class=\"w\">\n</span><span class=\"c1\">#True</span>\n</pre>\n<p>Automatic differentiation with multiple values:</p>\n<pre class=\"code python literal-block\">\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"nn\">numpy</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"nn\">np</span><span class=\"w\">\n\n</span><span class=\"n\">u</span> <span class=\"o\">=</span> <span class=\"n\">Value</span><span class=\"p\">(</span><span class=\"mf\">0.5</span><span class=\"p\">)</span><span class=\"w\">\n</span><span class=\"n\">v</span> <span class=\"o\">=</span> <span class=\"n\">Value</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">)</span><span class=\"w\">\n\n</span><span class=\"c1\">#AD</span><span class=\"w\">\n</span><span class=\"n\">w</span> <span class=\"o\">=</span> <span class=\"n\">u</span> <span class=\"o\">*</span> <span class=\"n\">v</span> <span class=\"o\">+</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">sin</span><span class=\"p\">(</span><span class=\"n\">u</span> <span class=\"o\">+</span> <span class=\"n\">v</span><span class=\"p\">)</span><span class=\"w\">\n\n</span><span class=\"c1\">#references</span><span class=\"w\">\n</span><span class=\"n\">dw_du</span> <span class=\"o\">=</span> <span class=\"n\">v</span> <span class=\"o\">+</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">cos</span><span class=\"p\">(</span><span class=\"n\">u</span> <span class=\"o\">+</span> <span class=\"n\">v</span><span class=\"p\">)</span><span class=\"w\">\n</span><span class=\"n\">dw_dv</span> <span class=\"o\">=</span> <span class=\"n\">u</span> <span class=\"o\">+</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">cos</span><span class=\"p\">(</span><span class=\"n\">u</span> <span class=\"o\">+</span> <span class=\"n\">v</span><span class=\"p\">)</span><span class=\"w\">\n\n</span><span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">dw_du</span> <span class=\"o\">==</span> <span class=\"n\">w</span><span class=\"p\">(</span><span class=\"n\">u</span><span class=\"p\">),</span> <span class=\"n\">dw_dv</span> <span class=\"o\">==</span> <span class=\"n\">w</span><span class=\"p\">(</span><span class=\"n\">v</span><span class=\"p\">))</span><span class=\"w\">\n</span><span class=\"c1\">#True True</span>\n</pre>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>val <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float, int, complex</span></dt>\n<dd>The numerical value.</dd>\n<dt>grad <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">defaultdict, None</span></dt>\n<dd>The gradient dictionary. If None, initializes with self derivative.</dd>\n<dt>sig <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float, int, complex</span></dt>\n<dd>Standard deviation of value for uncertainty analysis (optional)</dd>\n</dl>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>_id <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>id for reference tracking in gradient dict</dd>\n</dl>\n</div>\n",
          "source": "@add_funcs\nclass Value:\n    \"\"\"Dual number 'Value' definition for small autograd framework. \n\n    The dunder methods of the 'Value' class are overloaded to simultaneously compute \n    the partial derivatives with respect to the instance itself and other instances \n    of the value class. \n\n    This is realized by a dictionary that handles the reference tracking via the id \n    of the 'Value' instances.\n\n    Example\n    -------\n    Automatic differentiation of numpy functions:\n\n    .. code-block:: python\n\n        import numpy as np\n\n        v = Value(3)\n\n        #AD\n        w = np.sin(v)\n\n        #reference\n        dw_dv = np.cos(v)\n\n        print(dw_dv == w(v))\n        #True    \n\n    Automatic differentiation of concatenations:\n\n    .. code-block:: python\n\n        import numpy as np\n\n        v = Value(2)\n\n        #AD\n        w = np.exp(np.sin(v) + v**3)\n\n        #reference\n        dw_dv = np.exp(np.sin(v) + v**3) * (np.cos(v) + 3*v**2)\n\n        print(dw_dv == w(v))\n        #True\n\n    Automatic differentiation with multiple values:\n\n    .. code-block:: python\n\n        import numpy as np\n\n        u = Value(0.5)\n        v = Value(2)\n\n        #AD\n        w = u * v + np.sin(u + v)\n\n        #references\n        dw_du = v + np.cos(u + v)\n        dw_dv = u + np.cos(u + v)\n\n        print(dw_du == w(u), dw_dv == w(v))\n        #True True\n\n    Parameters\n    ----------\n    val  : float, int, complex\n        The numerical value.\n    grad : defaultdict, None\n        The gradient dictionary. If None, initializes with self derivative.\n    sig : float, int, complex\n        Standard deviation of value for uncertainty analysis (optional)\n\n    Attributes\n    ----------\n    _id : int \n        id for reference tracking in gradient dict\n\n    \"\"\"\n\n    #restrict attributes, makes access faster\n    __slots__ = [\"val\", \"grad\", \"sig\", \"_id\"] \n\n\n    def __init__(self, val=0.0, grad=None, sig=0.0):\n\n        #catch instantiating with Value\n        if isinstance(val, Value):\n            self.val = val.val\n        else:\n            self.val = val\n\n        #initialize fresh gradients\n        if grad is None:\n            self._id = id(self)\n            self.grad = defaultdict(float, {self._id: 1.0})\n        else:\n            self._id = None\n            self.grad = grad\n\n        #standard deviation\n        self.sig = sig\n\n\n    # dynamic properties ------------------------------------------------------------------------\n\n    @property\n    def real(self):\n        return Value(\n            val=np.real(self.val), \n            grad=defaultdict(float, {k: np.real(v) for k, v in self.grad.items()})\n            ) \n\n\n    @property\n    def imag(self):\n        return Value(\n            val=np.imag(self.val), \n            grad=defaultdict(float, {k: np.imag(v) for k, v in self.grad.items()})\n            ) \n\n\n    # array conversions -------------------------------------------------------------------------\n\n    @classmethod\n    def numeric(cls, arr):\n        \"\"\"Cast an array with value objects to an array of numeric values. \n\n        Numeric entries are just passed through.\n\n        Parameters\n        ----------  \n        arr : array[obj]\n            array of mixed value, numeric objects\n\n        Returns\n        -------\n        numeric : array[numeric] \n            array of numeric values\n        \"\"\"\n        _arr = np.atleast_1d(arr)\n        return np.array([a.val if isinstance(a, cls) else a  \n            for a in _arr.ravel()]).reshape(_arr.shape).squeeze()\n\n\n    @classmethod\n    def array(cls, arr):\n        \"\"\"Cast an array or list to an array of value objects. \n\n        For Value entries, their numeric values are used to \n        create a new Value instance.\n\n        Example\n        -------\n        Instantiate multiple values from 1d array:\n\n        .. code-block:: python\n\n            a, b, c = Value.array([1, 2, 3])\n\n        Instantiate numpy array filled with values:\n\n        .. code-block:: python\n\n            import numpy as np\n\n            A_num = np.random.rand(3, 5)\n\n            A = Value.array(A_num)\n\n        Parameters\n        ----------  \n        arr : array[obj]\n            array of mixed value, numeric objects\n\n        Returns\n        -------\n        array : array[Value] \n            array of Value objects\n        \"\"\"\n        _arr = np.atleast_1d(arr)\n        return np.array([cls(a) for a in _arr.ravel()]).reshape(_arr.shape).squeeze()\n\n\n    # convenience static methods ----------------------------------------------------------------\n\n    @staticmethod\n    def der(arr, val):\n        return der(arr, val)\n\n\n    @staticmethod\n    def jac(arr, vals):\n        return jac(arr, vals)\n\n\n    @staticmethod\n    def var(arr, vals):\n        return var(arr, vals)\n\n\n    # overload builtins -------------------------------------------------------------------------\n\n    def __call__(self, other):\n        \"\"\"\n        Get the partial derivative with respect to 'other'.\n\n        Parameters\n        ----------     \n        other : Value\n            variable with respect to which to take the derivative\n\n        Returns\n        -------\n        out : float\n            The partial derivative value\n        \"\"\"\n        if isinstance(other, Value): return self.grad[other._id]\n        else: return 0.0\n\n\n    def __hash__(self):\n        return id(self)\n\n\n    def __iter__(self):\n        yield self\n\n\n    def __len__(self):\n        return len(self.grad)\n\n\n    def __repr__(self):\n        return f\"Value(val={self.val}, grad={self.grad})\"    \n\n\n    # comparison operators ----------------------------------------------------------------------\n\n    def __eq__(self, other):\n        if isinstance(other, Value):\n            return self.val == other.val\n        else:\n            return self.val == other\n\n\n    def __ne__(self, other):\n        if isinstance(other, Value):\n            return self.val != other.val\n        else:\n            return self.val != other\n\n\n    def __lt__(self, other):\n        if isinstance(other, Value):\n            return self.val < other.val\n        else:\n            return self.val < other\n\n\n    def __gt__(self, other):\n        if isinstance(other, Value):\n            return self.val > other.val\n        else:\n            return self.val > other\n\n\n    def __le__(self, other):\n        if isinstance(other, Value):\n            return self.val <= other.val\n        else:\n            return self.val <= other\n\n\n    def __ge__(self, other):\n        if isinstance(other, Value):\n            return self.val >= other.val\n        else:\n            return self.val >= other\n\n\n    # type casting operators --------------------------------------------------------------------\n\n    def __bool__(self):\n        return bool(self.val)\n\n\n    def __int__(self):\n        return int(self.val)\n\n\n    def __float__(self):\n        return float(self.val)\n\n\n    def __complex__(self):\n        return complex(self.val)\n\n\n    # unary operators ---------------------------------------------------------------------------\n\n    def __pos__(self):\n        return self\n\n\n    def __neg__(self):\n        return Value(\n            val=-self.val, \n            grad=defaultdict(float, {k: -v for k, v in self.grad.items()})\n            )\n\n\n    def __abs__(self):\n        return Value(\n            val=abs(self.val), \n            grad=defaultdict(float, {k: v * np.sign(self.val) for k, v in self.grad.items()})\n            )\n\n\n    # arithmetic operators ----------------------------------------------------------------------\n\n    def __add__(self, other):\n        if isinstance(other, Value):\n            new_grad = defaultdict(float, self.grad)\n            for k, v in other.grad.items(): new_grad[k] += v\n            return Value(\n                val=self.val + other.val, \n                grad=new_grad\n                )\n        elif isinstance(other, np.ndarray):\n            return np.array([self + x for x in other])\n        else:\n            return Value(\n                val=self.val + other, \n                grad=self.grad\n                )\n\n\n    def __radd__(self, other):\n        return self + other\n\n\n    def __iadd__(self, other):\n        if isinstance(other, Value):\n            self.val += other.val\n            for k, v in other.grad.items(): self.grad[k] += v\n            return self\n        else:\n            self.val += other\n            return self\n\n\n    def __mul__(self, other):\n        if isinstance(other, Value):\n            new_grad = defaultdict(float)\n            for k, v in self.grad.items(): new_grad[k] += v * other.val\n            for k, v in other.grad.items(): new_grad[k] += v * self.val\n            return Value(\n                val=self.val * other.val, \n                grad=new_grad\n                )\n        elif isinstance(other, np.ndarray):\n            return np.array([self * x for x in other])\n        else:\n            return Value(\n                val=self.val * other, \n                grad=defaultdict(float, {k: v * other for k, v in self.grad.items()})\n                )\n\n\n    def __rmul__(self, other):\n        return self * other\n\n\n    def __imul__(self, other):\n        if isinstance(other, Value):\n            self.val *= other.val\n            for k, v in self.grad.items(): self.grad[k] *= other.val \n            for k, v in other.grad.items(): self.grad[k] += v * self.val\n            return self\n        else:\n            self.val *= other\n            return self\n\n\n    def __sub__(self, other):\n        if isinstance(other, Value):\n            new_grad = defaultdict(float, self.grad)\n            for k, v in other.grad.items(): new_grad[k] -= v\n            return Value(\n                val=self.val - other.val, \n                grad=new_grad\n                )\n        elif isinstance(other, np.ndarray):\n            return np.array([self - x for x in other])\n        else:\n            return Value(\n                val=self.val - other, \n                grad=self.grad\n                )\n\n\n    def __rsub__(self, other):\n        return -(self - other)\n\n\n    def __isub__(self, other):\n        if isinstance(other, Value):\n            self.val -= other.val\n            for k, v in other.grad.items(): self.grad[k] -= v\n            return self\n        else:\n            self.val -= other\n            return self\n\n\n    def __truediv__(self, other):\n        if isinstance(other, Value):\n            new_grad = defaultdict(float)\n            if other.val != 0.0:\n                a, b = self.val/other.val**2, 1/other.val\n                for k, v in self.grad.items(): new_grad[k] += v*b\n                for k, v in other.grad.items(): new_grad[k] -= v*a\n            return Value(\n                val=self.val / other.val, \n                grad=new_grad\n                )\n        if isinstance(other, np.ndarray):\n            return np.array([self / x for x in other])\n        else:\n            return Value(\n                val=self.val / other, \n                grad=defaultdict(float, {k: v / other for k, v in self.grad.items()})\n                )\n\n\n    def __rtruediv__(self, other):\n        if isinstance(other, Value):\n            return other / self\n        else:\n            new_grad = defaultdict(float)\n            if self.val != 0.0:\n                a = -other / (self.val ** 2)\n                for k, v in self.grad.items(): new_grad[k] += v*a\n            return Value(\n                val=other / self.val, \n                grad=new_grad\n                )\n\n\n    def __pow__(self, power):\n        if isinstance(power, Value):\n            new_val = self.val ** power.val\n            new_grad = defaultdict(float)\n            a, b = new_val * power.val / self.val, new_val * np.log(self.val)\n            for k, v in self.grad.items(): new_grad[k] += v*a\n            for k, v in power.grad.items(): new_grad[k] += v*b \n            return Value(\n                val=new_val, \n                grad=new_grad\n                )\n        else:\n            return Value(\n                val=self.val ** power, \n                grad=defaultdict(float, {k: power * (self.val ** (power - 1)) * v for k, v in self.grad.items()})\n                )\n\n\n    def __rpow__(self, base):\n        new_val = base ** self.val\n        return Value(\n            val=new_val, \n            grad=defaultdict(float, {k: new_val * np.log(base) * v for k, v in self.grad.items()})\n            )",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, val=0.0, grad=None, sig=0.0):\n\n    #catch instantiating with Value\n    if isinstance(val, Value):\n        self.val = val.val\n    else:\n        self.val = val\n\n    #initialize fresh gradients\n    if grad is None:\n        self._id = id(self)\n        self.grad = defaultdict(float, {self._id: 1.0})\n    else:\n        self._id = None\n        self.grad = grad\n\n    #standard deviation\n    self.sig = sig",
              "signature": "(val = 0.0, grad = None, sig = 0.0)",
              "parameters": [
                {
                  "name": "val",
                  "type": null,
                  "default": "0.0",
                  "description": ""
                },
                {
                  "name": "grad",
                  "type": null,
                  "default": "None",
                  "description": ""
                },
                {
                  "name": "sig",
                  "type": null,
                  "default": "0.0",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "numeric",
              "description": "Cast an array with value objects to an array of numeric values.",
              "docstring_html": "<p>Cast an array with value objects to an array of numeric values.</p>\n<p>Numeric entries are just passed through.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>arr <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array[obj]</span></dt>\n<dd>array of mixed value, numeric objects</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>numeric <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array[numeric]</span></dt>\n<dd>array of numeric values</dd>\n</dl>\n",
              "source": "@classmethod\ndef numeric(cls, arr):\n    \"\"\"Cast an array with value objects to an array of numeric values. \n\n    Numeric entries are just passed through.\n\n    Parameters\n    ----------  \n    arr : array[obj]\n        array of mixed value, numeric objects\n\n    Returns\n    -------\n    numeric : array[numeric] \n        array of numeric values\n    \"\"\"\n    _arr = np.atleast_1d(arr)\n    return np.array([a.val if isinstance(a, cls) else a  \n        for a in _arr.ravel()]).reshape(_arr.shape).squeeze()",
              "signature": "(cls, arr)",
              "parameters": [
                {
                  "name": "cls",
                  "type": null,
                  "default": null,
                  "description": ""
                },
                {
                  "name": "arr",
                  "type": null,
                  "default": null,
                  "description": "array of mixed value, numeric objects"
                }
              ],
              "returns": null,
              "method_type": "classmethod"
            },
            {
              "name": "array",
              "description": "Cast an array or list to an array of value objects.",
              "docstring_html": "<p>Cast an array or list to an array of value objects.</p>\n<p>For Value entries, their numeric values are used to\ncreate a new Value instance.</p>\n<div class=\"section\" id=\"example\">\n<h4>Example</h4>\n<p>Instantiate multiple values from 1d array:</p>\n<pre class=\"code python literal-block\">\n<span class=\"n\">a</span><span class=\"p\">,</span> <span class=\"n\">b</span><span class=\"p\">,</span> <span class=\"n\">c</span> <span class=\"o\">=</span> <span class=\"n\">Value</span><span class=\"o\">.</span><span class=\"n\">array</span><span class=\"p\">([</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">])</span>\n</pre>\n<p>Instantiate numpy array filled with values:</p>\n<pre class=\"code python literal-block\">\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"nn\">numpy</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"nn\">np</span><span class=\"w\">\n\n</span><span class=\"n\">A_num</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">random</span><span class=\"o\">.</span><span class=\"n\">rand</span><span class=\"p\">(</span><span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"mi\">5</span><span class=\"p\">)</span><span class=\"w\">\n\n</span><span class=\"n\">A</span> <span class=\"o\">=</span> <span class=\"n\">Value</span><span class=\"o\">.</span><span class=\"n\">array</span><span class=\"p\">(</span><span class=\"n\">A_num</span><span class=\"p\">)</span>\n</pre>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>arr <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array[obj]</span></dt>\n<dd>array of mixed value, numeric objects</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>array <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array[Value]</span></dt>\n<dd>array of Value objects</dd>\n</dl>\n</div>\n",
              "source": "@classmethod\ndef array(cls, arr):\n    \"\"\"Cast an array or list to an array of value objects. \n\n    For Value entries, their numeric values are used to \n    create a new Value instance.\n\n    Example\n    -------\n    Instantiate multiple values from 1d array:\n\n    .. code-block:: python\n\n        a, b, c = Value.array([1, 2, 3])\n\n    Instantiate numpy array filled with values:\n\n    .. code-block:: python\n\n        import numpy as np\n\n        A_num = np.random.rand(3, 5)\n\n        A = Value.array(A_num)\n\n    Parameters\n    ----------  \n    arr : array[obj]\n        array of mixed value, numeric objects\n\n    Returns\n    -------\n    array : array[Value] \n        array of Value objects\n    \"\"\"\n    _arr = np.atleast_1d(arr)\n    return np.array([cls(a) for a in _arr.ravel()]).reshape(_arr.shape).squeeze()",
              "signature": "(cls, arr)",
              "parameters": [
                {
                  "name": "cls",
                  "type": null,
                  "default": null,
                  "description": ""
                },
                {
                  "name": "arr",
                  "type": null,
                  "default": null,
                  "description": "array of mixed value, numeric objects"
                }
              ],
              "returns": null,
              "method_type": "classmethod"
            },
            {
              "name": "der",
              "description": "",
              "docstring_html": "",
              "source": "@staticmethod\ndef der(arr, val):\n    return der(arr, val)",
              "signature": "(arr, val)",
              "parameters": [
                {
                  "name": "arr",
                  "type": null,
                  "default": null,
                  "description": ""
                },
                {
                  "name": "val",
                  "type": null,
                  "default": null,
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "staticmethod"
            },
            {
              "name": "jac",
              "description": "",
              "docstring_html": "",
              "source": "@staticmethod\ndef jac(arr, vals):\n    return jac(arr, vals)",
              "signature": "(arr, vals)",
              "parameters": [
                {
                  "name": "arr",
                  "type": null,
                  "default": null,
                  "description": ""
                },
                {
                  "name": "vals",
                  "type": null,
                  "default": null,
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "staticmethod"
            },
            {
              "name": "var",
              "description": "",
              "docstring_html": "",
              "source": "@staticmethod\ndef var(arr, vals):\n    return var(arr, vals)",
              "signature": "(arr, vals)",
              "parameters": [
                {
                  "name": "arr",
                  "type": null,
                  "default": null,
                  "description": ""
                },
                {
                  "name": "vals",
                  "type": null,
                  "default": null,
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "staticmethod"
            }
          ],
          "attributes": [
            {
              "name": "val",
              "description": "",
              "type": null,
              "value": "val.val"
            },
            {
              "name": "_id",
              "description": "",
              "type": null,
              "value": "id(self)"
            },
            {
              "name": "grad",
              "description": "",
              "type": null,
              "value": "defaultdict(float, {self._id: 1.0})"
            },
            {
              "name": "sig",
              "description": "",
              "type": null,
              "value": "sig"
            },
            {
              "name": "real",
              "description": "",
              "type": null,
              "value": null
            },
            {
              "name": "imag",
              "description": "",
              "type": null,
              "value": null
            }
          ],
          "parameters": [
            {
              "name": "val",
              "type": null,
              "default": "0.0",
              "description": "The numerical value."
            },
            {
              "name": "grad",
              "type": null,
              "default": "None",
              "description": "The gradient dictionary. If None, initializes with self derivative."
            },
            {
              "name": "sig",
              "type": null,
              "default": "0.0",
              "description": "Standard deviation of value for uncertainty analysis (optional)"
            }
          ]
        }
      ],
      "functions": [
        {
          "name": "der",
          "description": "Compute the derivative of an array of 'Value' objects with respect",
          "docstring_html": "<p>Compute the derivative of an array of 'Value' objects with respect\nto 'val', fallback to scalar case and non-'Value' objects</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>arr <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array[Value]</span></dt>\n<dd>array or list of Values</dd>\n<dt>val <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">Value</span></dt>\n<dd>dual number value for AD</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>der <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array[float]</span></dt>\n<dd>partial derivatives w.r.t. the 'val'</dd>\n</dl>\n",
          "source": "def der(arr, val):\n    \"\"\"Compute the derivative of an array of 'Value' objects with respect \n    to 'val', fallback to scalar case and non-'Value' objects\n\n    Parameters\n    ----------\n    arr : array[Value]\n        array or list of Values\n    val : Value\n        dual number value for AD\n\n    Returns\n    -------\n    der : array[float]\n        partial derivatives w.r.t. the 'val'\n    \"\"\"\n    return np.array([a(val) if isinstance(a, Value) else 0.0 for a in np.atleast_1d(arr)])",
          "signature": "(arr, val)",
          "parameters": [
            {
              "name": "arr",
              "type": null,
              "default": null,
              "description": "array or list of Values"
            },
            {
              "name": "val",
              "type": null,
              "default": null,
              "description": "dual number value for AD"
            }
          ],
          "returns": null
        },
        {
          "name": "jac",
          "description": "Compute the derivative of an array of 'Value' objects with respect",
          "docstring_html": "<p>Compute the derivative of an array of 'Value' objects with respect\nto each 'Value' object in 'vals', fallback to scalars in both cases.</p>\n<p>This effectively constructs the jacobian.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>arr <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array[Value]</span></dt>\n<dd>array or list of Values</dd>\n<dt>vals <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array[Value]</span></dt>\n<dd>array or list of Values</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>jac <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array[float]</span></dt>\n<dd>partial derivatives w.r.t. all values in 'vals', effectively the jacobian</dd>\n</dl>\n",
          "source": "def jac(arr, vals):\n    \"\"\"Compute the derivative of an array of 'Value' objects with respect \n    to each 'Value' object in 'vals', fallback to scalars in both cases.\n\n    This effectively constructs the jacobian. \n\n    Parameters\n    ----------\n    arr : array[Value]\n        array or list of Values\n    vals : array[Value]\n        array or list of Values\n\n    Returns\n    -------\n    jac : array[float]\n        partial derivatives w.r.t. all values in 'vals', effectively the jacobian\n    \"\"\"\n    return np.array([der(arr, val) for val in np.atleast_1d(vals)]).T",
          "signature": "(arr, vals)",
          "parameters": [
            {
              "name": "arr",
              "type": null,
              "default": null,
              "description": "array or list of Values"
            },
            {
              "name": "vals",
              "type": null,
              "default": null,
              "description": "array or list of Values"
            }
          ],
          "returns": null
        },
        {
          "name": "var",
          "description": "Compute the variance of an array of 'Value' objects with respect",
          "docstring_html": "<p>Compute the variance of an array of 'Value' objects with respect\nto all the 'Value' objects in 'vals' using the standard deviations\nof the values and a first order taylor approximation using the\npartial derivatives.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>arr <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array[Value]</span></dt>\n<dd>array or list of Values</dd>\n<dt>vals <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array[Value]</span></dt>\n<dd>array or list of Values</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>var <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array[float]</span></dt>\n<dd>variance from taylor expansion w.r.t. all values in 'vals'</dd>\n</dl>\n",
          "source": "def var(arr, vals):\n    \"\"\"Compute the variance of an array of 'Value' objects with respect \n    to all the 'Value' objects in 'vals' using the standard deviations \n    of the values and a first order taylor approximation using the \n    partial derivatives.\n\n    Parameters\n    ----------\n    arr : array[Value]\n        array or list of Values\n    vals : array[Value]\n        array or list of Values\n\n    Returns\n    -------\n    var : array[float]\n        variance from taylor expansion w.r.t. all values in 'vals'\n    \"\"\"\n    return sum((val.sig*der(arr, val))**2 for val in np.atleast_1d(vals))",
          "signature": "(arr, vals)",
          "parameters": [
            {
              "name": "arr",
              "type": null,
              "default": null,
              "description": "array or list of Values"
            },
            {
              "name": "vals",
              "type": null,
              "default": null,
              "description": "array or list of Values"
            }
          ],
          "returns": null
        },
        {
          "name": "autojac",
          "description": "Decorator that wraps a function such that it computes its jacobian",
          "docstring_html": "<p>Decorator that wraps a function such that it computes its jacobian\nalongside its evaluaiton.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>fnc <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">callable</span></dt>\n<dd>function to wrap and compute jacobian of</dd>\n</dl>\n",
          "source": "def autojac(fnc):\n    \"\"\"Decorator that wraps a function such that it computes its jacobian \n    alongside its evaluaiton.\n\n    Parameters\n    ----------\n    fnc : callable\n        function to wrap and compute jacobian of\n    \"\"\"\n    @functools.wraps(fnc)\n    def wrap(*args):\n        vals = Value.array(args)\n        out = fnc(*vals)\n        return Value.numeric(out), jac(out, vals)\n    return wrap",
          "signature": "(fnc)",
          "parameters": [
            {
              "name": "fnc",
              "type": null,
              "default": null,
              "description": "function to wrap and compute jacobian of"
            }
          ],
          "returns": null
        },
        {
          "name": "add_funcs",
          "description": "Decorator that adds numpy functions as methods to the Value class while overloading",
          "docstring_html": "<p>Decorator that adds numpy functions as methods to the Value class while overloading\nthem with their analytical derivatives to propagate the gradient with the chain rule.</p>\n",
          "source": "def add_funcs(cls):\n    \"\"\"Decorator that adds numpy functions as methods to the Value class while overloading \n    them with their analytical derivatives to propagate the gradient with the chain rule.\n    \"\"\"\n\n    def create_method(fnc, grd):\n        @functools.wraps(fnc)\n        def method(self, *args, **kwargs):\n            grad_val = grd(self.val, *args, **kwargs)\n            return cls(\n                val=fnc(self.val, *args, **kwargs), \n                grad=defaultdict(\n                    float, \n                    {k: grad_val * v for k, v in self.grad.items()}\n                )\n            )\n        return method\n\n    # Add methods to class\n    for fnc, grd in FUNC_GRAD.items():\n        if not hasattr(cls, fnc.__name__):\n            setattr(cls, fnc.__name__, create_method(fnc, grd))\n\n    return cls",
          "signature": "(cls)",
          "parameters": [
            {
              "name": "cls",
              "type": null,
              "default": null,
              "description": ""
            }
          ],
          "returns": null
        }
      ]
    },
    "pathsim.utils.adaptivebuffer": {
      "name": "pathsim.utils.adaptivebuffer",
      "description": "",
      "docstring_html": "",
      "classes": [
        {
          "name": "AdaptiveBuffer",
          "description": "A class that manages an adaptive buffer for delay modeling which is primarily",
          "docstring_html": "<p>A class that manages an adaptive buffer for delay modeling which is primarily\nused in the pathsim 'Delay' block but might have future applications aswell.</p>\n<p>It implements a linear interpolation for arbitrary time lookup.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>delay <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>time delay in seconds</dd>\n</dl>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>buffer_t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">deque</span></dt>\n<dd>deque that collects the time data for buffering</dd>\n<dt>buffer_v <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">deque</span></dt>\n<dd>deque that collects the value data for buffering</dd>\n<dt>ns <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>savety for buffer truncation</dd>\n</dl>\n",
          "source": "class AdaptiveBuffer:\n    \"\"\"A class that manages an adaptive buffer for delay modeling which is primarily \n    used in the pathsim 'Delay' block but might have future applications aswell.\n\n    It implements a linear interpolation for arbitrary time lookup.\n\n    Parameters\n    ----------\n    delay : float\n        time delay in seconds\n\n    Attributes\n    ----------\n    buffer_t : deque\n        deque that collects the time data for buffering\n    buffer_v : deque\n        deque that collects the value data for buffering\n    ns : int\n        savety for buffer truncation\n    \"\"\"\n\n    def __init__(self, delay):\n\n        #the buffer uses a double ended queue\n        self.delay = delay\n        self.buffer_t = deque()\n        self.buffer_v = deque()\n\n        #savety for buffer truncation\n        self.ns = 5\n\n\n    def __len__(self):\n        return len(self.buffer_t)\n\n\n    def add(self, t, value):\n        \"\"\"adding a new datapoint to the buffer\n\n        Parameters\n        ----------\n        t : float\n            time to add\n        value : float, int, complex\n            numerical value to add\n        \"\"\"\n\n        #add the time-value tuple\n        self.buffer_t.append(t)\n        self.buffer_v.append(value)\n\n        #remove values after savety from buffer -> enable interpolation\n        if len(self.buffer_t) > self.ns:\n            while t - self.buffer_t[self.ns] > self.delay:\n                self.buffer_t.popleft()\n                self.buffer_v.popleft()\n\n\n    def interp(self, t):\n        \"\"\"interpolate buffer at defined lookup time\n\n        Parameters\n        ----------\n        t : float\n            time for interpolation\n\n        Returns\n        -------\n        out : float, array\n            interpolated value\n        \"\"\"\n\n        #empty or time too small -> return zero\n        if not self.buffer_t or t <= self.buffer_t[0]:\n            return 0.0\n\n        #requested time too large -> return last value\n        if t >= self.buffer_t[-1]:\n            return self.buffer_v[-1]\n\n        #find buffer index for requested time\n        i = bisect_left(self.buffer_t, t)\n        t0, t1 = self.buffer_t[i], self.buffer_t[i-1]\n        y0, y1 = self.buffer_v[i], self.buffer_v[i-1]\n\n        #linear interpolation\n        return y0 + (y1 - y0) * (t - t0) / (t1 - t0)\n\n\n    def get(self, t):\n        \"\"\"lookup datapoint from buffer with \n        delay at `t_lookup = t - delay`\n\n        Parameters\n        ----------\n        t : float\n            time for lookup with delay\n        \"\"\"\n        return self.interp(t - self.delay)\n\n\n    def clear(self):\n        \"\"\"clear the buffer, reset everything\"\"\"\n        self.buffer_t.clear()\n        self.buffer_v.clear()",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, delay):\n\n    #the buffer uses a double ended queue\n    self.delay = delay\n    self.buffer_t = deque()\n    self.buffer_v = deque()\n\n    #savety for buffer truncation\n    self.ns = 5",
              "signature": "(delay)",
              "parameters": [
                {
                  "name": "delay",
                  "type": null,
                  "default": null,
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "add",
              "description": "adding a new datapoint to the buffer",
              "docstring_html": "<p>adding a new datapoint to the buffer</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>time to add</dd>\n<dt>value <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float, int, complex</span></dt>\n<dd>numerical value to add</dd>\n</dl>\n",
              "source": "def add(self, t, value):\n    \"\"\"adding a new datapoint to the buffer\n\n    Parameters\n    ----------\n    t : float\n        time to add\n    value : float, int, complex\n        numerical value to add\n    \"\"\"\n\n    #add the time-value tuple\n    self.buffer_t.append(t)\n    self.buffer_v.append(value)\n\n    #remove values after savety from buffer -> enable interpolation\n    if len(self.buffer_t) > self.ns:\n        while t - self.buffer_t[self.ns] > self.delay:\n            self.buffer_t.popleft()\n            self.buffer_v.popleft()",
              "signature": "(t, value)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "time to add"
                },
                {
                  "name": "value",
                  "type": null,
                  "default": null,
                  "description": "numerical value to add"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "interp",
              "description": "interpolate buffer at defined lookup time",
              "docstring_html": "<p>interpolate buffer at defined lookup time</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>time for interpolation</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>out <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float, array</span></dt>\n<dd>interpolated value</dd>\n</dl>\n",
              "source": "def interp(self, t):\n    \"\"\"interpolate buffer at defined lookup time\n\n    Parameters\n    ----------\n    t : float\n        time for interpolation\n\n    Returns\n    -------\n    out : float, array\n        interpolated value\n    \"\"\"\n\n    #empty or time too small -> return zero\n    if not self.buffer_t or t <= self.buffer_t[0]:\n        return 0.0\n\n    #requested time too large -> return last value\n    if t >= self.buffer_t[-1]:\n        return self.buffer_v[-1]\n\n    #find buffer index for requested time\n    i = bisect_left(self.buffer_t, t)\n    t0, t1 = self.buffer_t[i], self.buffer_t[i-1]\n    y0, y1 = self.buffer_v[i], self.buffer_v[i-1]\n\n    #linear interpolation\n    return y0 + (y1 - y0) * (t - t0) / (t1 - t0)",
              "signature": "(t)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "time for interpolation"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "get",
              "description": "lookup datapoint from buffer with",
              "docstring_html": "<p>lookup datapoint from buffer with\ndelay at <cite>t_lookup = t - delay</cite></p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>time for lookup with delay</dd>\n</dl>\n",
              "source": "def get(self, t):\n    \"\"\"lookup datapoint from buffer with \n    delay at `t_lookup = t - delay`\n\n    Parameters\n    ----------\n    t : float\n        time for lookup with delay\n    \"\"\"\n    return self.interp(t - self.delay)",
              "signature": "(t)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "time for lookup with delay"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "clear",
              "description": "clear the buffer, reset everything",
              "docstring_html": "<p>clear the buffer, reset everything</p>\n",
              "source": "def clear(self):\n    \"\"\"clear the buffer, reset everything\"\"\"\n    self.buffer_t.clear()\n    self.buffer_v.clear()",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "delay",
              "description": "",
              "type": null,
              "value": "delay"
            },
            {
              "name": "buffer_t",
              "description": "",
              "type": null,
              "value": "deque()"
            },
            {
              "name": "buffer_v",
              "description": "",
              "type": null,
              "value": "deque()"
            },
            {
              "name": "ns",
              "description": "",
              "type": null,
              "value": "5"
            }
          ],
          "parameters": [
            {
              "name": "delay",
              "type": null,
              "default": null,
              "description": "time delay in seconds"
            }
          ]
        }
      ],
      "functions": []
    },
    "pathsim.utils.analysis": {
      "name": "pathsim.utils.analysis",
      "description": "",
      "docstring_html": "",
      "classes": [
        {
          "name": "Timer",
          "description": "Context manager that times the execution time",
          "docstring_html": "<p>Context manager that times the execution time\nof the code inside of the context in 'ms' for\ndebugging purposes.</p>\n<div class=\"section\" id=\"example\">\n<h4>Example</h4>\n<pre class=\"code python literal-block\">\n<span class=\"c1\">#time the code within the context</span><span class=\"w\">\n</span><span class=\"k\">with</span> <span class=\"n\">Timer</span><span class=\"p\">()</span> <span class=\"k\">as</span> <span class=\"n\">T</span><span class=\"p\">:</span><span class=\"w\">\n</span>    <span class=\"n\">complicated_function</span><span class=\"p\">()</span><span class=\"w\">\n\n</span><span class=\"c1\">#print the runtime in ms</span><span class=\"w\">\n</span><span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">T</span><span class=\"p\">)</span>\n</pre>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>verbose <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>flag for verbose output</dd>\n</dl>\n</div>\n",
          "source": "class Timer(ContextDecorator):\n    \"\"\"Context manager that times the execution time \n    of the code inside of the context in 'ms' for \n    debugging purposes.\n\n    Example\n    -------\n\n    .. code-block:: python\n\n        #time the code within the context\n        with Timer() as T:\n            complicated_function()\n\n        #print the runtime in ms\n        print(T)\n\n    Parameters\n    ----------\n    verbose : bool\n        flag for verbose output\n    \"\"\"\n    def __init__(self, verbose=True):\n        self.verbose = verbose\n        self.time = None\n\n\n    def __float__(self):\n        return self.time\n\n\n    def __repr__(self):\n        if self.time is None: return None\n        return f\"{self.time*1e3:.3f}ms\" \n\n\n    def __enter__(self):\n        self._start = perf_counter()\n        return self\n\n\n    def __exit__(self, type, value, traceback):\n        self.time = perf_counter() - self._start\n        if self.verbose: print(self)",
          "bases": [
            "contextlib.ContextDecorator"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, verbose=True):\n    self.verbose = verbose\n    self.time = None",
              "signature": "(verbose = True)",
              "parameters": [
                {
                  "name": "verbose",
                  "type": null,
                  "default": "True",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "verbose",
              "description": "",
              "type": null,
              "value": "verbose"
            },
            {
              "name": "time",
              "description": "",
              "type": null,
              "value": "None"
            }
          ],
          "parameters": [
            {
              "name": "verbose",
              "type": null,
              "default": "True",
              "description": "flag for verbose output"
            }
          ]
        },
        {
          "name": "Profiler",
          "description": "Context manager for easy code profiling",
          "docstring_html": "<p>Context manager for easy code profiling</p>\n<div class=\"section\" id=\"example\">\n<h4>Example</h4>\n<pre class=\"code python literal-block\">\n<span class=\"c1\">#profile the code within the context</span><span class=\"w\">\n</span><span class=\"k\">with</span> <span class=\"n\">Profiler</span><span class=\"p\">():</span><span class=\"w\">\n</span>    <span class=\"n\">complicated_function</span><span class=\"p\">()</span>\n</pre>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>top_n <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>track top n function calls</dd>\n<dt>sort_by <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">str</span></dt>\n<dd>method to sort function cally by</dd>\n</dl>\n</div>\n",
          "source": "class Profiler(ContextDecorator):\n\n    \"\"\"Context manager for easy code profiling\n\n    Example\n    -------\n\n    .. code-block:: python \n\n        #profile the code within the context\n        with Profiler():\n            complicated_function()\n\n    Parameters\n    ----------\n    top_n : int\n        track top n function calls\n    sort_by : str\n        method to sort function cally by\n    \"\"\"\n\n    def __init__(self, top_n=50, sort_by=\"cumulative\"):\n        self.top_n = top_n\n        self.sort_by = sort_by\n        if not PROFILE_AVAILABLE:\n            _msg = \"'Profiler' not available, make sure 'cProfile' and 'pstats' is installed!\"\n            raise ImportError(_msg)\n        self.profiler = cProfile.Profile()\n\n\n    def __enter__(self):\n        self.profiler.enable()\n        return self\n\n\n    def __exit__(self, *exc):\n        self.profiler.disable()\n        stats = pstats.Stats(self.profiler)\n        stats.strip_dirs()\n        stats.sort_stats(self.sort_by)\n        stats.print_stats(self.top_n)\n        return False",
          "bases": [
            "contextlib.ContextDecorator"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, top_n=50, sort_by=\"cumulative\"):\n    self.top_n = top_n\n    self.sort_by = sort_by\n    if not PROFILE_AVAILABLE:\n        _msg = \"'Profiler' not available, make sure 'cProfile' and 'pstats' is installed!\"\n        raise ImportError(_msg)\n    self.profiler = cProfile.Profile()",
              "signature": "(top_n = 50, sort_by = 'cumulative')",
              "parameters": [
                {
                  "name": "top_n",
                  "type": null,
                  "default": "50",
                  "description": ""
                },
                {
                  "name": "sort_by",
                  "type": null,
                  "default": "'cumulative'",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "top_n",
              "description": "",
              "type": null,
              "value": "top_n"
            },
            {
              "name": "sort_by",
              "description": "",
              "type": null,
              "value": "sort_by"
            },
            {
              "name": "profiler",
              "description": "",
              "type": null,
              "value": "cProfile.Profile()"
            }
          ],
          "parameters": [
            {
              "name": "top_n",
              "type": null,
              "default": "50",
              "description": "track top n function calls"
            },
            {
              "name": "sort_by",
              "type": null,
              "default": "'cumulative'",
              "description": "method to sort function cally by"
            }
          ]
        }
      ],
      "functions": [
        {
          "name": "timer",
          "description": "Shows the execution time in milliseconds of the",
          "docstring_html": "<p>Shows the execution time in milliseconds of the\nfunction object passed for debugging purposes</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>func <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">callable</span></dt>\n<dd>function to track execution time of</dd>\n</dl>\n",
          "source": "def timer(func):\n    \"\"\"Shows the execution time in milliseconds of the \n    function object passed for debugging purposes\n\n    Parameters\n    ----------\n    func : callable\n        function to track execution time of\n    \"\"\"\n\n    @wraps(func)\n    def wrap_func(*args, **kwargs):\n        with Timer(verbose=False) as T:\n            result = func(*args, **kwargs)\n        print(f\"Function '{func.__name__!r}' executed in {T}\")\n        return result\n    return wrap_func",
          "signature": "(func)",
          "parameters": [
            {
              "name": "func",
              "type": null,
              "default": null,
              "description": "function to track execution time of"
            }
          ],
          "returns": null
        }
      ]
    },
    "pathsim.utils.gilbert": {
      "name": "pathsim.utils.gilbert",
      "description": "",
      "docstring_html": "",
      "classes": [],
      "functions": [
        {
          "name": "gilbert_realization",
          "description": "Build real valued statespace model from transfer function",
          "docstring_html": "<p>Build real valued statespace model from transfer function\nin pole residue form by Gilberts method and an additional\nsimilarity transformation to get fully real valued matrices.</p>\n<p>pole residue form:</p>\n<div class=\"math\">\n\\begin{equation*}\n\\mathbf{H}(s) = \\mathmf{D} + \\sum_{n=1}^N \\frac{\\mathbf{R}_n}{s - p_n} )\n\\end{equation*}\n</div>\n<p>statespace form:</p>\n<div class=\"math\">\n\\begin{equation*}\n\\mathbf{H}(s) = \\mathbf{C} (s \\mathbf{I} - \\mathbf{A})^{-1} * \\mathbf{B} + \\mathbf{H}\n\\end{equation*}\n</div>\n<p><strong>Notes</strong></p>\n<p>The resulting system is identical to the so-called\n'Modal Form' and is a minimal realization.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>Poles <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array</span></dt>\n<dd>real and complex poles</dd>\n<dt>Residues <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array</span></dt>\n<dd>array of real and complex residue matrices</dd>\n<dt>Const <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array</span></dt>\n<dd>matrix for constant term</dd>\n<dt>tolerance <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>relative tolerance for checking real poles</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>A <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array</span></dt>\n<dd>state matrix</dd>\n<dt>B <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array</span></dt>\n<dd>input mapping matrix</dd>\n<dt>C <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array</span></dt>\n<dd>state to output projection matrix</dd>\n<dt>D <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array, float</span></dt>\n<dd>direct passthrough</dd>\n</dl>\n",
          "source": "def gilbert_realization(Poles=[], Residues=[], Const=0.0, tolerance=1e-9): \n    \"\"\"Build real valued statespace model from transfer function \n    in pole residue form by Gilberts method and an additional \n    similarity transformation to get fully real valued matrices.\n\n    pole residue form:\n\n    .. math::\n\n        \\\\mathbf{H}(s) = \\\\mathmf{D} + \\\\sum_{n=1}^N \\\\frac{\\\\mathbf{R}_n}{s - p_n} )\n\n    statespace form:\n\n    .. math::\n\n        \\\\mathbf{H}(s) = \\\\mathbf{C} (s \\\\mathbf{I} - \\\\mathbf{A})^{-1} * \\\\mathbf{B} + \\\\mathbf{H} \n\n    Notes\n    -----  \n    The resulting system is identical to the so-called \n    'Modal Form' and is a minimal realization.\n\n    Parameters\n    ---------- \n    Poles : array\n        real and complex poles\n    Residues : array\n        array of real and complex residue matrices\n    Const : array\n        matrix for constant term\n    tolerance : float\n        relative tolerance for checking real poles\n\n    Returns \n    -------\n    A : array\n        state matrix\n    B : array \n        input mapping matrix\n    C : array\n        state to output projection matrix\n    D : array, float\n        direct passthrough\n    \"\"\"\n\n    #make arrays\n    Poles = np.atleast_1d(Poles)\n    Residues = np.atleast_1d(Residues)\n\n    #check validity of args\n    if not len(Poles) or not len(Residues):\n        raise ValueError(\"No 'Poles' and 'Residues' defined!\")\n\n    if len(Poles) != len(Residues):\n        raise ValueError(\"Same number of 'Poles' and 'Residues' have to be given!\")\n\n    #check shape of residues for MIMO, etc\n    if Residues.ndim == 1:\n        N, m, n = Residues.size, 1, 1\n        Residues = np.reshape(Residues, (N, m, n))\n    elif Residues.ndim == 2:\n        N, m, n = *Residues.shape, 1\n        Residues = np.reshape(Residues, (N, m, n))\n    elif Residues.ndim == 3:\n        N, m, n = Residues.shape\n    else:\n        raise ValueError(f\"shape mismatch of 'Residues': Residues.shape={Residues.shape}\")\n\n    #initialize companion matrix\n    a = np.zeros((N, N))\n    b = np.zeros(N)\n\n    #residues\n    C = np.ones((m, n*N))\n\n    #go through poles and handle conjugate pairs\n    _Poles, _Residues = [], []\n    for p, R in zip(Poles, Residues):\n\n        #real pole\n        if np.isreal(p) or abs(np.imag(p) / np.real(p)) < tolerance:\n            _Poles.append(p.real)\n            _Residues.append(R.real)\n\n        #complex conjugate pair\n        elif np.imag(p) > 0.0:\n            _Poles.extend([p, np.conj(p)])\n            _Residues.extend([R, np.conj(R)])\n\n    #build real companion matrix from the poles\n    p_old = 0.0\n    for k, (p, R) in enumerate(zip(_Poles, _Residues)):\n\n        #check if complex conjugate\n        is_cc = (p.imag != 0.0 and p == np.conj(p_old))\n        p_old = p\n\n        a[k,k] = np.real(p)\n        b[k] = 1.0\n        if is_cc:\n            a[k, k-1] = - np.imag(p)\n            a[k-1, k] = np.imag(p)\n            b[k]   = 0.0\n            b[k-1] = 2.0\n\n        #iterate columns of residue\n        for i in range(n):\n            C[:,k+N*i] = np.imag(R[:,i]) if is_cc else np.real(R[:,i])  \n\n    #build block diagonal\n    A = np.kron(np.eye(n, dtype=float), a)\n    B = np.kron(np.eye(n, dtype=float), b).T\n    D = Const * np.ones((m, n)) if np.isscalar(Const) else Const\n\n    return  A, B, C, D",
          "signature": "(Poles = [], Residues = [], Const = 0.0, tolerance = 1e-09)",
          "parameters": [
            {
              "name": "Poles",
              "type": null,
              "default": "[]",
              "description": "real and complex poles"
            },
            {
              "name": "Residues",
              "type": null,
              "default": "[]",
              "description": "array of real and complex residue matrices"
            },
            {
              "name": "Const",
              "type": null,
              "default": "0.0",
              "description": "matrix for constant term"
            },
            {
              "name": "tolerance",
              "type": null,
              "default": "1e-09",
              "description": "relative tolerance for checking real poles"
            }
          ],
          "returns": null
        }
      ]
    },
    "pathsim.utils.graph": {
      "name": "pathsim.utils.graph",
      "description": "",
      "docstring_html": "",
      "classes": [
        {
          "name": "Graph",
          "description": "Representation of a directed graph, defined by blocks (nodes)",
          "docstring_html": "<p>Representation of a directed graph, defined by blocks (nodes)\nand edges (connections).</p>\n<p>Manages graph analysis methods, detect algebraic loops, sort blocks and\nconnections into algebraic levels by depth in directed acyclic graph (DAG).\nDoes the same for algebraic loop blocks and connections (DAG for open loops).</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>blocks <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">list[blocks] | None</span></dt>\n<dd>blocks / nodes of the graph</dd>\n<dt>connections <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">list[Connection] | None</span></dt>\n<dd>connections / edges of the graph</dd>\n</dl>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>has_loops <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>flag to indicate if graph has algebraic loops</dd>\n<dt>_alg_depth <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>algebraic depth of DAG (number of alg. levels)</dd>\n<dt>_loop_depth <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>algebraic depth of broken loop DAG (number of alg. levels in loops)</dd>\n<dt>_blocks_dag <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">defaultdict[int, list[Block]]</span></dt>\n<dd>algebraic levels of blocks in internal DAG</dd>\n<dt>_blocks_loop_dag <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">defaultdict[int, list[Block]]</span></dt>\n<dd>algebraic levels of blocks in broken loops DAG</dd>\n<dt>_connections_dag <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">defaultdict[int, list[Connection]]</span></dt>\n<dd>algebraic levels of connections in internal DAG</dd>\n<dt>_connections_loop_dag <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">defaultdict[int, list[Connection]]</span></dt>\n<dd>algebraic levels of connections in broken loops DAG</dd>\n<dt>_upst_blk_blk_map <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">defaultdict[Block, set[Block]]</span></dt>\n<dd>map for upstream connections between blocks</dd>\n<dt>_dnst_blk_blk_map <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">defaultdict[Block, set[Block]]</span></dt>\n<dd>map for downstream connections between blocks</dd>\n<dt>_outg_blk_con_map <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">defaultdict[Block, list[Connection]]</span></dt>\n<dd>map for outgoing connections of blocks</dd>\n</dl>\n",
          "source": "class Graph:\n    \"\"\"Representation of a directed graph, defined by blocks (nodes) \n    and edges (connections).\n\n    Manages graph analysis methods, detect algebraic loops, sort blocks and \n    connections into algebraic levels by depth in directed acyclic graph (DAG). \n    Does the same for algebraic loop blocks and connections (DAG for open loops).\n\n    Parameters\n    ----------\n    blocks : list[blocks] | None\n        blocks / nodes of the graph\n    connections : list[Connection] | None\n        connections / edges of the graph\n\n    Attributes\n    ----------\n    has_loops : bool\n        flag to indicate if graph has algebraic loops\n    _alg_depth : int\n        algebraic depth of DAG (number of alg. levels)\n    _loop_depth : int\n        algebraic depth of broken loop DAG (number of alg. levels in loops)\n    _blocks_dag : defaultdict[int, list[Block]]\n        algebraic levels of blocks in internal DAG\n    _blocks_loop_dag : defaultdict[int, list[Block]]\n        algebraic levels of blocks in broken loops DAG\n    _connections_dag : defaultdict[int, list[Connection]]\n        algebraic levels of connections in internal DAG\n    _connections_loop_dag : defaultdict[int, list[Connection]]\n        algebraic levels of connections in broken loops DAG\n    _upst_blk_blk_map : defaultdict[Block, set[Block]]\n        map for upstream connections between blocks\n    _dnst_blk_blk_map : defaultdict[Block, set[Block]]\n        map for downstream connections between blocks\n    _outg_blk_con_map : defaultdict[Block, list[Connection]]\n        map for outgoing connections of blocks\n    \"\"\"\n\n    def __init__(self, blocks=None, connections=None):\n\n        self.blocks      = [] if blocks is None else blocks\n        self.connections = [] if connections is None else connections\n\n        #loop flag\n        self.has_loops = False\n\n        #depths\n        self._alg_depth = 0\n        self._loop_depth = 0\n\n        #initialize graph orderings\n        self._blocks_dag = defaultdict(list)\n        self._blocks_loop_dag = defaultdict(list)\n\n        self._connections_dag = defaultdict(list)\n        self._connections_loop_dag = defaultdict(list)\n\n        #construct mappings for connections between blocks\n        self._upst_blk_blk_map = upstream_block_block_map(self.connections)\n        self._dnst_blk_blk_map = downstream_block_block_map(self.connections)\n        self._outg_blk_con_map = outgoing_block_connection_map(self.connections)\n\n        #assemble dag and loops\n        self._assemble()\n\n\n    def __bool__(self):\n        return True\n\n\n    def __len__(self):\n        return len(self.blocks)\n\n\n    def depth(self):\n        return self._alg_depth, self._loop_depth\n\n\n    def _assemble(self):\n        \"\"\"Constructs two separate DAG orderings of the graph components.\n\n        This method performs two key operations:\n\n        1. Constructs the main DAG for acyclic portions:\n           - Computes algebraic depth for each block using upstream traversal\n           - Blocks in algebraic loops are identified (depth = None) and collected\n           - Acyclic blocks are placed in _blocks_dag at their calculated depth\n\n        2. Constructs a DAG for loop components:\n           - Identifies strongly connected components (SCCs) to find separate loops\n           - For each SCC, finds proper entry points\n           - Builds a level structure for each loop using BFS from entry points\n           - Organizes all loop blocks into levels in _blocks_loop_dag\n\n        The result is two separate ordered representations:\n        - A standard DAG for acyclic portions (_blocks_dag/_connections_dag)\n        - A \"broken loop\" DAG (_blocks_loop_dag/_connections_loop_dag) with\n          proper entry points and topological ordering for all loops.\n        \"\"\"\n\n        #collect blocks involved in algebraic loops \n        blocks_loop = set()\n\n        #reset flag for loop detection\n        self.has_loops = False\n\n        #iterate blocks to calculate their algebraic depths\n        for blk in self.blocks:\n\n            #use 'inf' propagating mode to detect loops\n            depth = algebraic_depth_dfs(self._upst_blk_blk_map, blk, None, True)\n\n            #None -> upstream alg. loop taints downstream components\n            if depth is None:\n                blocks_loop.add(blk)\n                self.has_loops = True\n\n            else:\n                #add block to the DAG at its calculated depth\n                self._blocks_dag[depth].append(blk)\n                self._connections_dag[depth].extend(self._outg_blk_con_map[blk])\n\n        #compute total algebraic depth of DAG\n        self._alg_depth = max(self._blocks_dag) + 1 if self._blocks_dag else 0\n\n        #build the DAG for loop blocks with proper entry points\n        if not self.has_loops:\n            self._loop_depth = 0\n            return\n\n        #build the DAG for loop blocks with proper entry points\n        sccs = self._find_strongly_connected_components(blocks_loop)\n\n        #track global depth counter for all loop blocks\n        current_depth = 0\n\n        # Process each strongly connected component separately\n        for scc in sccs:\n\n            #find entry points for this SCC\n            entry_points = []\n            for blk in scc:\n                # A block is an entry point if:\n                # 1. It has no predecessors within this SCC, or\n                # 2. It has at least one predecessor outside this SCC\n                pred = self._upst_blk_blk_map[blk]\n                scc_pred = pred.intersection(set(scc))\n\n                if not scc_pred or len(pred) > len(scc_pred):\n                    entry_points.append(blk)\n\n            #if no natural entry points, choose one block as artificial entry\n            if not entry_points:\n                entry_points = [scc[0]]\n\n            #perform BFS from entry points for this SCC\n            visited = set()\n            queue = deque([(entry_point, 0) for entry_point in entry_points])\n            max_local_depth = 0\n\n            #map to store local depths within this SCC\n            local_depths = defaultdict(float)\n\n            while queue:\n                blk, local_depth = queue.popleft()\n\n                if blk in visited:\n                    continue\n\n                visited.add(blk)\n                local_depths[blk] = local_depth\n                max_local_depth = max(max_local_depth, local_depth)\n\n                #enqueue downstream neighbors that are in this SCC\n                for next_blk in self._dnst_blk_blk_map[blk]:\n                    if next_blk in scc and next_blk not in visited:\n                        queue.append((next_blk, local_depth + 1))\n\n            #assign blocks to global depths based on local depths\n            for blk in scc:\n                global_depth = current_depth + local_depths[blk]\n                self._blocks_loop_dag[global_depth].append(blk)\n                self._connections_loop_dag[global_depth].extend(self._outg_blk_con_map[blk])\n\n            #update global depth counter for the next SCC\n            current_depth += max_local_depth + 1\n\n        #compute depth of loop DAG\n        self._loop_depth = max(self._blocks_loop_dag) + 1 if self._blocks_loop_dag else 0\n\n\n    def _find_strongly_connected_components(self, blocks):\n        \"\"\"Finds strongly connected components (SCCs) in the subgraph \n        defined by blocks.\n\n        Uses Tarjan's algorithm to identify separate loop structures.\n\n        Parameters\n        ----------\n        blocks : list[Block]\n            Blocks to consider for SCC analysis\n\n        Returns\n        -------\n        list[list[Block]]\n            List of SCCs, where each SCC is a list of blocks\n        \"\"\"\n        block_set = set(blocks)\n        index_counter = [0]\n        index = {}  # node -> index\n        lowlink = {}  # node -> lowlink\n        onstack = set()  # nodes currently on stack\n        stack = []\n        result = []\n\n        def strongconnect(node):\n            #set the depth index for node\n            index[node] = index_counter[0]\n            lowlink[node] = index_counter[0]\n            index_counter[0] += 1\n            stack.append(node)\n            onstack.add(node)\n\n            #consider successors\n            for successor in self._dnst_blk_blk_map[node]:\n                if successor not in block_set:\n                    continue\n\n                if successor not in index:\n                    #successor has not yet been visited; recurse on it\n                    strongconnect(successor)\n                    lowlink[node] = min(lowlink[node], lowlink[successor])\n                elif successor in onstack:\n                    #successor is in stack and hence in the current SCC\n                    lowlink[node] = min(lowlink[node], index[successor])\n\n            #if node is a root node, pop the stack and generate an SCC\n            if lowlink[node] == index[node]:\n                scc = []\n\n                while True:\n                    successor = stack.pop()\n                    onstack.remove(successor)\n                    scc.append(successor)\n                    if successor == node:\n                        break\n\n                if len(scc) > 1 or any(node in self._dnst_blk_blk_map[node] for node in scc):\n                    result.append(scc)\n\n        #find SCCs for all nodes\n        for node in blocks:\n            if node not in index:\n                strongconnect(node)\n\n        return result\n\n\n    def outgoing_connections(self, block):\n        \"\"\"Returns the outgoing connections of a block, \n        or, connections that have 'block' as its source\n\n        Parameters\n        ----------\n        block : Block\n            block that we want to get the outgoing connections of\n\n        Returns\n        -------\n        list[Connections]\n            connections from the graph that have 'block' as their source\n        \"\"\"\n        return self._outg_blk_con_map[block]\n\n\n    def is_algebraic_path(self, start_block, end_block):\n        \"\"\"Check if two blocks are connected through a \n        purely algebraic path.\n\n        Parameters\n        ----------\n        start_block : Block\n            starting block of path\n        end_block : Block\n            end block of path\n\n        Returns\n        -------\n        bool\n            Is there a purely algebraic path between \n            the two blocks? \n\n        \"\"\" \n\n        #blocks are not part of same graph -> no algebraic path\n        if (start_block not in self._dnst_blk_blk_map or \n            end_block not in self._dnst_blk_blk_map):\n            return False\n\n        #use depth first search to see if there is a path\n        return has_algebraic_path(self._dnst_blk_blk_map, start_block, end_block)\n\n\n    def dag(self):\n        \"\"\"Generator that yields blocks and connections at each \n        algebraic depth level.\n\n        Yields\n        ------\n        tuple[int, list[Block], list[Connection]]\n            blocks and connections at current algebraic depth, \n            together with the depth 'd'\n        \"\"\"\n        for d in range(self._alg_depth):\n            yield (d, self._blocks_dag[d], self._connections_dag[d])\n\n\n    def loop(self):\n        \"\"\"Generator that yields blocks and connections that are part of \n        algebraic loops. \n\n        Formatted as a DAG, that represents a broken loop with entry points.\n\n        Yields\n        ------\n        tuple[int, list[Block], list[Connection]]\n            blocks and connections at current algebraic depth of \n            broken loop, together with the depth 'd'\n        \"\"\"\n        for d in range(self._loop_depth):\n            yield (d, self._blocks_loop_dag[d], self._connections_loop_dag[d])",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, blocks=None, connections=None):\n\n    self.blocks      = [] if blocks is None else blocks\n    self.connections = [] if connections is None else connections\n\n    #loop flag\n    self.has_loops = False\n\n    #depths\n    self._alg_depth = 0\n    self._loop_depth = 0\n\n    #initialize graph orderings\n    self._blocks_dag = defaultdict(list)\n    self._blocks_loop_dag = defaultdict(list)\n\n    self._connections_dag = defaultdict(list)\n    self._connections_loop_dag = defaultdict(list)\n\n    #construct mappings for connections between blocks\n    self._upst_blk_blk_map = upstream_block_block_map(self.connections)\n    self._dnst_blk_blk_map = downstream_block_block_map(self.connections)\n    self._outg_blk_con_map = outgoing_block_connection_map(self.connections)\n\n    #assemble dag and loops\n    self._assemble()",
              "signature": "(blocks = None, connections = None)",
              "parameters": [
                {
                  "name": "blocks",
                  "type": null,
                  "default": "None",
                  "description": ""
                },
                {
                  "name": "connections",
                  "type": null,
                  "default": "None",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "depth",
              "description": "",
              "docstring_html": "",
              "source": "def depth(self):\n    return self._alg_depth, self._loop_depth",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "_assemble",
              "description": "Constructs two separate DAG orderings of the graph components.",
              "docstring_html": "<p>Constructs two separate DAG orderings of the graph components.</p>\n<p>This method performs two key operations:</p>\n<ol class=\"arabic simple\">\n<li>Constructs the main DAG for acyclic portions:\n- Computes algebraic depth for each block using upstream traversal\n- Blocks in algebraic loops are identified (depth = None) and collected\n- Acyclic blocks are placed in _blocks_dag at their calculated depth</li>\n<li>Constructs a DAG for loop components:\n- Identifies strongly connected components (SCCs) to find separate loops\n- For each SCC, finds proper entry points\n- Builds a level structure for each loop using BFS from entry points\n- Organizes all loop blocks into levels in _blocks_loop_dag</li>\n</ol>\n<p>The result is two separate ordered representations:\n- A standard DAG for acyclic portions (_blocks_dag/_connections_dag)\n- A &quot;broken loop&quot; DAG (_blocks_loop_dag/_connections_loop_dag) with</p>\n<blockquote>\nproper entry points and topological ordering for all loops.</blockquote>\n",
              "source": "def _assemble(self):\n    \"\"\"Constructs two separate DAG orderings of the graph components.\n\n    This method performs two key operations:\n\n    1. Constructs the main DAG for acyclic portions:\n       - Computes algebraic depth for each block using upstream traversal\n       - Blocks in algebraic loops are identified (depth = None) and collected\n       - Acyclic blocks are placed in _blocks_dag at their calculated depth\n\n    2. Constructs a DAG for loop components:\n       - Identifies strongly connected components (SCCs) to find separate loops\n       - For each SCC, finds proper entry points\n       - Builds a level structure for each loop using BFS from entry points\n       - Organizes all loop blocks into levels in _blocks_loop_dag\n\n    The result is two separate ordered representations:\n    - A standard DAG for acyclic portions (_blocks_dag/_connections_dag)\n    - A \"broken loop\" DAG (_blocks_loop_dag/_connections_loop_dag) with\n      proper entry points and topological ordering for all loops.\n    \"\"\"\n\n    #collect blocks involved in algebraic loops \n    blocks_loop = set()\n\n    #reset flag for loop detection\n    self.has_loops = False\n\n    #iterate blocks to calculate their algebraic depths\n    for blk in self.blocks:\n\n        #use 'inf' propagating mode to detect loops\n        depth = algebraic_depth_dfs(self._upst_blk_blk_map, blk, None, True)\n\n        #None -> upstream alg. loop taints downstream components\n        if depth is None:\n            blocks_loop.add(blk)\n            self.has_loops = True\n\n        else:\n            #add block to the DAG at its calculated depth\n            self._blocks_dag[depth].append(blk)\n            self._connections_dag[depth].extend(self._outg_blk_con_map[blk])\n\n    #compute total algebraic depth of DAG\n    self._alg_depth = max(self._blocks_dag) + 1 if self._blocks_dag else 0\n\n    #build the DAG for loop blocks with proper entry points\n    if not self.has_loops:\n        self._loop_depth = 0\n        return\n\n    #build the DAG for loop blocks with proper entry points\n    sccs = self._find_strongly_connected_components(blocks_loop)\n\n    #track global depth counter for all loop blocks\n    current_depth = 0\n\n    # Process each strongly connected component separately\n    for scc in sccs:\n\n        #find entry points for this SCC\n        entry_points = []\n        for blk in scc:\n            # A block is an entry point if:\n            # 1. It has no predecessors within this SCC, or\n            # 2. It has at least one predecessor outside this SCC\n            pred = self._upst_blk_blk_map[blk]\n            scc_pred = pred.intersection(set(scc))\n\n            if not scc_pred or len(pred) > len(scc_pred):\n                entry_points.append(blk)\n\n        #if no natural entry points, choose one block as artificial entry\n        if not entry_points:\n            entry_points = [scc[0]]\n\n        #perform BFS from entry points for this SCC\n        visited = set()\n        queue = deque([(entry_point, 0) for entry_point in entry_points])\n        max_local_depth = 0\n\n        #map to store local depths within this SCC\n        local_depths = defaultdict(float)\n\n        while queue:\n            blk, local_depth = queue.popleft()\n\n            if blk in visited:\n                continue\n\n            visited.add(blk)\n            local_depths[blk] = local_depth\n            max_local_depth = max(max_local_depth, local_depth)\n\n            #enqueue downstream neighbors that are in this SCC\n            for next_blk in self._dnst_blk_blk_map[blk]:\n                if next_blk in scc and next_blk not in visited:\n                    queue.append((next_blk, local_depth + 1))\n\n        #assign blocks to global depths based on local depths\n        for blk in scc:\n            global_depth = current_depth + local_depths[blk]\n            self._blocks_loop_dag[global_depth].append(blk)\n            self._connections_loop_dag[global_depth].extend(self._outg_blk_con_map[blk])\n\n        #update global depth counter for the next SCC\n        current_depth += max_local_depth + 1\n\n    #compute depth of loop DAG\n    self._loop_depth = max(self._blocks_loop_dag) + 1 if self._blocks_loop_dag else 0",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "_find_strongly_connected_components",
              "description": "Finds strongly connected components (SCCs) in the subgraph",
              "docstring_html": "<p>Finds strongly connected components (SCCs) in the subgraph\ndefined by blocks.</p>\n<p>Uses Tarjan's algorithm to identify separate loop structures.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>blocks <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">list[Block]</span></dt>\n<dd>Blocks to consider for SCC analysis</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>list[list[Block]]</dt>\n<dd>List of SCCs, where each SCC is a list of blocks</dd>\n</dl>\n",
              "source": "def _find_strongly_connected_components(self, blocks):\n    \"\"\"Finds strongly connected components (SCCs) in the subgraph \n    defined by blocks.\n\n    Uses Tarjan's algorithm to identify separate loop structures.\n\n    Parameters\n    ----------\n    blocks : list[Block]\n        Blocks to consider for SCC analysis\n\n    Returns\n    -------\n    list[list[Block]]\n        List of SCCs, where each SCC is a list of blocks\n    \"\"\"\n    block_set = set(blocks)\n    index_counter = [0]\n    index = {}  # node -> index\n    lowlink = {}  # node -> lowlink\n    onstack = set()  # nodes currently on stack\n    stack = []\n    result = []\n\n    def strongconnect(node):\n        #set the depth index for node\n        index[node] = index_counter[0]\n        lowlink[node] = index_counter[0]\n        index_counter[0] += 1\n        stack.append(node)\n        onstack.add(node)\n\n        #consider successors\n        for successor in self._dnst_blk_blk_map[node]:\n            if successor not in block_set:\n                continue\n\n            if successor not in index:\n                #successor has not yet been visited; recurse on it\n                strongconnect(successor)\n                lowlink[node] = min(lowlink[node], lowlink[successor])\n            elif successor in onstack:\n                #successor is in stack and hence in the current SCC\n                lowlink[node] = min(lowlink[node], index[successor])\n\n        #if node is a root node, pop the stack and generate an SCC\n        if lowlink[node] == index[node]:\n            scc = []\n\n            while True:\n                successor = stack.pop()\n                onstack.remove(successor)\n                scc.append(successor)\n                if successor == node:\n                    break\n\n            if len(scc) > 1 or any(node in self._dnst_blk_blk_map[node] for node in scc):\n                result.append(scc)\n\n    #find SCCs for all nodes\n    for node in blocks:\n        if node not in index:\n            strongconnect(node)\n\n    return result",
              "signature": "(blocks)",
              "parameters": [
                {
                  "name": "blocks",
                  "type": null,
                  "default": null,
                  "description": "Blocks to consider for SCC analysis"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "outgoing_connections",
              "description": "Returns the outgoing connections of a block,",
              "docstring_html": "<p>Returns the outgoing connections of a block,\nor, connections that have 'block' as its source</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>block <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">Block</span></dt>\n<dd>block that we want to get the outgoing connections of</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>list[Connections]</dt>\n<dd>connections from the graph that have 'block' as their source</dd>\n</dl>\n",
              "source": "def outgoing_connections(self, block):\n    \"\"\"Returns the outgoing connections of a block, \n    or, connections that have 'block' as its source\n\n    Parameters\n    ----------\n    block : Block\n        block that we want to get the outgoing connections of\n\n    Returns\n    -------\n    list[Connections]\n        connections from the graph that have 'block' as their source\n    \"\"\"\n    return self._outg_blk_con_map[block]",
              "signature": "(block)",
              "parameters": [
                {
                  "name": "block",
                  "type": null,
                  "default": null,
                  "description": "block that we want to get the outgoing connections of"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "is_algebraic_path",
              "description": "Check if two blocks are connected through a",
              "docstring_html": "<p>Check if two blocks are connected through a\npurely algebraic path.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>start_block <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">Block</span></dt>\n<dd>starting block of path</dd>\n<dt>end_block <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">Block</span></dt>\n<dd>end block of path</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>bool</dt>\n<dd>Is there a purely algebraic path between\nthe two blocks?</dd>\n</dl>\n",
              "source": "def is_algebraic_path(self, start_block, end_block):\n    \"\"\"Check if two blocks are connected through a \n    purely algebraic path.\n\n    Parameters\n    ----------\n    start_block : Block\n        starting block of path\n    end_block : Block\n        end block of path\n\n    Returns\n    -------\n    bool\n        Is there a purely algebraic path between \n        the two blocks? \n\n    \"\"\" \n\n    #blocks are not part of same graph -> no algebraic path\n    if (start_block not in self._dnst_blk_blk_map or \n        end_block not in self._dnst_blk_blk_map):\n        return False\n\n    #use depth first search to see if there is a path\n    return has_algebraic_path(self._dnst_blk_blk_map, start_block, end_block)",
              "signature": "(start_block, end_block)",
              "parameters": [
                {
                  "name": "start_block",
                  "type": null,
                  "default": null,
                  "description": "starting block of path"
                },
                {
                  "name": "end_block",
                  "type": null,
                  "default": null,
                  "description": "end block of path"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "dag",
              "description": "Generator that yields blocks and connections at each",
              "docstring_html": "<p>Generator that yields blocks and connections at each\nalgebraic depth level.</p>\n<p><strong>Yields</strong></p>\n<dl class=\"docutils\">\n<dt>tuple[int, list[Block], list[Connection]]</dt>\n<dd>blocks and connections at current algebraic depth,\ntogether with the depth 'd'</dd>\n</dl>\n",
              "source": "def dag(self):\n    \"\"\"Generator that yields blocks and connections at each \n    algebraic depth level.\n\n    Yields\n    ------\n    tuple[int, list[Block], list[Connection]]\n        blocks and connections at current algebraic depth, \n        together with the depth 'd'\n    \"\"\"\n    for d in range(self._alg_depth):\n        yield (d, self._blocks_dag[d], self._connections_dag[d])",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "loop",
              "description": "Generator that yields blocks and connections that are part of",
              "docstring_html": "<p>Generator that yields blocks and connections that are part of\nalgebraic loops.</p>\n<p>Formatted as a DAG, that represents a broken loop with entry points.</p>\n<p><strong>Yields</strong></p>\n<dl class=\"docutils\">\n<dt>tuple[int, list[Block], list[Connection]]</dt>\n<dd>blocks and connections at current algebraic depth of\nbroken loop, together with the depth 'd'</dd>\n</dl>\n",
              "source": "def loop(self):\n    \"\"\"Generator that yields blocks and connections that are part of \n    algebraic loops. \n\n    Formatted as a DAG, that represents a broken loop with entry points.\n\n    Yields\n    ------\n    tuple[int, list[Block], list[Connection]]\n        blocks and connections at current algebraic depth of \n        broken loop, together with the depth 'd'\n    \"\"\"\n    for d in range(self._loop_depth):\n        yield (d, self._blocks_loop_dag[d], self._connections_loop_dag[d])",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "blocks",
              "description": "",
              "type": null,
              "value": "[] if blocks is None else blocks"
            },
            {
              "name": "connections",
              "description": "",
              "type": null,
              "value": "[] if connections is None else connections"
            },
            {
              "name": "has_loops",
              "description": "",
              "type": null,
              "value": "False"
            },
            {
              "name": "_alg_depth",
              "description": "",
              "type": null,
              "value": "0"
            },
            {
              "name": "_loop_depth",
              "description": "",
              "type": null,
              "value": "0"
            },
            {
              "name": "_blocks_dag",
              "description": "",
              "type": null,
              "value": "defaultdict(list)"
            },
            {
              "name": "_blocks_loop_dag",
              "description": "",
              "type": null,
              "value": "defaultdict(list)"
            },
            {
              "name": "_connections_dag",
              "description": "",
              "type": null,
              "value": "defaultdict(list)"
            },
            {
              "name": "_connections_loop_dag",
              "description": "",
              "type": null,
              "value": "defaultdict(list)"
            },
            {
              "name": "_upst_blk_blk_map",
              "description": "",
              "type": null,
              "value": "upstream_block_block_map(self.connections)"
            },
            {
              "name": "_dnst_blk_blk_map",
              "description": "",
              "type": null,
              "value": "downstream_block_block_map(self.connections)"
            },
            {
              "name": "_outg_blk_con_map",
              "description": "",
              "type": null,
              "value": "outgoing_block_connection_map(self.connections)"
            }
          ],
          "parameters": [
            {
              "name": "blocks",
              "type": null,
              "default": "None",
              "description": "blocks / nodes of the graph"
            },
            {
              "name": "connections",
              "type": null,
              "default": "None",
              "description": "connections / edges of the graph"
            }
          ]
        }
      ],
      "functions": [
        {
          "name": "outgoing_block_connection_map",
          "description": "Construct a mapping from blocks to their outgoing connections.",
          "docstring_html": "<p>Construct a mapping from blocks to their outgoing connections.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>connections <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">list[Connection]</span></dt>\n<dd>connections of the graph</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>block_connection_map <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">defaultdict[Block, list[Connection]]</span></dt>\n<dd>outgoing connections of block</dd>\n</dl>\n",
          "source": "def outgoing_block_connection_map(connections):\n    \"\"\"Construct a mapping from blocks to their outgoing connections.\n\n    Parameters\n    ----------\n    connections : list[Connection]\n        connections of the graph\n\n    Returns\n    -------\n    block_connection_map : defaultdict[Block, list[Connection]]\n        outgoing connections of block\n    \"\"\"\n    block_connection_map = defaultdict(list)\n    for con in connections:\n        src_blk = con.source.block\n        block_connection_map[src_blk].append(con)\n    return block_connection_map",
          "signature": "(connections)",
          "parameters": [
            {
              "name": "connections",
              "type": null,
              "default": null,
              "description": "connections of the graph"
            }
          ],
          "returns": null
        },
        {
          "name": "downstream_block_block_map",
          "description": "Construct a connection map (directed graph) from the list of",
          "docstring_html": "<p>Construct a connection map (directed graph) from the list of\nconnections in downstream (source -&gt; targets) orientation.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>connections <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">list[Connection]</span></dt>\n<dd>connections of the graph</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>connection_map <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">defaultdict[Block, set[Block]]</span></dt>\n<dd>directed downstream graph of connections (source -&gt; targets)</dd>\n</dl>\n",
          "source": "def downstream_block_block_map(connections):\n    \"\"\"Construct a connection map (directed graph) from the list of\n    connections in downstream (source -> targets) orientation.\n\n    Parameters\n    ----------\n    connections : list[Connection]\n        connections of the graph\n\n    Returns\n    -------\n    connection_map : defaultdict[Block, set[Block]]\n        directed downstream graph of connections (source -> targets)\n    \"\"\"\n    connection_map = defaultdict(set)\n    for con in connections:\n        src_blk = con.source.block\n        for trg in con.targets:\n            connection_map[src_blk].add(trg.block)\n    return connection_map",
          "signature": "(connections)",
          "parameters": [
            {
              "name": "connections",
              "type": null,
              "default": null,
              "description": "connections of the graph"
            }
          ],
          "returns": null
        },
        {
          "name": "upstream_block_block_map",
          "description": "Construct a connection map (directed graph) from the list of",
          "docstring_html": "<p>Construct a connection map (directed graph) from the list of\nconnections in upstream (targets -&gt; source) orientation.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>connections <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">list[Connection]</span></dt>\n<dd>connections of the graph</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>connection_map <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">defaultdict[Block, set[Block]]</span></dt>\n<dd>directed upstream graph of connections (target -&gt; source)</dd>\n</dl>\n",
          "source": "def upstream_block_block_map(connections):\n    \"\"\"Construct a connection map (directed graph) from the list of\n    connections in upstream (targets -> source) orientation.\n\n    Parameters\n    ----------\n    connections : list[Connection]\n        connections of the graph\n\n    Returns\n    -------\n    connection_map : defaultdict[Block, set[Block]]\n        directed upstream graph of connections (target -> source)\n    \"\"\"\n    connection_map = defaultdict(set)\n    for con in connections:\n        src_blk = con.source.block\n        for trg in con.targets:\n            connection_map[trg.block].add(src_blk)\n    return connection_map",
          "signature": "(connections)",
          "parameters": [
            {
              "name": "connections",
              "type": null,
              "default": null,
              "description": "connections of the graph"
            }
          ],
          "returns": null
        },
        {
          "name": "algebraic_depth_dfs",
          "description": "Computes the longest algebraic path length using depth-first search.",
          "docstring_html": "<p>Computes the longest algebraic path length using depth-first search.</p>\n<p>This function determines the longest algebraic path length from a given node,\ntraversing the graph in the direction specified by the graph_map. It can\noperate in two modes controlled by the propagate_inf parameter:</p>\n<ul class=\"simple\">\n<li>In propagate mode (propagate_inf=True): Cycles and hidden loops cause the\nentire result to be marked as infinite (None). Used for detecting algebraic\nloops that affect the entire system.</li>\n<li>In non-propagate mode (propagate_inf=False): Cycles and hidden loops act as\ntermination points (return 0). Used for constructing a DAG from components\nthat would otherwise form a cycle.</li>\n</ul>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>graph_map <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">dict[Block, set[Block]]</span></dt>\n<dd>Adjacency map in the direction of traversal:\n- For upstream traversal: {target : {sources}}\n- For downstream traversal: {source : {targets}}</dd>\n<dt>node <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">Block</span></dt>\n<dd>Starting block for the traversal.</dd>\n<dt>node_set <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">set[Block] | None, optional</span></dt>\n<dd>Optional set of blocks to restrict the search to.\nIf None, all blocks in the graph_map are considered.</dd>\n<dt>propagate_inf <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool, default=True</span></dt>\n<dd>Controls how cycles and hidden loops are handled:\n- True: Infinite paths propagate and taint the entire result (None)\n- False: Infinite paths simply terminate that branch (0)</dd>\n<dt>stack <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">frozenset[Block], optional</span></dt>\n<dd>Blocks on the current recursion path (used for cycle detection).\nInternal use only - do not supply manually.</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>int | None</dt>\n<dd><ul class=\"first last simple\">\n<li>Positive integer: Length of longest finite algebraic path</li>\n<li>0: No algebraic path exists (all paths broken by non-algebraic blocks)</li>\n<li>None: Infinite path length (due to algebraic loops or hidden loops)</li>\n</ul>\n</dd>\n</dl>\n",
          "source": "def algebraic_depth_dfs(graph_map, node, node_set=None, propagate_inf=True, stack=frozenset()):\n    \"\"\"Computes the longest algebraic path length using depth-first search.\n\n    This function determines the longest algebraic path length from a given node,\n    traversing the graph in the direction specified by the graph_map. It can\n    operate in two modes controlled by the propagate_inf parameter:\n\n    - In propagate mode (propagate_inf=True): Cycles and hidden loops cause the\n      entire result to be marked as infinite (None). Used for detecting algebraic\n      loops that affect the entire system.\n    - In non-propagate mode (propagate_inf=False): Cycles and hidden loops act as\n      termination points (return 0). Used for constructing a DAG from components\n      that would otherwise form a cycle.\n\n    Parameters\n    ----------\n    graph_map : dict[Block, set[Block]]\n        Adjacency map in the direction of traversal:\n        - For upstream traversal: {target : {sources}}\n        - For downstream traversal: {source : {targets}}\n    node : Block\n        Starting block for the traversal.\n    node_set : set[Block] | None, optional\n        Optional set of blocks to restrict the search to.\n        If None, all blocks in the graph_map are considered.\n    propagate_inf : bool, default=True\n        Controls how cycles and hidden loops are handled:\n        - True: Infinite paths propagate and taint the entire result (None)\n        - False: Infinite paths simply terminate that branch (0)\n    stack : frozenset[Block], optional\n        Blocks on the current recursion path (used for cycle detection).\n        Internal use only - do not supply manually.\n\n    Returns\n    -------\n    int | None\n        - Positive integer: Length of longest finite algebraic path\n        - 0: No algebraic path exists (all paths broken by non-algebraic blocks)\n        - None: Infinite path length (due to algebraic loops or hidden loops)\n    \"\"\"\n    @cache\n    def dfs(cur, stk):\n\n        #skip irrelevant nodes -> terminates\n        if node_set is not None: \n            if cur not in node_set:\n                return 0\n\n        alg_len = len(cur)\n\n        #non-algebraic block -> stops path \n        if alg_len == 0:\n            return 0\n\n        #hidden loop block\n        if alg_len is None: \n\n            #taint entire result or terminate\n            return None if propagate_inf else 0\n\n        #cycle detection\n        if cur in stk:\n\n            #taint entire result or terminate\n            return None if propagate_inf else 0\n\n        #recurse to neighbours\n        best = 0\n        nxt_stk = stk | {cur}\n        for nbr in graph_map.get(cur, ()):\n\n            sub = dfs(nbr, nxt_stk)\n\n            if sub is None:\n                #taint entire result or terminate\n                return None if propagate_inf else 0\n\n            #update best length\n            best = max(best, sub)\n\n        #count this algebraic block\n        return best + alg_len\n\n    return dfs(node, stack)",
          "signature": "(graph_map, node, node_set = None, propagate_inf = True, stack = frozenset())",
          "parameters": [
            {
              "name": "graph_map",
              "type": null,
              "default": null,
              "description": "Adjacency map in the direction of traversal: - For upstream traversal: {target : {sources}} - For downstream traversal: {source : {targets}}"
            },
            {
              "name": "node",
              "type": null,
              "default": null,
              "description": "Starting block for the traversal."
            },
            {
              "name": "node_set",
              "type": null,
              "default": "None",
              "description": "Optional set of blocks to restrict the search to. If None, all blocks in the graph_map are considered."
            },
            {
              "name": "propagate_inf",
              "type": null,
              "default": "True",
              "description": "Controls how cycles and hidden loops are handled: - True: Infinite paths propagate and taint the entire result (None) - False: Infinite paths simply terminate that branch (0)"
            },
            {
              "name": "stack",
              "type": null,
              "default": "frozenset()",
              "description": "Blocks on the current recursion path (used for cycle detection). Internal use only - do not supply manually."
            }
          ],
          "returns": null
        },
        {
          "name": "has_algebraic_path",
          "description": "Determines if an algebraic path exists between two blocks.",
          "docstring_html": "<p>Determines if an algebraic path exists between two blocks.</p>\n<p>An algebraic path exists if there is a directed path from start_block to\nend_block consisting entirely of algebraic blocks (blocks with len &gt; 0).\nThis function can also detect algebraic self-feedback loops when\nstart_block and end_block are the same.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>connection_map <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">dict[Block, set[Block]]</span></dt>\n<dd>Adjacency map in downstream (source -&gt; targets) orientation.</dd>\n<dt>start_block <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">Block</span></dt>\n<dd>Starting block for the path search.</dd>\n<dt>end_block <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">Block</span></dt>\n<dd>Target block to reach.</dd>\n<dt>node_set <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">set[Block] | None, optional</span></dt>\n<dd>Optional set of blocks to restrict the search to.\nIf None, all blocks in the connection_map are considered.</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>bool</dt>\n<dd>True if an algebraic path exists, False otherwise.</dd>\n</dl>\n<div class=\"section\" id=\"note\">\n<h4>Note</h4>\n<ul class=\"simple\">\n<li>Self-feedback loops (when start_block equals end_block) are detected by\nfinding a path that returns to the start block after traversing at least\none other node.</li>\n<li>Non-algebraic blocks (len == 0) break the path and prevent an algebraic\nconnection from being established.</li>\n<li>The function uses depth-first search with cycle detection to avoid\ninfinite recursion.</li>\n</ul>\n</div>\n",
          "source": "def has_algebraic_path(connection_map, start_block, end_block, node_set=None):\n    \"\"\"Determines if an algebraic path exists between two blocks.\n\n    An algebraic path exists if there is a directed path from start_block to \n    end_block consisting entirely of algebraic blocks (blocks with len > 0).\n    This function can also detect algebraic self-feedback loops when \n    start_block and end_block are the same.\n\n    Parameters\n    ----------\n    connection_map : dict[Block, set[Block]]\n        Adjacency map in downstream (source -> targets) orientation.\n    start_block : Block\n        Starting block for the path search.\n    end_block : Block\n        Target block to reach.\n    node_set : set[Block] | None, optional\n        Optional set of blocks to restrict the search to.\n        If None, all blocks in the connection_map are considered.\n\n    Returns\n    -------\n    bool\n        True if an algebraic path exists, False otherwise.\n\n    Note\n    ----\n    - Self-feedback loops (when start_block equals end_block) are detected by\n      finding a path that returns to the start block after traversing at least\n      one other node.\n    - Non-algebraic blocks (len == 0) break the path and prevent an algebraic\n      connection from being established.\n    - The function uses depth-first search with cycle detection to avoid\n      infinite recursion.\n    \"\"\"\n    # Create a visited set to avoid recomputing nodes\n    visited = set()\n\n    def dfs(current):\n\n        #skip if already visited or not in node_set (if specified)\n        if current in visited or (node_set is not None and current not in node_set):\n            return False\n\n        #mark as visited\n        visited.add(current)\n\n        #check if we reached the end block\n        if current is end_block:\n\n            #for self-loops, we need to find a path back to the start\n            if start_block is not end_block:\n                return True\n\n        #non-algebraic blocks break the path\n        if len(current) == 0:\n            return False\n\n        #explore neighbors\n        for next_block in connection_map.get(current, ()):\n\n            #self-loops -> True if we find end_block AND it's through a path (not directly)\n            if next_block is end_block and start_block is end_block:\n                return True\n\n            if dfs(next_block):\n                return True\n\n        return False\n\n    #start the search\n    return dfs(start_block)",
          "signature": "(connection_map, start_block, end_block, node_set = None)",
          "parameters": [
            {
              "name": "connection_map",
              "type": null,
              "default": null,
              "description": "Adjacency map in downstream (source -> targets) orientation."
            },
            {
              "name": "start_block",
              "type": null,
              "default": null,
              "description": "Starting block for the path search."
            },
            {
              "name": "end_block",
              "type": null,
              "default": null,
              "description": "Target block to reach."
            },
            {
              "name": "node_set",
              "type": null,
              "default": "None",
              "description": "Optional set of blocks to restrict the search to. If None, all blocks in the connection_map are considered. Returns ------- bool True if an algebraic path exists, False otherwise. Note ---- - Self-feedback loops (when start_block equals end_block) are detected by finding a path that returns to the start block after traversing at least one other node. - Non-algebraic blocks (len == 0) break the path and prevent an algebraic connection from being established. - The function uses depth-first search with cycle detection to avoid infinite recursion."
            }
          ],
          "returns": null
        }
      ]
    },
    "pathsim.utils.portreference": {
      "name": "pathsim.utils.portreference",
      "description": "",
      "docstring_html": "",
      "classes": [
        {
          "name": "PortReference",
          "description": "This is a container class that holds a reference to a block",
          "docstring_html": "<p>This is a container class that holds a reference to a block\nand a list of ports.</p>\n<div class=\"section\" id=\"note\">\n<h4>Note</h4>\n<p>The default port, when no ports are defined in the arguments is <cite>0</cite>.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>block <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">Block</span></dt>\n<dd>internal block reference</dd>\n<dt>ports <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">list[int, str]</span></dt>\n<dd>list of port indices or names</dd>\n</dl>\n</div>\n",
          "source": "class PortReference:\n    \"\"\"This is a container class that holds a reference to a block \n    and a list of ports.\n\n    Note\n    ----\n    The default port, when no ports are defined in the arguments is `0`.\n\n    Parameters\n    ----------\n    block : Block\n        internal block reference\n    ports : list[int, str]\n        list of port indices or names\n    \"\"\"\n\n    __slots__ = [\"block\", \"ports\"]\n\n\n    def __init__(self, block=None, ports=None):\n\n        #default port is '0'\n        _ports = [0] if ports is None else ports \n\n        #type validation for ports\n        if not isinstance(_ports, list):            \n            raise ValueError(f\"'ports' must be list[int, str] but is '{type(_ports)}'!\")\n\n        for p in _ports:\n\n            #type validation for individual ports\n            if not isinstance(p, (int, str)):\n                raise ValueError(f\"Port '{p}' must be (int, str) but is '{type(p)}'!\")\n\n            #validation for positive interger\n            if isinstance(p, int) and p < 0:\n                raise ValueError(f\"Port '{p}' is int but must be positive!\")\n\n            #key existance validation for string ports\n            if not (p in block.inputs or p in block.outputs):        \n                raise ValueError(f\"Port alias '{p}' not defined for Block {block}!\")\n\n        #port uniqueness validation\n        if len(_ports) != len(set(_ports)):\n            raise ValueError(\"'ports' must be unique!\")\n\n        self.block = block\n        self.ports = _ports\n\n\n    def __len__(self):\n        \"\"\"The number of ports managed by 'PortReference'\"\"\"\n        return len(self.ports)\n\n\n    def _validate_input_ports(self):\n        \"\"\"Check the existance of the input ports, specifically string port \n        aliases for the block inputs. Raises a ValueError if not existent.\n        \"\"\"\n        for p in self.ports:\n            if not p in self.block.inputs:\n                raise ValueError(f\"Input port '{p}' not defined for Block {self.block}!\")\n\n\n    def _validate_output_ports(self):\n        \"\"\"Check the existance of the output ports, specifically string port \n        aliases for the block inputs. Raises a ValueError if not existent.\n        \"\"\"\n        for p in self.ports:\n            if not p in self.block.outputs:\n                raise ValueError(f\"Output port '{p}' not defined for Block {self.block}!\")\n\n\n    def to(self, other):\n        \"\"\"Transfer the data between two `PortReference` instances, \n        in this direction `self` -> `other`. From outputs to inputs.\n\n        Parameters\n        ----------\n        other : PortReference\n            the `PortReference` instance to transfer data to from `self`\n        \"\"\"\n        for a, b in zip(other.ports, self.ports):\n            other.block.inputs[a] = self.block.outputs[b]\n\n\n    def get_inputs(self):\n        \"\"\"Return the input values of the block at specified ports\n\n        Returns\n        -------\n        out : list[float, obj]\n            input values of block\n        \"\"\"\n        return np.array([self.block.inputs[p] for p in self.ports])\n\n\n    def set_inputs(self, vals):\n        \"\"\"Set the block inputs with values at specified ports\n\n        Parameters\n        ----------\n        vals : list[float, obj]\n            values to set at block input ports\n        \"\"\"\n        for v, p in zip(vals, self.ports):\n            self.block.inputs[p] = v\n\n\n    def get_outputs(self):\n        \"\"\"Return the output values of the block at specified ports\n\n        Returns\n        -------\n        out : list[float, obj]\n            output values of block\n        \"\"\"\n        return np.array([self.block.outputs[p] for p in self.ports])\n\n\n    def set_outputs(self, vals):\n        \"\"\"Set the block outputs with values at specified ports\n\n        Parameters\n        ----------\n        vals : list[float, obj]\n            values to set at block output ports\n        \"\"\"\n        for v, p in zip(vals, self.ports):\n            self.block.outputs[p] = v\n\n\n    def to_dict(self):\n        \"\"\"Serialization into dict\"\"\"\n        return {\n            \"block\": id(self.block),\n            \"ports\": self.ports\n        }",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, block=None, ports=None):\n\n    #default port is '0'\n    _ports = [0] if ports is None else ports \n\n    #type validation for ports\n    if not isinstance(_ports, list):            \n        raise ValueError(f\"'ports' must be list[int, str] but is '{type(_ports)}'!\")\n\n    for p in _ports:\n\n        #type validation for individual ports\n        if not isinstance(p, (int, str)):\n            raise ValueError(f\"Port '{p}' must be (int, str) but is '{type(p)}'!\")\n\n        #validation for positive interger\n        if isinstance(p, int) and p < 0:\n            raise ValueError(f\"Port '{p}' is int but must be positive!\")\n\n        #key existance validation for string ports\n        if not (p in block.inputs or p in block.outputs):        \n            raise ValueError(f\"Port alias '{p}' not defined for Block {block}!\")\n\n    #port uniqueness validation\n    if len(_ports) != len(set(_ports)):\n        raise ValueError(\"'ports' must be unique!\")\n\n    self.block = block\n    self.ports = _ports",
              "signature": "(block = None, ports = None)",
              "parameters": [
                {
                  "name": "block",
                  "type": null,
                  "default": "None",
                  "description": ""
                },
                {
                  "name": "ports",
                  "type": null,
                  "default": "None",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "_validate_input_ports",
              "description": "Check the existance of the input ports, specifically string port",
              "docstring_html": "<p>Check the existance of the input ports, specifically string port\naliases for the block inputs. Raises a ValueError if not existent.</p>\n",
              "source": "def _validate_input_ports(self):\n    \"\"\"Check the existance of the input ports, specifically string port \n    aliases for the block inputs. Raises a ValueError if not existent.\n    \"\"\"\n    for p in self.ports:\n        if not p in self.block.inputs:\n            raise ValueError(f\"Input port '{p}' not defined for Block {self.block}!\")",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "_validate_output_ports",
              "description": "Check the existance of the output ports, specifically string port",
              "docstring_html": "<p>Check the existance of the output ports, specifically string port\naliases for the block inputs. Raises a ValueError if not existent.</p>\n",
              "source": "def _validate_output_ports(self):\n    \"\"\"Check the existance of the output ports, specifically string port \n    aliases for the block inputs. Raises a ValueError if not existent.\n    \"\"\"\n    for p in self.ports:\n        if not p in self.block.outputs:\n            raise ValueError(f\"Output port '{p}' not defined for Block {self.block}!\")",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "to",
              "description": "Transfer the data between two `PortReference` instances,",
              "docstring_html": "<p>Transfer the data between two <cite>PortReference</cite> instances,\nin this direction <cite>self</cite> -&gt; <cite>other</cite>. From outputs to inputs.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>other <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">PortReference</span></dt>\n<dd>the <cite>PortReference</cite> instance to transfer data to from <cite>self</cite></dd>\n</dl>\n",
              "source": "def to(self, other):\n    \"\"\"Transfer the data between two `PortReference` instances, \n    in this direction `self` -> `other`. From outputs to inputs.\n\n    Parameters\n    ----------\n    other : PortReference\n        the `PortReference` instance to transfer data to from `self`\n    \"\"\"\n    for a, b in zip(other.ports, self.ports):\n        other.block.inputs[a] = self.block.outputs[b]",
              "signature": "(other)",
              "parameters": [
                {
                  "name": "other",
                  "type": null,
                  "default": null,
                  "description": "the `PortReference` instance to transfer data to from `self`"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "get_inputs",
              "description": "Return the input values of the block at specified ports",
              "docstring_html": "<p>Return the input values of the block at specified ports</p>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>out <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">list[float, obj]</span></dt>\n<dd>input values of block</dd>\n</dl>\n",
              "source": "def get_inputs(self):\n    \"\"\"Return the input values of the block at specified ports\n\n    Returns\n    -------\n    out : list[float, obj]\n        input values of block\n    \"\"\"\n    return np.array([self.block.inputs[p] for p in self.ports])",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "set_inputs",
              "description": "Set the block inputs with values at specified ports",
              "docstring_html": "<p>Set the block inputs with values at specified ports</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>vals <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">list[float, obj]</span></dt>\n<dd>values to set at block input ports</dd>\n</dl>\n",
              "source": "def set_inputs(self, vals):\n    \"\"\"Set the block inputs with values at specified ports\n\n    Parameters\n    ----------\n    vals : list[float, obj]\n        values to set at block input ports\n    \"\"\"\n    for v, p in zip(vals, self.ports):\n        self.block.inputs[p] = v",
              "signature": "(vals)",
              "parameters": [
                {
                  "name": "vals",
                  "type": null,
                  "default": null,
                  "description": "values to set at block input ports"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "get_outputs",
              "description": "Return the output values of the block at specified ports",
              "docstring_html": "<p>Return the output values of the block at specified ports</p>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>out <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">list[float, obj]</span></dt>\n<dd>output values of block</dd>\n</dl>\n",
              "source": "def get_outputs(self):\n    \"\"\"Return the output values of the block at specified ports\n\n    Returns\n    -------\n    out : list[float, obj]\n        output values of block\n    \"\"\"\n    return np.array([self.block.outputs[p] for p in self.ports])",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "set_outputs",
              "description": "Set the block outputs with values at specified ports",
              "docstring_html": "<p>Set the block outputs with values at specified ports</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>vals <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">list[float, obj]</span></dt>\n<dd>values to set at block output ports</dd>\n</dl>\n",
              "source": "def set_outputs(self, vals):\n    \"\"\"Set the block outputs with values at specified ports\n\n    Parameters\n    ----------\n    vals : list[float, obj]\n        values to set at block output ports\n    \"\"\"\n    for v, p in zip(vals, self.ports):\n        self.block.outputs[p] = v",
              "signature": "(vals)",
              "parameters": [
                {
                  "name": "vals",
                  "type": null,
                  "default": null,
                  "description": "values to set at block output ports"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "to_dict",
              "description": "Serialization into dict",
              "docstring_html": "<p>Serialization into dict</p>\n",
              "source": "def to_dict(self):\n    \"\"\"Serialization into dict\"\"\"\n    return {\n        \"block\": id(self.block),\n        \"ports\": self.ports\n    }",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "block",
              "description": "",
              "type": null,
              "value": "block"
            },
            {
              "name": "ports",
              "description": "",
              "type": null,
              "value": "_ports"
            }
          ],
          "parameters": [
            {
              "name": "block",
              "type": null,
              "default": "None",
              "description": "internal block reference"
            },
            {
              "name": "ports",
              "type": null,
              "default": "None",
              "description": "list of port indices or names"
            }
          ]
        }
      ],
      "functions": []
    },
    "pathsim.utils.progresstracker": {
      "name": "pathsim.utils.progresstracker",
      "description": "",
      "docstring_html": "",
      "classes": [
        {
          "name": "ProgressTracker",
          "description": "A progress tracker suitable for simulations with variable timesteps,",
          "docstring_html": "<p>A progress tracker suitable for simulations with variable timesteps,\nupdated by progress fraction and integrated with standard logging.</p>\n<p>Logs progress updates periodically based on time and progress intervals.\nCalculates an estimated step rate based on the interval since the last log.\nCan be used as both an iterator and a context manager for convenient\nintegration into simulation loops.</p>\n<p><strong>Examples</strong></p>\n<!-- code-block::python\n\ntracker = ProgressTracker(total_duration=10.0)\n\nwith tracker: # Handles start() and close()\n\n    for _ in tracker: # Iterates until progress >= 1.0\n\n        # ... perform simulation step ...\n\n        current_time = get_current_sim_time()\n        progress = current_time / 10.0\n\n        tracker.update(progress, dt=current_dt) -->\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>total_duration <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>The total simulation duration (e.g., in seconds) to track against.\nMust be positive.</dd>\n<dt>description <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">str, optional</span></dt>\n<dd>A short description or name for the process being tracked, used in\nlog messages. Defaults to &quot;Progress&quot;.</dd>\n<dt>logger <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">logging.Logger, optional</span></dt>\n<dd>The logger instance to use for outputting progress messages. If None,\na default logger named 'ProgressTracker_&lt;description&gt;' is created\nand configured to print INFO level messages to stdout.</dd>\n<dt>log <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>Flag to indicate if logging messages should be printed or not.</dd>\n<dt>log_level <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int, optional</span></dt>\n<dd>The logging level (e.g., <cite>logging.INFO</cite>, <cite>logging.DEBUG</cite>) to use for\nprogress messages. Defaults to <cite>logging.INFO</cite>.</dd>\n<dt>min_log_interval <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float, optional</span></dt>\n<dd>The minimum real time interval in seconds that must pass between\nconsecutive log updates, regardless of progress change. Helps to\nthrottle output. Default from '_constants.py'.</dd>\n<dt>update_log_every <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float, optional</span></dt>\n<dd>Log a message every time the progress increases by at least this\nfraction (e.g., 0.1 for 10%). Must be between 0 (exclusive) and\n1 (inclusive). Default from '_constants.py'.</dd>\n</dl>\n",
          "source": "class ProgressTracker:\n    \"\"\"A progress tracker suitable for simulations with variable timesteps,\n    updated by progress fraction and integrated with standard logging.\n\n    Logs progress updates periodically based on time and progress intervals.\n    Calculates an estimated step rate based on the interval since the last log.\n    Can be used as both an iterator and a context manager for convenient\n    integration into simulation loops.\n\n    Examples\n    --------\n\n    .. code-block::python\n\n        tracker = ProgressTracker(total_duration=10.0)\n\n        with tracker: # Handles start() and close()\n\n            for _ in tracker: # Iterates until progress >= 1.0\n\n                # ... perform simulation step ...\n\n                current_time = get_current_sim_time()\n                progress = current_time / 10.0\n\n                tracker.update(progress, dt=current_dt)\n\n\n    Parameters\n    ----------\n    total_duration : float\n        The total simulation duration (e.g., in seconds) to track against.\n        Must be positive.\n    description : str, optional\n        A short description or name for the process being tracked, used in\n        log messages. Defaults to \"Progress\".\n    logger : logging.Logger, optional\n        The logger instance to use for outputting progress messages. If None,\n        a default logger named 'ProgressTracker_<description>' is created\n        and configured to print INFO level messages to stdout.\n    log : bool\n        Flag to indicate if logging messages should be printed or not.\n    log_level : int, optional\n        The logging level (e.g., `logging.INFO`, `logging.DEBUG`) to use for\n        progress messages. Defaults to `logging.INFO`.\n    min_log_interval : float, optional\n        The minimum real time interval in seconds that must pass between\n        consecutive log updates, regardless of progress change. Helps to\n        throttle output. Default from '_constants.py'.\n    update_log_every : float, optional\n        Log a message every time the progress increases by at least this\n        fraction (e.g., 0.1 for 10%). Must be between 0 (exclusive) and\n        1 (inclusive). Default from '_constants.py'.\n\n    \"\"\"\n\n    def __init__(\n        self,\n        total_duration,\n        description=\"\",\n        logger=None,\n        log=True,\n        log_level=logging.INFO,\n        min_log_interval=LOG_MIN_INTERVAL,\n        update_log_every=LOG_UPDATE_EVERY\n        ):\n\n        #input validation\n        if total_duration <= 0:\n            raise ValueError(\"total_duration must be positive\")\n        if not (0 < update_log_every <= 1):\n            raise ValueError(\"update_log_every must be between 0 (exclusive) and 1 (inclusive)\")\n        if min_log_interval < 0:\n            raise ValueError(\"min_log_interval cannot be negative\")\n\n        self.total_duration = float(total_duration)\n        self.description = description if description else \"Progress\"\n        self.log_level = log_level\n        self.min_log_interval = min_log_interval\n        self.update_log_every = update_log_every\n        self.log = log\n\n        #setup logger\n        self.logger = logger or logging.getLogger(f\"ProgressTracker_{self.description[:10]}\")\n\n        #ensure logger has a handler if none exists to enable output\n        if not self.logger.hasHandlers() and not self._has_configured_handler(self.logger):\n\n            #configure logger only if it hasn't been configured elsewhere\n            handler = logging.StreamHandler(sys.stdout)\n            formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s', datefmt='%H:%M:%S')\n            handler.setFormatter(formatter)\n            self.logger.addHandler(handler)\n            self.logger.setLevel(logging.INFO)\n            self.logger.propagate = False\n\n        #time tracking starts\n        self.start_time = None\n\n        #time of the last log message\n        self.last_log_time = 0\n\n        #store step count at last log for interval rate calculation\n        self.last_log_total_steps = 0\n\n        #progress milestone for percentage-based logging trigger\n        #initialized below zero to ensure the first log (0%) happens\n        self.last_log_progress_milestone = -self.update_log_every\n\n        #internal progress state (0.0 to 1.0)\n        self._current_progress = 0.0\n\n        self.stats = {\n            \"total_steps\": 0,\n            \"successful_steps\": 0,\n            \"runtime_ms\": 0.0\n        }\n\n        #latest dynamic info from update() kwargs\n        self.postfix_dict = {}\n\n        #flag to indicate if close() has been called\n        self._closed = False\n\n\n    @staticmethod\n    def _has_configured_handler(logger):\n        \"\"\"Checks if the logger or any of its ancestors have configured\n        handlers. Helps prevent adding duplicate default handlers.\n\n        Parameters\n        ----------\n        logger : logging.Logger\n            the logger instance to check.\n\n        Returns\n        -------\n        bool\n            True if a configured handler is found, False otherwise.\n        \"\"\"\n        l = logger\n        while l:\n\n            #check if any handler seems configured (e.g., has a formatter)\n            if l.handlers:\n                if any(h.formatter is not None for h in l.handlers):\n                    return True\n\n            #stop if propagation is disabled\n            if not l.propagate:\n                break\n\n            else:\n                #check parent logger\n                l = l.parent\n\n        return False\n\n\n    # properties -----------------------------------------------------------------------\n\n    @property\n    def current_progress(self):\n        \"\"\"float: The current progress fraction (0.0 to 1.0).\"\"\"\n        return self._current_progress\n\n\n    @current_progress.setter\n    def current_progress(self, value):\n        \"\"\"Sets and clamps the current progress between 0.0 and 1.0.\"\"\"\n        self._current_progress = max(0.0, min(1.0, float(value)))\n\n\n    # context manager protocol ---------------------------------------------------------\n\n    def __enter__(self):\n        \"\"\"Starts the tracker when entering a 'with' block.\n\n        Returns\n        -------\n        iterator\n            The tracker's iterator object (`self.__iter__()`).\n        \"\"\"\n        self.start()\n        return self.__iter__()\n\n\n    def __exit__(self, exc_type, exc_value, traceback):\n        \"\"\"Closes the tracker when exiting a 'with' block, ensuring final log.\n\n        Parameters\n        ----------\n        exc_type : type or None\n            The type of exception raised (if any).\n        exc_value : Exception or None\n            The exception instance raised (if any).\n        traceback : traceback or None\n            The traceback object (if any).\n\n        Returns\n        -------\n        bool\n            False to indicate exceptions (if any) should be propagated.\n        \"\"\"\n        self.close()\n        return False\n\n\n    # iterator protocol ----------------------------------------------------------------\n\n    def __iter__(self):\n        \"\"\"Iterator protocol allowing use in 'for' loops. Yields control\n         until `self.current_progress` reaches 1.0.\n\n        Yields\n        ------\n        ProgressTracker\n            Yields self to allow calling update() within the loop.\n        \"\"\"\n        if self.start_time is None:\n            warnings.warn(\"Tracker iterator started before entering 'with' block or calling start().\")\n            self.start() # Attempt to start if not already\n\n        # Loop continues as long as progress is less than 100%\n        while self.current_progress < 1.0:\n            yield self # Yield control back to the calling loop\n\n\n    # core methods ---------------------------------------------------------------------\n\n    def start(self):\n        \"\"\"Starts the progress timer and logs the initial message.\"\"\"\n\n        self.start_time = time.perf_counter()\n\n        #last log time and step count reset\n        self.last_log_time = self.start_time\n        self.last_log_total_steps = 0 # Reset step count for rate calculation\n        self.stats[\"total_steps\"] = 0 # Ensure stats also start fresh if restart occurs\n        self.stats[\"successful_steps\"] = 0\n\n        if self.log:\n            self.logger.log(\n                self.log_level,\n                f\"STARTING -> {self.description} (Duration: {self.total_duration:.2f}s)\"\n                )\n\n        #log initial 0% state\n        self._log_progress()\n\n\n    def update(self, progress, success=True, **kwargs):\n        \"\"\"Updates the tracker's progress and optional postfix info,\n        logging if necessary. Should be called within the loop iterating\n        over the tracker.\n\n        Parameters\n        ----------\n        progress : float\n            Current progress fraction (0.0 to 1.0).\n        success : bool, optional\n            Indicates if the step contributing to this progress was successful.\n            Defaults to True.\n        **kwargs : dict, optional\n            Key-value pairs to display as postfix information (e.g., dt=0.01).\n            These overwrite previous postfix values each time update is called.\n        \"\"\"\n\n        if self._closed:\n            warnings.warn(\"ProgressTracker updated after being closed.\")\n            return\n\n        if self.start_time is None:\n            # This shouldn't happen if used correctly with 'with' and 'for'\n            warnings.warn(\"ProgressTracker updated before start() or outside 'with' block.\")\n            self.start()\n\n        #update stats first\n        self.stats[\"total_steps\"] += 1\n        if success:\n            self.stats[\"successful_steps\"] += 1\n\n        #update postfix dict\n        self.postfix_dict = kwargs\n\n        #set current progress\n        self.current_progress = progress\n\n        #trigger logging check\n        self._log_progress()\n\n\n    def close(self):\n        \"\"\"Logs the final status, calculates final runtime, and marks tracker as closed.\n        \"\"\"\n\n        if not self._closed:\n\n            if self.start_time is not None:\n\n                #calculate final runtime\n                runtime = time.perf_counter() - self.start_time\n                self.stats[\"runtime_ms\"] = runtime * 1000\n\n                #ensure final progress is logged at 100%\n                self.current_progress = 1.0\n                self._log_progress(is_final=True) \n\n                #log summary statistics\n                if self.logger and self.log:\n                    final_stats_str = (\n                        f\"total steps: {self.stats['total_steps']}, \"\n                        f\"successful: {self.stats['successful_steps']}, \"\n                        f\"runtime: {self.stats['runtime_ms']:.2f} ms\"\n                        )\n                    self.logger.log(self.log_level, f\"FINISHED -> {self.description} ({final_stats_str})\")\n\n            self._closed = True\n\n\n    # helper methods -------------------------------------------------------------------\n\n    def _format_time(self, seconds):\n        \"\"\"Formats a duration in seconds into HH:MM:SS string format.\n\n        Parameters\n        ----------\n        seconds : float or None\n            the duration in seconds\n\n        Returns\n        -------\n        str\n            Formatted time string (e.g., \"00:01:35\") or \"--:--:--\" if input is invalid.\n        \"\"\"\n\n        #handle invalid inputs\n        if seconds is None or math.isinf(seconds) or math.isnan(seconds) or seconds < 0:\n            return \"--:--:--\"\n\n        #conversion\n        m, s = divmod(seconds, 60)\n        h, m = divmod(m, 60)\n        return f\"{int(h):02d}:{int(m):02d}:{int(s):02d}\"\n\n\n    def _log_progress(self, is_final=False):\n        \"\"\"Internal method to format and log the current progress status if\n        throttling conditions (time interval or progress milestone) are met,\n        or if it's the final call. Calculates rate based on interval since last log.\n        \"\"\"\n\n        #don't log if closed unless final\n        if self._closed and not is_final: return\n\n        #don't log if not started\n        if self.start_time is None: return\n\n        #don't log if no logger\n        if not self.logger: return\n\n        #don't log if logging not wanted\n        if not self.log: return                \n\n        current_time = time.perf_counter()\n\n        #logging needed?\n        progress_milestone_reached = (self.current_progress >= self.last_log_progress_milestone + self.update_log_every)\n        time_interval_reached = (current_time - self.last_log_time >= self.min_log_interval)\n\n        #first log after start()\n        is_initial_log = (self.current_progress == 0 and self.last_log_progress_milestone < 0) \n\n        #log if final, or milestone reached, or time interval reached, or initial 0% log\n        should_log = is_final or progress_milestone_reached or time_interval_reached or is_initial_log\n\n        if should_log:\n\n            elapsed_time = current_time - self.start_time\n            percentage = self.current_progress * 100\n\n            #calculate interval rate\n            time_since_last_log = current_time - self.last_log_time\n            steps_since_last_log = self.stats[\"total_steps\"] - self.last_log_total_steps\n\n            rate = 0.0\n            rate_label = \"steps/s\"\n\n            if is_initial_log:\n\n                # For the very first log, interval rate is meaningless, show N/A or 0\n                rate_str = \"N/A steps/s\"\n\n            elif is_final:\n\n                #for the final log -> overall average rate\n                if elapsed_time > 1e-6 and self.stats[\"total_steps\"] > 0:\n                    rate = self.stats[\"total_steps\"] / elapsed_time\n                    rate_str = f\"{rate:.1f} avg steps/s\"\n\n            else:\n                #for intermediate logs, calculate interval rate\n                if time_since_last_log > 1e-6 and steps_since_last_log > 0:\n                    rate = steps_since_last_log / time_since_last_log\n                    rate_str = f\"{rate:.1f} {rate_label}\"\n\n                elif steps_since_last_log == 0 and time_since_last_log > 1e-6:\n                    #0 rate if time passed but no steps\n                    rate_str = f\"0.0 {rate_label}\"\n\n                else:\n                    #avoid division by zero or near-zero if log triggered rapidly\n                    rate_str = \"calc steps/s...\" \n\n            #calculate ETA (based on percentage/time) - unchanged\n            eta_seconds = None\n            if self.current_progress > 1e-6 and elapsed_time > 0.1:\n                eta_seconds = elapsed_time * (1.0 - self.current_progress) / self.current_progress\n\n            eta_str = self._format_time(eta_seconds)\n            elapsed_str = self._format_time(elapsed_time)\n\n            #postfix\n            postfix_str = \", \".join([f\"{k}={v}\" for k, v in self.postfix_dict.items() if v is not None])\n            if postfix_str:\n                postfix_str = \" [\" + postfix_str + \"]\"\n\n            #assemble log message\n            _msg = (\n                f\"{self.description}: {percentage:3.0f}% | \"\n                f\"elapsed: {elapsed_str} (eta: {eta_str}) | \"\n                f\"{self.stats['total_steps']} steps ({rate_str})\"\n                f\"{postfix_str}\"\n                )\n\n            self.logger.log(self.log_level, _msg)\n\n            #update logging state\n            self.last_log_time = current_time\n\n            #update step count snapshot\n            self.last_log_total_steps = self.stats[\"total_steps\"]\n\n            #update progress milestone marker if it was reached\n            if progress_milestone_reached and not is_final:\n\n                #ensure milestone advances correctly even if progress jumps multiple thresholds\n                self.last_log_progress_milestone = math.floor(self.current_progress / self.update_log_every) * self.update_log_every\n\n            elif is_initial_log:\n                #mark 0% as logged if it was the trigger\n                self.last_log_progress_milestone = 0.0",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(\n    self,\n    total_duration,\n    description=\"\",\n    logger=None,\n    log=True,\n    log_level=logging.INFO,\n    min_log_interval=LOG_MIN_INTERVAL,\n    update_log_every=LOG_UPDATE_EVERY\n    ):\n\n    #input validation\n    if total_duration <= 0:\n        raise ValueError(\"total_duration must be positive\")\n    if not (0 < update_log_every <= 1):\n        raise ValueError(\"update_log_every must be between 0 (exclusive) and 1 (inclusive)\")\n    if min_log_interval < 0:\n        raise ValueError(\"min_log_interval cannot be negative\")\n\n    self.total_duration = float(total_duration)\n    self.description = description if description else \"Progress\"\n    self.log_level = log_level\n    self.min_log_interval = min_log_interval\n    self.update_log_every = update_log_every\n    self.log = log\n\n    #setup logger\n    self.logger = logger or logging.getLogger(f\"ProgressTracker_{self.description[:10]}\")\n\n    #ensure logger has a handler if none exists to enable output\n    if not self.logger.hasHandlers() and not self._has_configured_handler(self.logger):\n\n        #configure logger only if it hasn't been configured elsewhere\n        handler = logging.StreamHandler(sys.stdout)\n        formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s', datefmt='%H:%M:%S')\n        handler.setFormatter(formatter)\n        self.logger.addHandler(handler)\n        self.logger.setLevel(logging.INFO)\n        self.logger.propagate = False\n\n    #time tracking starts\n    self.start_time = None\n\n    #time of the last log message\n    self.last_log_time = 0\n\n    #store step count at last log for interval rate calculation\n    self.last_log_total_steps = 0\n\n    #progress milestone for percentage-based logging trigger\n    #initialized below zero to ensure the first log (0%) happens\n    self.last_log_progress_milestone = -self.update_log_every\n\n    #internal progress state (0.0 to 1.0)\n    self._current_progress = 0.0\n\n    self.stats = {\n        \"total_steps\": 0,\n        \"successful_steps\": 0,\n        \"runtime_ms\": 0.0\n    }\n\n    #latest dynamic info from update() kwargs\n    self.postfix_dict = {}\n\n    #flag to indicate if close() has been called\n    self._closed = False",
              "signature": "(total_duration, description = '', logger = None, log = True, log_level = logging.INFO, min_log_interval = LOG_MIN_INTERVAL, update_log_every = LOG_UPDATE_EVERY)",
              "parameters": [
                {
                  "name": "total_duration",
                  "type": null,
                  "default": null,
                  "description": ""
                },
                {
                  "name": "description",
                  "type": null,
                  "default": "''",
                  "description": ""
                },
                {
                  "name": "logger",
                  "type": null,
                  "default": "None",
                  "description": ""
                },
                {
                  "name": "log",
                  "type": null,
                  "default": "True",
                  "description": ""
                },
                {
                  "name": "log_level",
                  "type": null,
                  "default": "logging.INFO",
                  "description": ""
                },
                {
                  "name": "min_log_interval",
                  "type": null,
                  "default": "LOG_MIN_INTERVAL",
                  "description": ""
                },
                {
                  "name": "update_log_every",
                  "type": null,
                  "default": "LOG_UPDATE_EVERY",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "_has_configured_handler",
              "description": "Checks if the logger or any of its ancestors have configured",
              "docstring_html": "<p>Checks if the logger or any of its ancestors have configured\nhandlers. Helps prevent adding duplicate default handlers.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>logger <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">logging.Logger</span></dt>\n<dd>the logger instance to check.</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>bool</dt>\n<dd>True if a configured handler is found, False otherwise.</dd>\n</dl>\n",
              "source": "@staticmethod\ndef _has_configured_handler(logger):\n    \"\"\"Checks if the logger or any of its ancestors have configured\n    handlers. Helps prevent adding duplicate default handlers.\n\n    Parameters\n    ----------\n    logger : logging.Logger\n        the logger instance to check.\n\n    Returns\n    -------\n    bool\n        True if a configured handler is found, False otherwise.\n    \"\"\"\n    l = logger\n    while l:\n\n        #check if any handler seems configured (e.g., has a formatter)\n        if l.handlers:\n            if any(h.formatter is not None for h in l.handlers):\n                return True\n\n        #stop if propagation is disabled\n        if not l.propagate:\n            break\n\n        else:\n            #check parent logger\n            l = l.parent\n\n    return False",
              "signature": "(logger)",
              "parameters": [
                {
                  "name": "logger",
                  "type": null,
                  "default": null,
                  "description": "the logger instance to check."
                }
              ],
              "returns": null,
              "method_type": "staticmethod"
            },
            {
              "name": "start",
              "description": "Starts the progress timer and logs the initial message.",
              "docstring_html": "<p>Starts the progress timer and logs the initial message.</p>\n",
              "source": "def start(self):\n    \"\"\"Starts the progress timer and logs the initial message.\"\"\"\n\n    self.start_time = time.perf_counter()\n\n    #last log time and step count reset\n    self.last_log_time = self.start_time\n    self.last_log_total_steps = 0 # Reset step count for rate calculation\n    self.stats[\"total_steps\"] = 0 # Ensure stats also start fresh if restart occurs\n    self.stats[\"successful_steps\"] = 0\n\n    if self.log:\n        self.logger.log(\n            self.log_level,\n            f\"STARTING -> {self.description} (Duration: {self.total_duration:.2f}s)\"\n            )\n\n    #log initial 0% state\n    self._log_progress()",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "update",
              "description": "Updates the tracker's progress and optional postfix info,",
              "docstring_html": "<p>Updates the tracker's progress and optional postfix info,\nlogging if necessary. Should be called within the loop iterating\nover the tracker.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>progress <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>Current progress fraction (0.0 to 1.0).</dd>\n<dt>success <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool, optional</span></dt>\n<dd>Indicates if the step contributing to this progress was successful.\nDefaults to True.</dd>\n<dt>**kwargs <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">dict, optional</span></dt>\n<dd>Key-value pairs to display as postfix information (e.g., dt=0.01).\nThese overwrite previous postfix values each time update is called.</dd>\n</dl>\n",
              "source": "def update(self, progress, success=True, **kwargs):\n    \"\"\"Updates the tracker's progress and optional postfix info,\n    logging if necessary. Should be called within the loop iterating\n    over the tracker.\n\n    Parameters\n    ----------\n    progress : float\n        Current progress fraction (0.0 to 1.0).\n    success : bool, optional\n        Indicates if the step contributing to this progress was successful.\n        Defaults to True.\n    **kwargs : dict, optional\n        Key-value pairs to display as postfix information (e.g., dt=0.01).\n        These overwrite previous postfix values each time update is called.\n    \"\"\"\n\n    if self._closed:\n        warnings.warn(\"ProgressTracker updated after being closed.\")\n        return\n\n    if self.start_time is None:\n        # This shouldn't happen if used correctly with 'with' and 'for'\n        warnings.warn(\"ProgressTracker updated before start() or outside 'with' block.\")\n        self.start()\n\n    #update stats first\n    self.stats[\"total_steps\"] += 1\n    if success:\n        self.stats[\"successful_steps\"] += 1\n\n    #update postfix dict\n    self.postfix_dict = kwargs\n\n    #set current progress\n    self.current_progress = progress\n\n    #trigger logging check\n    self._log_progress()",
              "signature": "(progress, success = True, kwargs = {})",
              "parameters": [
                {
                  "name": "progress",
                  "type": null,
                  "default": null,
                  "description": "Current progress fraction (0.0 to 1.0)."
                },
                {
                  "name": "success",
                  "type": null,
                  "default": "True",
                  "description": "Indicates if the step contributing to this progress was successful. Defaults to True. **kwargs : dict, optional Key-value pairs to display as postfix information (e.g., dt=0.01). These overwrite previous postfix values each time update is called."
                },
                {
                  "name": "kwargs",
                  "type": null,
                  "default": "{}",
                  "description": "Key-value pairs to display as postfix information (e.g., dt=0.01). These overwrite previous postfix values each time update is called."
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "close",
              "description": "Logs the final status, calculates final runtime, and marks tracker as closed.",
              "docstring_html": "<p>Logs the final status, calculates final runtime, and marks tracker as closed.</p>\n",
              "source": "def close(self):\n    \"\"\"Logs the final status, calculates final runtime, and marks tracker as closed.\n    \"\"\"\n\n    if not self._closed:\n\n        if self.start_time is not None:\n\n            #calculate final runtime\n            runtime = time.perf_counter() - self.start_time\n            self.stats[\"runtime_ms\"] = runtime * 1000\n\n            #ensure final progress is logged at 100%\n            self.current_progress = 1.0\n            self._log_progress(is_final=True) \n\n            #log summary statistics\n            if self.logger and self.log:\n                final_stats_str = (\n                    f\"total steps: {self.stats['total_steps']}, \"\n                    f\"successful: {self.stats['successful_steps']}, \"\n                    f\"runtime: {self.stats['runtime_ms']:.2f} ms\"\n                    )\n                self.logger.log(self.log_level, f\"FINISHED -> {self.description} ({final_stats_str})\")\n\n        self._closed = True",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "_format_time",
              "description": "Formats a duration in seconds into HH:MM:SS string format.",
              "docstring_html": "<p>Formats a duration in seconds into HH:MM:SS string format.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>seconds <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float or None</span></dt>\n<dd>the duration in seconds</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>str</dt>\n<dd>Formatted time string (e.g., &quot;00:01:35&quot;) or &quot;--:--:--&quot; if input is invalid.</dd>\n</dl>\n",
              "source": "def _format_time(self, seconds):\n    \"\"\"Formats a duration in seconds into HH:MM:SS string format.\n\n    Parameters\n    ----------\n    seconds : float or None\n        the duration in seconds\n\n    Returns\n    -------\n    str\n        Formatted time string (e.g., \"00:01:35\") or \"--:--:--\" if input is invalid.\n    \"\"\"\n\n    #handle invalid inputs\n    if seconds is None or math.isinf(seconds) or math.isnan(seconds) or seconds < 0:\n        return \"--:--:--\"\n\n    #conversion\n    m, s = divmod(seconds, 60)\n    h, m = divmod(m, 60)\n    return f\"{int(h):02d}:{int(m):02d}:{int(s):02d}\"",
              "signature": "(seconds)",
              "parameters": [
                {
                  "name": "seconds",
                  "type": null,
                  "default": null,
                  "description": "the duration in seconds"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "_log_progress",
              "description": "Internal method to format and log the current progress status if",
              "docstring_html": "<p>Internal method to format and log the current progress status if\nthrottling conditions (time interval or progress milestone) are met,\nor if it's the final call. Calculates rate based on interval since last log.</p>\n",
              "source": "def _log_progress(self, is_final=False):\n    \"\"\"Internal method to format and log the current progress status if\n    throttling conditions (time interval or progress milestone) are met,\n    or if it's the final call. Calculates rate based on interval since last log.\n    \"\"\"\n\n    #don't log if closed unless final\n    if self._closed and not is_final: return\n\n    #don't log if not started\n    if self.start_time is None: return\n\n    #don't log if no logger\n    if not self.logger: return\n\n    #don't log if logging not wanted\n    if not self.log: return                \n\n    current_time = time.perf_counter()\n\n    #logging needed?\n    progress_milestone_reached = (self.current_progress >= self.last_log_progress_milestone + self.update_log_every)\n    time_interval_reached = (current_time - self.last_log_time >= self.min_log_interval)\n\n    #first log after start()\n    is_initial_log = (self.current_progress == 0 and self.last_log_progress_milestone < 0) \n\n    #log if final, or milestone reached, or time interval reached, or initial 0% log\n    should_log = is_final or progress_milestone_reached or time_interval_reached or is_initial_log\n\n    if should_log:\n\n        elapsed_time = current_time - self.start_time\n        percentage = self.current_progress * 100\n\n        #calculate interval rate\n        time_since_last_log = current_time - self.last_log_time\n        steps_since_last_log = self.stats[\"total_steps\"] - self.last_log_total_steps\n\n        rate = 0.0\n        rate_label = \"steps/s\"\n\n        if is_initial_log:\n\n            # For the very first log, interval rate is meaningless, show N/A or 0\n            rate_str = \"N/A steps/s\"\n\n        elif is_final:\n\n            #for the final log -> overall average rate\n            if elapsed_time > 1e-6 and self.stats[\"total_steps\"] > 0:\n                rate = self.stats[\"total_steps\"] / elapsed_time\n                rate_str = f\"{rate:.1f} avg steps/s\"\n\n        else:\n            #for intermediate logs, calculate interval rate\n            if time_since_last_log > 1e-6 and steps_since_last_log > 0:\n                rate = steps_since_last_log / time_since_last_log\n                rate_str = f\"{rate:.1f} {rate_label}\"\n\n            elif steps_since_last_log == 0 and time_since_last_log > 1e-6:\n                #0 rate if time passed but no steps\n                rate_str = f\"0.0 {rate_label}\"\n\n            else:\n                #avoid division by zero or near-zero if log triggered rapidly\n                rate_str = \"calc steps/s...\" \n\n        #calculate ETA (based on percentage/time) - unchanged\n        eta_seconds = None\n        if self.current_progress > 1e-6 and elapsed_time > 0.1:\n            eta_seconds = elapsed_time * (1.0 - self.current_progress) / self.current_progress\n\n        eta_str = self._format_time(eta_seconds)\n        elapsed_str = self._format_time(elapsed_time)\n\n        #postfix\n        postfix_str = \", \".join([f\"{k}={v}\" for k, v in self.postfix_dict.items() if v is not None])\n        if postfix_str:\n            postfix_str = \" [\" + postfix_str + \"]\"\n\n        #assemble log message\n        _msg = (\n            f\"{self.description}: {percentage:3.0f}% | \"\n            f\"elapsed: {elapsed_str} (eta: {eta_str}) | \"\n            f\"{self.stats['total_steps']} steps ({rate_str})\"\n            f\"{postfix_str}\"\n            )\n\n        self.logger.log(self.log_level, _msg)\n\n        #update logging state\n        self.last_log_time = current_time\n\n        #update step count snapshot\n        self.last_log_total_steps = self.stats[\"total_steps\"]\n\n        #update progress milestone marker if it was reached\n        if progress_milestone_reached and not is_final:\n\n            #ensure milestone advances correctly even if progress jumps multiple thresholds\n            self.last_log_progress_milestone = math.floor(self.current_progress / self.update_log_every) * self.update_log_every\n\n        elif is_initial_log:\n            #mark 0% as logged if it was the trigger\n            self.last_log_progress_milestone = 0.0",
              "signature": "(is_final = False)",
              "parameters": [
                {
                  "name": "is_final",
                  "type": null,
                  "default": "False",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "total_duration",
              "description": "",
              "type": null,
              "value": "float(total_duration)"
            },
            {
              "name": "description",
              "description": "",
              "type": null,
              "value": "description if description else 'Progress'"
            },
            {
              "name": "log_level",
              "description": "",
              "type": null,
              "value": "log_level"
            },
            {
              "name": "min_log_interval",
              "description": "",
              "type": null,
              "value": "min_log_interval"
            },
            {
              "name": "update_log_every",
              "description": "",
              "type": null,
              "value": "update_log_every"
            },
            {
              "name": "log",
              "description": "",
              "type": null,
              "value": "log"
            },
            {
              "name": "logger",
              "description": "",
              "type": null,
              "value": "logger or logging.getLogger(f'ProgressTracker_{self.description[:10]}')"
            },
            {
              "name": "start_time",
              "description": "",
              "type": null,
              "value": "None"
            },
            {
              "name": "last_log_time",
              "description": "",
              "type": null,
              "value": "0"
            },
            {
              "name": "last_log_total_steps",
              "description": "",
              "type": null,
              "value": "0"
            },
            {
              "name": "last_log_progress_milestone",
              "description": "",
              "type": null,
              "value": "-self.update_log_every"
            },
            {
              "name": "_current_progress",
              "description": "",
              "type": null,
              "value": "0.0"
            },
            {
              "name": "stats",
              "description": "",
              "type": null,
              "value": "{'total_steps': 0, 'successful_steps': 0, 'runtime_ms': 0.0}"
            },
            {
              "name": "postfix_dict",
              "description": "",
              "type": null,
              "value": "{}"
            },
            {
              "name": "_closed",
              "description": "",
              "type": null,
              "value": "False"
            },
            {
              "name": "current_progress",
              "description": "float: The current progress fraction (0.0 to 1.0).",
              "type": null,
              "value": null
            }
          ],
          "parameters": [
            {
              "name": "total_duration",
              "type": null,
              "default": null,
              "description": "The total simulation duration (e.g., in seconds) to track against. Must be positive."
            },
            {
              "name": "description",
              "type": null,
              "default": "''",
              "description": "A short description or name for the process being tracked, used in log messages. Defaults to \"Progress\"."
            },
            {
              "name": "logger",
              "type": null,
              "default": "None",
              "description": "The logger instance to use for outputting progress messages. If None, a default logger named 'ProgressTracker_<description>' is created and configured to print INFO level messages to stdout."
            },
            {
              "name": "log",
              "type": null,
              "default": "True",
              "description": "Flag to indicate if logging messages should be printed or not."
            },
            {
              "name": "log_level",
              "type": null,
              "default": "logging.INFO",
              "description": "The logging level (e.g., `logging.INFO`, `logging.DEBUG`) to use for progress messages. Defaults to `logging.INFO`."
            },
            {
              "name": "min_log_interval",
              "type": null,
              "default": "LOG_MIN_INTERVAL",
              "description": "The minimum real time interval in seconds that must pass between consecutive log updates, regardless of progress change. Helps to throttle output. Default from '_constants.py'."
            },
            {
              "name": "update_log_every",
              "type": null,
              "default": "LOG_UPDATE_EVERY",
              "description": "Log a message every time the progress increases by at least this fraction (e.g., 0.1 for 10%). Must be between 0 (exclusive) and 1 (inclusive). Default from '_constants.py'."
            }
          ]
        }
      ],
      "functions": []
    },
    "pathsim.utils.realtimeplotter": {
      "name": "pathsim.utils.realtimeplotter",
      "description": "",
      "docstring_html": "",
      "classes": [
        {
          "name": "RealtimePlotter",
          "description": "Class that manages a realtime plotting window that",
          "docstring_html": "<p>Class that manages a realtime plotting window that\ncan stream in x-y-data and update accordingly</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>max_samples <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>maximum number of samples to plot</dd>\n<dt>update_interval <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>time in seconds between refreshs</dd>\n<dt>labels <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">list[str]</span></dt>\n<dd>labels for plot traces</dd>\n<dt>x_label <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">str</span></dt>\n<dd>label for x-axis</dd>\n<dt>y_label <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">str</span></dt>\n<dd>label for y-axis</dd>\n</dl>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>fig <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">matplotlib.pyplot.figure</span></dt>\n<dd>internal figure of the realtime plotter</dd>\n<dt>ax <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">matplotlib.pyplot.axis</span></dt>\n<dd>internal axis of the realtime plotter</dd>\n</dl>\n",
          "source": "class RealtimePlotter:\n    \"\"\"Class that manages a realtime plotting window that \n    can stream in x-y-data and update accordingly\n\n    Parameters\n    ----------\n    max_samples : int\n        maximum number of samples to plot\n    update_interval : float\n        time in seconds between refreshs\n    labels : list[str]\n        labels for plot traces\n    x_label : str\n        label for x-axis\n    y_label : str\n        label for y-axis\n\n    Attributes\n    ----------\n    fig : matplotlib.pyplot.figure\n        internal figure of the realtime plotter\n    ax : matplotlib.pyplot.axis\n        internal axis of the realtime plotter\n    \"\"\"\n\n    def __init__(self, max_samples=None, update_interval=1, labels=[], x_label=\"\", y_label=\"\"):\n\n        #plotter settings\n        self.max_samples = max_samples\n        self.update_interval = update_interval\n        self.labels = labels\n        self.x_label = x_label\n        self.y_label = y_label\n\n        #figure initialization\n        self.fig, self.ax = plt.subplots(nrows=1, \n                                         ncols=1, \n                                         figsize=(8,4), \n                                         tight_layout=True, \n                                         dpi=120)\n\n        #custom colors\n        self.ax.set_prop_cycle(color=COLORS_ALL)\n\n        #plot settings\n        self.ax.set_xlabel(self.x_label)\n        self.ax.set_ylabel(self.y_label)\n        self.ax.grid(True)\n\n        #data and lines (traces) for plotting\n        self.lines = []\n        self.data = []\n\n        #tracking update time\n        self.last_update = time.time()\n\n        #flag for running mode\n        self.is_running = True\n\n        # Connect the close event to the on_close method\n        self.fig.canvas.mpl_connect(\"close_event\", self.on_close)\n\n        # Initialize legend\n        self.legend = None\n        self.lined = {}\n\n        #show the plotting window\n        self.show()\n\n\n    def update_all(self, x, y):\n        \"\"\"update the plot completely with new data\n\n        Parameters\n        ----------\n        x : array[float]\n            new x values to plot\n        y : array[float]\n            new y values to plot\n        \"\"\"\n\n        #not running? -> quit early\n        if not self.is_running:\n            return False\n\n        #no data yet? -> initialize lines\n        if not self.data:\n\n            #data initialization\n            for i, val in enumerate(y):\n                self.data.append({\"x\": [], \"y\": []})\n\n                #label selection and line (trace) initialization\n                label = self.labels[i] if i < len(self.labels) else f\"port {i}\"\n                line, = self.ax.plot([], [], lw=1.5, label=label)\n                self.lines.append(line)\n\n            # Create legend\n            self.legend = self.ax.legend(fancybox=False, ncols=int(np.ceil(len(y)/4)), loc=\"lower left\")\n            self._setup_legend_picking()\n\n        #check if new update of plot is required\n        current_time = time.time()\n        if current_time - self.last_update > self.update_interval:        \n\n            #replace the data\n            for i, val in enumerate(y):\n                self.data[i][\"x\"] = x\n                self.data[i][\"y\"] = val\n\n            self._update_plot()\n            self.last_update = current_time\n\n        return True\n\n\n    def update(self, x, y):\n        \"\"\"update the plot with new data\n\n        Parameters\n        ----------\n        x : float\n            new x value to add\n        y : float\n            new y value to add\n        \"\"\"\n\n        #not running? -> quit early\n        if not self.is_running:\n            return False\n\n        #no data yet? -> initialize lines\n        if not self.data:\n\n            #vectorial data -> multiple traces\n            if np.isscalar(y):\n\n                #size of data\n                n = 1\n\n                #check if rolling window plot\n                if self.max_samples is None:\n                    self.data.append({\"x\": [], \"y\": []})\n                else:\n                    self.data.append({\"x\": deque(maxlen=self.max_samples), \n                                      \"y\": deque(maxlen=self.max_samples)})\n\n                #label selection and line (trace) initialization\n                label = self.labels[0] if self.labels else \"port 0\"\n                line, = self.ax.plot([], [], lw=1.5, label=label)\n                self.lines.append(line)\n\n            else:\n\n                #size of data\n                n = len(y)\n\n                for i in range(n):\n\n                    #check if rolling window plot\n                    if self.max_samples is None:\n                        self.data.append({\"x\": [], \"y\": []})\n                    else:\n                        self.data.append({\"x\": deque(maxlen=self.max_samples), \n                                          \"y\": deque(maxlen=self.max_samples)})\n\n                    #label selection and line (trace) initialization\n                    label = self.labels[i] if i < len(self.labels) else f\"port {i}\"\n                    line, = self.ax.plot([], [], lw=1.5, label=label)\n                    self.lines.append(line)\n\n            # Create legend\n            self.legend = self.ax.legend(fancybox=False, ncols=int(np.ceil(n/4)), loc=\"lower left\")\n            self._setup_legend_picking()\n\n        #add the data\n        if np.isscalar(y):\n            self.data[0][\"x\"].append(x)\n            self.data[0][\"y\"].append(y)\n        else:\n            for i, val in enumerate(y):\n                self.data[i][\"x\"].append(x)\n                self.data[i][\"y\"].append(val)\n\n        #check if new update of plot is required\n        current_time = time.time()\n        if current_time - self.last_update > self.update_interval:\n            self._update_plot()\n            self.last_update = current_time\n\n        return True\n\n\n    def _update_plot(self):\n\n        #set the data to the lines (traces) of the plot\n        for i, line in enumerate(self.lines):\n            line.set_data(self.data[i][\"x\"], self.data[i][\"y\"])\n\n        #rescale the window\n        self.ax.relim()\n        self.ax.autoscale_view()\n\n        #redraw the figure\n        self.fig.canvas.draw()\n        self.fig.canvas.flush_events()\n\n\n    def show(self):\n        plt.show(block=False)\n\n\n    def on_close(self, event):\n        self.is_running = False\n\n\n    def _setup_legend_picking(self):\n\n        #setup the picking for the legend lines\n        for legline, origline in zip(self.legend.get_lines(), self.lines):\n            legline.set_picker(5)  # 5 points tolerance\n            self.lined[legline] = origline\n\n        def on_pick(event):\n            legline = event.artist\n            origline = self.lined[legline]\n            visible = not origline.get_visible()\n            origline.set_visible(visible)\n            legline.set_alpha(1.0 if visible else 0.2)\n            self.fig.canvas.draw()\n\n        self.fig.canvas.mpl_connect(\"pick_event\", on_pick)",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, max_samples=None, update_interval=1, labels=[], x_label=\"\", y_label=\"\"):\n\n    #plotter settings\n    self.max_samples = max_samples\n    self.update_interval = update_interval\n    self.labels = labels\n    self.x_label = x_label\n    self.y_label = y_label\n\n    #figure initialization\n    self.fig, self.ax = plt.subplots(nrows=1, \n                                     ncols=1, \n                                     figsize=(8,4), \n                                     tight_layout=True, \n                                     dpi=120)\n\n    #custom colors\n    self.ax.set_prop_cycle(color=COLORS_ALL)\n\n    #plot settings\n    self.ax.set_xlabel(self.x_label)\n    self.ax.set_ylabel(self.y_label)\n    self.ax.grid(True)\n\n    #data and lines (traces) for plotting\n    self.lines = []\n    self.data = []\n\n    #tracking update time\n    self.last_update = time.time()\n\n    #flag for running mode\n    self.is_running = True\n\n    # Connect the close event to the on_close method\n    self.fig.canvas.mpl_connect(\"close_event\", self.on_close)\n\n    # Initialize legend\n    self.legend = None\n    self.lined = {}\n\n    #show the plotting window\n    self.show()",
              "signature": "(max_samples = None, update_interval = 1, labels = [], x_label = '', y_label = '')",
              "parameters": [
                {
                  "name": "max_samples",
                  "type": null,
                  "default": "None",
                  "description": ""
                },
                {
                  "name": "update_interval",
                  "type": null,
                  "default": "1",
                  "description": ""
                },
                {
                  "name": "labels",
                  "type": null,
                  "default": "[]",
                  "description": ""
                },
                {
                  "name": "x_label",
                  "type": null,
                  "default": "''",
                  "description": ""
                },
                {
                  "name": "y_label",
                  "type": null,
                  "default": "''",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "update_all",
              "description": "update the plot completely with new data",
              "docstring_html": "<p>update the plot completely with new data</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>x <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array[float]</span></dt>\n<dd>new x values to plot</dd>\n<dt>y <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array[float]</span></dt>\n<dd>new y values to plot</dd>\n</dl>\n",
              "source": "def update_all(self, x, y):\n    \"\"\"update the plot completely with new data\n\n    Parameters\n    ----------\n    x : array[float]\n        new x values to plot\n    y : array[float]\n        new y values to plot\n    \"\"\"\n\n    #not running? -> quit early\n    if not self.is_running:\n        return False\n\n    #no data yet? -> initialize lines\n    if not self.data:\n\n        #data initialization\n        for i, val in enumerate(y):\n            self.data.append({\"x\": [], \"y\": []})\n\n            #label selection and line (trace) initialization\n            label = self.labels[i] if i < len(self.labels) else f\"port {i}\"\n            line, = self.ax.plot([], [], lw=1.5, label=label)\n            self.lines.append(line)\n\n        # Create legend\n        self.legend = self.ax.legend(fancybox=False, ncols=int(np.ceil(len(y)/4)), loc=\"lower left\")\n        self._setup_legend_picking()\n\n    #check if new update of plot is required\n    current_time = time.time()\n    if current_time - self.last_update > self.update_interval:        \n\n        #replace the data\n        for i, val in enumerate(y):\n            self.data[i][\"x\"] = x\n            self.data[i][\"y\"] = val\n\n        self._update_plot()\n        self.last_update = current_time\n\n    return True",
              "signature": "(x, y)",
              "parameters": [
                {
                  "name": "x",
                  "type": null,
                  "default": null,
                  "description": "new x values to plot"
                },
                {
                  "name": "y",
                  "type": null,
                  "default": null,
                  "description": "new y values to plot"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "update",
              "description": "update the plot with new data",
              "docstring_html": "<p>update the plot with new data</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>x <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>new x value to add</dd>\n<dt>y <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>new y value to add</dd>\n</dl>\n",
              "source": "def update(self, x, y):\n    \"\"\"update the plot with new data\n\n    Parameters\n    ----------\n    x : float\n        new x value to add\n    y : float\n        new y value to add\n    \"\"\"\n\n    #not running? -> quit early\n    if not self.is_running:\n        return False\n\n    #no data yet? -> initialize lines\n    if not self.data:\n\n        #vectorial data -> multiple traces\n        if np.isscalar(y):\n\n            #size of data\n            n = 1\n\n            #check if rolling window plot\n            if self.max_samples is None:\n                self.data.append({\"x\": [], \"y\": []})\n            else:\n                self.data.append({\"x\": deque(maxlen=self.max_samples), \n                                  \"y\": deque(maxlen=self.max_samples)})\n\n            #label selection and line (trace) initialization\n            label = self.labels[0] if self.labels else \"port 0\"\n            line, = self.ax.plot([], [], lw=1.5, label=label)\n            self.lines.append(line)\n\n        else:\n\n            #size of data\n            n = len(y)\n\n            for i in range(n):\n\n                #check if rolling window plot\n                if self.max_samples is None:\n                    self.data.append({\"x\": [], \"y\": []})\n                else:\n                    self.data.append({\"x\": deque(maxlen=self.max_samples), \n                                      \"y\": deque(maxlen=self.max_samples)})\n\n                #label selection and line (trace) initialization\n                label = self.labels[i] if i < len(self.labels) else f\"port {i}\"\n                line, = self.ax.plot([], [], lw=1.5, label=label)\n                self.lines.append(line)\n\n        # Create legend\n        self.legend = self.ax.legend(fancybox=False, ncols=int(np.ceil(n/4)), loc=\"lower left\")\n        self._setup_legend_picking()\n\n    #add the data\n    if np.isscalar(y):\n        self.data[0][\"x\"].append(x)\n        self.data[0][\"y\"].append(y)\n    else:\n        for i, val in enumerate(y):\n            self.data[i][\"x\"].append(x)\n            self.data[i][\"y\"].append(val)\n\n    #check if new update of plot is required\n    current_time = time.time()\n    if current_time - self.last_update > self.update_interval:\n        self._update_plot()\n        self.last_update = current_time\n\n    return True",
              "signature": "(x, y)",
              "parameters": [
                {
                  "name": "x",
                  "type": null,
                  "default": null,
                  "description": "new x value to add"
                },
                {
                  "name": "y",
                  "type": null,
                  "default": null,
                  "description": "new y value to add"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "_update_plot",
              "description": "",
              "docstring_html": "",
              "source": "def _update_plot(self):\n\n    #set the data to the lines (traces) of the plot\n    for i, line in enumerate(self.lines):\n        line.set_data(self.data[i][\"x\"], self.data[i][\"y\"])\n\n    #rescale the window\n    self.ax.relim()\n    self.ax.autoscale_view()\n\n    #redraw the figure\n    self.fig.canvas.draw()\n    self.fig.canvas.flush_events()",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "show",
              "description": "",
              "docstring_html": "",
              "source": "def show(self):\n    plt.show(block=False)",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "on_close",
              "description": "",
              "docstring_html": "",
              "source": "def on_close(self, event):\n    self.is_running = False",
              "signature": "(event)",
              "parameters": [
                {
                  "name": "event",
                  "type": null,
                  "default": null,
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "_setup_legend_picking",
              "description": "",
              "docstring_html": "",
              "source": "def _setup_legend_picking(self):\n\n    #setup the picking for the legend lines\n    for legline, origline in zip(self.legend.get_lines(), self.lines):\n        legline.set_picker(5)  # 5 points tolerance\n        self.lined[legline] = origline\n\n    def on_pick(event):\n        legline = event.artist\n        origline = self.lined[legline]\n        visible = not origline.get_visible()\n        origline.set_visible(visible)\n        legline.set_alpha(1.0 if visible else 0.2)\n        self.fig.canvas.draw()\n\n    self.fig.canvas.mpl_connect(\"pick_event\", on_pick)",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "max_samples",
              "description": "",
              "type": null,
              "value": "max_samples"
            },
            {
              "name": "update_interval",
              "description": "",
              "type": null,
              "value": "update_interval"
            },
            {
              "name": "labels",
              "description": "",
              "type": null,
              "value": "labels"
            },
            {
              "name": "x_label",
              "description": "",
              "type": null,
              "value": "x_label"
            },
            {
              "name": "y_label",
              "description": "",
              "type": null,
              "value": "y_label"
            },
            {
              "name": "lines",
              "description": "",
              "type": null,
              "value": "[]"
            },
            {
              "name": "data",
              "description": "",
              "type": null,
              "value": "[]"
            },
            {
              "name": "last_update",
              "description": "",
              "type": null,
              "value": "time.time()"
            },
            {
              "name": "is_running",
              "description": "",
              "type": null,
              "value": "True"
            },
            {
              "name": "legend",
              "description": "",
              "type": null,
              "value": "None"
            },
            {
              "name": "lined",
              "description": "",
              "type": null,
              "value": "{}"
            }
          ],
          "parameters": [
            {
              "name": "max_samples",
              "type": null,
              "default": "None",
              "description": "maximum number of samples to plot"
            },
            {
              "name": "update_interval",
              "type": null,
              "default": "1",
              "description": "time in seconds between refreshs"
            },
            {
              "name": "labels",
              "type": null,
              "default": "[]",
              "description": "labels for plot traces"
            },
            {
              "name": "x_label",
              "type": null,
              "default": "''",
              "description": "label for x-axis"
            },
            {
              "name": "y_label",
              "type": null,
              "default": "''",
              "description": "label for y-axis"
            }
          ]
        }
      ],
      "functions": []
    },
    "pathsim.utils.register": {
      "name": "pathsim.utils.register",
      "description": "",
      "docstring_html": "",
      "classes": [
        {
          "name": "Register",
          "description": "This class is a intended to be used for the inputs and outputs of blocks.",
          "docstring_html": "<p>This class is a intended to be used for the inputs and outputs of blocks.</p>\n<p>Its basic functionality is similar to a <cite>dict</cite> but with some additional methods.\nThe core functionality is that values can be added dynamically and the size of the\nregister doesnt have to be specified. It also implements some methods to interact\nwith numpy arrays and to streamline convergence checks.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>size <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int, optional</span></dt>\n<dd>initial size of the register</dd>\n</dl>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>_values <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">dict[int, float]</span></dt>\n<dd>internal dict that stores the values of the register</dd>\n<dt>_sorted_keys <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">list[int]</span></dt>\n<dd>internal sorted list of port keys for fast ordered iterations of <cite>_values</cite></dd>\n<dt>_mapping <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">dict[str: int]</span></dt>\n<dd>internal mapping for port aliases from string to int (index)</dd>\n</dl>\n",
          "source": "class Register:\n    \"\"\"This class is a intended to be used for the inputs and outputs of blocks. \n\n    Its basic functionality is similar to a `dict` but with some additional methods. \n    The core functionality is that values can be added dynamically and the size of the \n    register doesnt have to be specified. It also implements some methods to interact \n    with numpy arrays and to streamline convergence checks.\n\n    Parameters\n    ----------\n    size : int, optional\n        initial size of the register \n\n    Attributes\n    ----------\n    _values : dict[int, float]\n        internal dict that stores the values of the register\n    _sorted_keys : list[int]\n        internal sorted list of port keys for fast ordered iterations of `_values`\n    _mapping : dict[str: int]\n        internal mapping for port aliases from string to int (index)\n    \"\"\"\n\n    __slots__ = [\"_values\", \"_sorted_keys\", \"_mapping\"]\n\n\n    def __init__(self, size=1, mapping=None):\n        self._values = {k:0.0 for k in range(size)}\n        self._sorted_keys = list(range(size))\n        self._mapping = {} if mapping is None else mapping\n\n    def __len__(self):\n        \"\"\"Returns the number of register entries / ports.\"\"\"\n        return len(self._values)\n\n\n    def __iter__(self):\n        for k in self._sorted_keys:\n            yield self._values[k]\n\n\n    def _map(self, key):\n        \"\"\"Map string keys to integers defined in '_mapping'\n\n        Parameters\n        ----------\n        key : int, str\n            port key, to map to index\n\n        Returns\n        -------\n        _key : int\n            port index \n        \"\"\"\n        return self._mapping.get(key, key)\n\n\n    def reset(self):\n        \"\"\"Set all stored values of the register to zero.\"\"\"\n        for k in self._values.keys():\n            self._values[k] = 0.0\n\n\n    def clear(self):\n        \"\"\"Fully clear the register of all values to length is zero.\"\"\"\n        self._values.clear()\n        self._sorted_keys.clear()\n\n\n    def to_array(self):\n        \"\"\"Convert the register to a numpy array with entries \n        sorted by ports.\n\n        Note\n        ----\n        This method is performance critical, since it gets called **A LOT** \n        and makes up a siginificant portion of all function calls during the \n        main simulation loop! Its already profiled and optimized, so be \n        careful with premature *improvements*.\n\n        Returns\n        -------\n        arr : numpy.ndarray\n            converted register as array\n        \"\"\"\n        return np.array([self._values[k] for k in self._sorted_keys])\n\n\n    def update_from_array(self, arr):\n        \"\"\"Update the register values from an array in place.\n\n        Note\n        ----\n        This method is performance critical, since it gets called **A LOT** \n        and makes up a siginificant portion of all function calls during the \n        main simulation loop! Its already profiled and optimized, so be \n        careful with premature *improvements*.\n\n        Parameters\n        ----------\n        arr : numpy.ndarray, float\n            array or scalar that is used to update internal register values\n        \"\"\"\n        if np.isscalar(arr):\n            self._values[0] = arr\n            return\n\n        for k, a in enumerate(arr):\n            if k not in self._values:\n                insort(self._sorted_keys, k)\n            self._values[k] = a\n\n\n    def __contains__(self, key):\n        \"\"\"Check if a port key is in mapping or is integer \n\n        Parameters\n        ----------\n        key : int, str\n            port key to check\n\n        Returns\n        -------\n        in : bool\n            key exists in register\n        \"\"\"\n        return key in self._mapping or isinstance(key, int)\n\n\n    def __setitem__(self, key, val):\n        \"\"\"Set the value of `_values`, wraps its setter method. \n        For direct access to the register values.\n\n        Parameters\n        ----------\n        key : int, str\n            port key, where to set value\n        val : float, obj\n            value to set at port\n        \"\"\"\n        _key = self._map(key)\n        if _key not in self._values:\n            insort(self._sorted_keys, _key) \n        self._values[_key] = val\n\n\n    def __getitem__(self, key):\n        \"\"\"Get the value of `_values`, wraps its getter method.\n        For direct access to the register values.\n\n        Parameters\n        ----------\n        key : int, str\n            port key, where to get value from\n\n        Returns\n        -------\n        out : float, obj\n            value from port at `key` position\n        \"\"\"\n        _key = self._map(key)\n        return self._values.get(_key, 0.0)",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, size=1, mapping=None):\n    self._values = {k:0.0 for k in range(size)}\n    self._sorted_keys = list(range(size))\n    self._mapping = {} if mapping is None else mapping",
              "signature": "(size = 1, mapping = None)",
              "parameters": [
                {
                  "name": "size",
                  "type": null,
                  "default": "1",
                  "description": ""
                },
                {
                  "name": "mapping",
                  "type": null,
                  "default": "None",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "_map",
              "description": "Map string keys to integers defined in '_mapping'",
              "docstring_html": "<p>Map string keys to integers defined in '_mapping'</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>key <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int, str</span></dt>\n<dd>port key, to map to index</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>_key <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>port index</dd>\n</dl>\n",
              "source": "def _map(self, key):\n    \"\"\"Map string keys to integers defined in '_mapping'\n\n    Parameters\n    ----------\n    key : int, str\n        port key, to map to index\n\n    Returns\n    -------\n    _key : int\n        port index \n    \"\"\"\n    return self._mapping.get(key, key)",
              "signature": "(key)",
              "parameters": [
                {
                  "name": "key",
                  "type": null,
                  "default": null,
                  "description": "port key, to map to index"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "reset",
              "description": "Set all stored values of the register to zero.",
              "docstring_html": "<p>Set all stored values of the register to zero.</p>\n",
              "source": "def reset(self):\n    \"\"\"Set all stored values of the register to zero.\"\"\"\n    for k in self._values.keys():\n        self._values[k] = 0.0",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "clear",
              "description": "Fully clear the register of all values to length is zero.",
              "docstring_html": "<p>Fully clear the register of all values to length is zero.</p>\n",
              "source": "def clear(self):\n    \"\"\"Fully clear the register of all values to length is zero.\"\"\"\n    self._values.clear()\n    self._sorted_keys.clear()",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "to_array",
              "description": "Convert the register to a numpy array with entries",
              "docstring_html": "<p>Convert the register to a numpy array with entries\nsorted by ports.</p>\n<div class=\"section\" id=\"note\">\n<h4>Note</h4>\n<p>This method is performance critical, since it gets called <strong>A LOT</strong>\nand makes up a siginificant portion of all function calls during the\nmain simulation loop! Its already profiled and optimized, so be\ncareful with premature <em>improvements</em>.</p>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>arr <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">numpy.ndarray</span></dt>\n<dd>converted register as array</dd>\n</dl>\n</div>\n",
              "source": "def to_array(self):\n    \"\"\"Convert the register to a numpy array with entries \n    sorted by ports.\n\n    Note\n    ----\n    This method is performance critical, since it gets called **A LOT** \n    and makes up a siginificant portion of all function calls during the \n    main simulation loop! Its already profiled and optimized, so be \n    careful with premature *improvements*.\n\n    Returns\n    -------\n    arr : numpy.ndarray\n        converted register as array\n    \"\"\"\n    return np.array([self._values[k] for k in self._sorted_keys])",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "update_from_array",
              "description": "Update the register values from an array in place.",
              "docstring_html": "<p>Update the register values from an array in place.</p>\n<div class=\"section\" id=\"note\">\n<h4>Note</h4>\n<p>This method is performance critical, since it gets called <strong>A LOT</strong>\nand makes up a siginificant portion of all function calls during the\nmain simulation loop! Its already profiled and optimized, so be\ncareful with premature <em>improvements</em>.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>arr <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">numpy.ndarray, float</span></dt>\n<dd>array or scalar that is used to update internal register values</dd>\n</dl>\n</div>\n",
              "source": "def update_from_array(self, arr):\n    \"\"\"Update the register values from an array in place.\n\n    Note\n    ----\n    This method is performance critical, since it gets called **A LOT** \n    and makes up a siginificant portion of all function calls during the \n    main simulation loop! Its already profiled and optimized, so be \n    careful with premature *improvements*.\n\n    Parameters\n    ----------\n    arr : numpy.ndarray, float\n        array or scalar that is used to update internal register values\n    \"\"\"\n    if np.isscalar(arr):\n        self._values[0] = arr\n        return\n\n    for k, a in enumerate(arr):\n        if k not in self._values:\n            insort(self._sorted_keys, k)\n        self._values[k] = a",
              "signature": "(arr)",
              "parameters": [
                {
                  "name": "arr",
                  "type": null,
                  "default": null,
                  "description": "array or scalar that is used to update internal register values"
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "_values",
              "description": "",
              "type": null,
              "value": "{k: 0.0 for k in (range(size))}"
            },
            {
              "name": "_sorted_keys",
              "description": "",
              "type": null,
              "value": "list(range(size))"
            },
            {
              "name": "_mapping",
              "description": "",
              "type": null,
              "value": "{} if mapping is None else mapping"
            }
          ],
          "parameters": [
            {
              "name": "size",
              "type": null,
              "default": "1",
              "description": "initial size of the register"
            },
            {
              "name": "mapping",
              "type": null,
              "default": "None",
              "description": "internal mapping for port aliases from string to int (index)"
            }
          ]
        }
      ],
      "functions": []
    },
    "pathsim.utils.serialization": {
      "name": "pathsim.utils.serialization",
      "description": "",
      "docstring_html": "",
      "classes": [
        {
          "name": "Serializable",
          "description": "Mixin that provides automatic serialization based on __init__ parameters",
          "docstring_html": "<p>Mixin that provides automatic serialization based on __init__ parameters\nand loading/saving to json formatted readable files</p>\n",
          "source": "class Serializable:\n    \"\"\"Mixin that provides automatic serialization based on __init__ parameters \n    and loading/saving to json formatted readable files\n    \"\"\"\n\n\n    def __str__(self):\n        return json.dumps(self.to_dict(), indent=2, sort_keys=False)\n\n\n    def save(self, path=\"\", **metadata):\n        \"\"\"Save the dictionary representation of object to an external file\n\n        Parameters\n        ----------\n        path : str\n            filepath to save data to\n        metadata : dict\n            metadata for the object\n        \"\"\"\n        with open(path, \"w\", encoding=\"utf-8\") as file:\n            json.dump(self.to_dict(**metadata), file, indent=2, ensure_ascii=False)\n\n\n    @classmethod\n    def load(cls, path=\"\", **kwargs):\n        \"\"\"Load and instantiate an object from an external file in json format\n\n        Parameters\n        ----------\n        path : str\n            filepath to load data from\n        kwargs : dict\n            additional kwargs for object reconstruction\n\n        Returns\n        -------\n        out : obj\n            reconstructed object from dict representation\n        \"\"\"\n        with open(path, \"r\", encoding=\"utf-8\") as file:\n            return cls.from_dict(json.load(file), **kwargs)\n        return None\n\n\n    @classmethod\n    def from_dict(cls, data, **kwargs):\n        \"\"\"Create block instance from dictionary representation.\n\n        Parameters\n        ----------\n        data : dict\n            representation of object\n        kwargs : dict\n            additional kwargs for object reconstruction\n\n        Returns\n        -------\n        out : obj\n            reconstructed object from dict representation            \n        \"\"\"\n        # Use the class and module specified in the data\n        block_type = data.get(\"type\")\n        module_name = data.get(\"module\")\n\n        if module_name and block_type:\n\n            # Try direct import if module name is available\n            try:\n                module = importlib.import_module(module_name)\n                target_cls = getattr(module, block_type)\n            except (ImportError, AttributeError):\n                pass\n\n        else:\n\n            # Find the class in the module hierarchy, considering module name\n            target_cls = cls._find_class(block_type, module_name)\n\n        # We couldn't find the target class\n        if target_cls is None:\n            raise ValueError(f\"'{block_type}' cannot be found for deserialization!\")\n\n        # If this is already the target class\n        if target_cls == cls:\n\n            # Deserialize parameters\n            params = {}\n            for name, value in data[\"params\"].items():\n                params[name] = deserialize(value)\n\n            # Update optional kwargs\n            for name, value in kwargs.items():\n                params[name] = value\n\n            # Create the instance\n            return cls(**params)\n\n        else:\n            # Target class handle deserialization\n            return target_cls.from_dict(data)\n\n\n    def to_dict(self, **metadata):\n        \"\"\"Convert object to dictionary representation\"\"\"\n\n        # get parameter names from __init__ signature\n        signature = inspect.signature(self.__init__)\n        param_names = [p for p in signature.parameters if p != \"self\"]\n\n        # get current values of parameters\n        params = {}        \n        for name in param_names:\n\n            if hasattr(self, name):\n\n                value = getattr(self, name)\n\n                # handle callable parameters\n                if callable(value):\n                    params[name] = serialize_callable(value)\n                else:\n                    params[name] = serialize_object(value)\n\n        return {\n            \"id\"       : id(self),\n            \"type\"     : self.__class__.__name__,\n            \"module\"   : self.__class__.__module__,  \n            \"metadata\" : metadata,\n            \"params\"   : params\n        }\n\n\n    @classmethod\n    def _find_class(cls, class_name, module_name=None):\n        \"\"\"Find a class by name and optionally module name in the module hierarchy\"\"\"\n\n        # First check if this is the class we're looking for\n        if cls.__name__ == class_name:\n            # If module name is provided, verify it matches\n            if module_name is None or cls.__module__ == module_name:\n                return cls\n\n        # If not, check all subclasses recursively\n        for subclass in cls.__subclasses__():\n            if subclass.__name__ == class_name:\n                # If module name is provided, verify it matches\n                if module_name is None or subclass.__module__ == module_name:\n                    return subclass\n\n            # Recursively check subclasses of this subclass\n            found = subclass._find_class(class_name, module_name)\n            if found:\n                return found\n\n        return None",
          "bases": [],
          "methods": [
            {
              "name": "save",
              "description": "Save the dictionary representation of object to an external file",
              "docstring_html": "<p>Save the dictionary representation of object to an external file</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>path <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">str</span></dt>\n<dd>filepath to save data to</dd>\n<dt>metadata <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">dict</span></dt>\n<dd>metadata for the object</dd>\n</dl>\n",
              "source": "def save(self, path=\"\", **metadata):\n    \"\"\"Save the dictionary representation of object to an external file\n\n    Parameters\n    ----------\n    path : str\n        filepath to save data to\n    metadata : dict\n        metadata for the object\n    \"\"\"\n    with open(path, \"w\", encoding=\"utf-8\") as file:\n        json.dump(self.to_dict(**metadata), file, indent=2, ensure_ascii=False)",
              "signature": "(path = '', metadata = {})",
              "parameters": [
                {
                  "name": "path",
                  "type": null,
                  "default": "''",
                  "description": "filepath to save data to"
                },
                {
                  "name": "metadata",
                  "type": null,
                  "default": "{}",
                  "description": "metadata for the object"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "load",
              "description": "Load and instantiate an object from an external file in json format",
              "docstring_html": "<p>Load and instantiate an object from an external file in json format</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>path <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">str</span></dt>\n<dd>filepath to load data from</dd>\n<dt>kwargs <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">dict</span></dt>\n<dd>additional kwargs for object reconstruction</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>out <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">obj</span></dt>\n<dd>reconstructed object from dict representation</dd>\n</dl>\n",
              "source": "@classmethod\ndef load(cls, path=\"\", **kwargs):\n    \"\"\"Load and instantiate an object from an external file in json format\n\n    Parameters\n    ----------\n    path : str\n        filepath to load data from\n    kwargs : dict\n        additional kwargs for object reconstruction\n\n    Returns\n    -------\n    out : obj\n        reconstructed object from dict representation\n    \"\"\"\n    with open(path, \"r\", encoding=\"utf-8\") as file:\n        return cls.from_dict(json.load(file), **kwargs)\n    return None",
              "signature": "(cls, path = '', kwargs = {})",
              "parameters": [
                {
                  "name": "cls",
                  "type": null,
                  "default": null,
                  "description": ""
                },
                {
                  "name": "path",
                  "type": null,
                  "default": "''",
                  "description": "filepath to load data from"
                },
                {
                  "name": "kwargs",
                  "type": null,
                  "default": "{}",
                  "description": "additional kwargs for object reconstruction"
                }
              ],
              "returns": null,
              "method_type": "classmethod"
            },
            {
              "name": "from_dict",
              "description": "Create block instance from dictionary representation.",
              "docstring_html": "<p>Create block instance from dictionary representation.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>data <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">dict</span></dt>\n<dd>representation of object</dd>\n<dt>kwargs <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">dict</span></dt>\n<dd>additional kwargs for object reconstruction</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>out <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">obj</span></dt>\n<dd>reconstructed object from dict representation</dd>\n</dl>\n",
              "source": "@classmethod\ndef from_dict(cls, data, **kwargs):\n    \"\"\"Create block instance from dictionary representation.\n\n    Parameters\n    ----------\n    data : dict\n        representation of object\n    kwargs : dict\n        additional kwargs for object reconstruction\n\n    Returns\n    -------\n    out : obj\n        reconstructed object from dict representation            \n    \"\"\"\n    # Use the class and module specified in the data\n    block_type = data.get(\"type\")\n    module_name = data.get(\"module\")\n\n    if module_name and block_type:\n\n        # Try direct import if module name is available\n        try:\n            module = importlib.import_module(module_name)\n            target_cls = getattr(module, block_type)\n        except (ImportError, AttributeError):\n            pass\n\n    else:\n\n        # Find the class in the module hierarchy, considering module name\n        target_cls = cls._find_class(block_type, module_name)\n\n    # We couldn't find the target class\n    if target_cls is None:\n        raise ValueError(f\"'{block_type}' cannot be found for deserialization!\")\n\n    # If this is already the target class\n    if target_cls == cls:\n\n        # Deserialize parameters\n        params = {}\n        for name, value in data[\"params\"].items():\n            params[name] = deserialize(value)\n\n        # Update optional kwargs\n        for name, value in kwargs.items():\n            params[name] = value\n\n        # Create the instance\n        return cls(**params)\n\n    else:\n        # Target class handle deserialization\n        return target_cls.from_dict(data)",
              "signature": "(cls, data, kwargs = {})",
              "parameters": [
                {
                  "name": "cls",
                  "type": null,
                  "default": null,
                  "description": ""
                },
                {
                  "name": "data",
                  "type": null,
                  "default": null,
                  "description": "representation of object"
                },
                {
                  "name": "kwargs",
                  "type": null,
                  "default": "{}",
                  "description": "additional kwargs for object reconstruction"
                }
              ],
              "returns": null,
              "method_type": "classmethod"
            },
            {
              "name": "to_dict",
              "description": "Convert object to dictionary representation",
              "docstring_html": "<p>Convert object to dictionary representation</p>\n",
              "source": "def to_dict(self, **metadata):\n    \"\"\"Convert object to dictionary representation\"\"\"\n\n    # get parameter names from __init__ signature\n    signature = inspect.signature(self.__init__)\n    param_names = [p for p in signature.parameters if p != \"self\"]\n\n    # get current values of parameters\n    params = {}        \n    for name in param_names:\n\n        if hasattr(self, name):\n\n            value = getattr(self, name)\n\n            # handle callable parameters\n            if callable(value):\n                params[name] = serialize_callable(value)\n            else:\n                params[name] = serialize_object(value)\n\n    return {\n        \"id\"       : id(self),\n        \"type\"     : self.__class__.__name__,\n        \"module\"   : self.__class__.__module__,  \n        \"metadata\" : metadata,\n        \"params\"   : params\n    }",
              "signature": "(metadata = {})",
              "parameters": [
                {
                  "name": "metadata",
                  "type": null,
                  "default": "{}",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "_find_class",
              "description": "Find a class by name and optionally module name in the module hierarchy",
              "docstring_html": "<p>Find a class by name and optionally module name in the module hierarchy</p>\n",
              "source": "@classmethod\ndef _find_class(cls, class_name, module_name=None):\n    \"\"\"Find a class by name and optionally module name in the module hierarchy\"\"\"\n\n    # First check if this is the class we're looking for\n    if cls.__name__ == class_name:\n        # If module name is provided, verify it matches\n        if module_name is None or cls.__module__ == module_name:\n            return cls\n\n    # If not, check all subclasses recursively\n    for subclass in cls.__subclasses__():\n        if subclass.__name__ == class_name:\n            # If module name is provided, verify it matches\n            if module_name is None or subclass.__module__ == module_name:\n                return subclass\n\n        # Recursively check subclasses of this subclass\n        found = subclass._find_class(class_name, module_name)\n        if found:\n            return found\n\n    return None",
              "signature": "(cls, class_name, module_name = None)",
              "parameters": [
                {
                  "name": "cls",
                  "type": null,
                  "default": null,
                  "description": ""
                },
                {
                  "name": "class_name",
                  "type": null,
                  "default": null,
                  "description": ""
                },
                {
                  "name": "module_name",
                  "type": null,
                  "default": "None",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "classmethod"
            }
          ],
          "attributes": [],
          "parameters": []
        }
      ],
      "functions": [
        {
          "name": "serialize_callable",
          "description": "Serialize a callable with priority for human-readable formats",
          "docstring_html": "<p>Serialize a callable with priority for human-readable formats</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>func <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">callable</span></dt>\n<dd>function to serialize into dict</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>dict</dt>\n<dd>serialized function</dd>\n</dl>\n",
          "source": "def serialize_callable(func):\n    \"\"\"Serialize a callable with priority for human-readable formats\n\n    Parameters\n    ----------\n    func : callable\n        function to serialize into dict\n\n    Returns\n    -------\n    dict\n        serialized function\n    \"\"\"\n\n    #case 1: built-in function\n    if isinstance(func, types.BuiltinFunctionType):\n        return {\n            \"type\": \"builtin\",\n            \"module\": func.__module__,\n            \"name\": func.__qualname__\n        }\n\n    #case 2: module-level function or class method from standard library\n    if (hasattr(func, \"__module__\") and \n        (func.__module__ in sys.modules) and \n        not func.__module__.startswith('__main__')):\n\n        try:\n            #verify we can resolve reference\n            module = importlib.import_module(func.__module__)\n            obj = module\n            for part in func.__qualname__.split('.'):\n                obj = getattr(obj, part)\n\n            #make sure we got the same function back\n            if obj is func:  \n                return {\n                    \"type\": \"reference\",\n                    \"module\": func.__module__,\n                    \"qualname\": func.__qualname__\n                }\n        except (ImportError, AttributeError):\n            pass  #fall through to next method\n\n    #case 3: last resort -> use dill\n    serialized = dill.dumps(\n        func, \n        recurse=True, \n        byref=False,\n        protocol=dill.HIGHEST_PROTOCOL\n        )\n    return {\n        \"type\": \"dill\",\n        \"data\": base64.b64encode(serialized).decode('ascii'),\n        \"name\": getattr(func, \"__name__\", \"unknown\")\n    }",
          "signature": "(func)",
          "parameters": [
            {
              "name": "func",
              "type": null,
              "default": null,
              "description": "function to serialize into dict"
            }
          ],
          "returns": null
        },
        {
          "name": "serialize_object",
          "description": "Serialize any object by capturing its module and class",
          "docstring_html": "<p>Serialize any object by capturing its module and class</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>obj <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">object</span></dt>\n<dd>object to serialize into dict</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>dict</dt>\n<dd>serialized object</dd>\n</dl>\n",
          "source": "def serialize_object(obj):\n    \"\"\"Serialize any object by capturing its module and class\n\n    Parameters\n    ----------\n    obj : object\n        object to serialize into dict\n\n    Returns\n    -------\n    dict\n        serialized object\n    \"\"\"\n\n    #case 1: direct serialization\n    try:\n        json.dumps(obj)\n        return obj\n\n    #case 2: specific strategies\n    except (TypeError, OverflowError):\n\n        #get module and class info from the class object, not the instance\n        if hasattr(obj, '__class__'):\n\n            #get class info from the class itself\n            cls = obj.__class__\n            module_name = getattr(cls, '__module__', None)\n            class_name = getattr(cls, '__name__', str(cls))\n\n            #handle basic types with simple conversion methods\n            if hasattr(obj, \"tolist\"):\n                return {\n                    \"type\": \"object\",\n                    \"__module__\": module_name,\n                    \"__class__\": class_name,\n                    \"data\": obj.tolist()\n                }\n\n            elif hasattr(obj, \"__list__\"):\n                return {\n                    \"type\": \"object\",\n                    \"__module__\": module_name,\n                    \"__class__\": class_name,\n                    \"data\": list(obj)\n                }\n\n    #case 3: last resort -> use dill\n    serialized = dill.dumps(\n        obj, \n        recurse=True, \n        byref=False,\n        protocol=dill.HIGHEST_PROTOCOL\n        )\n    return {\n        \"type\": \"dill\",\n        \"data\": base64.b64encode(serialized).decode('ascii'),\n        \"name\": getattr(obj, \"__name__\", \"unknown\")\n    }",
          "signature": "(obj)",
          "parameters": [
            {
              "name": "obj",
              "type": null,
              "default": null,
              "description": "object to serialize into dict"
            }
          ],
          "returns": null
        },
        {
          "name": "deserialize",
          "description": "Deserialize an object from dictionary representation",
          "docstring_html": "<p>Deserialize an object from dictionary representation</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>data <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">dict</span></dt>\n<dd>dict to deserialize into object</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>object</dt>\n<dd>python object recovered from dict</dd>\n</dl>\n",
          "source": "def deserialize(data):\n    \"\"\"Deserialize an object from dictionary representation\n\n    Parameters\n    ----------\n    data : dict\n        dict to deserialize into object\n\n    Returns\n    -------\n    object\n        python object recovered from dict\n    \"\"\"\n\n    #regular values and python objects\n    if not isinstance(data, dict):\n        return data\n\n    #special types, builtin functions\n    if data[\"type\"] == \"builtin\":\n        module = importlib.import_module(data[\"module\"])\n        names = data[\"name\"].split('.')\n        obj = module\n        for name in names:\n            obj = getattr(obj, name)\n        return obj\n\n    #functions with reference\n    elif data[\"type\"] == \"reference\":\n        module = importlib.import_module(data[\"module\"])\n        names = data[\"qualname\"].split('.')\n        obj = module\n        for name in names:\n            obj = getattr(obj, name)\n        return obj\n\n    #dill\n    elif data[\"type\"] == \"dill\":\n        return dill.loads(base64.b64decode(data[\"data\"]))\n\n    #other objects\n    elif \"__module__\" in data and \"__class__\" in data:\n\n        module_name, class_name = data[\"__module__\"], data[\"__class__\"]\n\n        try:\n            #try importing the module and class\n            module = __import__(module_name, fromlist=[class_name])\n            cls = getattr(module, class_name)\n\n        except (ImportError, AttributeError) as E:\n            raise E(f\"<{module_name}.{class_name}> unrecoverable\")\n\n        if \"data\" in data:\n\n            #get the data\n            obj_data = data[\"data\"]\n\n            #objects with simple initialization from list\n            if hasattr(cls, \"from_list\") and callable(cls.from_list):\n                return cls.from_list(obj_data)\n\n            #numpy-like arrays\n            if module_name.startswith(\"numpy\") and class_name.startswith(\"ndarray\"):\n                return np.array(obj_data)\n\n            try:\n                #everything else\n                return cls(obj_data)\n\n            except (AttributeError, ValueError) as E:              \n                #data not recoverable\n                raise E(f\"<{module_name}.{data}> unrecoverable, {obj_data}\")\n\n    else:\n        raise AttributeError(f\"<{data}> unrecoverable\")",
          "signature": "(data)",
          "parameters": [
            {
              "name": "data",
              "type": null,
              "default": null,
              "description": "dict to deserialize into object"
            }
          ],
          "returns": null
        }
      ]
    }
  }
}