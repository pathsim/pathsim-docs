{
  "package": "pathsim",
  "modules": {
    "pathsim.connection": {
      "name": "pathsim.connection",
      "description": "",
      "docstring_html": "",
      "classes": [
        {
          "name": "Connection",
          "description": "Class to handle input-output relations of blocks by connecting them (directed graph)",
          "docstring_html": "<p>Class to handle input-output relations of blocks by connecting them (directed graph)\nand transfering data from the output port of the source block to the input port of\nthe target block.</p>\n<p>The default ports for connection are (0) -&gt; (0), since these are the default inputs\nthat are used in the SISO blocks.</p>\n<p><strong>Examples</strong></p>\n<p>Lets assume we have some generic blocks</p>\n<pre class=\"code python literal-block\">\n<span class=\"kn\">from</span><span class=\"w\"> </span><span class=\"nn\">pathsim.blocks._block</span><span class=\"w\"> </span><span class=\"kn\">import</span> <span class=\"n\">Block</span><span class=\"w\">\n\n</span><span class=\"n\">B1</span> <span class=\"o\">=</span> <span class=\"n\">Block</span><span class=\"p\">()</span><span class=\"w\">\n</span><span class=\"n\">B2</span> <span class=\"o\">=</span> <span class=\"n\">Block</span><span class=\"p\">()</span><span class=\"w\">\n</span><span class=\"n\">B3</span> <span class=\"o\">=</span> <span class=\"n\">Block</span><span class=\"p\">()</span>\n</pre>\n<p>that we want to connect. We initialize a 'Connection' with the blocks directly\nas the arguments if we want to connect the default ports (0) -&gt; (0)</p>\n<pre class=\"code python literal-block\">\n<span class=\"kn\">from</span><span class=\"w\"> </span><span class=\"nn\">pathsim</span><span class=\"w\"> </span><span class=\"kn\">import</span> <span class=\"n\">Connection</span><span class=\"w\">\n\n</span><span class=\"n\">C</span> <span class=\"o\">=</span> <span class=\"n\">Connection</span><span class=\"p\">(</span><span class=\"n\">B1</span><span class=\"p\">,</span> <span class=\"n\">B2</span><span class=\"p\">)</span>\n</pre>\n<p>which is a connection from block 'B1' to 'B2'. If we want to explicitly declare\nthe input and output ports we can do that by utilizing the '__getitem__' method\nof the blocks</p>\n<pre class=\"code python literal-block\">\n<span class=\"n\">C</span> <span class=\"o\">=</span> <span class=\"n\">Connection</span><span class=\"p\">(</span><span class=\"n\">B1</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">],</span> <span class=\"n\">B2</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">])</span>\n</pre>\n<p>which is exactly the default port setup. Connecting output port (1) of 'B1' to\nthe default input port (0) of 'B2' do</p>\n<pre class=\"code python literal-block\">\n<span class=\"n\">C</span> <span class=\"o\">=</span> <span class=\"n\">Connection</span><span class=\"p\">(</span><span class=\"n\">B1</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">],</span> <span class=\"n\">B2</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">])</span>\n</pre>\n<p>or just</p>\n<pre class=\"code python literal-block\">\n<span class=\"n\">C</span> <span class=\"o\">=</span> <span class=\"n\">Connection</span><span class=\"p\">(</span><span class=\"n\">B1</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">],</span> <span class=\"n\">B2</span><span class=\"p\">)</span><span class=\"o\">.</span>\n</pre>\n<p>The 'Connection' class also supports multiple targets for a single source.\nThis is specified by just adding more blocks with their respective ports into\nthe constructor like this:</p>\n<pre class=\"code python literal-block\">\n<span class=\"n\">C</span> <span class=\"o\">=</span> <span class=\"n\">Connection</span><span class=\"p\">(</span><span class=\"n\">B1</span><span class=\"p\">,</span> <span class=\"n\">B2</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">],</span> <span class=\"n\">B2</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">],</span> <span class=\"n\">B3</span><span class=\"p\">)</span>\n</pre>\n<p>The port definitions follow the same structure as for single target connections.</p>\n<p>'self'-connections also work without a problem. This is useful for modeling direct\nfeedback of a block to itself.</p>\n<p>Port definitions support slicing. This enables direct MIMO connections. For example\nconnecting ports 0, 1, 2 of 'B1' to ports 1, 2, 3 of 'B2' works like this:</p>\n<pre class=\"code python literal-block\">\n<span class=\"n\">C</span> <span class=\"o\">=</span> <span class=\"n\">Connection</span><span class=\"p\">(</span><span class=\"n\">B1</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">:</span><span class=\"mi\">2</span><span class=\"p\">],</span> <span class=\"n\">B2</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">:</span><span class=\"mi\">3</span><span class=\"p\">])</span>\n</pre>\n<p>Port definitions also support lists and tuples of 'int'. For example the slice\nabove is identical to this:</p>\n<pre class=\"code python literal-block\">\n<span class=\"n\">C</span> <span class=\"o\">=</span> <span class=\"n\">Connection</span><span class=\"p\">(</span><span class=\"n\">B1</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">],</span> <span class=\"n\">B2</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">])</span>\n</pre>\n<p>Or to be more programmatic about it, like this:</p>\n<pre class=\"code python literal-block\">\n<span class=\"n\">prts_1</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">]</span><span class=\"w\">\n</span><span class=\"n\">prts_2</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">]</span><span class=\"w\">\n\n</span><span class=\"n\">C</span> <span class=\"o\">=</span> <span class=\"n\">Connection</span><span class=\"p\">(</span><span class=\"n\">B1</span><span class=\"p\">[</span><span class=\"n\">prts_1</span><span class=\"p\">],</span> <span class=\"n\">B2</span><span class=\"p\">[</span><span class=\"n\">prts_2</span><span class=\"p\">])</span>\n</pre>\n<p>Another way to define the ports is by using strings. Some blocks have internal\naliases for the ports that can be used instead of the integer port indices to\ndefine the connections (or access the port data):</p>\n<pre class=\"code python literal-block\">\n<span class=\"n\">C</span> <span class=\"o\">=</span> <span class=\"n\">Connection</span><span class=\"p\">(</span><span class=\"n\">B1</span><span class=\"p\">[</span><span class=\"s2\">&quot;out&quot;</span><span class=\"p\">],</span> <span class=\"n\">B2</span><span class=\"p\">[</span><span class=\"s2\">&quot;in&quot;</span><span class=\"p\">])</span>\n</pre>\n<p>Or mixed with integer port indices:</p>\n<pre class=\"code python literal-block\">\n<span class=\"n\">C</span> <span class=\"o\">=</span> <span class=\"n\">Connection</span><span class=\"p\">(</span><span class=\"n\">B1</span><span class=\"p\">[</span><span class=\"s2\">&quot;out&quot;</span><span class=\"p\">],</span> <span class=\"n\">B2</span><span class=\"p\">[</span><span class=\"s2\">&quot;in&quot;</span><span class=\"p\">])</span>\n</pre>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>source <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">PortReference, Block</span></dt>\n<dd>source block and optional source output port</dd>\n<dt>targets <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">tuple[PortReference], tuple[Block]</span></dt>\n<dd>target blocks and optional target input ports</dd>\n</dl>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>_active <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>flag to set 'Connection' as active or inactive</dd>\n</dl>\n",
          "source": "class Connection:\n    \"\"\"Class to handle input-output relations of blocks by connecting them (directed graph) \n    and transfering data from the output port of the source block to the input port of \n    the target block.\n\n    The default ports for connection are (0) -> (0), since these are the default inputs \n    that are used in the SISO blocks.\n\n    Examples\n    --------\n    Lets assume we have some generic blocks \n\n    .. code-block:: python\n\n        from pathsim.blocks._block import Block\n\n        B1 = Block()\n        B2 = Block()\n        B3 = Block()\n\n\n    that we want to connect. We initialize a 'Connection' with the blocks directly \n    as the arguments if we want to connect the default ports (0) -> (0) \n\n    .. code-block:: python\n\n        from pathsim import Connection\n\n        C = Connection(B1, B2)\n\n\n    which is a connection from block 'B1' to 'B2'. If we want to explicitly declare \n    the input and output ports we can do that by utilizing the '__getitem__' method\n    of the blocks\n\n    .. code-block:: python\n\n        C = Connection(B1[0], B2[0])\n\n\n    which is exactly the default port setup. Connecting output port (1) of 'B1' to \n    the default input port (0) of 'B2' do\n\n    .. code-block:: python\n\n        C = Connection(B1[1], B2[0])\n\n\n    or just\n\n    .. code-block:: python\n\n        C = Connection(B1[1], B2).\n\n\n    The 'Connection' class also supports multiple targets for a single source. \n    This is specified by just adding more blocks with their respective ports into \n    the constructor like this:\n\n    .. code-block:: python\n\n        C = Connection(B1, B2[0], B2[1], B3)\n\n\n    The port definitions follow the same structure as for single target connections.\n\n    'self'-connections also work without a problem. This is useful for modeling direct \n    feedback of a block to itself.\n\n    Port definitions support slicing. This enables direct MIMO connections. For example \n    connecting ports 0, 1, 2 of 'B1' to ports 1, 2, 3 of 'B2' works like this:\n\n    .. code-block:: python\n\n        C = Connection(B1[0:2], B2[1:3])\n\n\n    Port definitions also support lists and tuples of 'int'. For example the slice \n    above is identical to this:\n\n    .. code-block:: python\n\n        C = Connection(B1[0, 1], B2[1, 2])\n\n\n    Or to be more programmatic about it, like this:\n\n    .. code-block:: python\n\n        prts_1 = [0, 1]\n        prts_2 = [1, 2]\n\n        C = Connection(B1[prts_1], B2[prts_2])\n\n\n    Another way to define the ports is by using strings. Some blocks have internal \n    aliases for the ports that can be used instead of the integer port indices to \n    define the connections (or access the port data):\n\n    .. code-block:: python\n\n        C = Connection(B1[\"out\"], B2[\"in\"])\n\n\n    Or mixed with integer port indices:\n\n    .. code-block:: python\n\n        C = Connection(B1[\"out\"], B2[\"in\"])\n\n\n    Parameters\n    ----------\n    source : PortReference, Block\n        source block and optional source output port\n    targets : tuple[PortReference], tuple[Block]\n        target blocks and optional target input ports\n\n\n    Attributes\n    ----------\n    _active : bool\n        flag to set 'Connection' as active or inactive\n    \"\"\"\n\n    __slots__ = [\"source\", \"targets\", \"_active\"]\n\n\n    def __init__(self, source, *targets):\n\n        #assign source block and port\n        self.source = source if isinstance(source, PortReference) else PortReference(source)\n\n        #assign target blocks and ports\n        self.targets = [trg if isinstance(trg, PortReference) else PortReference(trg) for trg in targets]\n\n        #flag to set connection active\n        self._active = True\n\n        #validate port aliases\n        self._validate_ports()\n\n        #validate port dimensions at connection creation\n        self._validate_dimensions()\n\n\n    def __str__(self):\n        \"\"\"String representation of the connection\"\"\"\n        src = f\"{self.source.block}[{self.source.ports}]\"\n        trgs = \", \".join(f\"{t.block}[{t.ports}]\" for t in self.targets)\n        return f\"Connection({src} -> {trgs})\"\n\n\n    def __len__(self):\n        \"\"\"Returns the number of ports that are defined in the connection\"\"\"\n        return len(self.source)\n\n\n    def __bool__(self):\n        return self._active\n\n\n    def __contains__(self, other):\n        \"\"\"Check if block is part of connection\n\n        Paramters\n        ---------\n        other : Block\n            block to check if its part of the connection\n\n        Returns\n        -------\n        bool\n            is other part of connecion?\n        \"\"\"\n        if isinstance(other, Block): \n            return other in self.get_blocks()\n        return False\n\n\n    def _validate_dimensions(self):\n        \"\"\"Check the dimensions of the source and target ports, \n        if they dont match, raises an exception.\n        \"\"\"\n        n_src = len(self.source)\n        for trg in self.targets:\n            if len(trg) != n_src:\n                raise ValueError(f\"Source and target have different number of ports!\")\n\n\n    def _validate_ports(self):\n        \"\"\"Check the existence of the input and output ports of \n        the defined source and target blocks. \n\n        Utilizes the `PortReference._validate_output_ports` and \n        `PortReference._validate_input_ports` methods.\n        \"\"\"\n        self.source._validate_output_ports()\n        for trg in self.targets:\n            trg._validate_input_ports()\n\n\n    def get_blocks(self):\n        \"\"\"Returns all the unique internal source and target blocks \n        of the connection instance\n\n        Returns\n        -------\n        list[Block]\n            internal unique blocks of the connection\n        \"\"\"\n        blocks = [self.source.block]\n        for trg in self.targets:\n            if trg.block not in blocks:\n                blocks.append(trg.block)\n        return blocks\n\n\n    def on(self):\n        self._active = True\n\n\n    def off(self):\n        self._active = False\n\n\n    def update(self):\n        \"\"\"Transfers data from the source block output port \n        to the target block input port.\n        \"\"\"\n        for trg in self.targets:\n            self.source.to(trg)",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, source, *targets):\n\n    #assign source block and port\n    self.source = source if isinstance(source, PortReference) else PortReference(source)\n\n    #assign target blocks and ports\n    self.targets = [trg if isinstance(trg, PortReference) else PortReference(trg) for trg in targets]\n\n    #flag to set connection active\n    self._active = True\n\n    #validate port aliases\n    self._validate_ports()\n\n    #validate port dimensions at connection creation\n    self._validate_dimensions()",
              "signature": "(source, targets = ())",
              "parameters": [
                {
                  "name": "source",
                  "type": null,
                  "default": null,
                  "description": ""
                },
                {
                  "name": "targets",
                  "type": null,
                  "default": "()",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "_validate_dimensions",
              "description": "Check the dimensions of the source and target ports,",
              "docstring_html": "<p>Check the dimensions of the source and target ports,\nif they dont match, raises an exception.</p>\n",
              "source": "def _validate_dimensions(self):\n    \"\"\"Check the dimensions of the source and target ports, \n    if they dont match, raises an exception.\n    \"\"\"\n    n_src = len(self.source)\n    for trg in self.targets:\n        if len(trg) != n_src:\n            raise ValueError(f\"Source and target have different number of ports!\")",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "_validate_ports",
              "description": "Check the existence of the input and output ports of",
              "docstring_html": "<p>Check the existence of the input and output ports of\nthe defined source and target blocks.</p>\n<p>Utilizes the <cite>PortReference._validate_output_ports</cite> and\n<cite>PortReference._validate_input_ports</cite> methods.</p>\n",
              "source": "def _validate_ports(self):\n    \"\"\"Check the existence of the input and output ports of \n    the defined source and target blocks. \n\n    Utilizes the `PortReference._validate_output_ports` and \n    `PortReference._validate_input_ports` methods.\n    \"\"\"\n    self.source._validate_output_ports()\n    for trg in self.targets:\n        trg._validate_input_ports()",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "get_blocks",
              "description": "Returns all the unique internal source and target blocks",
              "docstring_html": "<p>Returns all the unique internal source and target blocks\nof the connection instance</p>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>list[Block]</dt>\n<dd>internal unique blocks of the connection</dd>\n</dl>\n",
              "source": "def get_blocks(self):\n    \"\"\"Returns all the unique internal source and target blocks \n    of the connection instance\n\n    Returns\n    -------\n    list[Block]\n        internal unique blocks of the connection\n    \"\"\"\n    blocks = [self.source.block]\n    for trg in self.targets:\n        if trg.block not in blocks:\n            blocks.append(trg.block)\n    return blocks",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "on",
              "description": "",
              "docstring_html": "",
              "source": "def on(self):\n    self._active = True",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "off",
              "description": "",
              "docstring_html": "",
              "source": "def off(self):\n    self._active = False",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "update",
              "description": "Transfers data from the source block output port",
              "docstring_html": "<p>Transfers data from the source block output port\nto the target block input port.</p>\n",
              "source": "def update(self):\n    \"\"\"Transfers data from the source block output port \n    to the target block input port.\n    \"\"\"\n    for trg in self.targets:\n        self.source.to(trg)",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "source",
              "description": "",
              "type": null,
              "value": "source if isinstance(source, PortReference) else PortReference(source)"
            },
            {
              "name": "targets",
              "description": "",
              "type": null,
              "value": "[(trg if isinstance(trg, PortReference) else PortReference(trg)) for trg in targets]"
            },
            {
              "name": "_active",
              "description": "",
              "type": null,
              "value": "True"
            }
          ],
          "parameters": [
            {
              "name": "source",
              "type": null,
              "default": null,
              "description": "source block and optional source output port"
            },
            {
              "name": "targets",
              "type": null,
              "default": "()",
              "description": "target blocks and optional target input ports"
            }
          ]
        },
        {
          "name": "Duplex",
          "description": "Extension of the 'Connection' class, that defines bidirectional",
          "docstring_html": "<p>Extension of the 'Connection' class, that defines bidirectional\nconnections between two blocks by grouping together the inputs and\noutputs of the blocks into an IO-pair.</p>\n",
          "source": "@deprecated(version=\"1.0.0\")\nclass Duplex(Connection):\n    \"\"\"Extension of the 'Connection' class, that defines bidirectional\n    connections between two blocks by grouping together the inputs and\n    outputs of the blocks into an IO-pair.\n    \"\"\"\n\n    __slots__ = [\"source\", \"target\", \"targets\", \"_active\"]\n\n\n    def __init__(self, source, target):\n\n        self.source = source if isinstance(source, PortReference) else PortReference(source)\n        self.target = target if isinstance(target, PortReference) else PortReference(target)\n\n        #this is required for path length estimation\n        self.targets = [self.target, self.source]\n\n        #flag to set connection active\n        self._active = True\n\n\n    def update(self):\n        \"\"\"Transfers data between the two target blocks \n        and ports bidirectionally.\n        \"\"\"\n\n        #bidirectional data transfer\n        self.target.to(self.source)\n        self.source.to(self.target)",
          "bases": [
            "pathsim.connection.Connection"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, source, target):\n\n    self.source = source if isinstance(source, PortReference) else PortReference(source)\n    self.target = target if isinstance(target, PortReference) else PortReference(target)\n\n    #this is required for path length estimation\n    self.targets = [self.target, self.source]\n\n    #flag to set connection active\n    self._active = True",
              "signature": "(source, target)",
              "parameters": [
                {
                  "name": "source",
                  "type": null,
                  "default": null,
                  "description": ""
                },
                {
                  "name": "target",
                  "type": null,
                  "default": null,
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "update",
              "description": "Transfers data between the two target blocks",
              "docstring_html": "<p>Transfers data between the two target blocks\nand ports bidirectionally.</p>\n",
              "source": "def update(self):\n    \"\"\"Transfers data between the two target blocks \n    and ports bidirectionally.\n    \"\"\"\n\n    #bidirectional data transfer\n    self.target.to(self.source)\n    self.source.to(self.target)",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "source",
              "description": "",
              "type": null,
              "value": "source if isinstance(source, PortReference) else PortReference(source)"
            },
            {
              "name": "target",
              "description": "",
              "type": null,
              "value": "target if isinstance(target, PortReference) else PortReference(target)"
            },
            {
              "name": "targets",
              "description": "",
              "type": null,
              "value": "[self.target, self.source]"
            },
            {
              "name": "_active",
              "description": "",
              "type": null,
              "value": "True"
            }
          ],
          "parameters": [
            {
              "name": "source",
              "type": null,
              "default": null,
              "description": ""
            },
            {
              "name": "target",
              "type": null,
              "default": null,
              "description": ""
            }
          ]
        }
      ],
      "functions": []
    },
    "pathsim.simulation": {
      "name": "pathsim.simulation",
      "description": "",
      "docstring_html": "",
      "classes": [
        {
          "name": "Simulation",
          "description": "Class that performs transient analysis of the dynamical system, defined by the",
          "docstring_html": "<p>Class that performs transient analysis of the dynamical system, defined by the\nblocks and connecions. It manages all the blocks and connections and the timestep update.</p>\n<p>The global system equation is evaluated by fixed point iteration, so the information from\neach timestep gets distributed within the entire system and is available for all blocks at\nall times.</p>\n<p>The minimum number of fixed-point iterations 'iterations_min' is set to 'None' by default\nand then the length of the longest internal signal path (with passthrough) is used as the\nestimate for minimum number of iterations needed for the information to reach all instant\ntime blocks in each timestep. Dont change this unless you know that the actual path is\nshorter or something similar that prohibits instant time information flow.</p>\n<p>Convergence check for the fixed-point iteration loop with 'tolerance_fpi' is based on\nmax absolute error (max-norm) to previous iteration and should not be touched.</p>\n<p>Multiple numerical integrators are implemented in the 'pathsim.solvers' module.\nThe default solver is a fixed timestep 2nd order Strong Stability Preserving Runge Kutta\n(SSPRK22) method which is quite fast and has ok accuracy, especially if you are forced to\ntake small steps to cover the behaviour of forcing functions. Adaptive timestepping and\nimplicit integrators are also available.</p>\n<p>Manages an event handling system based on zero crossing detection. Uses 'Event' objects\nto monitor solver states of stateful blocks and applys transformations on the state in\ncase an event is detected.</p>\n<div class=\"section\" id=\"example\">\n<h4>Example</h4>\n<p>This is how to setup a simple system simulation using the 'Simulation' class:</p>\n<pre class=\"code python literal-block\">\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"nn\">numpy</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"nn\">np</span><span class=\"w\">\n\n</span><span class=\"kn\">from</span><span class=\"w\"> </span><span class=\"nn\">pathsim</span><span class=\"w\"> </span><span class=\"kn\">import</span> <span class=\"n\">Simulation</span><span class=\"p\">,</span> <span class=\"n\">Connection</span><span class=\"w\">\n</span><span class=\"kn\">from</span><span class=\"w\"> </span><span class=\"nn\">pathsim.blocks</span><span class=\"w\"> </span><span class=\"kn\">import</span> <span class=\"n\">Source</span><span class=\"p\">,</span> <span class=\"n\">Integrator</span><span class=\"p\">,</span> <span class=\"n\">Scope</span><span class=\"w\">\n\n</span><span class=\"n\">src</span> <span class=\"o\">=</span> <span class=\"n\">Source</span><span class=\"p\">(</span><span class=\"k\">lambda</span> <span class=\"n\">t</span><span class=\"p\">:</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">cos</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"o\">*</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">pi</span><span class=\"o\">*</span><span class=\"n\">t</span><span class=\"p\">))</span><span class=\"w\">\n</span><span class=\"n\">itg</span> <span class=\"o\">=</span> <span class=\"n\">Integrator</span><span class=\"p\">()</span><span class=\"w\">\n</span><span class=\"n\">sco</span> <span class=\"o\">=</span> <span class=\"n\">Scope</span><span class=\"p\">(</span><span class=\"n\">labels</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"s2\">&quot;source&quot;</span><span class=\"p\">,</span> <span class=\"s2\">&quot;integrator&quot;</span><span class=\"p\">])</span><span class=\"w\">\n\n</span><span class=\"n\">sim</span> <span class=\"o\">=</span> <span class=\"n\">Simulation</span><span class=\"p\">(</span><span class=\"w\">\n</span>    <span class=\"n\">blocks</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"n\">src</span><span class=\"p\">,</span> <span class=\"n\">itg</span><span class=\"p\">,</span> <span class=\"n\">sco</span><span class=\"p\">],</span><span class=\"w\">\n</span>    <span class=\"n\">connections</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"w\">\n</span>        <span class=\"n\">Connection</span><span class=\"p\">(</span><span class=\"n\">src</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">],</span> <span class=\"n\">itg</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">],</span> <span class=\"n\">sco</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]),</span><span class=\"w\">\n</span>        <span class=\"n\">Connection</span><span class=\"p\">(</span><span class=\"n\">itg</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">],</span> <span class=\"n\">sco</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">])</span><span class=\"w\">\n</span>        <span class=\"p\">],</span><span class=\"w\">\n</span>    <span class=\"n\">dt</span><span class=\"o\">=</span><span class=\"mf\">0.01</span><span class=\"w\">\n</span>    <span class=\"p\">)</span><span class=\"w\">\n\n</span><span class=\"n\">sim</span><span class=\"o\">.</span><span class=\"n\">run</span><span class=\"p\">(</span><span class=\"mi\">4</span><span class=\"p\">)</span><span class=\"w\">\n</span><span class=\"n\">sim</span><span class=\"o\">.</span><span class=\"n\">plot</span><span class=\"p\">()</span>\n</pre>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>blocks <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">list[Block]</span></dt>\n<dd>blocks that define the system</dd>\n<dt>connections <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">list[Connection]</span></dt>\n<dd>connections that connect the blocks</dd>\n<dt>events <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">list[Event]</span></dt>\n<dd>list of event trackers (zero crossing detection, schedule, etc.)</dd>\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>transient simulation timestep in time units,\ndefault see ´SIM_TIMESTEP´ in ´_constants.py´</dd>\n<dt>dt_min <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>lower bound for transient simulation timestep,\ndefault see ´SIM_TIMESTEP_MIN´ in ´_constants.py´</dd>\n<dt>dt_max <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>upper bound for transient simulation timestep,\ndefault see ´SIM_TIMESTEP_MAX´ in ´_constants.py´</dd>\n<dt>Solver <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">Solver</span></dt>\n<dd>ODE solver class for numerical integration from ´pathsim.solvers´,\ndefault is ´pathsim.solvers.ssprk22.SSPRK22´ (2nd order expl. Runge Kutta)</dd>\n<dt>tolerance_fpi <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>absolute tolerance for convergence of algebraic loops\nand internal optimizers of implicit ODE solvers,\ndefault see ´SIM_TOLERANCE_FPI´ in ´_constants.py´</dd>\n<dt>iterations_max <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>maximum allowed number of iterations for implicit ODE\nsolver optimizers and algebraic loop solver,\ndefault see ´SIM_ITERATIONS_MAX´ in ´_constants.py´</dd>\n<dt>log <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool | string</span></dt>\n<dd>flag to enable logging, default see ´LOG_ENABLE´ in ´_constants.py´\n(alternatively a path to a log file can be specified)</dd>\n<dt>solver_kwargs <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">dict</span></dt>\n<dd>additional parameters for numerical solvers such as absolute\n(´tolerance_lte_abs´) and relative (´tolerance_lte_rel´) tolerance,\ndefaults are defined in ´_constants.py´</dd>\n</dl>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>time <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>global simulation time, starting at ´0.0´</dd>\n<dt>graph <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">Graph</span></dt>\n<dd>internal graph representation for fast system funcion evluations\nusing DAG with algebraic depths</dd>\n<dt>boosters <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">None | list[ConnectionBooster]</span></dt>\n<dd>list of boosters (fixed point accelerators) that wrap algebraic\nloop closing connections assembled from the system graph</dd>\n<dt>engine <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">Solver</span></dt>\n<dd>global integrator (ODE solver) instance serving as a dummy to\nget attributes and access to intermediate evaluation stages</dd>\n<dt>logger <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">logging.Logger</span></dt>\n<dd>global simulation logger</dd>\n<dt>_blocks_dyn <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">set[Block]</span></dt>\n<dd>blocks with internal ´Solver´ instances (stateful)</dd>\n<dt>_blocks_evt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">set[Block]</span></dt>\n<dd>blocks with internal events (discrete time, eventful)</dd>\n<dt>_active <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>flag for setting the simulation as active, used for interrupts</dd>\n</dl>\n</div>\n",
          "source": "class Simulation:\n    \"\"\"Class that performs transient analysis of the dynamical system, defined by the \n    blocks and connecions. It manages all the blocks and connections and the timestep update.\n\n    The global system equation is evaluated by fixed point iteration, so the information from \n    each timestep gets distributed within the entire system and is available for all blocks at \n    all times.\n\n    The minimum number of fixed-point iterations 'iterations_min' is set to 'None' by default \n    and then the length of the longest internal signal path (with passthrough) is used as the \n    estimate for minimum number of iterations needed for the information to reach all instant \n    time blocks in each timestep. Dont change this unless you know that the actual path is \n    shorter or something similar that prohibits instant time information flow. \n\n    Convergence check for the fixed-point iteration loop with 'tolerance_fpi' is based on \n    max absolute error (max-norm) to previous iteration and should not be touched.\n\n    Multiple numerical integrators are implemented in the 'pathsim.solvers' module. \n    The default solver is a fixed timestep 2nd order Strong Stability Preserving Runge Kutta \n    (SSPRK22) method which is quite fast and has ok accuracy, especially if you are forced to \n    take small steps to cover the behaviour of forcing functions. Adaptive timestepping and \n    implicit integrators are also available.\n\n    Manages an event handling system based on zero crossing detection. Uses 'Event' objects \n    to monitor solver states of stateful blocks and applys transformations on the state in \n    case an event is detected. \n\n    Example\n    -------\n\n    This is how to setup a simple system simulation using the 'Simulation' class:\n\n    .. code-block:: python\n\n        import numpy as np\n\n        from pathsim import Simulation, Connection\n        from pathsim.blocks import Source, Integrator, Scope\n\n        src = Source(lambda t: np.cos(2*np.pi*t))\n        itg = Integrator()\n        sco = Scope(labels=[\"source\", \"integrator\"])\n\n        sim = Simulation(\n            blocks=[src, itg, sco],\n            connections=[\n                Connection(src[0], itg[0], sco[0]),\n                Connection(itg[0], sco[1])    \n                ],\n            dt=0.01\n            )\n\n        sim.run(4)\n        sim.plot()\n\n    Parameters\n    ----------\n    blocks : list[Block] \n        blocks that define the system\n    connections : list[Connection] \n        connections that connect the blocks\n    events : list[Event]\n        list of event trackers (zero crossing detection, schedule, etc.)\n    dt : float\n        transient simulation timestep in time units, \n        default see ´SIM_TIMESTEP´ in ´_constants.py´\n    dt_min : float\n        lower bound for transient simulation timestep, \n        default see ´SIM_TIMESTEP_MIN´ in ´_constants.py´\n    dt_max : float\n        upper bound for transient simulation timestep, \n        default see ´SIM_TIMESTEP_MAX´ in ´_constants.py´\n    Solver : Solver \n        ODE solver class for numerical integration from ´pathsim.solvers´,\n        default is ´pathsim.solvers.ssprk22.SSPRK22´ (2nd order expl. Runge Kutta)\n    tolerance_fpi : float\n        absolute tolerance for convergence of algebraic loops \n        and internal optimizers of implicit ODE solvers, \n        default see ´SIM_TOLERANCE_FPI´ in ´_constants.py´\n    iterations_max : int\n        maximum allowed number of iterations for implicit ODE \n        solver optimizers and algebraic loop solver, \n        default see ´SIM_ITERATIONS_MAX´ in ´_constants.py´\n    log : bool | string\n        flag to enable logging, default see ´LOG_ENABLE´ in ´_constants.py´\n        (alternatively a path to a log file can be specified)\n    solver_kwargs : dict\n        additional parameters for numerical solvers such as absolute \n        (´tolerance_lte_abs´) and relative (´tolerance_lte_rel´) tolerance, \n        defaults are defined in ´_constants.py´\n\n    Attributes\n    ----------\n    time : float\n        global simulation time, starting at ´0.0´\n    graph : Graph\n        internal graph representation for fast system funcion evluations \n        using DAG with algebraic depths\n    boosters : None | list[ConnectionBooster]\n        list of boosters (fixed point accelerators) that wrap algebraic \n        loop closing connections assembled from the system graph\n    engine : Solver\n        global integrator (ODE solver) instance serving as a dummy to \n        get attributes and access to intermediate evaluation stages\n    logger : logging.Logger\n        global simulation logger\n    _blocks_dyn : set[Block]\n        blocks with internal ´Solver´ instances (stateful) \n    _blocks_evt : set[Block]\n        blocks with internal events (discrete time, eventful) \n    _active : bool\n        flag for setting the simulation as active, used for interrupts\n    \"\"\"\n\n    def __init__(\n        self, \n        blocks=None, \n        connections=None, \n        events=None,\n        dt=SIM_TIMESTEP, \n        dt_min=SIM_TIMESTEP_MIN, \n        dt_max=SIM_TIMESTEP_MAX, \n        Solver=SSPRK22, \n        tolerance_fpi=SIM_TOLERANCE_FPI, \n        iterations_max=SIM_ITERATIONS_MAX, \n        log=LOG_ENABLE,\n        **solver_kwargs\n        ):\n\n        #system definition\n        self.blocks      = set()\n        self.connections = set()\n        self.events      = set()\n\n        #simulation timestep and bounds\n        self.dt     = dt\n        self.dt_min = dt_min\n        self.dt_max = dt_max\n\n        #numerical integrator to be used (class definition)\n        self.Solver = Solver\n\n        #numerical integrator instance\n        self.engine = Solver()\n\n        #internal system graph -> initialized later\n        self.graph = None\n\n        #internal algebraic loop solvers -> initialized later\n        self.boosters = None\n\n        #error tolerance for fixed point loop and implicit solver\n        self.tolerance_fpi = tolerance_fpi\n\n        #additional solver parameters\n        self.solver_kwargs = solver_kwargs\n\n        #iterations for fixed-point loop\n        self.iterations_max = iterations_max\n\n        #enable logging flag\n        self.log = log\n\n        #initial simulation time\n        self.time = 0.0\n\n        #collection of blocks with internal ODE solvers\n        self._blocks_dyn = set()\n\n        #collection of blocks with internal events\n        self._blocks_evt = set()\n\n        #flag for setting the simulation active\n        self._active = True\n\n        #initialize logging \n        logger_mgr = LoggerManager(\n            enabled=bool(self.log),\n            output=self.log if isinstance(self.log, str) else None,\n            level=logging.INFO,\n            date_format='%H:%M:%S'\n            )\n        self.logger = logger_mgr.get_logger(\"simulation\")\n        self.logger.info(f\"LOGGING (log: {self.log})\")\n\n        #prepare and add blocks (including internal events)\n        if blocks is not None:\n            for block in blocks:\n                self.add_block(block, _defer_graph=True)\n\n        #check and add connections\n        if connections is not None:\n            for connection in connections:\n                self.add_connection(connection, _defer_graph=True)\n\n        #check and add events\n        if events is not None:\n            for event in events:\n                self.add_event(event)\n\n        #check if blocks from connections are in simulation\n        self._check_blocks_are_managed()\n\n        #assemble the system graph for simulation\n        self._assemble_graph()\n\n\n    def __contains__(self, other):\n        \"\"\"Check if blocks, connections or events are \n        already part of the simulation \n\n        Paramters\n        ---------\n        other : obj\n            object to check if its part of simulation\n\n        Returns\n        -------\n        bool\n        \"\"\"\n        return (\n            other in self.blocks or \n            other in self.connections or \n            other in self.events\n            )\n\n\n    def __bool__(self):\n        \"\"\"Boolean evaluation of Simulation instances\n\n        Returns\n        -------\n        active : bool\n            is the simulation active\n        \"\"\"\n        return self._active\n\n\n    # methods for access to metadata ----------------------------------------------\n\n    @property\n    def size(self):\n        \"\"\"Get size information of the simulation, such as total number \n        of blocks and dynamic states, with recursive retrieval from subsystems\n\n        Returns\n        -------\n        sizes : tuple[int]\n            size of simulation (number of blocks) and number \n            of internal states (from internal engines)\n        \"\"\"\n        total_n, total_nx = 0, 0\n        for block in self.blocks:\n            n, nx = block.size\n            total_n += n\n            total_nx += nx\n        return total_n, total_nx\n\n\n    # visualization ---------------------------------------------------------------\n\n    def plot(self, *args, **kwargs):\n        \"\"\"Plot the simulation results by calling all the blocks \n        that have visualization capabilities such as the 'Scope' \n        and 'Spectrum'.\n\n        This is a quality of life method. Blocks can be visualized \n        individually due to the object oriented nature, but it might \n        be nice to just call the plot metho globally and look at all \n        the results at once. Also works for models loaded from an \n        external file.\n\n        Parameters\n        ----------\n        args : tuple\n            args for the plot methods\n        kwargs : dict\n            kwargs for the plot method\n        \"\"\"\n        for block in self.blocks:\n            if block: block.plot(*args, **kwargs)\n\n\n    # adding system components ----------------------------------------------------\n\n    def add_block(self, block, _defer_graph=False):\n        \"\"\"Adds a new block to the simulation, initializes its local solver \n        instance and collects internal events of the new block. \n\n        This works dynamically for running simulations.\n\n        Parameters\n        ----------\n        block : Block \n            block to add to the simulation\n        _defer_graph : bool\n            flag for defering graph construction to a later stage\n        \"\"\"\n\n        #check if block already in block list\n        if block in self.blocks:\n            _msg = f\"block {block} already part of simulation\"\n            self.logger.error(_msg)\n            raise ValueError(_msg)\n\n        #initialize numerical integrator of block with parent\n        block.set_solver(self.Solver, self.engine, **self.solver_kwargs)\n\n        #add to dynamic list if solver was initialized\n        if block.engine:\n            self._blocks_dyn.add(block)\n\n        #add to eventful list if internal events\n        if block.events:\n            self._blocks_evt.add(block)\n\n        #add block to global blocklist\n        self.blocks.add(block)\n\n        #if graph already exists, it needs to be rebuilt\n        if not _defer_graph and self.graph:\n            self._assemble_graph()\n\n\n    def add_connection(self, connection, _defer_graph=False):\n        \"\"\"Adds a new connection to the simulaiton and checks if \n        the new connection overwrites any existing connections.\n\n        This works dynamically for running simulations.\n\n        Parameters\n        ----------\n        connection : Connection\n            connection to add to the simulation\n        _defer_graph : bool\n            flag for defering graph construction to a later stage\n        \"\"\"\n\n        #check if connection already in connection list\n        if connection in self.connections:\n            _msg = f\"{connection} already part of simulation\"\n            self.logger.error(_msg)\n            raise ValueError(_msg)\n\n        #add connection to global connection list\n        self.connections.add(connection)\n\n        #if graph already exists, it needs to be rebuilt\n        if not _defer_graph and self.graph:\n            self._assemble_graph()\n\n\n    def add_event(self, event):\n        \"\"\"Checks and adds a new event to the simulation.\n\n        This works dynamically for running simulations.\n\n        Parameters\n        ----------\n        event : Event\n            event to add to the simulation\n        \"\"\"\n\n        #check if event already in event list\n        if event in self.events:\n            _msg = f\"{event} already part of simulation\"\n            self.logger.error(_msg)\n            raise ValueError(_msg)\n\n        #add event to global event list\n        self.events.add(event)\n\n\n    # system assembly -------------------------------------------------------------\n\n    def _assemble_graph(self):\n        \"\"\"Build the internal graph representation for fast system function \n        evaluation and algebraic loop resolution.\n        \"\"\"\n\n        #time the graph construction\n        with Timer(verbose=False) as T:\n            self.graph = Graph(self.blocks, self.connections)\n\n        #create boosters for loop closing connections\n        if self.graph.has_loops:\n            self.boosters = [\n                ConnectionBooster(conn) for conn in self.graph.loop_closing_connections()\n            ]\n\n        #log block summary\n        num_dynamic = len(self._blocks_dyn)\n        num_static = len(self.blocks) - num_dynamic\n        num_eventful = len(self._blocks_evt)\n        self.logger.info(\n            f\"BLOCKS (total: {len(self.blocks)}, dynamic: {num_dynamic}, \"\n            f\"static: {num_static}, eventful: {num_eventful})\"\n            )\n\n        #log graph info\n        self.logger.info(\n            \"GRAPH (nodes: {}, edges: {}, alg. depth: {}, loop depth: {}, runtime: {})\".format(\n                *self.graph.size, *self.graph.depth, T\n                )\n            )\n\n\n    # topological checks ----------------------------------------------------------\n\n    def _check_blocks_are_managed(self):\n        \"\"\"Check whether the blocks that are part of the connections are \n        in the simulation block set ('self.blocks') and therefore managed \n        by the simulation.\n\n        If not, there will be a warning in the logging.            \n        \"\"\"\n\n        # Collect connection blocks\n        conn_blocks = set()\n        for conn in self.connections:\n            conn_blocks.update(conn.get_blocks())\n\n        # Check subset actively managed\n        if not conn_blocks.issubset(self.blocks):\n            self.logger.warning(\n                f\"{blk} in 'connections' but not in 'blocks'!\"\n                )\n\n\n    # solver management -----------------------------------------------------------\n\n    def _set_solver(self, Solver=None, **solver_kwargs):\n        \"\"\"Initialize all blocks with solver for numerical integration\n        and tolerance for local truncation error ´tolerance_lte´.\n\n        If blocks already have solvers, change the numerical integrator\n        to the ´Solver´ class.\n\n        Parameters\n        ----------\n        Solver : Solver\n            numerical solver definition from ´pathsim.solvers´\n        solver_kwargs : dict\n            additional parameters for numerical solvers\n        \"\"\"\n\n        #update global solver class\n        if Solver is not None:\n            self.Solver = Solver\n\n        #update solver parmeters\n        self.solver_kwargs.update(solver_kwargs)\n\n        #initialize dummy engine to get solver attributes\n        self.engine = self.Solver()\n\n        #iterate all blocks and set integration engines with tolerances\n        self._blocks_dyn = set()\n        for block in self.blocks:\n            block.set_solver(self.Solver, self.engine, **self.solver_kwargs)\n\n            #add dynamic blocks to list\n            if block.engine:\n                self._blocks_dyn.add(block)\n\n        #logging message\n        self.logger.info(\n            \"SOLVER (dyn. blocks: {}) -> {} (adaptive: {}, explicit: {})\".format(\n                len(self._blocks_dyn),\n                self.engine,\n                self.engine.is_adaptive,\n                self.engine.is_explicit\n                )\n            )\n\n\n    # resetting -------------------------------------------------------------------\n\n    def reset(self, time=0.0):\n        \"\"\"Reset the blocks to their initial state and the global time of \n        the simulation. \n\n        For recording blocks such as 'Scope', their recorded \n        data is also reset. \n\n        Resets linearization automatically, since resetting the blocks \n        resets their internal operators.\n\n        Afterwards the system function is evaluated with '_update' to update\n        the block inputs and outputs.\n\n        Parameters\n        ----------\n        time : float\n            simulation time for reset\n        \"\"\"\n\n        self.logger.info(f\"RESET (time: {time})\")\n\n        #set active again\n        self._active = True\n\n        #reset simulation time\n        self.time = time\n\n        #reset integration engine\n        self.engine.reset()\n\n        #reset all blocks to initial state\n        for block in self.blocks:\n            block.reset()\n\n        #reset all event managers\n        for event in self.events:\n            event.reset()\n\n        #evaluate system function\n        self._update(self.time)\n\n\n    # linearization ---------------------------------------------------------------\n\n    def linearize(self):\n        \"\"\"Linearize the full system in the current simulation state \n        at the current simulation time.\n\n        This is achieved by linearizing algebraic and dynamic operators \n        of the internal blocks. See definition of the 'Block' class.\n\n        Before linearization, the global system function is evaluated \n        to get the blocks into the current simulation state. \n        This is only really relevant if no solving attempt has been \n        happened before.\n        \"\"\"\n        #evaluate system function at current time\n        self._update(self.time)\n\n        #linearize all internal blocks and time it\n        with Timer(verbose=False) as T:\n            for block in self.blocks:\n                block.linearize(self.time)\n\n        self.logger.info(f\"LINEARIZED (runtime: {T})\")\n\n\n    def delinearize(self):\n        \"\"\"Revert the linearization of the full system.\"\"\"\n        for block in self.blocks: \n            block.delinearize()\n\n        self.logger.info(\"DELINEARIZED\")\n\n\n    # event system helpers --------------------------------------------------------\n\n    def _get_active_events(self):\n        \"\"\"Generator that yields all active events from simulation\n        and internal block events.\n        \"\"\"\n        for event in self.events:\n            if event:\n                yield event\n        for block in self._blocks_evt:\n            for event in block.events:\n                if event:\n                    yield event\n\n\n    def _estimate_events(self, t):\n        \"\"\"Estimate the time until the next.\n\n        Parameters\n        ----------\n        t : float \n            evaluation time for event estimation\n\n        Returns\n        -------\n        float | None\n            esimated time until next event (delta)\n        \"\"\"\n\n        dt_evt_min = None\n\n        #check external events\n        for event in self._get_active_events():\n\n            #get the estimate\n            dt_evt = event.estimate(self.time)\n\n            #no estimate available\n            if dt_evt is None: continue\n\n            #smaller than min\n            if dt_evt_min is None or dt_evt < dt_evt_min:\n                dt_evt_min = dt_evt\n\n        #return time until next event or None\n        return dt_evt_min\n\n\n    def _detected_events(self, t):\n        \"\"\"Check for possible (active) events and return them chronologically, \n        sorted by their timestep ratios (closest to the initial point in time).\n\n        Parameters\n        ----------\n        t : float\n            evaluation time for event function\n\n        Returns\n        -------\n        detected : list[Event]\n            list of detected events within timestep\n        \"\"\"\n\n        #iterate all event managers\n        detected_events = []\n        for event in self._get_active_events():\n\n            #check if an event is detected\n            detected, close, ratio = event.detect(t)\n\n            #event was detected during the timestep \n            if detected:\n                detected_events.append([event, close, ratio])\n\n        #return detected events sorted by ratio\n        return sorted(detected_events, key=lambda e: e[-1])\n\n\n    # solving system equations ----------------------------------------------------\n\n    def _update(self, t):        \n        \"\"\"Distribute information within the system by evaluating the directed acyclic graph \n        (DAG) formed by the algebraic passthroughs of the blocks and resolving algebraic loops \n        through accelerated fixed-point iterations.\n\n        Effectively evaluates the right hand side function of the global \n        system ODE/DAE\n\n        .. math:: \n\n            \\\\begin{equnarray}\n                \\\\dot{x} &= f(x, t) \\\\\\\\\n                       0 &= g(x, t) \n            \\\\end{equnarray}\n\n        by converging the whole system (´f´ and ´g´) to a fixed-point at a given point \n        in time ´t´.\n\n        If no algebraic loops are present in the system, convergence is \n        guaranteed after the first stage (evaluation of the DAG in '_dag'). \n\n        Otherwise, accelerated fixed-point iterations ('_loops') are performed as a second \n        stage on the DAGs (broken cycles) of blocks that are part of or tainted by upstream \n        algebraic loops. \n\n        Parameters\n        ----------\n        t : float\n            evaluation time for system function\n        \"\"\"\n\n        #evaluate DAG\n        self._dag(t)\n\n        #algebraic loops -> solve them\n        if self.graph.has_loops:   \n            self._loops(t)\n\n\n    def _dag(self, t):\n        \"\"\"Update the directed acyclic graph components of the system.\n\n        Parameters\n        ----------\n        t : float\n            evaluation time for system function\n        \"\"\"\n\n        #perform gauss-seidel iterations without error checking\n        for _, blocks_dag, connections_dag in self.graph.dag():\n\n            #update blocks at algebraic depth (no error control)\n            for block in blocks_dag:\n                if block: block.update(t)\n\n            #update connenctions at algebraic depth (data transfer)\n            for connection in connections_dag:\n                if connection: connection.update()\n\n\n    def _loops(self, t):\n        \"\"\"Perform the algebraic loop solve of the system using accelerated \n        fixed-point iterations on the broken loop directed graph.\n\n        Parameters\n        ----------\n        t : float\n            evaluation time for system function\n        \"\"\"\n\n        #reset accelerators of loop closing connections\n        for con_booster in self.boosters:\n            con_booster.reset()\n\n        #perform solver iterations on algebraic loops\n        for iteration in range(1, self.iterations_max):\n\n            #iterate DAG depths of broken loops\n            for _, blocks_loop, connections_loop in self.graph.loop():\n\n                #update blocks at algebraic depth\n                for block in blocks_loop:\n                    if block: block.update(t)\n\n                #update connenctions at algebraic depth (data transfer)\n                for connection in connections_loop:\n                    if connection: connection.update()\n\n            #step boosters of loop closing connections\n            max_err = 0.0\n            for con_booster in self.boosters:\n                err = con_booster.update()\n                if err > max_err:\n                    max_err = err\n\n            #check convergence\n            if max_err <= self.tolerance_fpi:\n                return\n\n        #not converged -> error\n        _msg = \"algebraic loop not converged (iters: {}, err: {})\".format(\n            self.iterations_max, max_err\n            )\n        self.logger.error(_msg)\n        raise RuntimeError(_msg)\n\n\n    def _solve(self, t, dt):\n        \"\"\"For implicit solvers, this method implements the solving step \n        of the implicit update equation.\n\n        It already involves the evaluation of the system equation with \n        the '_update' method within the loop.\n\n        This also tracks the evolution of the solution as an estimate \n        for the convergence via the max residual norm of the fixed point \n        equation of the previous solution.\n\n        Parameters\n        ----------\n        t : float\n            evaluation time for system function\n        dt : float\n            timestep\n\n        Returns\n        -------\n        success : bool\n            indicator if the timestep was successful\n        total_evals : int\n            total number of system evaluations\n        total_solver_its : int\n            total number of implicit solver iterations\n        \"\"\"\n\n        #total evaluations of system equation\n        total_evals = 0\n\n        #perform fixed-point iterations to solve implicit update equation\n        for it in range(self.iterations_max):\n\n            #evaluate system equation (this is a fixed point loop)\n            self._update(t)\n            total_evals += 1            \n\n            #advance solution of implicit solver\n            max_error = 0.0\n            for block in self._blocks_dyn:\n\n                #skip inactive blocks\n                if not block: \n                    continue\n\n                #advance solution (internal optimizer)\n                error = block.solve(t, dt)\n                if error > max_error:\n                    max_error = error\n\n            #check for convergence (only error)\n            if max_error <= self.tolerance_fpi:\n                return True, total_evals, it+1\n\n        #not converged in 'self.iterations_max' steps\n        return False, total_evals, self.iterations_max\n\n\n    def steadystate(self, reset=False): \n        \"\"\"Find steady state solution (DC operating point) of the system \n        by switching all blocks to steady state solver, solving the \n        fixed point equations, then switching back.\n\n        The steady state solver forces all the temporal derivatives, i.e.\n        the right hand side equation (including external inputs) of the \n        engines of dynamic blocks to zero.\n\n        Note\n        ----\n        This is really a sort of pseudo-steady-state solve. It does NOT compute \n        the limit :math:`t\\\\rightarrow\\\\infty` but rather forces all time \n        derivatives to zero at a given moment in time. \n\n        This means, for a given `t` it computes the block states `x` such that:\n\n        .. math:: \n\n            0 = f(x, t)\n\n        instead of the real steady state:\n\n        .. math:: \n\n            \\\\lim_{t \\\\rightarrow \\\\infty} x(t)\n\n\n        Parameters\n        ----------\n        reset : bool\n            reset the simulation before solving for steady state (default False)\n        \"\"\"\n\n        #reset the simulation before solving\n        if reset:\n            self.reset()\n\n        #current solver class\n        _solver = self.Solver\n\n        #switch to steady state solver\n        self._set_solver(SteadyState)\n\n        #log message begin of steady state solver\n        self.logger.info(f\"STEADYSTATE -> STARTING (reset: {reset})\")\n\n        #solve for steady state at current time\n        with Timer(verbose=False) as T:\n            success, evals, iters = self._solve(self.time, self.dt)\n\n        #catch non convergence\n        if not success:\n            _msg = \"STEADYSTATE -> FINISHED (success: {}, evals: {}, iters: {}, runtime: {})\".format(\n                success, evals, iters, T)\n            self.logger.error(_msg)\n            raise RuntimeError(_msg)\n\n        #sample result\n        self._sample(self.time, self.dt)\n\n        #log message\n        self.logger.info(\n            \"STEADYSTATE -> FINISHED (success: {}, evals: {}, iters: {}, runtime: {})\".format(\n                success, evals, iters, T)\n            )\n\n        #switch back to original solver\n        self._set_solver(_solver)\n\n\n    # timestepping helpers --------------------------------------------------------\n\n    def _revert(self, t):\n        \"\"\"Revert simulation state to previous timestep for adaptive solvers \n        when local truncation error is too large and timestep has to be \n        retaken with smaller timestep.\n\n        Parameters\n        ----------\n        t : float\n            evaluation time for simulation revert \n        \"\"\"\n\n        #revert dummy engine (for history, allways)\n        self.engine.revert()\n\n        #revert block states\n        for block in self._blocks_dyn:\n            if block: block.revert()\n\n        #update the simulation (evaluation of rhs)\n        self._update(t)\n\n\n    def _sample(self, t, dt):\n        \"\"\"Sample data from blocks that implement the 'sample' method such \n        as 'Scope', 'Delay' and the blocks that sample from a random \n        distribution at a given time 't'.\n\n        Parameters\n        ----------\n        t : float\n            time where to sample\n        \"\"\"\n        for block in self.blocks:\n            if block: block.sample(t, dt)\n\n\n    def _buffer(self, t, dt):\n        \"\"\"Buffer states for event monitoring and internal states of blocks \n        before the timestep is taken. \n\n        For events, this is required to set reference for event monitoring and \n        backtracking for root finding.\n\n        for blocks, this is required for runge-kutta integrators but also for the \n        zero crossing detection of the event handling system. The timesteps are \n        also buffered because some integrators such as GEAR-type methods need a \n        history of the timesteps.\n\n        Parameters\n        ----------\n        t : float \n            evaluation time for buffering\n        dt : float\n            timestep\n        \"\"\"\n\n        #buffer states for event detection (with timestamp)\n        for event in self._get_active_events():\n            event.buffer(t)\n\n        #buffer the dummy engine (allways)\n        self.engine.buffer(dt)\n\n        #buffer internal states of stateful blocks\n        for block in self._blocks_dyn:\n            if block: block.buffer(dt)\n\n\n    def _step(self, t, dt):\n        \"\"\"Performs the 'step' method for dynamical blocks with internal \n        states that have a numerical integration engine. \n\n        Collects the local truncation error estimates and the timestep \n        rescale factor from the error controllers of the internal \n        intergation engines if they provide an error estimate \n        (for example embedded Runge-Kutta methods).\n\n        Notes\n        -----\n        Not to be confused with the global 'step' method, the '_step' \n        method executes the intermediate timesteps in multistage solvers \n        such as Runge-Kutta methods.\n\n        Parameters\n        ----------\n        t : float\n            evaluation time of dynamical timestepping\n        dt : float\n            timestep\n\n        Returns\n        -------\n        success : bool \n            indicator if the timestep was successful\n        max_error : float \n            maximum local truncation error from integration\n        scale : float\n            rescale factor for timestep\n        \"\"\"\n\n        #initial timestep rescale and error estimate\n        success, max_error_norm, min_scale = True, 0.0, None\n\n        #step blocks and get error estimates if available\n        for block in self._blocks_dyn:\n\n            #skip inactive blocks\n            if not block: continue\n\n            #step the block\n            suc, err_norm, scl = block.step(t, dt)\n\n            #check solver stepping success\n            if not suc:\n                success = False\n\n            #update error tracking\n            if err_norm > max_error_norm:\n                max_error_norm = err_norm\n\n            #track minimum relevant scale directly (avoids list allocation)\n            if scl is not None:\n                if min_scale is None or scl < min_scale:\n                    min_scale = scl\n\n        return success, max_error_norm, min_scale if min_scale is not None else 1.0\n\n\n    # timestepping ----------------------------------------------------------------\n\n    @deprecated(version=\"1.0.0\", replacement=\"timestep\")\n    def timestep_fixed_explicit(self, dt=None):\n        \"\"\"Advances the simulation by one timestep 'dt' for explicit fixed step solvers.\n\n        Parameters\n        ----------\n        dt : float\n            timestep\n\n        Returns\n        -------\n        success : bool\n            indicator if the timestep was successful\n        max_error : float\n            maximum local truncation error from integration\n        scale : float\n            rescale factor for timestep\n        total_evals : int\n            total number of system evaluations\n        total_solver_its : int\n            total number of implicit solver iterations\n        \"\"\"\n        return self.timestep(dt, adaptive=False)\n\n\n    @deprecated(version=\"1.0.0\", replacement=\"timestep\")\n    def timestep_fixed_implicit(self, dt=None):\n        \"\"\"Advances the simulation by one timestep 'dt' for implicit fixed step solvers.\n\n        Parameters\n        ----------\n        dt : float\n            timestep\n\n        Returns\n        -------\n        success : bool\n            indicator if the timestep was successful\n        max_error : float\n            maximum local truncation error from integration\n        scale : float\n            rescale factor for timestep\n        total_evals : int\n            total number of system evaluations\n        total_solver_its : int\n            total number of implicit solver iterations\n        \"\"\"\n        return self.timestep(dt, adaptive=False)\n\n\n    @deprecated(version=\"1.0.0\", replacement=\"timestep\")\n    def timestep_adaptive_explicit(self, dt=None):\n        \"\"\"Advances the simulation by one timestep 'dt' for explicit adaptive solvers.\n\n        Parameters\n        ----------\n        dt : float\n            timestep\n\n        Returns\n        -------\n        success : bool\n            indicator if the timestep was successful\n        max_error : float\n            maximum local truncation error from integration\n        scale : float\n            rescale factor for timestep\n        total_evals : int\n            total number of system evaluations\n        total_solver_its : int\n            total number of implicit solver iterations\n        \"\"\"\n        return self.timestep(dt, adaptive=True)\n\n\n    @deprecated(version=\"1.0.0\", replacement=\"timestep\")\n    def timestep_adaptive_implicit(self, dt=None):\n        \"\"\"Advances the simulation by one timestep 'dt' for implicit adaptive solvers.\n\n        Parameters\n        ----------\n        dt : float\n            timestep\n\n        Returns\n        -------\n        success : bool\n            indicator if the timestep was successful\n        max_error : float\n            maximum local truncation error from integration\n        scale : float\n            rescale factor for timestep\n        total_evals : int\n            total number of system evaluations\n        total_solver_its : int\n            total number of implicit solver iterations\n        \"\"\"\n        return self.timestep(dt, adaptive=True)\n\n\n    def timestep(self, dt=None, adaptive=True):\n        \"\"\"Advances the transient simulation by one timestep 'dt'.\n\n        Automatic behavior selection based on selected `Solver` and `adaptive` flag:\n\n        - Explicit solvers: Uses `_update()` for system evaluation\n        - Implicit solvers: Uses `_solve()` for implicit update equation\n        - Adaptive solvers (with adaptive=True): Reverts timestep if error too large\n          or event not close\n        - Fixed solvers (or adaptive=False): Always completes timestep, resolves\n          events at detected time\n\n        If discrete events are detected, they are handled according to stepping mode:\n\n        - Fixed stepping: Events resolved at interpolated time within step\n        - Adaptive stepping: Events approached via timestep rescaling (secant method)\n\n        Parameters\n        ----------\n        dt : float\n            timestep size for transient simulation\n        adaptive : bool\n            explicitly enable/disable adaptive timestepping; when False, adaptive\n            solvers are forced to take fixed steps without error control (default True)\n\n        Returns\n        -------\n        success : bool\n            indicator if the timestep was successful\n        max_error : float\n            maximum local truncation error from integration\n        scale : float\n            rescale factor for timestep\n        total_evals : int\n            total number of system evaluations\n        total_solver_its : int\n            total number of implicit solver iterations\n        \"\"\"\n        #solver behavior flags (adaptive only if both flag and solver support it)\n        is_adaptive = adaptive and self.engine.is_adaptive\n        is_implicit = not self.engine.is_explicit\n\n        #stats tracking\n        total_evals, total_solver_its = 0, 0\n        error_norm, scale, success = 0.0, 1.0, True\n\n        #default global timestep as local timestep\n        if dt is None:\n            dt = self.dt\n\n        #buffer events and dynamic blocks before timestep\n        self._buffer(self.time, dt)\n\n        #solver stages iteration (skip if no dynamic blocks)\n        if self._blocks_dyn:\n            for time_stage in self.engine.stages(self.time, dt):\n\n                if is_implicit:\n                    #implicit: solve update equation (contains _update internally)\n                    success, evals, solver_its = self._solve(time_stage, dt)\n                    total_evals += evals\n                    total_solver_its += solver_its\n\n                    #adaptive implicit: revert if solver didn't converge\n                    if not success and is_adaptive:\n                        self._revert(self.time)\n                        return False, 0.0, 0.5, total_evals + 1, total_solver_its\n                else:\n                    #explicit: evaluate system equation\n                    self._update(time_stage)\n                    total_evals += 1\n\n                #step dynamic blocks, get error estimate\n                success, error_norm, scale = self._step(time_stage, dt)\n\n                #adaptive: revert if local truncation error too large\n                if not success and is_adaptive:\n                    self._revert(self.time)\n                    return False, error_norm, scale, total_evals + 1, total_solver_its\n\n        #system time after timestep\n        time_dt = self.time + dt\n\n        #evaluate system equation before event check\n        self._update(time_dt)\n        total_evals += 1\n\n        #handle detected events chronologically\n        for event, close, ratio in self._detected_events(time_dt):\n            if is_adaptive:\n                #adaptive: only resolve if close enough to event\n                if close:\n                    event.resolve(time_dt)\n                    self._update(time_dt)\n                    total_evals += 1\n                else:\n                    #not close: revert and use ratio as rescale\n                    self._revert(self.time)\n                    return False, error_norm, ratio, total_evals + 1, total_solver_its\n            else:\n                #fixed: resolve at interpolated time within step\n                event.resolve(self.time + ratio * dt)\n                self._update(time_dt)\n                total_evals += 1\n\n        #sample data after successful timestep\n        self._sample(time_dt, dt)\n\n        #increment global time\n        self.time = time_dt\n\n        return success, error_norm, scale, total_evals, total_solver_its\n\n\n    def step(self, dt=None, adaptive=True):\n        \"\"\"Wraps 'Simulation.timestep' for backward compatibility\"\"\"\n        self.logger.warning(\n            \"'Simulation.step' method will be deprecated with release version 1.0.0, use 'Simulation.timestep' instead!\"\n            )\n        return self.timestep(dt, adaptive)\n\n\n    # data extraction -------------------------------------------------------------\n\n    @deprecated(version=\"1.0.0\", reason=\"its against pathsims philosophy\")\n    def collect(self):\n        \"\"\"Collect all current simulation results from the internal \n        recording blocks\n\n        Returns\n        -------\n        results : dict\n        \"\"\"\n        scopes, spectra = {}, {}\n        for block in self.blocks:\n            for _category, _id, _data in block.collect():\n                if _category == \"scope\":\n                    scopes[_id] = _data\n                elif _category == \"spectrum\":\n                    spectra[_id] = _data\n        return {\"scopes\": scopes, \"spectra\": spectra}\n\n\n    # simulation execution --------------------------------------------------------\n\n    def stop(self):\n        \"\"\"Set the flag for active simulation to 'False', intended to be\n        called from the outside (for example by events) to interrupt the\n        timestepping loop in 'run'.\n        \"\"\"\n        self._active = False\n\n\n    def _run_loop(self, duration, reset, adaptive, tracker=None):\n        \"\"\"Core simulation loop generator that yields after each timestep.\n\n        This internal method contains the shared simulation logic used by\n        'run', 'run_streaming', and 'run_realtime'. It handles initialization,\n        timestepping, adaptive rescaling, and progress tracking.\n\n        Parameters\n        ----------\n        duration : float\n            simulation time (in time units)\n        reset : bool\n            reset the simulation before running\n        adaptive : bool\n            use adaptive timesteps if solver is adaptive\n        tracker : ProgressTracker | None\n            optional progress tracker for logging\n\n        Yields\n        ------\n        step_info : dict\n            dictionary containing 'progress', 'success', and 'dt' for each step\n        \"\"\"\n\n        #set simulation active\n        self._active = True\n\n        #reset the simulation before running it\n        if reset:\n            self.reset()\n\n        #make an adaptive run?\n        _adaptive = adaptive and self.engine.is_adaptive\n\n        #simulation start and end time\n        start_time, end_time = self.time, self.time + duration\n\n        #effective timestep for duration\n        _dt = self.dt\n\n        #initial system function evaluation\n        self._update(self.time)\n\n        #catch and resolve initial events\n        for event, *_ in self._detected_events(self.time):\n\n            #resolve events directly\n            event.resolve(self.time)\n\n            #evaluate system function again -> propagate event\n            self._update(self.time)\n\n        #sampling states and inputs at 'self.time == starting_time'\n        self._sample(self.time, _dt)\n\n        #main simulation loop\n        while self.time < end_time and self._active:\n\n            #advance the simulation by one (effective) timestep '_dt'\n            success, error_norm, scale, *_ = self.timestep(\n                dt=_dt,\n                adaptive=_adaptive\n                )\n\n            #perform adaptive rescale\n            if _adaptive:\n\n                #if no error estimate and rescale -> back to default timestep\n                if not error_norm and scale == 1:\n                    _dt = self.dt\n\n                #rescale due to error control\n                _dt = scale * _dt\n\n                #estimate time until next event and adjust timestep\n                _dt_evt = self._estimate_events(self.time)\n                if _dt_evt is not None and _dt_evt < _dt:\n                    _dt = _dt_evt\n\n                #rescale if in danger of overshooting 'end_time' at next step\n                if self.time + _dt > end_time:\n                    _dt = end_time - self.time\n\n                #apply bounds to timestep after rescale\n                _dt = np.clip(_dt, self.dt_min, self.dt_max)\n\n            #compute simulation progress\n            progress = np.clip((self.time - start_time) / duration, 0.0, 1.0)\n\n            #update the tracker if provided\n            if tracker:\n                tracker.update(progress, success=success)\n\n            #yield step information\n            yield {'progress': progress, 'success': success, 'dt': _dt}\n\n        #handle interrupt\n        if tracker and not self._active:\n            tracker.interrupt()\n\n\n    def run(self, duration=10, reset=False, adaptive=True):\n        \"\"\"Perform multiple simulation timesteps for a given 'duration'.\n\n        Tracks the total number of block evaluations (proxy for function\n        calls, although larger, since one function call of the system equation\n        consists of many block evaluations) and the total number of solver\n        iterations for implicit solvers.\n\n        Additionally the progress of the simulation is tracked by a custom\n        'ProgressTracker' class that is a dynamic generator and interfaces\n        the logging system.\n\n        Parameters\n        ----------\n        duration : float\n            simulation time (in time units)\n        reset : bool\n            reset the simulation before running (default False)\n        adaptive : bool\n            use adaptive timesteps if solver is adaptive (default True)\n\n        Returns\n        -------\n        stats : dict\n            stats of simulation run tracked by the 'ProgressTracker'\n        \"\"\"\n\n        #initialize progress tracker\n        tracker = ProgressTracker(\n            total_duration=duration,\n            description=\"TRANSIENT\",\n            logger=self.logger,\n            log=self.log\n            )\n\n        #enter tracker context and consume the run loop\n        with tracker:\n            for _ in self._run_loop(duration, reset, adaptive, tracker=tracker):\n                pass\n\n        return tracker.stats\n\n\n    def run_streaming(self, duration=10, reset=False, adaptive=True, tickrate=10, func_callback=None):\n        \"\"\"Perform simulation with streaming output at a fixed wall-clock rate.\n\n        This method runs the simulation as fast as possible while yielding\n        intermediate results at a fixed rate defined by 'tickrate'. Useful\n        for real-time visualization and UI updates.\n\n        The progress is tracked and logged using the 'ProgressTracker' class.\n\n        Parameters\n        ----------\n        duration : float\n            simulation time (in time units)\n        reset : bool\n            reset the simulation before running (default False)\n        adaptive : bool\n            use adaptive timesteps if solver is adaptive (default True)\n        tickrate : float\n            output rate in Hz, i.e., yields per second of wall-clock time\n            (default 10)\n        func_callback : callable | None\n            callback function that is called at every tick, can be used \n            for data extraction, its return value is yielded by this generator\n\n        Yields\n        ------\n        result \n            The return value of the 'func_callback' callable. \n        \"\"\"\n\n        #initialize progress tracker\n        tracker = ProgressTracker(\n            total_duration=duration,\n            description=\"STREAMING\",\n            logger=self.logger,\n            log=self.log\n            )\n\n        #streaming timing setup\n        tick_interval = 1.0 / tickrate\n        last_tick = time.perf_counter()\n\n        #enter tracker context\n        with tracker:\n\n            #iterate the core simulation loop\n            for step in self._run_loop(duration, reset, adaptive, tracker=tracker):\n\n                #check if enough wall-clock time has passed\n                now = time.perf_counter()\n                if now - last_tick >= tick_interval:\n                    last_tick = now\n\n                    #yield intermediate results\n                    yield func_callback() if callable(func_callback) else None\n\n            #final yield with complete results\n            yield func_callback() if callable(func_callback) else None\n\n\n    def run_realtime(self, duration=10, reset=False, adaptive=True, tickrate=30, speed=1.0, func_callback=None):\n        \"\"\"Perform simulation paced to wall-clock time.\n\n        This method runs the simulation synchronized to real time, optionally\n        scaled by 'speed'. The simulation advances to match elapsed wall-clock\n        time, yielding results at the rate defined by 'tickrate'.\n\n        Useful for interactive simulations, hardware-in-the-loop testing,\n        or when simulation should match real-world timing.\n\n        The progress is tracked and logged using the 'ProgressTracker' class.\n\n        Parameters\n        ----------\n        duration : float\n            simulation time (in time units)\n        reset : bool\n            reset the simulation before running (default False)\n        adaptive : bool\n            use adaptive timesteps if solver is adaptive (default True)\n        tickrate : float\n            output rate in Hz, i.e., yields per second of wall-clock time\n            (default 30)\n        speed : float\n            time scaling factor where 1.0 is real-time, 2.0 is twice as fast,\n            0.5 is half speed (default 1.0)\n        func_callback : callable | None\n            callback function that is called at every tick, can be used \n            for data extraction, its return value is yielded by this generator\n\n        Yields\n        ------\n        result \n            The return value of the 'func_callback' callable. \n        \"\"\"\n\n        #initialize progress tracker\n        tracker = ProgressTracker(\n            total_duration=duration,\n            description=\"REALTIME\",\n            logger=self.logger,\n            log=self.log\n            )\n\n        #realtime timing setup\n        tick_interval = 1.0 / tickrate\n        last_tick = time.perf_counter()\n        start_wall = time.perf_counter()\n        start_sim = self.time\n\n        #enter tracker context\n        with tracker:\n\n            #create the core simulation loop generator\n            loop = self._run_loop(duration, reset, adaptive, tracker=tracker)\n\n            #realtime pacing loop\n            while self._active:\n\n                #compute target simulation time based on wall-clock\n                wall_elapsed = time.perf_counter() - start_wall\n                target_time = start_sim + wall_elapsed * speed\n\n                #advance simulation until caught up with target time\n                try:\n                    while self.time < target_time:\n                        next(loop)\n                except StopIteration:\n                    break\n\n                #check if enough wall-clock time has passed for yield\n                now = time.perf_counter()\n                if now - last_tick >= tick_interval:\n                    last_tick = now\n\n                    #compute progress\n                    progress = (self.time - start_sim) / duration\n\n                    #yield intermediate results\n                    yield func_callback() if callable(func_callback) else None\n\n                #small sleep to avoid busy-waiting\n                time.sleep(0.001)\n\n            #final yield with complete results\n            yield func_callback() if callable(func_callback) else None",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(\n    self, \n    blocks=None, \n    connections=None, \n    events=None,\n    dt=SIM_TIMESTEP, \n    dt_min=SIM_TIMESTEP_MIN, \n    dt_max=SIM_TIMESTEP_MAX, \n    Solver=SSPRK22, \n    tolerance_fpi=SIM_TOLERANCE_FPI, \n    iterations_max=SIM_ITERATIONS_MAX, \n    log=LOG_ENABLE,\n    **solver_kwargs\n    ):\n\n    #system definition\n    self.blocks      = set()\n    self.connections = set()\n    self.events      = set()\n\n    #simulation timestep and bounds\n    self.dt     = dt\n    self.dt_min = dt_min\n    self.dt_max = dt_max\n\n    #numerical integrator to be used (class definition)\n    self.Solver = Solver\n\n    #numerical integrator instance\n    self.engine = Solver()\n\n    #internal system graph -> initialized later\n    self.graph = None\n\n    #internal algebraic loop solvers -> initialized later\n    self.boosters = None\n\n    #error tolerance for fixed point loop and implicit solver\n    self.tolerance_fpi = tolerance_fpi\n\n    #additional solver parameters\n    self.solver_kwargs = solver_kwargs\n\n    #iterations for fixed-point loop\n    self.iterations_max = iterations_max\n\n    #enable logging flag\n    self.log = log\n\n    #initial simulation time\n    self.time = 0.0\n\n    #collection of blocks with internal ODE solvers\n    self._blocks_dyn = set()\n\n    #collection of blocks with internal events\n    self._blocks_evt = set()\n\n    #flag for setting the simulation active\n    self._active = True\n\n    #initialize logging \n    logger_mgr = LoggerManager(\n        enabled=bool(self.log),\n        output=self.log if isinstance(self.log, str) else None,\n        level=logging.INFO,\n        date_format='%H:%M:%S'\n        )\n    self.logger = logger_mgr.get_logger(\"simulation\")\n    self.logger.info(f\"LOGGING (log: {self.log})\")\n\n    #prepare and add blocks (including internal events)\n    if blocks is not None:\n        for block in blocks:\n            self.add_block(block, _defer_graph=True)\n\n    #check and add connections\n    if connections is not None:\n        for connection in connections:\n            self.add_connection(connection, _defer_graph=True)\n\n    #check and add events\n    if events is not None:\n        for event in events:\n            self.add_event(event)\n\n    #check if blocks from connections are in simulation\n    self._check_blocks_are_managed()\n\n    #assemble the system graph for simulation\n    self._assemble_graph()",
              "signature": "(blocks = None, connections = None, events = None, dt = SIM_TIMESTEP, dt_min = SIM_TIMESTEP_MIN, dt_max = SIM_TIMESTEP_MAX, Solver = SSPRK22, tolerance_fpi = SIM_TOLERANCE_FPI, iterations_max = SIM_ITERATIONS_MAX, log = LOG_ENABLE, solver_kwargs = {})",
              "parameters": [
                {
                  "name": "blocks",
                  "type": null,
                  "default": "None",
                  "description": ""
                },
                {
                  "name": "connections",
                  "type": null,
                  "default": "None",
                  "description": ""
                },
                {
                  "name": "events",
                  "type": null,
                  "default": "None",
                  "description": ""
                },
                {
                  "name": "dt",
                  "type": null,
                  "default": "SIM_TIMESTEP",
                  "description": ""
                },
                {
                  "name": "dt_min",
                  "type": null,
                  "default": "SIM_TIMESTEP_MIN",
                  "description": ""
                },
                {
                  "name": "dt_max",
                  "type": null,
                  "default": "SIM_TIMESTEP_MAX",
                  "description": ""
                },
                {
                  "name": "Solver",
                  "type": null,
                  "default": "SSPRK22",
                  "description": ""
                },
                {
                  "name": "tolerance_fpi",
                  "type": null,
                  "default": "SIM_TOLERANCE_FPI",
                  "description": ""
                },
                {
                  "name": "iterations_max",
                  "type": null,
                  "default": "SIM_ITERATIONS_MAX",
                  "description": ""
                },
                {
                  "name": "log",
                  "type": null,
                  "default": "LOG_ENABLE",
                  "description": ""
                },
                {
                  "name": "solver_kwargs",
                  "type": null,
                  "default": "{}",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "plot",
              "description": "Plot the simulation results by calling all the blocks",
              "docstring_html": "<p>Plot the simulation results by calling all the blocks\nthat have visualization capabilities such as the 'Scope'\nand 'Spectrum'.</p>\n<p>This is a quality of life method. Blocks can be visualized\nindividually due to the object oriented nature, but it might\nbe nice to just call the plot metho globally and look at all\nthe results at once. Also works for models loaded from an\nexternal file.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>args <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">tuple</span></dt>\n<dd>args for the plot methods</dd>\n<dt>kwargs <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">dict</span></dt>\n<dd>kwargs for the plot method</dd>\n</dl>\n",
              "source": "def plot(self, *args, **kwargs):\n    \"\"\"Plot the simulation results by calling all the blocks \n    that have visualization capabilities such as the 'Scope' \n    and 'Spectrum'.\n\n    This is a quality of life method. Blocks can be visualized \n    individually due to the object oriented nature, but it might \n    be nice to just call the plot metho globally and look at all \n    the results at once. Also works for models loaded from an \n    external file.\n\n    Parameters\n    ----------\n    args : tuple\n        args for the plot methods\n    kwargs : dict\n        kwargs for the plot method\n    \"\"\"\n    for block in self.blocks:\n        if block: block.plot(*args, **kwargs)",
              "signature": "(args = (), kwargs = {})",
              "parameters": [
                {
                  "name": "args",
                  "type": null,
                  "default": "()",
                  "description": "args for the plot methods"
                },
                {
                  "name": "kwargs",
                  "type": null,
                  "default": "{}",
                  "description": "kwargs for the plot method"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "add_block",
              "description": "Adds a new block to the simulation, initializes its local solver",
              "docstring_html": "<p>Adds a new block to the simulation, initializes its local solver\ninstance and collects internal events of the new block.</p>\n<p>This works dynamically for running simulations.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>block <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">Block</span></dt>\n<dd>block to add to the simulation</dd>\n<dt>_defer_graph <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>flag for defering graph construction to a later stage</dd>\n</dl>\n",
              "source": "def add_block(self, block, _defer_graph=False):\n    \"\"\"Adds a new block to the simulation, initializes its local solver \n    instance and collects internal events of the new block. \n\n    This works dynamically for running simulations.\n\n    Parameters\n    ----------\n    block : Block \n        block to add to the simulation\n    _defer_graph : bool\n        flag for defering graph construction to a later stage\n    \"\"\"\n\n    #check if block already in block list\n    if block in self.blocks:\n        _msg = f\"block {block} already part of simulation\"\n        self.logger.error(_msg)\n        raise ValueError(_msg)\n\n    #initialize numerical integrator of block with parent\n    block.set_solver(self.Solver, self.engine, **self.solver_kwargs)\n\n    #add to dynamic list if solver was initialized\n    if block.engine:\n        self._blocks_dyn.add(block)\n\n    #add to eventful list if internal events\n    if block.events:\n        self._blocks_evt.add(block)\n\n    #add block to global blocklist\n    self.blocks.add(block)\n\n    #if graph already exists, it needs to be rebuilt\n    if not _defer_graph and self.graph:\n        self._assemble_graph()",
              "signature": "(block, _defer_graph = False)",
              "parameters": [
                {
                  "name": "block",
                  "type": null,
                  "default": null,
                  "description": "block to add to the simulation"
                },
                {
                  "name": "_defer_graph",
                  "type": null,
                  "default": "False",
                  "description": "flag for defering graph construction to a later stage"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "add_connection",
              "description": "Adds a new connection to the simulaiton and checks if",
              "docstring_html": "<p>Adds a new connection to the simulaiton and checks if\nthe new connection overwrites any existing connections.</p>\n<p>This works dynamically for running simulations.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>connection <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">Connection</span></dt>\n<dd>connection to add to the simulation</dd>\n<dt>_defer_graph <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>flag for defering graph construction to a later stage</dd>\n</dl>\n",
              "source": "def add_connection(self, connection, _defer_graph=False):\n    \"\"\"Adds a new connection to the simulaiton and checks if \n    the new connection overwrites any existing connections.\n\n    This works dynamically for running simulations.\n\n    Parameters\n    ----------\n    connection : Connection\n        connection to add to the simulation\n    _defer_graph : bool\n        flag for defering graph construction to a later stage\n    \"\"\"\n\n    #check if connection already in connection list\n    if connection in self.connections:\n        _msg = f\"{connection} already part of simulation\"\n        self.logger.error(_msg)\n        raise ValueError(_msg)\n\n    #add connection to global connection list\n    self.connections.add(connection)\n\n    #if graph already exists, it needs to be rebuilt\n    if not _defer_graph and self.graph:\n        self._assemble_graph()",
              "signature": "(connection, _defer_graph = False)",
              "parameters": [
                {
                  "name": "connection",
                  "type": null,
                  "default": null,
                  "description": "connection to add to the simulation"
                },
                {
                  "name": "_defer_graph",
                  "type": null,
                  "default": "False",
                  "description": "flag for defering graph construction to a later stage"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "add_event",
              "description": "Checks and adds a new event to the simulation.",
              "docstring_html": "<p>Checks and adds a new event to the simulation.</p>\n<p>This works dynamically for running simulations.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>event <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">Event</span></dt>\n<dd>event to add to the simulation</dd>\n</dl>\n",
              "source": "def add_event(self, event):\n    \"\"\"Checks and adds a new event to the simulation.\n\n    This works dynamically for running simulations.\n\n    Parameters\n    ----------\n    event : Event\n        event to add to the simulation\n    \"\"\"\n\n    #check if event already in event list\n    if event in self.events:\n        _msg = f\"{event} already part of simulation\"\n        self.logger.error(_msg)\n        raise ValueError(_msg)\n\n    #add event to global event list\n    self.events.add(event)",
              "signature": "(event)",
              "parameters": [
                {
                  "name": "event",
                  "type": null,
                  "default": null,
                  "description": "event to add to the simulation"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "_assemble_graph",
              "description": "Build the internal graph representation for fast system function",
              "docstring_html": "<p>Build the internal graph representation for fast system function\nevaluation and algebraic loop resolution.</p>\n",
              "source": "def _assemble_graph(self):\n    \"\"\"Build the internal graph representation for fast system function \n    evaluation and algebraic loop resolution.\n    \"\"\"\n\n    #time the graph construction\n    with Timer(verbose=False) as T:\n        self.graph = Graph(self.blocks, self.connections)\n\n    #create boosters for loop closing connections\n    if self.graph.has_loops:\n        self.boosters = [\n            ConnectionBooster(conn) for conn in self.graph.loop_closing_connections()\n        ]\n\n    #log block summary\n    num_dynamic = len(self._blocks_dyn)\n    num_static = len(self.blocks) - num_dynamic\n    num_eventful = len(self._blocks_evt)\n    self.logger.info(\n        f\"BLOCKS (total: {len(self.blocks)}, dynamic: {num_dynamic}, \"\n        f\"static: {num_static}, eventful: {num_eventful})\"\n        )\n\n    #log graph info\n    self.logger.info(\n        \"GRAPH (nodes: {}, edges: {}, alg. depth: {}, loop depth: {}, runtime: {})\".format(\n            *self.graph.size, *self.graph.depth, T\n            )\n        )",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "_check_blocks_are_managed",
              "description": "Check whether the blocks that are part of the connections are",
              "docstring_html": "<p>Check whether the blocks that are part of the connections are\nin the simulation block set ('self.blocks') and therefore managed\nby the simulation.</p>\n<p>If not, there will be a warning in the logging.</p>\n",
              "source": "def _check_blocks_are_managed(self):\n    \"\"\"Check whether the blocks that are part of the connections are \n    in the simulation block set ('self.blocks') and therefore managed \n    by the simulation.\n\n    If not, there will be a warning in the logging.            \n    \"\"\"\n\n    # Collect connection blocks\n    conn_blocks = set()\n    for conn in self.connections:\n        conn_blocks.update(conn.get_blocks())\n\n    # Check subset actively managed\n    if not conn_blocks.issubset(self.blocks):\n        self.logger.warning(\n            f\"{blk} in 'connections' but not in 'blocks'!\"\n            )",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "_set_solver",
              "description": "Initialize all blocks with solver for numerical integration",
              "docstring_html": "<p>Initialize all blocks with solver for numerical integration\nand tolerance for local truncation error ´tolerance_lte´.</p>\n<p>If blocks already have solvers, change the numerical integrator\nto the ´Solver´ class.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>Solver <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">Solver</span></dt>\n<dd>numerical solver definition from ´pathsim.solvers´</dd>\n<dt>solver_kwargs <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">dict</span></dt>\n<dd>additional parameters for numerical solvers</dd>\n</dl>\n",
              "source": "def _set_solver(self, Solver=None, **solver_kwargs):\n    \"\"\"Initialize all blocks with solver for numerical integration\n    and tolerance for local truncation error ´tolerance_lte´.\n\n    If blocks already have solvers, change the numerical integrator\n    to the ´Solver´ class.\n\n    Parameters\n    ----------\n    Solver : Solver\n        numerical solver definition from ´pathsim.solvers´\n    solver_kwargs : dict\n        additional parameters for numerical solvers\n    \"\"\"\n\n    #update global solver class\n    if Solver is not None:\n        self.Solver = Solver\n\n    #update solver parmeters\n    self.solver_kwargs.update(solver_kwargs)\n\n    #initialize dummy engine to get solver attributes\n    self.engine = self.Solver()\n\n    #iterate all blocks and set integration engines with tolerances\n    self._blocks_dyn = set()\n    for block in self.blocks:\n        block.set_solver(self.Solver, self.engine, **self.solver_kwargs)\n\n        #add dynamic blocks to list\n        if block.engine:\n            self._blocks_dyn.add(block)\n\n    #logging message\n    self.logger.info(\n        \"SOLVER (dyn. blocks: {}) -> {} (adaptive: {}, explicit: {})\".format(\n            len(self._blocks_dyn),\n            self.engine,\n            self.engine.is_adaptive,\n            self.engine.is_explicit\n            )\n        )",
              "signature": "(Solver = None, solver_kwargs = {})",
              "parameters": [
                {
                  "name": "Solver",
                  "type": null,
                  "default": "None",
                  "description": "numerical solver definition from ´pathsim.solvers´"
                },
                {
                  "name": "solver_kwargs",
                  "type": null,
                  "default": "{}",
                  "description": "additional parameters for numerical solvers"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "reset",
              "description": "Reset the blocks to their initial state and the global time of",
              "docstring_html": "<p>Reset the blocks to their initial state and the global time of\nthe simulation.</p>\n<p>For recording blocks such as 'Scope', their recorded\ndata is also reset.</p>\n<p>Resets linearization automatically, since resetting the blocks\nresets their internal operators.</p>\n<p>Afterwards the system function is evaluated with '_update' to update\nthe block inputs and outputs.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>time <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>simulation time for reset</dd>\n</dl>\n",
              "source": "def reset(self, time=0.0):\n    \"\"\"Reset the blocks to their initial state and the global time of \n    the simulation. \n\n    For recording blocks such as 'Scope', their recorded \n    data is also reset. \n\n    Resets linearization automatically, since resetting the blocks \n    resets their internal operators.\n\n    Afterwards the system function is evaluated with '_update' to update\n    the block inputs and outputs.\n\n    Parameters\n    ----------\n    time : float\n        simulation time for reset\n    \"\"\"\n\n    self.logger.info(f\"RESET (time: {time})\")\n\n    #set active again\n    self._active = True\n\n    #reset simulation time\n    self.time = time\n\n    #reset integration engine\n    self.engine.reset()\n\n    #reset all blocks to initial state\n    for block in self.blocks:\n        block.reset()\n\n    #reset all event managers\n    for event in self.events:\n        event.reset()\n\n    #evaluate system function\n    self._update(self.time)",
              "signature": "(time = 0.0)",
              "parameters": [
                {
                  "name": "time",
                  "type": null,
                  "default": "0.0",
                  "description": "simulation time for reset"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "linearize",
              "description": "Linearize the full system in the current simulation state",
              "docstring_html": "<p>Linearize the full system in the current simulation state\nat the current simulation time.</p>\n<p>This is achieved by linearizing algebraic and dynamic operators\nof the internal blocks. See definition of the 'Block' class.</p>\n<p>Before linearization, the global system function is evaluated\nto get the blocks into the current simulation state.\nThis is only really relevant if no solving attempt has been\nhappened before.</p>\n",
              "source": "def linearize(self):\n    \"\"\"Linearize the full system in the current simulation state \n    at the current simulation time.\n\n    This is achieved by linearizing algebraic and dynamic operators \n    of the internal blocks. See definition of the 'Block' class.\n\n    Before linearization, the global system function is evaluated \n    to get the blocks into the current simulation state. \n    This is only really relevant if no solving attempt has been \n    happened before.\n    \"\"\"\n    #evaluate system function at current time\n    self._update(self.time)\n\n    #linearize all internal blocks and time it\n    with Timer(verbose=False) as T:\n        for block in self.blocks:\n            block.linearize(self.time)\n\n    self.logger.info(f\"LINEARIZED (runtime: {T})\")",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "delinearize",
              "description": "Revert the linearization of the full system.",
              "docstring_html": "<p>Revert the linearization of the full system.</p>\n",
              "source": "def delinearize(self):\n    \"\"\"Revert the linearization of the full system.\"\"\"\n    for block in self.blocks: \n        block.delinearize()\n\n    self.logger.info(\"DELINEARIZED\")",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "_get_active_events",
              "description": "Generator that yields all active events from simulation",
              "docstring_html": "<p>Generator that yields all active events from simulation\nand internal block events.</p>\n",
              "source": "def _get_active_events(self):\n    \"\"\"Generator that yields all active events from simulation\n    and internal block events.\n    \"\"\"\n    for event in self.events:\n        if event:\n            yield event\n    for block in self._blocks_evt:\n        for event in block.events:\n            if event:\n                yield event",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "_estimate_events",
              "description": "Estimate the time until the next.",
              "docstring_html": "<p>Estimate the time until the next.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time for event estimation</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>float | None</dt>\n<dd>esimated time until next event (delta)</dd>\n</dl>\n",
              "source": "def _estimate_events(self, t):\n    \"\"\"Estimate the time until the next.\n\n    Parameters\n    ----------\n    t : float \n        evaluation time for event estimation\n\n    Returns\n    -------\n    float | None\n        esimated time until next event (delta)\n    \"\"\"\n\n    dt_evt_min = None\n\n    #check external events\n    for event in self._get_active_events():\n\n        #get the estimate\n        dt_evt = event.estimate(self.time)\n\n        #no estimate available\n        if dt_evt is None: continue\n\n        #smaller than min\n        if dt_evt_min is None or dt_evt < dt_evt_min:\n            dt_evt_min = dt_evt\n\n    #return time until next event or None\n    return dt_evt_min",
              "signature": "(t)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time for event estimation"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "_detected_events",
              "description": "Check for possible (active) events and return them chronologically,",
              "docstring_html": "<p>Check for possible (active) events and return them chronologically,\nsorted by their timestep ratios (closest to the initial point in time).</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time for event function</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>detected <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">list[Event]</span></dt>\n<dd>list of detected events within timestep</dd>\n</dl>\n",
              "source": "def _detected_events(self, t):\n    \"\"\"Check for possible (active) events and return them chronologically, \n    sorted by their timestep ratios (closest to the initial point in time).\n\n    Parameters\n    ----------\n    t : float\n        evaluation time for event function\n\n    Returns\n    -------\n    detected : list[Event]\n        list of detected events within timestep\n    \"\"\"\n\n    #iterate all event managers\n    detected_events = []\n    for event in self._get_active_events():\n\n        #check if an event is detected\n        detected, close, ratio = event.detect(t)\n\n        #event was detected during the timestep \n        if detected:\n            detected_events.append([event, close, ratio])\n\n    #return detected events sorted by ratio\n    return sorted(detected_events, key=lambda e: e[-1])",
              "signature": "(t)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time for event function"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "_update",
              "description": "Distribute information within the system by evaluating the directed acyclic graph",
              "docstring_html": "<p>Distribute information within the system by evaluating the directed acyclic graph\n(DAG) formed by the algebraic passthroughs of the blocks and resolving algebraic loops\nthrough accelerated fixed-point iterations.</p>\n<p>Effectively evaluates the right hand side function of the global\nsystem ODE/DAE</p>\n<pre class=\"math\">\n\\begin{equnarray}\n    \\dot{x} &amp;= f(x, t) \\\\\n           0 &amp;= g(x, t)\n\\end{equnarray}\n</pre>\n<p>by converging the whole system (´f´ and ´g´) to a fixed-point at a given point\nin time ´t´.</p>\n<p>If no algebraic loops are present in the system, convergence is\nguaranteed after the first stage (evaluation of the DAG in '_dag').</p>\n<p>Otherwise, accelerated fixed-point iterations ('_loops') are performed as a second\nstage on the DAGs (broken cycles) of blocks that are part of or tainted by upstream\nalgebraic loops.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time for system function</dd>\n</dl>\n",
              "source": "def _update(self, t):        \n    \"\"\"Distribute information within the system by evaluating the directed acyclic graph \n    (DAG) formed by the algebraic passthroughs of the blocks and resolving algebraic loops \n    through accelerated fixed-point iterations.\n\n    Effectively evaluates the right hand side function of the global \n    system ODE/DAE\n\n    .. math:: \n\n        \\\\begin{equnarray}\n            \\\\dot{x} &= f(x, t) \\\\\\\\\n                   0 &= g(x, t) \n        \\\\end{equnarray}\n\n    by converging the whole system (´f´ and ´g´) to a fixed-point at a given point \n    in time ´t´.\n\n    If no algebraic loops are present in the system, convergence is \n    guaranteed after the first stage (evaluation of the DAG in '_dag'). \n\n    Otherwise, accelerated fixed-point iterations ('_loops') are performed as a second \n    stage on the DAGs (broken cycles) of blocks that are part of or tainted by upstream \n    algebraic loops. \n\n    Parameters\n    ----------\n    t : float\n        evaluation time for system function\n    \"\"\"\n\n    #evaluate DAG\n    self._dag(t)\n\n    #algebraic loops -> solve them\n    if self.graph.has_loops:   \n        self._loops(t)",
              "signature": "(t)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time for system function"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "_dag",
              "description": "Update the directed acyclic graph components of the system.",
              "docstring_html": "<p>Update the directed acyclic graph components of the system.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time for system function</dd>\n</dl>\n",
              "source": "def _dag(self, t):\n    \"\"\"Update the directed acyclic graph components of the system.\n\n    Parameters\n    ----------\n    t : float\n        evaluation time for system function\n    \"\"\"\n\n    #perform gauss-seidel iterations without error checking\n    for _, blocks_dag, connections_dag in self.graph.dag():\n\n        #update blocks at algebraic depth (no error control)\n        for block in blocks_dag:\n            if block: block.update(t)\n\n        #update connenctions at algebraic depth (data transfer)\n        for connection in connections_dag:\n            if connection: connection.update()",
              "signature": "(t)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time for system function"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "_loops",
              "description": "Perform the algebraic loop solve of the system using accelerated",
              "docstring_html": "<p>Perform the algebraic loop solve of the system using accelerated\nfixed-point iterations on the broken loop directed graph.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time for system function</dd>\n</dl>\n",
              "source": "def _loops(self, t):\n    \"\"\"Perform the algebraic loop solve of the system using accelerated \n    fixed-point iterations on the broken loop directed graph.\n\n    Parameters\n    ----------\n    t : float\n        evaluation time for system function\n    \"\"\"\n\n    #reset accelerators of loop closing connections\n    for con_booster in self.boosters:\n        con_booster.reset()\n\n    #perform solver iterations on algebraic loops\n    for iteration in range(1, self.iterations_max):\n\n        #iterate DAG depths of broken loops\n        for _, blocks_loop, connections_loop in self.graph.loop():\n\n            #update blocks at algebraic depth\n            for block in blocks_loop:\n                if block: block.update(t)\n\n            #update connenctions at algebraic depth (data transfer)\n            for connection in connections_loop:\n                if connection: connection.update()\n\n        #step boosters of loop closing connections\n        max_err = 0.0\n        for con_booster in self.boosters:\n            err = con_booster.update()\n            if err > max_err:\n                max_err = err\n\n        #check convergence\n        if max_err <= self.tolerance_fpi:\n            return\n\n    #not converged -> error\n    _msg = \"algebraic loop not converged (iters: {}, err: {})\".format(\n        self.iterations_max, max_err\n        )\n    self.logger.error(_msg)\n    raise RuntimeError(_msg)",
              "signature": "(t)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time for system function"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "_solve",
              "description": "For implicit solvers, this method implements the solving step",
              "docstring_html": "<p>For implicit solvers, this method implements the solving step\nof the implicit update equation.</p>\n<p>It already involves the evaluation of the system equation with\nthe '_update' method within the loop.</p>\n<p>This also tracks the evolution of the solution as an estimate\nfor the convergence via the max residual norm of the fixed point\nequation of the previous solution.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time for system function</dd>\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>timestep</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>success <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>indicator if the timestep was successful</dd>\n<dt>total_evals <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>total number of system evaluations</dd>\n<dt>total_solver_its <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>total number of implicit solver iterations</dd>\n</dl>\n",
              "source": "def _solve(self, t, dt):\n    \"\"\"For implicit solvers, this method implements the solving step \n    of the implicit update equation.\n\n    It already involves the evaluation of the system equation with \n    the '_update' method within the loop.\n\n    This also tracks the evolution of the solution as an estimate \n    for the convergence via the max residual norm of the fixed point \n    equation of the previous solution.\n\n    Parameters\n    ----------\n    t : float\n        evaluation time for system function\n    dt : float\n        timestep\n\n    Returns\n    -------\n    success : bool\n        indicator if the timestep was successful\n    total_evals : int\n        total number of system evaluations\n    total_solver_its : int\n        total number of implicit solver iterations\n    \"\"\"\n\n    #total evaluations of system equation\n    total_evals = 0\n\n    #perform fixed-point iterations to solve implicit update equation\n    for it in range(self.iterations_max):\n\n        #evaluate system equation (this is a fixed point loop)\n        self._update(t)\n        total_evals += 1            \n\n        #advance solution of implicit solver\n        max_error = 0.0\n        for block in self._blocks_dyn:\n\n            #skip inactive blocks\n            if not block: \n                continue\n\n            #advance solution (internal optimizer)\n            error = block.solve(t, dt)\n            if error > max_error:\n                max_error = error\n\n        #check for convergence (only error)\n        if max_error <= self.tolerance_fpi:\n            return True, total_evals, it+1\n\n    #not converged in 'self.iterations_max' steps\n    return False, total_evals, self.iterations_max",
              "signature": "(t, dt)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time for system function"
                },
                {
                  "name": "dt",
                  "type": null,
                  "default": null,
                  "description": "timestep"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "steadystate",
              "description": "Find steady state solution (DC operating point) of the system",
              "docstring_html": "<p>Find steady state solution (DC operating point) of the system\nby switching all blocks to steady state solver, solving the\nfixed point equations, then switching back.</p>\n<p>The steady state solver forces all the temporal derivatives, i.e.\nthe right hand side equation (including external inputs) of the\nengines of dynamic blocks to zero.</p>\n<div class=\"section\" id=\"note\">\n<h4>Note</h4>\n<p>This is really a sort of pseudo-steady-state solve. It does NOT compute\nthe limit <tt class=\"math\">t\\rightarrow\\infty</tt> but rather forces all time\nderivatives to zero at a given moment in time.</p>\n<p>This means, for a given <cite>t</cite> it computes the block states <cite>x</cite> such that:</p>\n<pre class=\"math\">\n0 = f(x, t)\n</pre>\n<p>instead of the real steady state:</p>\n<pre class=\"math\">\n\\lim_{t \\rightarrow \\infty} x(t)\n</pre>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>reset <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>reset the simulation before solving for steady state (default False)</dd>\n</dl>\n</div>\n",
              "source": "def steadystate(self, reset=False): \n    \"\"\"Find steady state solution (DC operating point) of the system \n    by switching all blocks to steady state solver, solving the \n    fixed point equations, then switching back.\n\n    The steady state solver forces all the temporal derivatives, i.e.\n    the right hand side equation (including external inputs) of the \n    engines of dynamic blocks to zero.\n\n    Note\n    ----\n    This is really a sort of pseudo-steady-state solve. It does NOT compute \n    the limit :math:`t\\\\rightarrow\\\\infty` but rather forces all time \n    derivatives to zero at a given moment in time. \n\n    This means, for a given `t` it computes the block states `x` such that:\n\n    .. math:: \n\n        0 = f(x, t)\n\n    instead of the real steady state:\n\n    .. math:: \n\n        \\\\lim_{t \\\\rightarrow \\\\infty} x(t)\n\n\n    Parameters\n    ----------\n    reset : bool\n        reset the simulation before solving for steady state (default False)\n    \"\"\"\n\n    #reset the simulation before solving\n    if reset:\n        self.reset()\n\n    #current solver class\n    _solver = self.Solver\n\n    #switch to steady state solver\n    self._set_solver(SteadyState)\n\n    #log message begin of steady state solver\n    self.logger.info(f\"STEADYSTATE -> STARTING (reset: {reset})\")\n\n    #solve for steady state at current time\n    with Timer(verbose=False) as T:\n        success, evals, iters = self._solve(self.time, self.dt)\n\n    #catch non convergence\n    if not success:\n        _msg = \"STEADYSTATE -> FINISHED (success: {}, evals: {}, iters: {}, runtime: {})\".format(\n            success, evals, iters, T)\n        self.logger.error(_msg)\n        raise RuntimeError(_msg)\n\n    #sample result\n    self._sample(self.time, self.dt)\n\n    #log message\n    self.logger.info(\n        \"STEADYSTATE -> FINISHED (success: {}, evals: {}, iters: {}, runtime: {})\".format(\n            success, evals, iters, T)\n        )\n\n    #switch back to original solver\n    self._set_solver(_solver)",
              "signature": "(reset = False)",
              "parameters": [
                {
                  "name": "reset",
                  "type": null,
                  "default": "False",
                  "description": "reset the simulation before solving for steady state (default False)"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "_revert",
              "description": "Revert simulation state to previous timestep for adaptive solvers",
              "docstring_html": "<p>Revert simulation state to previous timestep for adaptive solvers\nwhen local truncation error is too large and timestep has to be\nretaken with smaller timestep.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time for simulation revert</dd>\n</dl>\n",
              "source": "def _revert(self, t):\n    \"\"\"Revert simulation state to previous timestep for adaptive solvers \n    when local truncation error is too large and timestep has to be \n    retaken with smaller timestep.\n\n    Parameters\n    ----------\n    t : float\n        evaluation time for simulation revert \n    \"\"\"\n\n    #revert dummy engine (for history, allways)\n    self.engine.revert()\n\n    #revert block states\n    for block in self._blocks_dyn:\n        if block: block.revert()\n\n    #update the simulation (evaluation of rhs)\n    self._update(t)",
              "signature": "(t)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time for simulation revert"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "_sample",
              "description": "Sample data from blocks that implement the 'sample' method such",
              "docstring_html": "<p>Sample data from blocks that implement the 'sample' method such\nas 'Scope', 'Delay' and the blocks that sample from a random\ndistribution at a given time 't'.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>time where to sample</dd>\n</dl>\n",
              "source": "def _sample(self, t, dt):\n    \"\"\"Sample data from blocks that implement the 'sample' method such \n    as 'Scope', 'Delay' and the blocks that sample from a random \n    distribution at a given time 't'.\n\n    Parameters\n    ----------\n    t : float\n        time where to sample\n    \"\"\"\n    for block in self.blocks:\n        if block: block.sample(t, dt)",
              "signature": "(t, dt)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "time where to sample"
                },
                {
                  "name": "dt",
                  "type": null,
                  "default": null,
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "_buffer",
              "description": "Buffer states for event monitoring and internal states of blocks",
              "docstring_html": "<p>Buffer states for event monitoring and internal states of blocks\nbefore the timestep is taken.</p>\n<p>For events, this is required to set reference for event monitoring and\nbacktracking for root finding.</p>\n<p>for blocks, this is required for runge-kutta integrators but also for the\nzero crossing detection of the event handling system. The timesteps are\nalso buffered because some integrators such as GEAR-type methods need a\nhistory of the timesteps.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time for buffering</dd>\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>timestep</dd>\n</dl>\n",
              "source": "def _buffer(self, t, dt):\n    \"\"\"Buffer states for event monitoring and internal states of blocks \n    before the timestep is taken. \n\n    For events, this is required to set reference for event monitoring and \n    backtracking for root finding.\n\n    for blocks, this is required for runge-kutta integrators but also for the \n    zero crossing detection of the event handling system. The timesteps are \n    also buffered because some integrators such as GEAR-type methods need a \n    history of the timesteps.\n\n    Parameters\n    ----------\n    t : float \n        evaluation time for buffering\n    dt : float\n        timestep\n    \"\"\"\n\n    #buffer states for event detection (with timestamp)\n    for event in self._get_active_events():\n        event.buffer(t)\n\n    #buffer the dummy engine (allways)\n    self.engine.buffer(dt)\n\n    #buffer internal states of stateful blocks\n    for block in self._blocks_dyn:\n        if block: block.buffer(dt)",
              "signature": "(t, dt)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time for buffering"
                },
                {
                  "name": "dt",
                  "type": null,
                  "default": null,
                  "description": "timestep"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "_step",
              "description": "Performs the 'step' method for dynamical blocks with internal",
              "docstring_html": "<p>Performs the 'step' method for dynamical blocks with internal\nstates that have a numerical integration engine.</p>\n<p>Collects the local truncation error estimates and the timestep\nrescale factor from the error controllers of the internal\nintergation engines if they provide an error estimate\n(for example embedded Runge-Kutta methods).</p>\n<p><strong>Notes</strong></p>\n<p>Not to be confused with the global 'step' method, the '_step'\nmethod executes the intermediate timesteps in multistage solvers\nsuch as Runge-Kutta methods.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time of dynamical timestepping</dd>\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>timestep</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>success <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>indicator if the timestep was successful</dd>\n<dt>max_error <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>maximum local truncation error from integration</dd>\n<dt>scale <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>rescale factor for timestep</dd>\n</dl>\n",
              "source": "def _step(self, t, dt):\n    \"\"\"Performs the 'step' method for dynamical blocks with internal \n    states that have a numerical integration engine. \n\n    Collects the local truncation error estimates and the timestep \n    rescale factor from the error controllers of the internal \n    intergation engines if they provide an error estimate \n    (for example embedded Runge-Kutta methods).\n\n    Notes\n    -----\n    Not to be confused with the global 'step' method, the '_step' \n    method executes the intermediate timesteps in multistage solvers \n    such as Runge-Kutta methods.\n\n    Parameters\n    ----------\n    t : float\n        evaluation time of dynamical timestepping\n    dt : float\n        timestep\n\n    Returns\n    -------\n    success : bool \n        indicator if the timestep was successful\n    max_error : float \n        maximum local truncation error from integration\n    scale : float\n        rescale factor for timestep\n    \"\"\"\n\n    #initial timestep rescale and error estimate\n    success, max_error_norm, min_scale = True, 0.0, None\n\n    #step blocks and get error estimates if available\n    for block in self._blocks_dyn:\n\n        #skip inactive blocks\n        if not block: continue\n\n        #step the block\n        suc, err_norm, scl = block.step(t, dt)\n\n        #check solver stepping success\n        if not suc:\n            success = False\n\n        #update error tracking\n        if err_norm > max_error_norm:\n            max_error_norm = err_norm\n\n        #track minimum relevant scale directly (avoids list allocation)\n        if scl is not None:\n            if min_scale is None or scl < min_scale:\n                min_scale = scl\n\n    return success, max_error_norm, min_scale if min_scale is not None else 1.0",
              "signature": "(t, dt)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time of dynamical timestepping"
                },
                {
                  "name": "dt",
                  "type": null,
                  "default": null,
                  "description": "timestep"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "timestep_fixed_explicit",
              "description": "Advances the simulation by one timestep 'dt' for explicit fixed step solvers.",
              "docstring_html": "<p>Advances the simulation by one timestep 'dt' for explicit fixed step solvers.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>timestep</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>success <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>indicator if the timestep was successful</dd>\n<dt>max_error <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>maximum local truncation error from integration</dd>\n<dt>scale <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>rescale factor for timestep</dd>\n<dt>total_evals <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>total number of system evaluations</dd>\n<dt>total_solver_its <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>total number of implicit solver iterations</dd>\n</dl>\n",
              "source": "@deprecated(version=\"1.0.0\", replacement=\"timestep\")\ndef timestep_fixed_explicit(self, dt=None):\n    \"\"\"Advances the simulation by one timestep 'dt' for explicit fixed step solvers.\n\n    Parameters\n    ----------\n    dt : float\n        timestep\n\n    Returns\n    -------\n    success : bool\n        indicator if the timestep was successful\n    max_error : float\n        maximum local truncation error from integration\n    scale : float\n        rescale factor for timestep\n    total_evals : int\n        total number of system evaluations\n    total_solver_its : int\n        total number of implicit solver iterations\n    \"\"\"\n    return self.timestep(dt, adaptive=False)",
              "signature": "(dt = None)",
              "parameters": [
                {
                  "name": "dt",
                  "type": null,
                  "default": "None",
                  "description": "timestep"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "timestep_fixed_implicit",
              "description": "Advances the simulation by one timestep 'dt' for implicit fixed step solvers.",
              "docstring_html": "<p>Advances the simulation by one timestep 'dt' for implicit fixed step solvers.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>timestep</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>success <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>indicator if the timestep was successful</dd>\n<dt>max_error <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>maximum local truncation error from integration</dd>\n<dt>scale <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>rescale factor for timestep</dd>\n<dt>total_evals <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>total number of system evaluations</dd>\n<dt>total_solver_its <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>total number of implicit solver iterations</dd>\n</dl>\n",
              "source": "@deprecated(version=\"1.0.0\", replacement=\"timestep\")\ndef timestep_fixed_implicit(self, dt=None):\n    \"\"\"Advances the simulation by one timestep 'dt' for implicit fixed step solvers.\n\n    Parameters\n    ----------\n    dt : float\n        timestep\n\n    Returns\n    -------\n    success : bool\n        indicator if the timestep was successful\n    max_error : float\n        maximum local truncation error from integration\n    scale : float\n        rescale factor for timestep\n    total_evals : int\n        total number of system evaluations\n    total_solver_its : int\n        total number of implicit solver iterations\n    \"\"\"\n    return self.timestep(dt, adaptive=False)",
              "signature": "(dt = None)",
              "parameters": [
                {
                  "name": "dt",
                  "type": null,
                  "default": "None",
                  "description": "timestep"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "timestep_adaptive_explicit",
              "description": "Advances the simulation by one timestep 'dt' for explicit adaptive solvers.",
              "docstring_html": "<p>Advances the simulation by one timestep 'dt' for explicit adaptive solvers.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>timestep</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>success <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>indicator if the timestep was successful</dd>\n<dt>max_error <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>maximum local truncation error from integration</dd>\n<dt>scale <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>rescale factor for timestep</dd>\n<dt>total_evals <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>total number of system evaluations</dd>\n<dt>total_solver_its <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>total number of implicit solver iterations</dd>\n</dl>\n",
              "source": "@deprecated(version=\"1.0.0\", replacement=\"timestep\")\ndef timestep_adaptive_explicit(self, dt=None):\n    \"\"\"Advances the simulation by one timestep 'dt' for explicit adaptive solvers.\n\n    Parameters\n    ----------\n    dt : float\n        timestep\n\n    Returns\n    -------\n    success : bool\n        indicator if the timestep was successful\n    max_error : float\n        maximum local truncation error from integration\n    scale : float\n        rescale factor for timestep\n    total_evals : int\n        total number of system evaluations\n    total_solver_its : int\n        total number of implicit solver iterations\n    \"\"\"\n    return self.timestep(dt, adaptive=True)",
              "signature": "(dt = None)",
              "parameters": [
                {
                  "name": "dt",
                  "type": null,
                  "default": "None",
                  "description": "timestep"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "timestep_adaptive_implicit",
              "description": "Advances the simulation by one timestep 'dt' for implicit adaptive solvers.",
              "docstring_html": "<p>Advances the simulation by one timestep 'dt' for implicit adaptive solvers.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>timestep</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>success <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>indicator if the timestep was successful</dd>\n<dt>max_error <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>maximum local truncation error from integration</dd>\n<dt>scale <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>rescale factor for timestep</dd>\n<dt>total_evals <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>total number of system evaluations</dd>\n<dt>total_solver_its <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>total number of implicit solver iterations</dd>\n</dl>\n",
              "source": "@deprecated(version=\"1.0.0\", replacement=\"timestep\")\ndef timestep_adaptive_implicit(self, dt=None):\n    \"\"\"Advances the simulation by one timestep 'dt' for implicit adaptive solvers.\n\n    Parameters\n    ----------\n    dt : float\n        timestep\n\n    Returns\n    -------\n    success : bool\n        indicator if the timestep was successful\n    max_error : float\n        maximum local truncation error from integration\n    scale : float\n        rescale factor for timestep\n    total_evals : int\n        total number of system evaluations\n    total_solver_its : int\n        total number of implicit solver iterations\n    \"\"\"\n    return self.timestep(dt, adaptive=True)",
              "signature": "(dt = None)",
              "parameters": [
                {
                  "name": "dt",
                  "type": null,
                  "default": "None",
                  "description": "timestep"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "timestep",
              "description": "Advances the transient simulation by one timestep 'dt'.",
              "docstring_html": "<p>Advances the transient simulation by one timestep 'dt'.</p>\n<p>Automatic behavior selection based on selected <cite>Solver</cite> and <cite>adaptive</cite> flag:</p>\n<ul class=\"simple\">\n<li>Explicit solvers: Uses <cite>_update()</cite> for system evaluation</li>\n<li>Implicit solvers: Uses <cite>_solve()</cite> for implicit update equation</li>\n<li>Adaptive solvers (with adaptive=True): Reverts timestep if error too large\nor event not close</li>\n<li>Fixed solvers (or adaptive=False): Always completes timestep, resolves\nevents at detected time</li>\n</ul>\n<p>If discrete events are detected, they are handled according to stepping mode:</p>\n<ul class=\"simple\">\n<li>Fixed stepping: Events resolved at interpolated time within step</li>\n<li>Adaptive stepping: Events approached via timestep rescaling (secant method)</li>\n</ul>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>timestep size for transient simulation</dd>\n<dt>adaptive <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>explicitly enable/disable adaptive timestepping; when False, adaptive\nsolvers are forced to take fixed steps without error control (default True)</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>success <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>indicator if the timestep was successful</dd>\n<dt>max_error <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>maximum local truncation error from integration</dd>\n<dt>scale <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>rescale factor for timestep</dd>\n<dt>total_evals <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>total number of system evaluations</dd>\n<dt>total_solver_its <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>total number of implicit solver iterations</dd>\n</dl>\n",
              "source": "def timestep(self, dt=None, adaptive=True):\n    \"\"\"Advances the transient simulation by one timestep 'dt'.\n\n    Automatic behavior selection based on selected `Solver` and `adaptive` flag:\n\n    - Explicit solvers: Uses `_update()` for system evaluation\n    - Implicit solvers: Uses `_solve()` for implicit update equation\n    - Adaptive solvers (with adaptive=True): Reverts timestep if error too large\n      or event not close\n    - Fixed solvers (or adaptive=False): Always completes timestep, resolves\n      events at detected time\n\n    If discrete events are detected, they are handled according to stepping mode:\n\n    - Fixed stepping: Events resolved at interpolated time within step\n    - Adaptive stepping: Events approached via timestep rescaling (secant method)\n\n    Parameters\n    ----------\n    dt : float\n        timestep size for transient simulation\n    adaptive : bool\n        explicitly enable/disable adaptive timestepping; when False, adaptive\n        solvers are forced to take fixed steps without error control (default True)\n\n    Returns\n    -------\n    success : bool\n        indicator if the timestep was successful\n    max_error : float\n        maximum local truncation error from integration\n    scale : float\n        rescale factor for timestep\n    total_evals : int\n        total number of system evaluations\n    total_solver_its : int\n        total number of implicit solver iterations\n    \"\"\"\n    #solver behavior flags (adaptive only if both flag and solver support it)\n    is_adaptive = adaptive and self.engine.is_adaptive\n    is_implicit = not self.engine.is_explicit\n\n    #stats tracking\n    total_evals, total_solver_its = 0, 0\n    error_norm, scale, success = 0.0, 1.0, True\n\n    #default global timestep as local timestep\n    if dt is None:\n        dt = self.dt\n\n    #buffer events and dynamic blocks before timestep\n    self._buffer(self.time, dt)\n\n    #solver stages iteration (skip if no dynamic blocks)\n    if self._blocks_dyn:\n        for time_stage in self.engine.stages(self.time, dt):\n\n            if is_implicit:\n                #implicit: solve update equation (contains _update internally)\n                success, evals, solver_its = self._solve(time_stage, dt)\n                total_evals += evals\n                total_solver_its += solver_its\n\n                #adaptive implicit: revert if solver didn't converge\n                if not success and is_adaptive:\n                    self._revert(self.time)\n                    return False, 0.0, 0.5, total_evals + 1, total_solver_its\n            else:\n                #explicit: evaluate system equation\n                self._update(time_stage)\n                total_evals += 1\n\n            #step dynamic blocks, get error estimate\n            success, error_norm, scale = self._step(time_stage, dt)\n\n            #adaptive: revert if local truncation error too large\n            if not success and is_adaptive:\n                self._revert(self.time)\n                return False, error_norm, scale, total_evals + 1, total_solver_its\n\n    #system time after timestep\n    time_dt = self.time + dt\n\n    #evaluate system equation before event check\n    self._update(time_dt)\n    total_evals += 1\n\n    #handle detected events chronologically\n    for event, close, ratio in self._detected_events(time_dt):\n        if is_adaptive:\n            #adaptive: only resolve if close enough to event\n            if close:\n                event.resolve(time_dt)\n                self._update(time_dt)\n                total_evals += 1\n            else:\n                #not close: revert and use ratio as rescale\n                self._revert(self.time)\n                return False, error_norm, ratio, total_evals + 1, total_solver_its\n        else:\n            #fixed: resolve at interpolated time within step\n            event.resolve(self.time + ratio * dt)\n            self._update(time_dt)\n            total_evals += 1\n\n    #sample data after successful timestep\n    self._sample(time_dt, dt)\n\n    #increment global time\n    self.time = time_dt\n\n    return success, error_norm, scale, total_evals, total_solver_its",
              "signature": "(dt = None, adaptive = True)",
              "parameters": [
                {
                  "name": "dt",
                  "type": null,
                  "default": "None",
                  "description": "timestep size for transient simulation"
                },
                {
                  "name": "adaptive",
                  "type": null,
                  "default": "True",
                  "description": "explicitly enable/disable adaptive timestepping; when False, adaptive solvers are forced to take fixed steps without error control (default True)"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "step",
              "description": "Wraps 'Simulation.timestep' for backward compatibility",
              "docstring_html": "<p>Wraps 'Simulation.timestep' for backward compatibility</p>\n",
              "source": "def step(self, dt=None, adaptive=True):\n    \"\"\"Wraps 'Simulation.timestep' for backward compatibility\"\"\"\n    self.logger.warning(\n        \"'Simulation.step' method will be deprecated with release version 1.0.0, use 'Simulation.timestep' instead!\"\n        )\n    return self.timestep(dt, adaptive)",
              "signature": "(dt = None, adaptive = True)",
              "parameters": [
                {
                  "name": "dt",
                  "type": null,
                  "default": "None",
                  "description": ""
                },
                {
                  "name": "adaptive",
                  "type": null,
                  "default": "True",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "collect",
              "description": "Collect all current simulation results from the internal",
              "docstring_html": "<p>Collect all current simulation results from the internal\nrecording blocks</p>\n<p><strong>Returns</strong></p>\n<p>results : dict</p>\n",
              "source": "@deprecated(version=\"1.0.0\", reason=\"its against pathsims philosophy\")\ndef collect(self):\n    \"\"\"Collect all current simulation results from the internal \n    recording blocks\n\n    Returns\n    -------\n    results : dict\n    \"\"\"\n    scopes, spectra = {}, {}\n    for block in self.blocks:\n        for _category, _id, _data in block.collect():\n            if _category == \"scope\":\n                scopes[_id] = _data\n            elif _category == \"spectrum\":\n                spectra[_id] = _data\n    return {\"scopes\": scopes, \"spectra\": spectra}",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "stop",
              "description": "Set the flag for active simulation to 'False', intended to be",
              "docstring_html": "<p>Set the flag for active simulation to 'False', intended to be\ncalled from the outside (for example by events) to interrupt the\ntimestepping loop in 'run'.</p>\n",
              "source": "def stop(self):\n    \"\"\"Set the flag for active simulation to 'False', intended to be\n    called from the outside (for example by events) to interrupt the\n    timestepping loop in 'run'.\n    \"\"\"\n    self._active = False",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "_run_loop",
              "description": "Core simulation loop generator that yields after each timestep.",
              "docstring_html": "<p>Core simulation loop generator that yields after each timestep.</p>\n<p>This internal method contains the shared simulation logic used by\n'run', 'run_streaming', and 'run_realtime'. It handles initialization,\ntimestepping, adaptive rescaling, and progress tracking.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>duration <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>simulation time (in time units)</dd>\n<dt>reset <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>reset the simulation before running</dd>\n<dt>adaptive <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>use adaptive timesteps if solver is adaptive</dd>\n<dt>tracker <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">ProgressTracker | None</span></dt>\n<dd>optional progress tracker for logging</dd>\n</dl>\n<p><strong>Yields</strong></p>\n<dl class=\"docutils\">\n<dt>step_info <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">dict</span></dt>\n<dd>dictionary containing 'progress', 'success', and 'dt' for each step</dd>\n</dl>\n",
              "source": "def _run_loop(self, duration, reset, adaptive, tracker=None):\n    \"\"\"Core simulation loop generator that yields after each timestep.\n\n    This internal method contains the shared simulation logic used by\n    'run', 'run_streaming', and 'run_realtime'. It handles initialization,\n    timestepping, adaptive rescaling, and progress tracking.\n\n    Parameters\n    ----------\n    duration : float\n        simulation time (in time units)\n    reset : bool\n        reset the simulation before running\n    adaptive : bool\n        use adaptive timesteps if solver is adaptive\n    tracker : ProgressTracker | None\n        optional progress tracker for logging\n\n    Yields\n    ------\n    step_info : dict\n        dictionary containing 'progress', 'success', and 'dt' for each step\n    \"\"\"\n\n    #set simulation active\n    self._active = True\n\n    #reset the simulation before running it\n    if reset:\n        self.reset()\n\n    #make an adaptive run?\n    _adaptive = adaptive and self.engine.is_adaptive\n\n    #simulation start and end time\n    start_time, end_time = self.time, self.time + duration\n\n    #effective timestep for duration\n    _dt = self.dt\n\n    #initial system function evaluation\n    self._update(self.time)\n\n    #catch and resolve initial events\n    for event, *_ in self._detected_events(self.time):\n\n        #resolve events directly\n        event.resolve(self.time)\n\n        #evaluate system function again -> propagate event\n        self._update(self.time)\n\n    #sampling states and inputs at 'self.time == starting_time'\n    self._sample(self.time, _dt)\n\n    #main simulation loop\n    while self.time < end_time and self._active:\n\n        #advance the simulation by one (effective) timestep '_dt'\n        success, error_norm, scale, *_ = self.timestep(\n            dt=_dt,\n            adaptive=_adaptive\n            )\n\n        #perform adaptive rescale\n        if _adaptive:\n\n            #if no error estimate and rescale -> back to default timestep\n            if not error_norm and scale == 1:\n                _dt = self.dt\n\n            #rescale due to error control\n            _dt = scale * _dt\n\n            #estimate time until next event and adjust timestep\n            _dt_evt = self._estimate_events(self.time)\n            if _dt_evt is not None and _dt_evt < _dt:\n                _dt = _dt_evt\n\n            #rescale if in danger of overshooting 'end_time' at next step\n            if self.time + _dt > end_time:\n                _dt = end_time - self.time\n\n            #apply bounds to timestep after rescale\n            _dt = np.clip(_dt, self.dt_min, self.dt_max)\n\n        #compute simulation progress\n        progress = np.clip((self.time - start_time) / duration, 0.0, 1.0)\n\n        #update the tracker if provided\n        if tracker:\n            tracker.update(progress, success=success)\n\n        #yield step information\n        yield {'progress': progress, 'success': success, 'dt': _dt}\n\n    #handle interrupt\n    if tracker and not self._active:\n        tracker.interrupt()",
              "signature": "(duration, reset, adaptive, tracker = None)",
              "parameters": [
                {
                  "name": "duration",
                  "type": null,
                  "default": null,
                  "description": "simulation time (in time units)"
                },
                {
                  "name": "reset",
                  "type": null,
                  "default": null,
                  "description": "reset the simulation before running"
                },
                {
                  "name": "adaptive",
                  "type": null,
                  "default": null,
                  "description": "use adaptive timesteps if solver is adaptive"
                },
                {
                  "name": "tracker",
                  "type": null,
                  "default": "None",
                  "description": "optional progress tracker for logging"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "run",
              "description": "Perform multiple simulation timesteps for a given 'duration'.",
              "docstring_html": "<p>Perform multiple simulation timesteps for a given 'duration'.</p>\n<p>Tracks the total number of block evaluations (proxy for function\ncalls, although larger, since one function call of the system equation\nconsists of many block evaluations) and the total number of solver\niterations for implicit solvers.</p>\n<p>Additionally the progress of the simulation is tracked by a custom\n'ProgressTracker' class that is a dynamic generator and interfaces\nthe logging system.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>duration <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>simulation time (in time units)</dd>\n<dt>reset <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>reset the simulation before running (default False)</dd>\n<dt>adaptive <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>use adaptive timesteps if solver is adaptive (default True)</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>stats <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">dict</span></dt>\n<dd>stats of simulation run tracked by the 'ProgressTracker'</dd>\n</dl>\n",
              "source": "def run(self, duration=10, reset=False, adaptive=True):\n    \"\"\"Perform multiple simulation timesteps for a given 'duration'.\n\n    Tracks the total number of block evaluations (proxy for function\n    calls, although larger, since one function call of the system equation\n    consists of many block evaluations) and the total number of solver\n    iterations for implicit solvers.\n\n    Additionally the progress of the simulation is tracked by a custom\n    'ProgressTracker' class that is a dynamic generator and interfaces\n    the logging system.\n\n    Parameters\n    ----------\n    duration : float\n        simulation time (in time units)\n    reset : bool\n        reset the simulation before running (default False)\n    adaptive : bool\n        use adaptive timesteps if solver is adaptive (default True)\n\n    Returns\n    -------\n    stats : dict\n        stats of simulation run tracked by the 'ProgressTracker'\n    \"\"\"\n\n    #initialize progress tracker\n    tracker = ProgressTracker(\n        total_duration=duration,\n        description=\"TRANSIENT\",\n        logger=self.logger,\n        log=self.log\n        )\n\n    #enter tracker context and consume the run loop\n    with tracker:\n        for _ in self._run_loop(duration, reset, adaptive, tracker=tracker):\n            pass\n\n    return tracker.stats",
              "signature": "(duration = 10, reset = False, adaptive = True)",
              "parameters": [
                {
                  "name": "duration",
                  "type": null,
                  "default": "10",
                  "description": "simulation time (in time units)"
                },
                {
                  "name": "reset",
                  "type": null,
                  "default": "False",
                  "description": "reset the simulation before running (default False)"
                },
                {
                  "name": "adaptive",
                  "type": null,
                  "default": "True",
                  "description": "use adaptive timesteps if solver is adaptive (default True)"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "run_streaming",
              "description": "Perform simulation with streaming output at a fixed wall-clock rate.",
              "docstring_html": "<p>Perform simulation with streaming output at a fixed wall-clock rate.</p>\n<p>This method runs the simulation as fast as possible while yielding\nintermediate results at a fixed rate defined by 'tickrate'. Useful\nfor real-time visualization and UI updates.</p>\n<p>The progress is tracked and logged using the 'ProgressTracker' class.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>duration <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>simulation time (in time units)</dd>\n<dt>reset <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>reset the simulation before running (default False)</dd>\n<dt>adaptive <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>use adaptive timesteps if solver is adaptive (default True)</dd>\n<dt>tickrate <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>output rate in Hz, i.e., yields per second of wall-clock time\n(default 10)</dd>\n<dt>func_callback <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">callable | None</span></dt>\n<dd>callback function that is called at every tick, can be used\nfor data extraction, its return value is yielded by this generator</dd>\n</dl>\n<p><strong>Yields</strong></p>\n<dl class=\"docutils\">\n<dt>result</dt>\n<dd>The return value of the 'func_callback' callable.</dd>\n</dl>\n",
              "source": "def run_streaming(self, duration=10, reset=False, adaptive=True, tickrate=10, func_callback=None):\n    \"\"\"Perform simulation with streaming output at a fixed wall-clock rate.\n\n    This method runs the simulation as fast as possible while yielding\n    intermediate results at a fixed rate defined by 'tickrate'. Useful\n    for real-time visualization and UI updates.\n\n    The progress is tracked and logged using the 'ProgressTracker' class.\n\n    Parameters\n    ----------\n    duration : float\n        simulation time (in time units)\n    reset : bool\n        reset the simulation before running (default False)\n    adaptive : bool\n        use adaptive timesteps if solver is adaptive (default True)\n    tickrate : float\n        output rate in Hz, i.e., yields per second of wall-clock time\n        (default 10)\n    func_callback : callable | None\n        callback function that is called at every tick, can be used \n        for data extraction, its return value is yielded by this generator\n\n    Yields\n    ------\n    result \n        The return value of the 'func_callback' callable. \n    \"\"\"\n\n    #initialize progress tracker\n    tracker = ProgressTracker(\n        total_duration=duration,\n        description=\"STREAMING\",\n        logger=self.logger,\n        log=self.log\n        )\n\n    #streaming timing setup\n    tick_interval = 1.0 / tickrate\n    last_tick = time.perf_counter()\n\n    #enter tracker context\n    with tracker:\n\n        #iterate the core simulation loop\n        for step in self._run_loop(duration, reset, adaptive, tracker=tracker):\n\n            #check if enough wall-clock time has passed\n            now = time.perf_counter()\n            if now - last_tick >= tick_interval:\n                last_tick = now\n\n                #yield intermediate results\n                yield func_callback() if callable(func_callback) else None\n\n        #final yield with complete results\n        yield func_callback() if callable(func_callback) else None",
              "signature": "(duration = 10, reset = False, adaptive = True, tickrate = 10, func_callback = None)",
              "parameters": [
                {
                  "name": "duration",
                  "type": null,
                  "default": "10",
                  "description": "simulation time (in time units)"
                },
                {
                  "name": "reset",
                  "type": null,
                  "default": "False",
                  "description": "reset the simulation before running (default False)"
                },
                {
                  "name": "adaptive",
                  "type": null,
                  "default": "True",
                  "description": "use adaptive timesteps if solver is adaptive (default True)"
                },
                {
                  "name": "tickrate",
                  "type": null,
                  "default": "10",
                  "description": "output rate in Hz, i.e., yields per second of wall-clock time (default 10)"
                },
                {
                  "name": "func_callback",
                  "type": null,
                  "default": "None",
                  "description": "callback function that is called at every tick, can be used for data extraction, its return value is yielded by this generator"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "run_realtime",
              "description": "Perform simulation paced to wall-clock time.",
              "docstring_html": "<p>Perform simulation paced to wall-clock time.</p>\n<p>This method runs the simulation synchronized to real time, optionally\nscaled by 'speed'. The simulation advances to match elapsed wall-clock\ntime, yielding results at the rate defined by 'tickrate'.</p>\n<p>Useful for interactive simulations, hardware-in-the-loop testing,\nor when simulation should match real-world timing.</p>\n<p>The progress is tracked and logged using the 'ProgressTracker' class.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>duration <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>simulation time (in time units)</dd>\n<dt>reset <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>reset the simulation before running (default False)</dd>\n<dt>adaptive <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>use adaptive timesteps if solver is adaptive (default True)</dd>\n<dt>tickrate <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>output rate in Hz, i.e., yields per second of wall-clock time\n(default 30)</dd>\n<dt>speed <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>time scaling factor where 1.0 is real-time, 2.0 is twice as fast,\n0.5 is half speed (default 1.0)</dd>\n<dt>func_callback <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">callable | None</span></dt>\n<dd>callback function that is called at every tick, can be used\nfor data extraction, its return value is yielded by this generator</dd>\n</dl>\n<p><strong>Yields</strong></p>\n<dl class=\"docutils\">\n<dt>result</dt>\n<dd>The return value of the 'func_callback' callable.</dd>\n</dl>\n",
              "source": "def run_realtime(self, duration=10, reset=False, adaptive=True, tickrate=30, speed=1.0, func_callback=None):\n    \"\"\"Perform simulation paced to wall-clock time.\n\n    This method runs the simulation synchronized to real time, optionally\n    scaled by 'speed'. The simulation advances to match elapsed wall-clock\n    time, yielding results at the rate defined by 'tickrate'.\n\n    Useful for interactive simulations, hardware-in-the-loop testing,\n    or when simulation should match real-world timing.\n\n    The progress is tracked and logged using the 'ProgressTracker' class.\n\n    Parameters\n    ----------\n    duration : float\n        simulation time (in time units)\n    reset : bool\n        reset the simulation before running (default False)\n    adaptive : bool\n        use adaptive timesteps if solver is adaptive (default True)\n    tickrate : float\n        output rate in Hz, i.e., yields per second of wall-clock time\n        (default 30)\n    speed : float\n        time scaling factor where 1.0 is real-time, 2.0 is twice as fast,\n        0.5 is half speed (default 1.0)\n    func_callback : callable | None\n        callback function that is called at every tick, can be used \n        for data extraction, its return value is yielded by this generator\n\n    Yields\n    ------\n    result \n        The return value of the 'func_callback' callable. \n    \"\"\"\n\n    #initialize progress tracker\n    tracker = ProgressTracker(\n        total_duration=duration,\n        description=\"REALTIME\",\n        logger=self.logger,\n        log=self.log\n        )\n\n    #realtime timing setup\n    tick_interval = 1.0 / tickrate\n    last_tick = time.perf_counter()\n    start_wall = time.perf_counter()\n    start_sim = self.time\n\n    #enter tracker context\n    with tracker:\n\n        #create the core simulation loop generator\n        loop = self._run_loop(duration, reset, adaptive, tracker=tracker)\n\n        #realtime pacing loop\n        while self._active:\n\n            #compute target simulation time based on wall-clock\n            wall_elapsed = time.perf_counter() - start_wall\n            target_time = start_sim + wall_elapsed * speed\n\n            #advance simulation until caught up with target time\n            try:\n                while self.time < target_time:\n                    next(loop)\n            except StopIteration:\n                break\n\n            #check if enough wall-clock time has passed for yield\n            now = time.perf_counter()\n            if now - last_tick >= tick_interval:\n                last_tick = now\n\n                #compute progress\n                progress = (self.time - start_sim) / duration\n\n                #yield intermediate results\n                yield func_callback() if callable(func_callback) else None\n\n            #small sleep to avoid busy-waiting\n            time.sleep(0.001)\n\n        #final yield with complete results\n        yield func_callback() if callable(func_callback) else None",
              "signature": "(duration = 10, reset = False, adaptive = True, tickrate = 30, speed = 1.0, func_callback = None)",
              "parameters": [
                {
                  "name": "duration",
                  "type": null,
                  "default": "10",
                  "description": "simulation time (in time units)"
                },
                {
                  "name": "reset",
                  "type": null,
                  "default": "False",
                  "description": "reset the simulation before running (default False)"
                },
                {
                  "name": "adaptive",
                  "type": null,
                  "default": "True",
                  "description": "use adaptive timesteps if solver is adaptive (default True)"
                },
                {
                  "name": "tickrate",
                  "type": null,
                  "default": "30",
                  "description": "output rate in Hz, i.e., yields per second of wall-clock time (default 30)"
                },
                {
                  "name": "speed",
                  "type": null,
                  "default": "1.0",
                  "description": "time scaling factor where 1.0 is real-time, 2.0 is twice as fast, 0.5 is half speed (default 1.0)"
                },
                {
                  "name": "func_callback",
                  "type": null,
                  "default": "None",
                  "description": "callback function that is called at every tick, can be used for data extraction, its return value is yielded by this generator"
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "blocks",
              "description": "",
              "type": null,
              "value": "set()"
            },
            {
              "name": "connections",
              "description": "",
              "type": null,
              "value": "set()"
            },
            {
              "name": "events",
              "description": "",
              "type": null,
              "value": "set()"
            },
            {
              "name": "dt",
              "description": "",
              "type": null,
              "value": "dt"
            },
            {
              "name": "dt_min",
              "description": "",
              "type": null,
              "value": "dt_min"
            },
            {
              "name": "dt_max",
              "description": "",
              "type": null,
              "value": "dt_max"
            },
            {
              "name": "Solver",
              "description": "",
              "type": null,
              "value": "Solver"
            },
            {
              "name": "engine",
              "description": "",
              "type": null,
              "value": "Solver()"
            },
            {
              "name": "graph",
              "description": "",
              "type": null,
              "value": "None"
            },
            {
              "name": "boosters",
              "description": "",
              "type": null,
              "value": "None"
            },
            {
              "name": "tolerance_fpi",
              "description": "",
              "type": null,
              "value": "tolerance_fpi"
            },
            {
              "name": "solver_kwargs",
              "description": "",
              "type": null,
              "value": "solver_kwargs"
            },
            {
              "name": "iterations_max",
              "description": "",
              "type": null,
              "value": "iterations_max"
            },
            {
              "name": "log",
              "description": "",
              "type": null,
              "value": "log"
            },
            {
              "name": "time",
              "description": "",
              "type": null,
              "value": "0.0"
            },
            {
              "name": "_blocks_dyn",
              "description": "",
              "type": null,
              "value": "set()"
            },
            {
              "name": "_blocks_evt",
              "description": "",
              "type": null,
              "value": "set()"
            },
            {
              "name": "_active",
              "description": "",
              "type": null,
              "value": "True"
            },
            {
              "name": "logger",
              "description": "",
              "type": null,
              "value": "logger_mgr.get_logger('simulation')"
            },
            {
              "name": "size",
              "description": "Get size information of the simulation, such as total number",
              "type": null,
              "value": null
            }
          ],
          "parameters": [
            {
              "name": "blocks",
              "type": null,
              "default": "None",
              "description": "blocks that define the system"
            },
            {
              "name": "connections",
              "type": null,
              "default": "None",
              "description": "connections that connect the blocks"
            },
            {
              "name": "events",
              "type": null,
              "default": "None",
              "description": "list of event trackers (zero crossing detection, schedule, etc.)"
            },
            {
              "name": "dt",
              "type": null,
              "default": "SIM_TIMESTEP",
              "description": "transient simulation timestep in time units, default see ´SIM_TIMESTEP´ in ´_constants.py´"
            },
            {
              "name": "dt_min",
              "type": null,
              "default": "SIM_TIMESTEP_MIN",
              "description": "lower bound for transient simulation timestep, default see ´SIM_TIMESTEP_MIN´ in ´_constants.py´"
            },
            {
              "name": "dt_max",
              "type": null,
              "default": "SIM_TIMESTEP_MAX",
              "description": "upper bound for transient simulation timestep, default see ´SIM_TIMESTEP_MAX´ in ´_constants.py´"
            },
            {
              "name": "Solver",
              "type": null,
              "default": "SSPRK22",
              "description": "ODE solver class for numerical integration from ´pathsim.solvers´, default is ´pathsim.solvers.ssprk22.SSPRK22´ (2nd order expl. Runge Kutta)"
            },
            {
              "name": "tolerance_fpi",
              "type": null,
              "default": "SIM_TOLERANCE_FPI",
              "description": "absolute tolerance for convergence of algebraic loops and internal optimizers of implicit ODE solvers, default see ´SIM_TOLERANCE_FPI´ in ´_constants.py´"
            },
            {
              "name": "iterations_max",
              "type": null,
              "default": "SIM_ITERATIONS_MAX",
              "description": "maximum allowed number of iterations for implicit ODE solver optimizers and algebraic loop solver, default see ´SIM_ITERATIONS_MAX´ in ´_constants.py´"
            },
            {
              "name": "log",
              "type": null,
              "default": "LOG_ENABLE",
              "description": "flag to enable logging, default see ´LOG_ENABLE´ in ´_constants.py´ (alternatively a path to a log file can be specified)"
            },
            {
              "name": "solver_kwargs",
              "type": null,
              "default": "{}",
              "description": "additional parameters for numerical solvers such as absolute (´tolerance_lte_abs´) and relative (´tolerance_lte_rel´) tolerance, defaults are defined in ´_constants.py´"
            }
          ]
        }
      ],
      "functions": []
    },
    "pathsim.subsystem": {
      "name": "pathsim.subsystem",
      "description": "",
      "docstring_html": "",
      "classes": [
        {
          "name": "Interface",
          "description": "Bare-bone block that serves as a data interface for the 'Subsystem' class.",
          "docstring_html": "<p>Bare-bone block that serves as a data interface for the 'Subsystem' class.</p>\n<p>It works like this:</p>\n<ul class=\"simple\">\n<li>Internal blocks of the subsystem are connected to the inputs and outputs\nof this Interface block via the internal connections.</li>\n<li>It behaves like a normal block (inherits the main 'Block' class methods).</li>\n<li>It implements some special methods to get and set the inputs and outputs\nof the blocks, that are used to translate between the internal blocks of the\nsubsystem and the inputs and outputs of the subsystem.</li>\n<li>Handles data transfer to and from the internal subsystem blocks\nto and from the inputs and outputs of the subsystem.</li>\n</ul>\n",
          "source": "class Interface(Block):\n    \"\"\"Bare-bone block that serves as a data interface for the 'Subsystem' class.\n\n    It works like this:\n\n    - Internal blocks of the subsystem are connected to the inputs and outputs \n      of this Interface block via the internal connections.\n    - It behaves like a normal block (inherits the main 'Block' class methods).\n    - It implements some special methods to get and set the inputs and outputs \n      of the blocks, that are used to translate between the internal blocks of the \n      subsystem and the inputs and outputs of the subsystem.\n    - Handles data transfer to and from the internal subsystem blocks \n      to and from the inputs and outputs of the subsystem.\n    \"\"\"\n    def __len__(self):\n        return 0\n\n\n    def register_port_map(self, port_map_in, port_map_out):\n        \"\"\"Update the input and output registers of the interface block with port mappings\n\n        Parameters\n        ----------\n        port_map_in : dict[str: int]\n            port alias mapping for block inputs\n        port_map_out : dict[str: int]\n            port alias mapping for block outputs\n        \"\"\"\n        self.input_port_labels = port_map_in\n        self.output_port_labels = port_map_out\n\n        #build registers with mappings\n        self.inputs = Register(mapping=port_map_in)\n        self.outputs = Register(mapping=port_map_out)",
          "bases": [
            "pathsim.blocks._block.Block"
          ],
          "methods": [
            {
              "name": "register_port_map",
              "description": "Update the input and output registers of the interface block with port mappings",
              "docstring_html": "<p>Update the input and output registers of the interface block with port mappings</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>port_map_in <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">dict[str: int]</span></dt>\n<dd>port alias mapping for block inputs</dd>\n<dt>port_map_out <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">dict[str: int]</span></dt>\n<dd>port alias mapping for block outputs</dd>\n</dl>\n",
              "source": "def register_port_map(self, port_map_in, port_map_out):\n    \"\"\"Update the input and output registers of the interface block with port mappings\n\n    Parameters\n    ----------\n    port_map_in : dict[str: int]\n        port alias mapping for block inputs\n    port_map_out : dict[str: int]\n        port alias mapping for block outputs\n    \"\"\"\n    self.input_port_labels = port_map_in\n    self.output_port_labels = port_map_out\n\n    #build registers with mappings\n    self.inputs = Register(mapping=port_map_in)\n    self.outputs = Register(mapping=port_map_out)",
              "signature": "(port_map_in, port_map_out)",
              "parameters": [
                {
                  "name": "port_map_in",
                  "type": null,
                  "default": null,
                  "description": "port alias mapping for block inputs"
                },
                {
                  "name": "port_map_out",
                  "type": null,
                  "default": null,
                  "description": "port alias mapping for block outputs"
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [],
          "parameters": []
        },
        {
          "name": "Subsystem",
          "description": "Subsystem class that holds its own blocks and connecions and",
          "docstring_html": "<p>Subsystem class that holds its own blocks and connecions and\ncan natively interface with the main simulation loop.</p>\n<p>IO interface is realized by a special 'Interface' block, that has extra\nmethods for setting and getting inputs and outputs and serves\nas the interface of the internal blocks to the outside.</p>\n<p>The subsystem doesnt use its 'inputs' and 'outputs' dicts directly.\nIt exclusively handles data transfer via the 'Interface' block.</p>\n<p>This class can be used just like any other block during the simulation,\nsince it implements the required methods 'update' for the fixed-point\niteration (resolving algebraic loops with instant time blocks),\nthe 'step' method that performs timestepping (especially for dynamic\nblocks with internal states) and the 'solve' method for solving the\nimplicit update equation for implicit solvers.</p>\n<div class=\"section\" id=\"example\">\n<h4>Example</h4>\n<p>This is how we can wrap up multiple blocks within a subsystem.\nIn this case vanderpol system built from discrete components\ninstead of using an ODE block (in practice you should use\na monolithic ODE whenever possible due to performance).</p>\n<pre class=\"code python literal-block\">\n<span class=\"kn\">from</span><span class=\"w\"> </span><span class=\"nn\">pathsim</span><span class=\"w\"> </span><span class=\"kn\">import</span> <span class=\"n\">Subsystem</span><span class=\"p\">,</span> <span class=\"n\">Interface</span><span class=\"p\">,</span> <span class=\"n\">Connection</span><span class=\"w\">\n</span><span class=\"kn\">from</span><span class=\"w\"> </span><span class=\"nn\">pathsim.blocks</span><span class=\"w\"> </span><span class=\"kn\">import</span> <span class=\"n\">Integrator</span><span class=\"p\">,</span> <span class=\"n\">Function</span><span class=\"w\">\n\n</span><span class=\"c1\">#van der Pol parameter</span><span class=\"w\">\n</span><span class=\"n\">mu</span> <span class=\"o\">=</span> <span class=\"mi\">1000</span><span class=\"w\">\n\n</span><span class=\"c1\">#blocks in the subsystem</span><span class=\"w\">\n</span><span class=\"n\">If</span> <span class=\"o\">=</span> <span class=\"n\">Interface</span><span class=\"p\">()</span> <span class=\"c1\"># this is the interface to the outside</span><span class=\"w\">\n</span><span class=\"n\">I1</span> <span class=\"o\">=</span> <span class=\"n\">Integrator</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">)</span><span class=\"w\">\n</span><span class=\"n\">I2</span> <span class=\"o\">=</span> <span class=\"n\">Integrator</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">)</span><span class=\"w\">\n</span><span class=\"n\">Fn</span> <span class=\"o\">=</span> <span class=\"n\">Function</span><span class=\"p\">(</span><span class=\"k\">lambda</span> <span class=\"n\">x1</span><span class=\"p\">,</span> <span class=\"n\">x2</span><span class=\"p\">:</span> <span class=\"n\">mu</span><span class=\"o\">*</span><span class=\"p\">(</span><span class=\"mi\">1</span> <span class=\"o\">-</span> <span class=\"n\">x1</span><span class=\"o\">**</span><span class=\"mi\">2</span><span class=\"p\">)</span><span class=\"o\">*</span><span class=\"n\">x2</span> <span class=\"o\">-</span> <span class=\"n\">x1</span><span class=\"p\">)</span><span class=\"w\">\n\n</span><span class=\"n\">sub_blocks</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"n\">If</span><span class=\"p\">,</span> <span class=\"n\">I1</span><span class=\"p\">,</span> <span class=\"n\">I2</span><span class=\"p\">,</span> <span class=\"n\">Fn</span><span class=\"p\">]</span><span class=\"w\">\n\n</span><span class=\"c1\">#connections in the subsystem</span><span class=\"w\">\n</span><span class=\"n\">sub_connections</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"w\">\n</span>    <span class=\"n\">Connection</span><span class=\"p\">(</span><span class=\"n\">I2</span><span class=\"p\">,</span> <span class=\"n\">I1</span><span class=\"p\">,</span> <span class=\"n\">Fn</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">],</span> <span class=\"n\">If</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]),</span><span class=\"w\">\n</span>    <span class=\"n\">Connection</span><span class=\"p\">(</span><span class=\"n\">I1</span><span class=\"p\">,</span> <span class=\"n\">Fn</span><span class=\"p\">,</span> <span class=\"n\">If</span><span class=\"p\">),</span><span class=\"w\">\n</span>    <span class=\"n\">Connection</span><span class=\"p\">(</span><span class=\"n\">Fn</span><span class=\"p\">,</span> <span class=\"n\">I2</span><span class=\"p\">)</span><span class=\"w\">\n</span>    <span class=\"p\">]</span><span class=\"w\">\n\n</span><span class=\"c1\">#the subsystem acts just like a normal block</span><span class=\"w\">\n</span><span class=\"n\">vdp</span> <span class=\"o\">=</span> <span class=\"n\">Subsystem</span><span class=\"p\">(</span><span class=\"n\">sub_blocks</span><span class=\"p\">,</span> <span class=\"n\">sub_connections</span><span class=\"p\">)</span>\n</pre>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>blocks <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">list[Block] | None</span></dt>\n<dd>internal blocks of the subsystem</dd>\n<dt>connections <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">list[Connection] | None</span></dt>\n<dd>internal connections of the subsystem</dd>\n</dl>\n<p>events : list[Event] | None\ntolerance_fpi : float</p>\n<blockquote>\nabsolute tolerance for convergence of algebraic loops\ndefault see ´SIM_TOLERANCE_FPI´ in ´_constants.py´</blockquote>\n<dl class=\"docutils\">\n<dt>iterations_max <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>maximum allowed number of iterations for algebraic loop\nsolver, default see ´SIM_ITERATIONS_MAX´ in ´_constants.py´</dd>\n</dl>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>interface <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">Interface</span></dt>\n<dd>internal interface block for data transfer to the outside</dd>\n<dt>graph <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">Graph</span></dt>\n<dd>internal graph representation for fast system funcion\nevluations using DAG with algebraic depths</dd>\n<dt>boosters <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">None | list[ConnectionBooster]</span></dt>\n<dd>list of boosters (fixed point accelerators) that wrap\nalgebraic loop closing connections assembled from the\nsystem graph</dd>\n</dl>\n</div>\n",
          "source": "class Subsystem(Block):\n    \"\"\"Subsystem class that holds its own blocks and connecions and \n    can natively interface with the main simulation loop. \n\n    IO interface is realized by a special 'Interface' block, that has extra \n    methods for setting and getting inputs and outputs and serves \n    as the interface of the internal blocks to the outside. \n\n    The subsystem doesnt use its 'inputs' and 'outputs' dicts directly. \n    It exclusively handles data transfer via the 'Interface' block. \n\n    This class can be used just like any other block during the simulation, \n    since it implements the required methods 'update' for the fixed-point \n    iteration (resolving algebraic loops with instant time blocks), \n    the 'step' method that performs timestepping (especially for dynamic \n    blocks with internal states) and the 'solve' method for solving the \n    implicit update equation for implicit solvers. \n\n\n    Example\n    -------\n    This is how we can wrap up multiple blocks within a subsystem. \n    In this case vanderpol system built from discrete components \n    instead of using an ODE block (in practice you should use \n    a monolithic ODE whenever possible due to performance).\n\n    .. code-block:: python\n\n        from pathsim import Subsystem, Interface, Connection\n        from pathsim.blocks import Integrator, Function\n\n        #van der Pol parameter\n        mu = 1000\n\n        #blocks in the subsystem\n        If = Interface() # this is the interface to the outside\n        I1 = Integrator(2)\n        I2 = Integrator(0)\n        Fn = Function(lambda x1, x2: mu*(1 - x1**2)*x2 - x1)\n\n        sub_blocks = [If, I1, I2, Fn]\n\n        #connections in the subsystem\n        sub_connections = [\n            Connection(I2, I1, Fn[1], If[1]), \n            Connection(I1, Fn, If), \n            Connection(Fn, I2)\n            ]\n\n        #the subsystem acts just like a normal block\n        vdp = Subsystem(sub_blocks, sub_connections)\n\n\n    Parameters\n    ----------\n    blocks : list[Block] | None\n        internal blocks of the subsystem\n    connections : list[Connection] | None\n        internal connections of the subsystem\n    events : list[Event] | None\n    tolerance_fpi : float\n        absolute tolerance for convergence of algebraic loops\n        default see ´SIM_TOLERANCE_FPI´ in ´_constants.py´\n    iterations_max : int\n        maximum allowed number of iterations for algebraic loop \n        solver, default see ´SIM_ITERATIONS_MAX´ in ´_constants.py´\n\n    Attributes\n    ----------\n    interface : Interface\n        internal interface block for data transfer to the outside\n    graph : Graph\n        internal graph representation for fast system funcion \n        evluations using DAG with algebraic depths\n    boosters : None | list[ConnectionBooster]\n        list of boosters (fixed point accelerators) that wrap \n        algebraic loop closing connections assembled from the \n        system graph\n    \"\"\"\n\n    def __init__(self, \n        blocks=None, \n        connections=None,\n        events=None,\n        tolerance_fpi=SIM_TOLERANCE_FPI, \n        iterations_max=SIM_ITERATIONS_MAX\n        ):\n\n        #internal integration engine -> initialized later\n        self.engine = None\n\n        #flag to set block (subsystem) active\n        self._active = True\n\n        #error tolerance for alg. loop solver\n        self.tolerance_fpi = tolerance_fpi\n\n        #max iterations for internal alg. loop solver\n        self.iterations_max = iterations_max\n\n        #operators for algebraic and dynamic components (not here)\n        self.op_alg = None\n        self.op_dyn = None\n\n        #internal graph representation -> initialized later\n        self.graph = None\n\n        #internal algebraic loop solvers -> initialized later\n        self.boosters = None\n\n        #internal connecions\n        self.connections = set() \n        if connections:\n            self.connections.update(connections)\n\n        #collect and organize internal blocks\n        self.blocks = set()\n        self.interface = None\n\n        if blocks:\n            for block in blocks:\n                if isinstance(block, Interface): \n\n                    if self.interface is not None:\n                        #interface block is already defined\n                        raise ValueError(\"Subsystem can only have one 'Interface' block!\")\n\n                    self.interface = block\n                else: \n                    #regular blocks\n                    self.blocks.add(block)\n\n        #check if interface is defined\n        if self.interface is None:\n            raise ValueError(\"Subsystem 'blocks' list needs to contain 'Interface' block!\")\n\n\n        #collect events if specified\n        self._events = [] if events is None else events\n\n        #assemble internal graph\n        self._assemble_graph()\n\n\n    def __len__(self):\n        \"\"\"Check if the Subsystem has algebraic passthrough by quering \n        the graph for an algebraic path from the interface to itself.\n        \"\"\"\n        is_alg = self.graph.is_algebraic_path(self.interface, self.interface)\n        return int(is_alg)\n\n\n    def __call__(self):\n        \"\"\"Recursively get the subsystems internal states of engines \n        (if available) of all internal blocks and nested subsystems \n        and the subsystem inputs and outputs as arrays for use outside. \n\n        Either for monitoring, postprocessing or event detection. \n        In any case this enables easy access to the current block state.\n        \"\"\"\n        _inputs  = self.interface.outputs.to_array()\n        _outputs = self.interface.inputs.to_array()\n        _states  = []\n        for block in self.blocks:\n            _i, _o, _s = block()\n            _states.append(_s)\n        return _inputs, _outputs, np.hstack(_states)\n\n\n    def __contains__(self, other):\n        \"\"\"Check if blocks and connections are already part of the subsystem\n\n        Paramters\n        ---------\n        other : obj\n            object to check if its part of subsystem\n\n        Returns\n        -------\n        bool\n        \"\"\"\n        return other in self.blocks or other in self.connections\n\n\n    # subsystem graph assembly --------------------------------------------------------------\n\n    def _assemble_graph(self):\n        \"\"\"Assemble internal graph of subsystem for fast \n        algebraic evaluation during simulation.\n        \"\"\"\n        self.graph = Graph({*self.blocks, self.interface}, self.connections)\n\n        #create boosters for loop closing connections\n        if self.graph.has_loops:\n            self.boosters = [\n                ConnectionBooster(conn) for conn in self.graph.loop_closing_connections()\n            ]\n\n\n    # methods for access to metadata --------------------------------------------------------\n\n    @property\n    def size(self):\n        \"\"\"Get size information from subsystem, recursively assembled \n        from internal blocks, including nested subsystems.\n\n        Returns\n        -------\n        sizes : tuple[int]\n            size of block (number of all internal blocks) \n            and number of internal states (from internal engines)\n        \"\"\"\n        total_n, total_nx = 0, 0\n        for block in self.blocks:\n            n, nx = block.size\n            total_n += n\n            total_nx += nx\n        return total_n, total_nx\n\n\n    # visualization -------------------------------------------------------------------------\n\n    def plot(self, *args, **kwargs):\n        \"\"\"Plot the simulation results by calling all the blocks \n        that have visualization capabilities such as the 'Scope' \n        and 'Spectrum'.\n\n        Parameters\n        ----------\n        args : tuple\n            args for the plot methods\n        kwargs : dict\n            kwargs for the plot method\n        \"\"\"\n        for block in self.blocks:\n            block.plot(*args, **kwargs)\n\n\n    # extracting data -----------------------------------------------------------------------\n\n    @deprecated(version=\"1.0.0\", reason=\"its against pathsims philosophy\")\n    def collect(self):\n        \"\"\"Aggregate results from internal blocks.\"\"\"\n        for block in self.blocks:\n            yield from block.collect()\n\n\n    # system management ---------------------------------------------------------------------\n\n    def reset(self):\n        \"\"\"Reset the subsystem interface and all internal blocks\"\"\"\n\n        #reset interface\n        self.interface.reset()\n\n        #reset internal blocks\n        for block in self.blocks:\n            block.reset()\n\n\n    def on(self):\n        \"\"\"Activate the subsystem and all internal blocks, sets the boolean\n        evaluation flag to 'True'.\n        \"\"\"\n        self._active = True\n        for block in self.blocks: \n            block.on()\n\n\n    def off(self):\n        \"\"\"Deactivate the subsystem and all internal blocks, sets the boolean\n        evaluation flag to 'False'. Also resets the subsystem.\n        \"\"\"\n        self._active = False\n        for block in self.blocks: \n            block.off()\n        self.reset()\n\n\n    def linearize(self, t):\n        \"\"\"Linearize the algebraic and dynamic components of the internal blocks.\n\n        This is done by linearizing the internal 'Operator' and 'DynamicOperator' \n        instances of all the internal blocks of the subsystem in the current system \n        operating point. The operators create 1st order taylor approximations \n        internally and use them on subsequent calls after linearization.\n\n        Recursively traverses down the hierarchy for nested subsystems and linearizes \n        all of them.\n\n        Parameters\n        ----------\n        t : float \n            evaluation time\n        \"\"\"\n        for block in self.blocks: \n            block.linearize(t)\n\n\n    def delinearize(self):\n        \"\"\"Revert the linearization of the internal blocks.\"\"\"\n        for block in self.blocks: \n            block.delinearize()\n\n\n    # methods for discrete event management -------------------------------------------------\n\n    @property\n    def events(self):\n        \"\"\"Recursively collect and return events spawned by the \n        internal blocks of the subsystem, for discrete time \n        blocks such as triggers / comparators, clocks, etc.\n        \"\"\"\n        _all_events = self._events.copy()\n        for block in self.blocks:\n            _all_events.extend(block.events)\n        return _all_events\n\n\n    # methods for inter-block data transfer -------------------------------------------------\n\n    @property    \n    def inputs(self):\n        return self.interface.outputs\n\n    @property\n    def outputs(self):\n        return self.interface.inputs\n\n\n    # methods for data recording ------------------------------------------------------------\n\n    def sample(self, t, dt):\n        \"\"\"Update the internal connections again and sample data from \n        the internal blocks that implement the 'sample' method.\n\n        Parameters\n        ----------\n        t : float\n            evaluation time\n        dt : float\n            integration timestep \n        \"\"\"\n\n        #record data if required\n        for block in self.blocks:\n            block.sample(t, dt)\n\n\n    # methods for block output and state updates --------------------------------------------\n\n    def update(self, t):\n        \"\"\"Update the instant time components of the internal blocks \n        to evaluate the (distributed) system equation.\n\n        Parameters\n        ----------\n        t : float\n            evaluation time \n        \"\"\"\n\n        #evaluate DAG\n        self._dag(t)\n\n        #algebraic loops -> solve them\n        if self.graph.has_loops:   \n            self._loops(t)\n\n\n    def _dag(self, t):\n        \"\"\"Update the directed acyclic graph components of the system.\n\n        Parameters\n        ----------\n        t : float\n            evaluation time for system function\n        \"\"\"\n\n        #update interface outgoing connections\n        for connection in self.graph.outgoing_connections(self.interface):\n            if connection: connection.update()\n\n        #perform gauss-seidel iterations without error checking\n        for _, blocks_dag, connections_dag in self.graph.dag():\n\n            #update blocks at algebraic depth\n            for block in blocks_dag:\n                if block: block.update(t)\n\n            #update connenctions at algebraic depth (data transfer)\n            for connection in connections_dag:\n                if connection: connection.update()\n\n\n    def _loops(self, t):\n        \"\"\"Perform the algebraic loop solve of the subsystem using accelerated \n        fixed-point iterations on the broken loop directed graph.\n\n        Parameters\n        ----------\n        t : float\n            evaluation time for system function\n        \"\"\"\n\n        #reset accelerators of loop closing connections\n        for con_booster in self.boosters:\n            con_booster.reset()\n\n        #perform solver iterations on algebraic loops\n        for iteration in range(1, self.iterations_max):\n\n            #iterate DAG depths of broken loops\n            for depth, blocks_loop, connections_loop in self.graph.loop():\n\n                #update blocks at algebraic depth\n                for block in blocks_loop:\n                    if block: block.update(t)\n\n                #step accelerated connenctions at algebraic depth (data transfer)\n                for connection in connections_loop:\n                    if connection: connection.update()\n\n            #step boosters of loop closing connections\n            max_err = 0.0\n            for con_booster in self.boosters:\n                err = con_booster.update()\n                if err > max_err:\n                    max_err = err\n\n            #check convergence after first iteration\n            if max_err <= self.tolerance_fpi:\n                return\n\n        #not converged -> error\n        raise RuntimeError(\n            \"algebraic loop in 'Subsystem' not converged (iters: {}, err: {})\".format(\n                self.iterations_max, max_err)\n            )\n\n\n    # methods for blocks with integration engines -------------------------------------------\n\n    def solve(self, t, dt):\n        \"\"\"Advance solution of implicit update equation \n        for internal blocks.\n\n        Parameters\n        ----------\n        t : float\n            evaluation time \n        dt : float\n            timestep\n\n        Returns\n        -------\n        max_error : float\n            maximum error of implicit update equaiton\n        \"\"\"\n        max_error = 0.0\n        for block in self._blocks_dyn:\n            if not block: continue\n            err = block.solve(t, dt)\n            if err > max_error:\n                max_error = err\n        return max_error\n\n\n    def step(self, t, dt):\n        \"\"\"Explicit component of timestep for internal blocks \n        including error propagation.\n\n        Notes\n        ----- \n        This is pretty much an exact copy of the '_step' method \n        from the 'Simulation' class.\n\n        Parameters\n        ---------- \n        t : float\n            evaluation time \n        dt : float\n            timestep\n\n        Returns\n        -------\n        success : bool\n            indicator if the timestep was successful\n        max_error : float\n            maximum local truncation error from integration\n        scale : float\n            rescale factor for timestep\n        \"\"\"\n\n        #initial timestep rescale and error estimate\n        success, max_error_norm, min_scale = True, 0.0, None\n\n        #step blocks and get error estimates if available\n        for block in self._blocks_dyn:\n\n            #skip inactive internal blocks\n            if not block: continue\n\n            suc, err_norm, scl = block.step(t, dt)\n\n            #check solver stepping success\n            if not suc:\n                success = False\n\n            #update error tracking\n            if err_norm > max_error_norm:\n                max_error_norm = err_norm\n\n            #track minimum relevant scale directly (avoids list allocation)\n            if scl is not None:\n                if min_scale is None or scl < min_scale:\n                    min_scale = scl\n\n        return success, max_error_norm, min_scale if min_scale is not None else 1.0\n\n\n    def set_solver(self, Solver, parent, **solver_args):\n        \"\"\"Initialize all blocks with solver for numerical integration\n        and additional args for the solver such as tolerances, etc.\n\n        If blocks already have solvers, change the numerical integrator\n        to the 'Solver' class.\n\n        Parameters\n        ----------\n        Solver : Solver\n            numerical solver definition\n        parent : Solver\n            numerical solver instance as parent\n        solver_args : dict\n            args to initialize solver with\n        \"\"\"\n\n        #set integration engines and assemble list of dynamic blocks\n        self._blocks_dyn = []\n        for block in self.blocks:\n            block.set_solver(Solver, parent, **solver_args)\n            if block.engine:\n                self._blocks_dyn.append(block)\n\n        #only set dummy engine if subsystem has dynamic blocks\n        #this prevents purely algebraic subsystems from being treated as dynamic\n        if self._blocks_dyn:\n            self.engine = Solver(parent=parent, **solver_args)\n        else:\n            self.engine = None\n\n\n    def revert(self):\n        \"\"\"revert the internal blocks to the state \n        of the previous timestep \n        \"\"\"\n        for block in self._blocks_dyn:\n            if block: block.revert()\n\n\n    def buffer(self, dt):\n        \"\"\"buffer internal states of blocks with \n        internal integration engines \n\n        Parameters\n        ----------\n        dt : float\n            evaluation time for buffering    \n        \"\"\"\n        for block in self._blocks_dyn:\n            if block: block.buffer(dt)",
          "bases": [
            "pathsim.blocks._block.Block"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, \n    blocks=None, \n    connections=None,\n    events=None,\n    tolerance_fpi=SIM_TOLERANCE_FPI, \n    iterations_max=SIM_ITERATIONS_MAX\n    ):\n\n    #internal integration engine -> initialized later\n    self.engine = None\n\n    #flag to set block (subsystem) active\n    self._active = True\n\n    #error tolerance for alg. loop solver\n    self.tolerance_fpi = tolerance_fpi\n\n    #max iterations for internal alg. loop solver\n    self.iterations_max = iterations_max\n\n    #operators for algebraic and dynamic components (not here)\n    self.op_alg = None\n    self.op_dyn = None\n\n    #internal graph representation -> initialized later\n    self.graph = None\n\n    #internal algebraic loop solvers -> initialized later\n    self.boosters = None\n\n    #internal connecions\n    self.connections = set() \n    if connections:\n        self.connections.update(connections)\n\n    #collect and organize internal blocks\n    self.blocks = set()\n    self.interface = None\n\n    if blocks:\n        for block in blocks:\n            if isinstance(block, Interface): \n\n                if self.interface is not None:\n                    #interface block is already defined\n                    raise ValueError(\"Subsystem can only have one 'Interface' block!\")\n\n                self.interface = block\n            else: \n                #regular blocks\n                self.blocks.add(block)\n\n    #check if interface is defined\n    if self.interface is None:\n        raise ValueError(\"Subsystem 'blocks' list needs to contain 'Interface' block!\")\n\n\n    #collect events if specified\n    self._events = [] if events is None else events\n\n    #assemble internal graph\n    self._assemble_graph()",
              "signature": "(blocks = None, connections = None, events = None, tolerance_fpi = SIM_TOLERANCE_FPI, iterations_max = SIM_ITERATIONS_MAX)",
              "parameters": [
                {
                  "name": "blocks",
                  "type": null,
                  "default": "None",
                  "description": ""
                },
                {
                  "name": "connections",
                  "type": null,
                  "default": "None",
                  "description": ""
                },
                {
                  "name": "events",
                  "type": null,
                  "default": "None",
                  "description": ""
                },
                {
                  "name": "tolerance_fpi",
                  "type": null,
                  "default": "SIM_TOLERANCE_FPI",
                  "description": ""
                },
                {
                  "name": "iterations_max",
                  "type": null,
                  "default": "SIM_ITERATIONS_MAX",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "_assemble_graph",
              "description": "Assemble internal graph of subsystem for fast",
              "docstring_html": "<p>Assemble internal graph of subsystem for fast\nalgebraic evaluation during simulation.</p>\n",
              "source": "def _assemble_graph(self):\n    \"\"\"Assemble internal graph of subsystem for fast \n    algebraic evaluation during simulation.\n    \"\"\"\n    self.graph = Graph({*self.blocks, self.interface}, self.connections)\n\n    #create boosters for loop closing connections\n    if self.graph.has_loops:\n        self.boosters = [\n            ConnectionBooster(conn) for conn in self.graph.loop_closing_connections()\n        ]",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "plot",
              "description": "Plot the simulation results by calling all the blocks",
              "docstring_html": "<p>Plot the simulation results by calling all the blocks\nthat have visualization capabilities such as the 'Scope'\nand 'Spectrum'.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>args <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">tuple</span></dt>\n<dd>args for the plot methods</dd>\n<dt>kwargs <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">dict</span></dt>\n<dd>kwargs for the plot method</dd>\n</dl>\n",
              "source": "def plot(self, *args, **kwargs):\n    \"\"\"Plot the simulation results by calling all the blocks \n    that have visualization capabilities such as the 'Scope' \n    and 'Spectrum'.\n\n    Parameters\n    ----------\n    args : tuple\n        args for the plot methods\n    kwargs : dict\n        kwargs for the plot method\n    \"\"\"\n    for block in self.blocks:\n        block.plot(*args, **kwargs)",
              "signature": "(args = (), kwargs = {})",
              "parameters": [
                {
                  "name": "args",
                  "type": null,
                  "default": "()",
                  "description": "args for the plot methods"
                },
                {
                  "name": "kwargs",
                  "type": null,
                  "default": "{}",
                  "description": "kwargs for the plot method"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "collect",
              "description": "Aggregate results from internal blocks.",
              "docstring_html": "<p>Aggregate results from internal blocks.</p>\n",
              "source": "@deprecated(version=\"1.0.0\", reason=\"its against pathsims philosophy\")\ndef collect(self):\n    \"\"\"Aggregate results from internal blocks.\"\"\"\n    for block in self.blocks:\n        yield from block.collect()",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "reset",
              "description": "Reset the subsystem interface and all internal blocks",
              "docstring_html": "<p>Reset the subsystem interface and all internal blocks</p>\n",
              "source": "def reset(self):\n    \"\"\"Reset the subsystem interface and all internal blocks\"\"\"\n\n    #reset interface\n    self.interface.reset()\n\n    #reset internal blocks\n    for block in self.blocks:\n        block.reset()",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "on",
              "description": "Activate the subsystem and all internal blocks, sets the boolean",
              "docstring_html": "<p>Activate the subsystem and all internal blocks, sets the boolean\nevaluation flag to 'True'.</p>\n",
              "source": "def on(self):\n    \"\"\"Activate the subsystem and all internal blocks, sets the boolean\n    evaluation flag to 'True'.\n    \"\"\"\n    self._active = True\n    for block in self.blocks: \n        block.on()",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "off",
              "description": "Deactivate the subsystem and all internal blocks, sets the boolean",
              "docstring_html": "<p>Deactivate the subsystem and all internal blocks, sets the boolean\nevaluation flag to 'False'. Also resets the subsystem.</p>\n",
              "source": "def off(self):\n    \"\"\"Deactivate the subsystem and all internal blocks, sets the boolean\n    evaluation flag to 'False'. Also resets the subsystem.\n    \"\"\"\n    self._active = False\n    for block in self.blocks: \n        block.off()\n    self.reset()",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "linearize",
              "description": "Linearize the algebraic and dynamic components of the internal blocks.",
              "docstring_html": "<p>Linearize the algebraic and dynamic components of the internal blocks.</p>\n<p>This is done by linearizing the internal 'Operator' and 'DynamicOperator'\ninstances of all the internal blocks of the subsystem in the current system\noperating point. The operators create 1st order taylor approximations\ninternally and use them on subsequent calls after linearization.</p>\n<p>Recursively traverses down the hierarchy for nested subsystems and linearizes\nall of them.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time</dd>\n</dl>\n",
              "source": "def linearize(self, t):\n    \"\"\"Linearize the algebraic and dynamic components of the internal blocks.\n\n    This is done by linearizing the internal 'Operator' and 'DynamicOperator' \n    instances of all the internal blocks of the subsystem in the current system \n    operating point. The operators create 1st order taylor approximations \n    internally and use them on subsequent calls after linearization.\n\n    Recursively traverses down the hierarchy for nested subsystems and linearizes \n    all of them.\n\n    Parameters\n    ----------\n    t : float \n        evaluation time\n    \"\"\"\n    for block in self.blocks: \n        block.linearize(t)",
              "signature": "(t)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "delinearize",
              "description": "Revert the linearization of the internal blocks.",
              "docstring_html": "<p>Revert the linearization of the internal blocks.</p>\n",
              "source": "def delinearize(self):\n    \"\"\"Revert the linearization of the internal blocks.\"\"\"\n    for block in self.blocks: \n        block.delinearize()",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "sample",
              "description": "Update the internal connections again and sample data from",
              "docstring_html": "<p>Update the internal connections again and sample data from\nthe internal blocks that implement the 'sample' method.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time</dd>\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>integration timestep</dd>\n</dl>\n",
              "source": "def sample(self, t, dt):\n    \"\"\"Update the internal connections again and sample data from \n    the internal blocks that implement the 'sample' method.\n\n    Parameters\n    ----------\n    t : float\n        evaluation time\n    dt : float\n        integration timestep \n    \"\"\"\n\n    #record data if required\n    for block in self.blocks:\n        block.sample(t, dt)",
              "signature": "(t, dt)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time"
                },
                {
                  "name": "dt",
                  "type": null,
                  "default": null,
                  "description": "integration timestep"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "update",
              "description": "Update the instant time components of the internal blocks",
              "docstring_html": "<p>Update the instant time components of the internal blocks\nto evaluate the (distributed) system equation.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time</dd>\n</dl>\n",
              "source": "def update(self, t):\n    \"\"\"Update the instant time components of the internal blocks \n    to evaluate the (distributed) system equation.\n\n    Parameters\n    ----------\n    t : float\n        evaluation time \n    \"\"\"\n\n    #evaluate DAG\n    self._dag(t)\n\n    #algebraic loops -> solve them\n    if self.graph.has_loops:   \n        self._loops(t)",
              "signature": "(t)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "_dag",
              "description": "Update the directed acyclic graph components of the system.",
              "docstring_html": "<p>Update the directed acyclic graph components of the system.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time for system function</dd>\n</dl>\n",
              "source": "def _dag(self, t):\n    \"\"\"Update the directed acyclic graph components of the system.\n\n    Parameters\n    ----------\n    t : float\n        evaluation time for system function\n    \"\"\"\n\n    #update interface outgoing connections\n    for connection in self.graph.outgoing_connections(self.interface):\n        if connection: connection.update()\n\n    #perform gauss-seidel iterations without error checking\n    for _, blocks_dag, connections_dag in self.graph.dag():\n\n        #update blocks at algebraic depth\n        for block in blocks_dag:\n            if block: block.update(t)\n\n        #update connenctions at algebraic depth (data transfer)\n        for connection in connections_dag:\n            if connection: connection.update()",
              "signature": "(t)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time for system function"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "_loops",
              "description": "Perform the algebraic loop solve of the subsystem using accelerated",
              "docstring_html": "<p>Perform the algebraic loop solve of the subsystem using accelerated\nfixed-point iterations on the broken loop directed graph.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time for system function</dd>\n</dl>\n",
              "source": "def _loops(self, t):\n    \"\"\"Perform the algebraic loop solve of the subsystem using accelerated \n    fixed-point iterations on the broken loop directed graph.\n\n    Parameters\n    ----------\n    t : float\n        evaluation time for system function\n    \"\"\"\n\n    #reset accelerators of loop closing connections\n    for con_booster in self.boosters:\n        con_booster.reset()\n\n    #perform solver iterations on algebraic loops\n    for iteration in range(1, self.iterations_max):\n\n        #iterate DAG depths of broken loops\n        for depth, blocks_loop, connections_loop in self.graph.loop():\n\n            #update blocks at algebraic depth\n            for block in blocks_loop:\n                if block: block.update(t)\n\n            #step accelerated connenctions at algebraic depth (data transfer)\n            for connection in connections_loop:\n                if connection: connection.update()\n\n        #step boosters of loop closing connections\n        max_err = 0.0\n        for con_booster in self.boosters:\n            err = con_booster.update()\n            if err > max_err:\n                max_err = err\n\n        #check convergence after first iteration\n        if max_err <= self.tolerance_fpi:\n            return\n\n    #not converged -> error\n    raise RuntimeError(\n        \"algebraic loop in 'Subsystem' not converged (iters: {}, err: {})\".format(\n            self.iterations_max, max_err)\n        )",
              "signature": "(t)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time for system function"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "solve",
              "description": "Advance solution of implicit update equation",
              "docstring_html": "<p>Advance solution of implicit update equation\nfor internal blocks.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time</dd>\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>timestep</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>max_error <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>maximum error of implicit update equaiton</dd>\n</dl>\n",
              "source": "def solve(self, t, dt):\n    \"\"\"Advance solution of implicit update equation \n    for internal blocks.\n\n    Parameters\n    ----------\n    t : float\n        evaluation time \n    dt : float\n        timestep\n\n    Returns\n    -------\n    max_error : float\n        maximum error of implicit update equaiton\n    \"\"\"\n    max_error = 0.0\n    for block in self._blocks_dyn:\n        if not block: continue\n        err = block.solve(t, dt)\n        if err > max_error:\n            max_error = err\n    return max_error",
              "signature": "(t, dt)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time"
                },
                {
                  "name": "dt",
                  "type": null,
                  "default": null,
                  "description": "timestep"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "step",
              "description": "Explicit component of timestep for internal blocks",
              "docstring_html": "<p>Explicit component of timestep for internal blocks\nincluding error propagation.</p>\n<p><strong>Notes</strong></p>\n<p>This is pretty much an exact copy of the '_step' method\nfrom the 'Simulation' class.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time</dd>\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>timestep</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>success <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>indicator if the timestep was successful</dd>\n<dt>max_error <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>maximum local truncation error from integration</dd>\n<dt>scale <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>rescale factor for timestep</dd>\n</dl>\n",
              "source": "def step(self, t, dt):\n    \"\"\"Explicit component of timestep for internal blocks \n    including error propagation.\n\n    Notes\n    ----- \n    This is pretty much an exact copy of the '_step' method \n    from the 'Simulation' class.\n\n    Parameters\n    ---------- \n    t : float\n        evaluation time \n    dt : float\n        timestep\n\n    Returns\n    -------\n    success : bool\n        indicator if the timestep was successful\n    max_error : float\n        maximum local truncation error from integration\n    scale : float\n        rescale factor for timestep\n    \"\"\"\n\n    #initial timestep rescale and error estimate\n    success, max_error_norm, min_scale = True, 0.0, None\n\n    #step blocks and get error estimates if available\n    for block in self._blocks_dyn:\n\n        #skip inactive internal blocks\n        if not block: continue\n\n        suc, err_norm, scl = block.step(t, dt)\n\n        #check solver stepping success\n        if not suc:\n            success = False\n\n        #update error tracking\n        if err_norm > max_error_norm:\n            max_error_norm = err_norm\n\n        #track minimum relevant scale directly (avoids list allocation)\n        if scl is not None:\n            if min_scale is None or scl < min_scale:\n                min_scale = scl\n\n    return success, max_error_norm, min_scale if min_scale is not None else 1.0",
              "signature": "(t, dt)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time"
                },
                {
                  "name": "dt",
                  "type": null,
                  "default": null,
                  "description": "timestep"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "set_solver",
              "description": "Initialize all blocks with solver for numerical integration",
              "docstring_html": "<p>Initialize all blocks with solver for numerical integration\nand additional args for the solver such as tolerances, etc.</p>\n<p>If blocks already have solvers, change the numerical integrator\nto the 'Solver' class.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>Solver <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">Solver</span></dt>\n<dd>numerical solver definition</dd>\n<dt>parent <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">Solver</span></dt>\n<dd>numerical solver instance as parent</dd>\n<dt>solver_args <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">dict</span></dt>\n<dd>args to initialize solver with</dd>\n</dl>\n",
              "source": "def set_solver(self, Solver, parent, **solver_args):\n    \"\"\"Initialize all blocks with solver for numerical integration\n    and additional args for the solver such as tolerances, etc.\n\n    If blocks already have solvers, change the numerical integrator\n    to the 'Solver' class.\n\n    Parameters\n    ----------\n    Solver : Solver\n        numerical solver definition\n    parent : Solver\n        numerical solver instance as parent\n    solver_args : dict\n        args to initialize solver with\n    \"\"\"\n\n    #set integration engines and assemble list of dynamic blocks\n    self._blocks_dyn = []\n    for block in self.blocks:\n        block.set_solver(Solver, parent, **solver_args)\n        if block.engine:\n            self._blocks_dyn.append(block)\n\n    #only set dummy engine if subsystem has dynamic blocks\n    #this prevents purely algebraic subsystems from being treated as dynamic\n    if self._blocks_dyn:\n        self.engine = Solver(parent=parent, **solver_args)\n    else:\n        self.engine = None",
              "signature": "(Solver, parent, solver_args = {})",
              "parameters": [
                {
                  "name": "Solver",
                  "type": null,
                  "default": null,
                  "description": "numerical solver definition"
                },
                {
                  "name": "parent",
                  "type": null,
                  "default": null,
                  "description": "numerical solver instance as parent"
                },
                {
                  "name": "solver_args",
                  "type": null,
                  "default": "{}",
                  "description": "args to initialize solver with"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "revert",
              "description": "revert the internal blocks to the state",
              "docstring_html": "<p>revert the internal blocks to the state\nof the previous timestep</p>\n",
              "source": "def revert(self):\n    \"\"\"revert the internal blocks to the state \n    of the previous timestep \n    \"\"\"\n    for block in self._blocks_dyn:\n        if block: block.revert()",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "buffer",
              "description": "buffer internal states of blocks with",
              "docstring_html": "<p>buffer internal states of blocks with\ninternal integration engines</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time for buffering</dd>\n</dl>\n",
              "source": "def buffer(self, dt):\n    \"\"\"buffer internal states of blocks with \n    internal integration engines \n\n    Parameters\n    ----------\n    dt : float\n        evaluation time for buffering    \n    \"\"\"\n    for block in self._blocks_dyn:\n        if block: block.buffer(dt)",
              "signature": "(dt)",
              "parameters": [
                {
                  "name": "dt",
                  "type": null,
                  "default": null,
                  "description": "evaluation time for buffering"
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "engine",
              "description": "",
              "type": null,
              "value": "None"
            },
            {
              "name": "_active",
              "description": "",
              "type": null,
              "value": "True"
            },
            {
              "name": "tolerance_fpi",
              "description": "",
              "type": null,
              "value": "tolerance_fpi"
            },
            {
              "name": "iterations_max",
              "description": "",
              "type": null,
              "value": "iterations_max"
            },
            {
              "name": "op_alg",
              "description": "",
              "type": null,
              "value": "None"
            },
            {
              "name": "op_dyn",
              "description": "",
              "type": null,
              "value": "None"
            },
            {
              "name": "graph",
              "description": "",
              "type": null,
              "value": "None"
            },
            {
              "name": "boosters",
              "description": "",
              "type": null,
              "value": "None"
            },
            {
              "name": "connections",
              "description": "",
              "type": null,
              "value": "set()"
            },
            {
              "name": "blocks",
              "description": "",
              "type": null,
              "value": "set()"
            },
            {
              "name": "interface",
              "description": "",
              "type": null,
              "value": "None"
            },
            {
              "name": "_events",
              "description": "",
              "type": null,
              "value": "[] if events is None else events"
            },
            {
              "name": "size",
              "description": "Get size information from subsystem, recursively assembled",
              "type": null,
              "value": null
            },
            {
              "name": "events",
              "description": "Recursively collect and return events spawned by the",
              "type": null,
              "value": null
            },
            {
              "name": "inputs",
              "description": "",
              "type": null,
              "value": null
            },
            {
              "name": "outputs",
              "description": "",
              "type": null,
              "value": null
            }
          ],
          "parameters": [
            {
              "name": "blocks",
              "type": null,
              "default": "None",
              "description": "internal blocks of the subsystem"
            },
            {
              "name": "connections",
              "type": null,
              "default": "None",
              "description": "internal connections of the subsystem"
            },
            {
              "name": "events",
              "type": null,
              "default": "None",
              "description": ""
            },
            {
              "name": "tolerance_fpi",
              "type": null,
              "default": "SIM_TOLERANCE_FPI",
              "description": "absolute tolerance for convergence of algebraic loops default see ´SIM_TOLERANCE_FPI´ in ´_constants.py´"
            },
            {
              "name": "iterations_max",
              "type": null,
              "default": "SIM_ITERATIONS_MAX",
              "description": "maximum allowed number of iterations for algebraic loop solver, default see ´SIM_ITERATIONS_MAX´ in ´_constants.py´"
            }
          ]
        }
      ],
      "functions": []
    },
    "pathsim.blocks._block": {
      "name": "pathsim.blocks._block",
      "description": "",
      "docstring_html": "",
      "classes": [
        {
          "name": "Block",
          "description": "Base 'Block' object that defines the inputs, outputs and the block interface.",
          "docstring_html": "<p>Base 'Block' object that defines the inputs, outputs and the block interface.</p>\n<p>Block interconnections are handled via the io interface of the blocks.\nIt is realized by dicts for the 'inputs' and for the 'outputs', where the\nkey of the dict is the input/output channel and the corresponding value is\nthe input/output value.</p>\n<p>The block can spawn discrete events that are handled by the main simulation\nfor triggers, discrete time blocks, etc.</p>\n<p>Mathematically the block behavior is defined by two operators in most cases</p>\n<pre class=\"math\">\n\\begin{align}\n\\dot{x} &amp;= f_\\mathrm{dyn}(x, u, t)\\\\\n       y &amp;= f_\\mathrm{alg}(x, u, t)\n\\end{align}\n</pre>\n<p>they are algebraic operators for the algebraic path of the block and for the\ndynamic path that feeds into the internal numerical integration engine.</p>\n<p>There are special cases where one or both of them are not defined, also for\npurely algebraic blocks such as multipliers and functions, there exists a\nsimplified operator definition:</p>\n<pre class=\"math\">\ny = f_\\mathrm{alg}(u)\n</pre>\n<div class=\"section\" id=\"note\">\n<h4>Note</h4>\n<p>This block is not intended to be used directly and serves as a base\nclass definition for other blocks to be inherited.</p>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>inputs <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">Register</span></dt>\n<dd>input value register of block</dd>\n<dt>outputs <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">Register</span></dt>\n<dd>output value register of block</dd>\n<dt>engine <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">None | Solver</span></dt>\n<dd>numerical integrator instance</dd>\n<dt>events <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">list[Event]</span></dt>\n<dd>list of internal events, for mixed signal blocks</dd>\n<dt>_active <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>flag that sets the block active or inactive</dd>\n<dt>op_alg <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">Operator | DynamicOperator | None</span></dt>\n<dd>internal callable operator for algebraic components of block</dd>\n<dt>op_dyn <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">DynamicOperator | None</span></dt>\n<dd>internal callable operator for dynamic (ODE) components of block</dd>\n</dl>\n</div>\n",
          "source": "class Block:\n    \"\"\"Base 'Block' object that defines the inputs, outputs and the block interface.\n\n    Block interconnections are handled via the io interface of the blocks. \n    It is realized by dicts for the 'inputs' and for the 'outputs', where the \n    key of the dict is the input/output channel and the corresponding value is \n    the input/output value. \n\n    The block can spawn discrete events that are handled by the main simulation \n    for triggers, discrete time blocks, etc.\n\n    Mathematically the block behavior is defined by two operators in most cases\n\n    .. math::\n\n        \\\\begin{align}\n        \\\\dot{x} &= f_\\\\mathrm{dyn}(x, u, t)\\\\\\\\\n               y &= f_\\\\mathrm{alg}(x, u, t)\n        \\\\end{align}\n\n\n    they are algebraic operators for the algebraic path of the block and for the \n    dynamic path that feeds into the internal numerical integration engine.\n\n    There are special cases where one or both of them are not defined, also for \n    purely algebraic blocks such as multipliers and functions, there exists a \n    simplified operator definition:\n\n    .. math::\n\n        y = f_\\\\mathrm{alg}(u)\n\n\n    Note\n    ----\n    This block is not intended to be used directly and serves as a base \n    class definition for other blocks to be inherited.\n\n\n    Attributes\n    ----------\n    inputs : Register\n        input value register of block\n    outputs : Register\n        output value register of block\n    engine : None | Solver\n        numerical integrator instance\n    events : list[Event]\n        list of internal events, for mixed signal blocks\n    _active : bool\n        flag that sets the block active or inactive\n    op_alg : Operator | DynamicOperator | None\n        internal callable operator for algebraic components of block\n    op_dyn : DynamicOperator | None\n        internal callable operator for dynamic (ODE) components of block\n    \"\"\"\n\n    input_port_labels = None\n    output_port_labels = None\n\n    def __init__(self):\n\n        #registers to hold input and output values\n        self.inputs = Register(\n            mapping=self.input_port_labels and self.input_port_labels.copy()\n            )\n        self.outputs = Register(\n            mapping=self.output_port_labels and self.output_port_labels.copy()\n            )\n\n        #initialize integration engine as 'None' by default\n        self.engine = None\n\n        #flag to set block active\n        self._active = True\n\n        #internal discrete events (for mixed signal blocks)\n        self.events = []\n\n        #operators for algebraic and dynamic components\n        self.op_alg = None\n        self.op_dyn = None\n\n\n    def __len__(self):\n        \"\"\"The '__len__' method of the block is used to compute the length of the \n        algebraic path of the block. \n\n        For instant time blocks or blocks with purely algebraic components \n        (adders, amplifiers, etc.) it returns 1, otherwise (integrator, delay, etc.) \n        it returns 0.\n\n        If the block is disabled '_active == False', it returns 0 as well, since\n        this breaks the signal path.\n\n        Returns\n        -------\n        len : int\n            length of the algebraic path of the block\n        \"\"\"\n        return 1 if self._active else 0\n\n\n    def __getitem__(self, key):\n        \"\"\"The '__getitem__' method is intended to make connection creation more \n        convenient and therefore just returns the block itself and the key directly \n        after doing some basic checks.\n\n        Parameters\n        ----------\n        key : int, str, slice, tuple[int, str], list[int, str]\n            port indices or port names, or list / tuple of them\n\n        Returns\n        -------\n        PortReference\n            container object that hold block reference and list of ports\n        \"\"\"\n\n        if isinstance(key, slice):\n\n            #slice validation\n            if key.stop is None: raise ValueError(\"Port slice cannot be open ended!\")\n            if key.stop == 0: raise ValueError(\"Port slice cannot end with 0!\")\n\n            #start, step handling\n            start = 0 if key.start is None else key.start\n            step  = 1 if key.step  is None else key.step\n\n            #build port list\n            ports = list(range(start, key.stop, step))\n            return PortReference(self, ports)\n\n        elif isinstance(key, (tuple, list)):\n\n            for k in key:\n\n                #port type validation\n                if not isinstance(k, (int, str)):\n                    raise ValueError(f\"Port '{k}' must be (int, str) but is '{type(k)}'!\")\n\n            #duplicate validation\n            if len(set(key)) < len(key):\n                raise ValueError(\"Ports cannot be duplicates!\")\n\n            return PortReference(self, list(key))\n\n        elif isinstance(key, (int, str)):\n\n            #standard key\n            return PortReference(self, [key])\n\n        else:\n            raise ValueError(f\"Port must be type (int, str, slice, tuple[int, str], list[int, str]) but is '{type(key)}'!\")\n\n\n    def __call__(self):\n        \"\"\"The '__call__' is an alias for the 'get_all' method.\"\"\"\n        return self.get_all()\n\n\n    def __bool__(self):\n        return self._active\n\n\n    # methods for access to metadata ----------------------------------------------------\n\n    @property\n    def size(self):\n        \"\"\"Get size information from block, such as \n        number of internal states, etc.\n\n        Returns\n        -------\n        sizes : tuple[int]\n            size of block (default 1) and number \n            of internal states (from internal engine)\n        \"\"\"\n        nx = len(self.engine) if self.engine else 0\n        return 1, nx\n\n\n    @property\n    def shape(self):\n        \"\"\"Get the number of input and output ports of the block\n\n        Returns\n        -------\n        shape : tuple[int]\n            number of input and output ports\n        \"\"\" \n        return len(self.inputs), len(self.outputs)\n\n\n    @classmethod\n    @lru_cache()\n    def info(cls):\n        \"\"\"Get block metadata for introspection and UI integration.\n\n        Returns a dictionary containing block type information, port mappings,\n        and parameter definitions. Results are cached per class.\n\n        Returns\n        -------\n        info : dict\n            Block metadata with the following keys:\n            - type : str\n                Class name of the block\n            - description : str\n                Block docstring\n            - shape : tuple\n                Input/output shape (n_inputs, n_outputs)\n            - size : int\n                State vector size\n            - in_labels : dict\n                Input port name to index mapping\n            - out_labels : dict\n                Output port name to index mapping\n            - parameters : dict\n                Parameter names mapped to their default values\n        \"\"\"\n\n        # Get __init__ signature for parameters\n        sig = inspect.signature(cls.__init__)\n        params = {\n            name: {\n                \"default\": None if param.default is inspect.Parameter.empty else param.default\n                }\n            for name, param in sig.parameters.items() \n            if name not in (\"self\", \"kwargs\", \"args\")\n            }\n\n        return {\n            \"type\": cls.__name__,\n            \"description\": cls.__doc__,\n            \"input_port_labels\": cls.input_port_labels,\n            \"output_port_labels\": cls.output_port_labels,\n            \"parameters\": params,\n            }\n\n\n    # methods for visualization ---------------------------------------------------------\n\n    def plot(self, *args, **kwargs):\n        \"\"\"Block specific visualization, enables plotting \n        access from the simulation level.\n\n        This gets primarily used by the visualization blocks \n        such as the 'Scope' and 'Spectrum'.\n\n        Parameters\n        ----------\n        args : tuple\n            args for the plot methods\n        kwargs : dict\n            kwargs for the plot method\n        \"\"\"\n        pass\n\n\n    # methods for simulation management -------------------------------------------------\n\n    def on(self):\n        \"\"\"Activate the block and all internal events, sets the boolean\n        evaluation flag to 'True'.\n        \"\"\"\n        self._active = True\n        for event in self.events: \n            event.on()\n\n\n    def off(self):\n        \"\"\"Deactivate the block and all internal events, sets the boolean \n        evaluation flag to 'False'. Also resets the block.\n        \"\"\"\n        self._active = False\n        for event in self.events: \n            event.off()\n        self.reset()  \n\n\n    def reset(self):\n        \"\"\"Reset the blocks inputs and outputs and also its internal solver, \n        if the block has a solver instance.\n        \"\"\"\n        #reset inputs and outputs\n        self.inputs.reset()\n        self.outputs.reset()\n\n        #reset engine if block has solver\n        if self.engine: self.engine.reset()\n\n        #reset operators if defined\n        if self.op_alg: self.op_alg.reset()\n        if self.op_dyn: self.op_dyn.reset()\n\n        #reset internal events (if there are any)\n        for event in self.events:\n            event.reset()\n\n\n    def linearize(self, t):\n        \"\"\"Linearize the algebraic and dynamic components of the block.\n\n        This is done by linearizing the internal 'Operator' and 'DynamicOperator' \n        instances in the current system operating point. The operators create \n        1st order taylor approximations internally and use them on subsequent \n        calls after linearization.\n\n        Parameters\n        ----------\n        t : float \n            evaluation time\n        \"\"\"\n\n        #get current state\n        u, _, x = self.get_all()\n\n        #no engine -> stateless\n        if not self.engine:\n            #linearize only algebraic operator \n            if self.op_alg: self.op_alg.linearize(u)\n        else:\n            #linearize algebraic and dynamic operators\n            if self.op_alg: self.op_alg.linearize(x, u, t)\n            if self.op_dyn: self.op_dyn.linearize(x, u, t)\n\n\n    def delinearize(self):\n        \"\"\"Revert the linearization of the blocks algebraic and dynamic components.\n\n        This is resets the internal 'Operator' and 'DynamicOperator' instances, \n        deleting the linear surrogate model and using the original function for \n        subsequent calls.\n        \"\"\"\n        #reset algebraic and dynamic operators\n        if self.op_alg: self.op_alg.reset()\n        if self.op_dyn: self.op_dyn.reset()\n\n\n    # methods for blocks with integration engines ---------------------------------------\n\n    def set_solver(self, Solver, parent, **solver_args):\n        \"\"\"Initialize the numerical integration engine with local truncation error\n        tolerance if required.\n\n        If the block already has an integration engine, it is changed.\n        If the block does not have an 'initial_value' attribute, this method\n        does nothing (block is not dynamic).\n\n        Parameters\n        ----------\n        Solver : Solver\n            numerical integrator class\n        parent : None | Solver\n            numerical integrator instance for stage synchronization\n        solver_args : dict\n            additional args for the solver\n        \"\"\"\n        #only initialize solver if block has initial_value (is dynamic)\n        if not hasattr(self, 'initial_value'):\n            return\n\n        #use unified create method - handles both new and existing engine\n        self.engine = Solver.create(\n            self.initial_value,\n            parent,\n            from_engine=self.engine,\n            **solver_args\n            )\n\n\n    def revert(self):\n        \"\"\"Revert the block to the state of the previous timestep, if the \n        block has a solver instance indicated by the 'has_engine' flag.\n\n        This is required for adaptive solvers to revert the state to the \n        previous timestep.\n        \"\"\"\n        if self.engine: self.engine.revert()\n\n\n    def buffer(self, dt):\n        \"\"\"\n        Buffer current internal state of the block and the current timestep\n        if the block has a solver instance (is stateful).\n\n        This is required for multistage, multistep and adaptive integrators.\n\n        Parameters\n        ----------\n        dt : float\n            integration timestep\n        \"\"\"\n        if self.engine: self.engine.buffer(dt)\n\n\n    # methods for sampling data ---------------------------------------------------------\n\n    def sample(self, t, dt):\n        \"\"\"Samples the data of the blocks inputs or internal state when called. \n\n        This can record block parameters after a successful timestep such as \n        for the 'Scope' and 'Delay' blocks but also for sampling from a random \n        distribution in the 'RNG' and the noise blocks.\n\n        Parameters\n        ----------\n        t : float\n            evaluation time for sampling\n        dt : float\n            integration timestep\n        \"\"\"\n        pass\n\n\n    # methods for extracting data -------------------------------------------------------\n\n    def read(self):\n        \"\"\"Read data from recording blocks.\n\n        Note\n        ----\n        Not implemented by default, special recording blocks \n        implement this method.\n        \"\"\"\n        pass\n\n\n    @deprecated(version=\"1.0.0\", reason=\"its against pathsims philosophy\")\n    def collect(self):\n        \"\"\"Yield (category, id, data) tuples for recording blocks to simplify \n        global data collection from all recording blocks.\n\n        Note\n        ----\n        Yields an empty generator by default, needs to be implemented by \n        special recording blocks.\n        \"\"\"\n        yield from ()\n\n\n    # methods for inter-block data transfer ---------------------------------------------\n\n    def get_all(self):\n        \"\"\"Retrieves and returns internal states of engine (if available) \n        and the block inputs and outputs as arrays for use outside. \n\n        Either for monitoring, postprocessing or event detection. \n        In any case this enables easy access to the current block state.\n\n        Returns\n        -------\n        inputs : array\n            block input register\n        outputs : array\n            block output register\n        states : array\n            internal states of the block\n        \"\"\"\n        _inputs  = self.inputs.to_array()\n        _outputs = self.outputs.to_array()\n        _states  = self.engine.state if self.engine else []\n        return _inputs, _outputs, _states\n\n\n    # methods for block output and state updates ----------------------------------------\n\n    def update(self, t):\n        \"\"\"The 'update' method is called iteratively for all blocks to evaluate the \n        algebraic components of the global system ode from the DAG.\n\n        It is meant for instant time blocks (blocks that dont have a delay due to the \n        timestep, such as Amplifier, etc.) and updates the 'outputs' of the block \n        directly based on the 'inputs' and possibly internal states. \n\n        Note\n        ----\n        The implementation of the 'update' method in the base 'Block' class is intended \n        as a fallback and is not performance optimized. Special blocks might reimplement \n        this method differently for higher performance, for example SISO or MISO blocks.\n\n        Parameters\n        ----------\n        t : float\n            evaluation time\n        \"\"\"\n\n        #no internal algebraic operator -> early exit\n        if self.op_alg is None:\n            return 0.0\n\n        #block inputs \n        u = self.inputs.to_array()\n\n        #no internal state -> standard 'Operator'\n        if self.engine: \n            x = self.engine.state\n            y = self.op_alg(x, u, t)\n        else: \n            y = self.op_alg(u)           \n\n        #update register\n        self.outputs.update_from_array(y)\n\n\n    def solve(self, t, dt):\n        \"\"\"The 'solve' method performs one iterative solution step that is required\n        to solve the implicit update equation of the solver if an implicit solver \n        (numerical integrator) is used.\n\n        It returns the relative difference between the new updated solution \n        and the previous iteration of the solution to track convergence within \n        an outer loop.\n\n        This only has to be implemented by blocks that have an internal \n        integration engine with an implicit solver.\n\n        Parameters\n        ----------\n        t : float\n            evaluation time\n        dt : float\n            integration timestep\n\n        Returns\n        ------- \n        error : float\n            solver residual norm\n        \"\"\"\n        return 0.0 \n\n\n    def step(self, t, dt):\n        \"\"\"The 'step' method is used in transient simulations and performs an action \n        (numeric integration timestep, recording data, etc.) based on the current \n        inputs and the current internal state. \n\n        It performs one timestep for the internal states. For instant time blocks,\n        the 'step' method does not has to be implemented specifically. \n\n        The method handles timestepping for dynamic blocks with internal states\n        such as 'Integrator', 'StateSpace', etc.\n\n        Parameters\n        ----------\n        t : float\n            evaluation time\n        dt : float\n            integration timestep\n\n        Returns\n        -------\n        success : bool\n            step was successful\n        error : float\n            local truncation error from adaptive integrators\n        scale : float | None\n            timestep rescale from adaptive integrators, None if no rescale needed\n        \"\"\"\n\n        #by default no error estimate (error norm -> 0.0)\n        return True, 0.0, None",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self):\n\n    #registers to hold input and output values\n    self.inputs = Register(\n        mapping=self.input_port_labels and self.input_port_labels.copy()\n        )\n    self.outputs = Register(\n        mapping=self.output_port_labels and self.output_port_labels.copy()\n        )\n\n    #initialize integration engine as 'None' by default\n    self.engine = None\n\n    #flag to set block active\n    self._active = True\n\n    #internal discrete events (for mixed signal blocks)\n    self.events = []\n\n    #operators for algebraic and dynamic components\n    self.op_alg = None\n    self.op_dyn = None",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "info",
              "description": "Get block metadata for introspection and UI integration.",
              "docstring_html": "<p>Get block metadata for introspection and UI integration.</p>\n<p>Returns a dictionary containing block type information, port mappings,\nand parameter definitions. Results are cached per class.</p>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>info <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">dict</span></dt>\n<dd><p class=\"first\">Block metadata with the following keys:\n- type : str</p>\n<blockquote>\nClass name of the block</blockquote>\n<ul class=\"last simple\">\n<li><dl class=\"first docutils\">\n<dt>description <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">str</span></dt>\n<dd>Block docstring</dd>\n</dl>\n</li>\n<li><dl class=\"first docutils\">\n<dt>shape <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">tuple</span></dt>\n<dd>Input/output shape (n_inputs, n_outputs)</dd>\n</dl>\n</li>\n<li><dl class=\"first docutils\">\n<dt>size <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>State vector size</dd>\n</dl>\n</li>\n<li><dl class=\"first docutils\">\n<dt>in_labels <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">dict</span></dt>\n<dd>Input port name to index mapping</dd>\n</dl>\n</li>\n<li><dl class=\"first docutils\">\n<dt>out_labels <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">dict</span></dt>\n<dd>Output port name to index mapping</dd>\n</dl>\n</li>\n<li><dl class=\"first docutils\">\n<dt>parameters <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">dict</span></dt>\n<dd>Parameter names mapped to their default values</dd>\n</dl>\n</li>\n</ul>\n</dd>\n</dl>\n",
              "source": "@classmethod\n@lru_cache()\ndef info(cls):\n    \"\"\"Get block metadata for introspection and UI integration.\n\n    Returns a dictionary containing block type information, port mappings,\n    and parameter definitions. Results are cached per class.\n\n    Returns\n    -------\n    info : dict\n        Block metadata with the following keys:\n        - type : str\n            Class name of the block\n        - description : str\n            Block docstring\n        - shape : tuple\n            Input/output shape (n_inputs, n_outputs)\n        - size : int\n            State vector size\n        - in_labels : dict\n            Input port name to index mapping\n        - out_labels : dict\n            Output port name to index mapping\n        - parameters : dict\n            Parameter names mapped to their default values\n    \"\"\"\n\n    # Get __init__ signature for parameters\n    sig = inspect.signature(cls.__init__)\n    params = {\n        name: {\n            \"default\": None if param.default is inspect.Parameter.empty else param.default\n            }\n        for name, param in sig.parameters.items() \n        if name not in (\"self\", \"kwargs\", \"args\")\n        }\n\n    return {\n        \"type\": cls.__name__,\n        \"description\": cls.__doc__,\n        \"input_port_labels\": cls.input_port_labels,\n        \"output_port_labels\": cls.output_port_labels,\n        \"parameters\": params,\n        }",
              "signature": "(cls)",
              "parameters": [
                {
                  "name": "cls",
                  "type": null,
                  "default": null,
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "classmethod"
            },
            {
              "name": "plot",
              "description": "Block specific visualization, enables plotting",
              "docstring_html": "<p>Block specific visualization, enables plotting\naccess from the simulation level.</p>\n<p>This gets primarily used by the visualization blocks\nsuch as the 'Scope' and 'Spectrum'.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>args <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">tuple</span></dt>\n<dd>args for the plot methods</dd>\n<dt>kwargs <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">dict</span></dt>\n<dd>kwargs for the plot method</dd>\n</dl>\n",
              "source": "def plot(self, *args, **kwargs):\n    \"\"\"Block specific visualization, enables plotting \n    access from the simulation level.\n\n    This gets primarily used by the visualization blocks \n    such as the 'Scope' and 'Spectrum'.\n\n    Parameters\n    ----------\n    args : tuple\n        args for the plot methods\n    kwargs : dict\n        kwargs for the plot method\n    \"\"\"\n    pass",
              "signature": "(args = (), kwargs = {})",
              "parameters": [
                {
                  "name": "args",
                  "type": null,
                  "default": "()",
                  "description": "args for the plot methods"
                },
                {
                  "name": "kwargs",
                  "type": null,
                  "default": "{}",
                  "description": "kwargs for the plot method"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "on",
              "description": "Activate the block and all internal events, sets the boolean",
              "docstring_html": "<p>Activate the block and all internal events, sets the boolean\nevaluation flag to 'True'.</p>\n",
              "source": "def on(self):\n    \"\"\"Activate the block and all internal events, sets the boolean\n    evaluation flag to 'True'.\n    \"\"\"\n    self._active = True\n    for event in self.events: \n        event.on()",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "off",
              "description": "Deactivate the block and all internal events, sets the boolean",
              "docstring_html": "<p>Deactivate the block and all internal events, sets the boolean\nevaluation flag to 'False'. Also resets the block.</p>\n",
              "source": "def off(self):\n    \"\"\"Deactivate the block and all internal events, sets the boolean \n    evaluation flag to 'False'. Also resets the block.\n    \"\"\"\n    self._active = False\n    for event in self.events: \n        event.off()\n    self.reset()",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "reset",
              "description": "Reset the blocks inputs and outputs and also its internal solver,",
              "docstring_html": "<p>Reset the blocks inputs and outputs and also its internal solver,\nif the block has a solver instance.</p>\n",
              "source": "def reset(self):\n    \"\"\"Reset the blocks inputs and outputs and also its internal solver, \n    if the block has a solver instance.\n    \"\"\"\n    #reset inputs and outputs\n    self.inputs.reset()\n    self.outputs.reset()\n\n    #reset engine if block has solver\n    if self.engine: self.engine.reset()\n\n    #reset operators if defined\n    if self.op_alg: self.op_alg.reset()\n    if self.op_dyn: self.op_dyn.reset()\n\n    #reset internal events (if there are any)\n    for event in self.events:\n        event.reset()",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "linearize",
              "description": "Linearize the algebraic and dynamic components of the block.",
              "docstring_html": "<p>Linearize the algebraic and dynamic components of the block.</p>\n<p>This is done by linearizing the internal 'Operator' and 'DynamicOperator'\ninstances in the current system operating point. The operators create\n1st order taylor approximations internally and use them on subsequent\ncalls after linearization.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time</dd>\n</dl>\n",
              "source": "def linearize(self, t):\n    \"\"\"Linearize the algebraic and dynamic components of the block.\n\n    This is done by linearizing the internal 'Operator' and 'DynamicOperator' \n    instances in the current system operating point. The operators create \n    1st order taylor approximations internally and use them on subsequent \n    calls after linearization.\n\n    Parameters\n    ----------\n    t : float \n        evaluation time\n    \"\"\"\n\n    #get current state\n    u, _, x = self.get_all()\n\n    #no engine -> stateless\n    if not self.engine:\n        #linearize only algebraic operator \n        if self.op_alg: self.op_alg.linearize(u)\n    else:\n        #linearize algebraic and dynamic operators\n        if self.op_alg: self.op_alg.linearize(x, u, t)\n        if self.op_dyn: self.op_dyn.linearize(x, u, t)",
              "signature": "(t)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "delinearize",
              "description": "Revert the linearization of the blocks algebraic and dynamic components.",
              "docstring_html": "<p>Revert the linearization of the blocks algebraic and dynamic components.</p>\n<p>This is resets the internal 'Operator' and 'DynamicOperator' instances,\ndeleting the linear surrogate model and using the original function for\nsubsequent calls.</p>\n",
              "source": "def delinearize(self):\n    \"\"\"Revert the linearization of the blocks algebraic and dynamic components.\n\n    This is resets the internal 'Operator' and 'DynamicOperator' instances, \n    deleting the linear surrogate model and using the original function for \n    subsequent calls.\n    \"\"\"\n    #reset algebraic and dynamic operators\n    if self.op_alg: self.op_alg.reset()\n    if self.op_dyn: self.op_dyn.reset()",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "set_solver",
              "description": "Initialize the numerical integration engine with local truncation error",
              "docstring_html": "<p>Initialize the numerical integration engine with local truncation error\ntolerance if required.</p>\n<p>If the block already has an integration engine, it is changed.\nIf the block does not have an 'initial_value' attribute, this method\ndoes nothing (block is not dynamic).</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>Solver <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">Solver</span></dt>\n<dd>numerical integrator class</dd>\n<dt>parent <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">None | Solver</span></dt>\n<dd>numerical integrator instance for stage synchronization</dd>\n<dt>solver_args <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">dict</span></dt>\n<dd>additional args for the solver</dd>\n</dl>\n",
              "source": "def set_solver(self, Solver, parent, **solver_args):\n    \"\"\"Initialize the numerical integration engine with local truncation error\n    tolerance if required.\n\n    If the block already has an integration engine, it is changed.\n    If the block does not have an 'initial_value' attribute, this method\n    does nothing (block is not dynamic).\n\n    Parameters\n    ----------\n    Solver : Solver\n        numerical integrator class\n    parent : None | Solver\n        numerical integrator instance for stage synchronization\n    solver_args : dict\n        additional args for the solver\n    \"\"\"\n    #only initialize solver if block has initial_value (is dynamic)\n    if not hasattr(self, 'initial_value'):\n        return\n\n    #use unified create method - handles both new and existing engine\n    self.engine = Solver.create(\n        self.initial_value,\n        parent,\n        from_engine=self.engine,\n        **solver_args\n        )",
              "signature": "(Solver, parent, solver_args = {})",
              "parameters": [
                {
                  "name": "Solver",
                  "type": null,
                  "default": null,
                  "description": "numerical integrator class"
                },
                {
                  "name": "parent",
                  "type": null,
                  "default": null,
                  "description": "numerical integrator instance for stage synchronization"
                },
                {
                  "name": "solver_args",
                  "type": null,
                  "default": "{}",
                  "description": "additional args for the solver"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "revert",
              "description": "Revert the block to the state of the previous timestep, if the",
              "docstring_html": "<p>Revert the block to the state of the previous timestep, if the\nblock has a solver instance indicated by the 'has_engine' flag.</p>\n<p>This is required for adaptive solvers to revert the state to the\nprevious timestep.</p>\n",
              "source": "def revert(self):\n    \"\"\"Revert the block to the state of the previous timestep, if the \n    block has a solver instance indicated by the 'has_engine' flag.\n\n    This is required for adaptive solvers to revert the state to the \n    previous timestep.\n    \"\"\"\n    if self.engine: self.engine.revert()",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "buffer",
              "description": "Buffer current internal state of the block and the current timestep",
              "docstring_html": "<p>Buffer current internal state of the block and the current timestep\nif the block has a solver instance (is stateful).</p>\n<p>This is required for multistage, multistep and adaptive integrators.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>integration timestep</dd>\n</dl>\n",
              "source": "def buffer(self, dt):\n    \"\"\"\n    Buffer current internal state of the block and the current timestep\n    if the block has a solver instance (is stateful).\n\n    This is required for multistage, multistep and adaptive integrators.\n\n    Parameters\n    ----------\n    dt : float\n        integration timestep\n    \"\"\"\n    if self.engine: self.engine.buffer(dt)",
              "signature": "(dt)",
              "parameters": [
                {
                  "name": "dt",
                  "type": null,
                  "default": null,
                  "description": "integration timestep"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "sample",
              "description": "Samples the data of the blocks inputs or internal state when called.",
              "docstring_html": "<p>Samples the data of the blocks inputs or internal state when called.</p>\n<p>This can record block parameters after a successful timestep such as\nfor the 'Scope' and 'Delay' blocks but also for sampling from a random\ndistribution in the 'RNG' and the noise blocks.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time for sampling</dd>\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>integration timestep</dd>\n</dl>\n",
              "source": "def sample(self, t, dt):\n    \"\"\"Samples the data of the blocks inputs or internal state when called. \n\n    This can record block parameters after a successful timestep such as \n    for the 'Scope' and 'Delay' blocks but also for sampling from a random \n    distribution in the 'RNG' and the noise blocks.\n\n    Parameters\n    ----------\n    t : float\n        evaluation time for sampling\n    dt : float\n        integration timestep\n    \"\"\"\n    pass",
              "signature": "(t, dt)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time for sampling"
                },
                {
                  "name": "dt",
                  "type": null,
                  "default": null,
                  "description": "integration timestep"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "read",
              "description": "Read data from recording blocks.",
              "docstring_html": "<p>Read data from recording blocks.</p>\n<div class=\"section\" id=\"note\">\n<h4>Note</h4>\n<p>Not implemented by default, special recording blocks\nimplement this method.</p>\n</div>\n",
              "source": "def read(self):\n    \"\"\"Read data from recording blocks.\n\n    Note\n    ----\n    Not implemented by default, special recording blocks \n    implement this method.\n    \"\"\"\n    pass",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "collect",
              "description": "Yield (category, id, data) tuples for recording blocks to simplify",
              "docstring_html": "<p>Yield (category, id, data) tuples for recording blocks to simplify\nglobal data collection from all recording blocks.</p>\n<div class=\"section\" id=\"note\">\n<h4>Note</h4>\n<p>Yields an empty generator by default, needs to be implemented by\nspecial recording blocks.</p>\n</div>\n",
              "source": "@deprecated(version=\"1.0.0\", reason=\"its against pathsims philosophy\")\ndef collect(self):\n    \"\"\"Yield (category, id, data) tuples for recording blocks to simplify \n    global data collection from all recording blocks.\n\n    Note\n    ----\n    Yields an empty generator by default, needs to be implemented by \n    special recording blocks.\n    \"\"\"\n    yield from ()",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "get_all",
              "description": "Retrieves and returns internal states of engine (if available)",
              "docstring_html": "<p>Retrieves and returns internal states of engine (if available)\nand the block inputs and outputs as arrays for use outside.</p>\n<p>Either for monitoring, postprocessing or event detection.\nIn any case this enables easy access to the current block state.</p>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>inputs <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array</span></dt>\n<dd>block input register</dd>\n<dt>outputs <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array</span></dt>\n<dd>block output register</dd>\n<dt>states <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array</span></dt>\n<dd>internal states of the block</dd>\n</dl>\n",
              "source": "def get_all(self):\n    \"\"\"Retrieves and returns internal states of engine (if available) \n    and the block inputs and outputs as arrays for use outside. \n\n    Either for monitoring, postprocessing or event detection. \n    In any case this enables easy access to the current block state.\n\n    Returns\n    -------\n    inputs : array\n        block input register\n    outputs : array\n        block output register\n    states : array\n        internal states of the block\n    \"\"\"\n    _inputs  = self.inputs.to_array()\n    _outputs = self.outputs.to_array()\n    _states  = self.engine.state if self.engine else []\n    return _inputs, _outputs, _states",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "update",
              "description": "The 'update' method is called iteratively for all blocks to evaluate the",
              "docstring_html": "<p>The 'update' method is called iteratively for all blocks to evaluate the\nalgebraic components of the global system ode from the DAG.</p>\n<p>It is meant for instant time blocks (blocks that dont have a delay due to the\ntimestep, such as Amplifier, etc.) and updates the 'outputs' of the block\ndirectly based on the 'inputs' and possibly internal states.</p>\n<div class=\"section\" id=\"note\">\n<h4>Note</h4>\n<p>The implementation of the 'update' method in the base 'Block' class is intended\nas a fallback and is not performance optimized. Special blocks might reimplement\nthis method differently for higher performance, for example SISO or MISO blocks.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time</dd>\n</dl>\n</div>\n",
              "source": "def update(self, t):\n    \"\"\"The 'update' method is called iteratively for all blocks to evaluate the \n    algebraic components of the global system ode from the DAG.\n\n    It is meant for instant time blocks (blocks that dont have a delay due to the \n    timestep, such as Amplifier, etc.) and updates the 'outputs' of the block \n    directly based on the 'inputs' and possibly internal states. \n\n    Note\n    ----\n    The implementation of the 'update' method in the base 'Block' class is intended \n    as a fallback and is not performance optimized. Special blocks might reimplement \n    this method differently for higher performance, for example SISO or MISO blocks.\n\n    Parameters\n    ----------\n    t : float\n        evaluation time\n    \"\"\"\n\n    #no internal algebraic operator -> early exit\n    if self.op_alg is None:\n        return 0.0\n\n    #block inputs \n    u = self.inputs.to_array()\n\n    #no internal state -> standard 'Operator'\n    if self.engine: \n        x = self.engine.state\n        y = self.op_alg(x, u, t)\n    else: \n        y = self.op_alg(u)           \n\n    #update register\n    self.outputs.update_from_array(y)",
              "signature": "(t)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "solve",
              "description": "The 'solve' method performs one iterative solution step that is required",
              "docstring_html": "<p>The 'solve' method performs one iterative solution step that is required\nto solve the implicit update equation of the solver if an implicit solver\n(numerical integrator) is used.</p>\n<p>It returns the relative difference between the new updated solution\nand the previous iteration of the solution to track convergence within\nan outer loop.</p>\n<p>This only has to be implemented by blocks that have an internal\nintegration engine with an implicit solver.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time</dd>\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>integration timestep</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>error <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>solver residual norm</dd>\n</dl>\n",
              "source": "def solve(self, t, dt):\n    \"\"\"The 'solve' method performs one iterative solution step that is required\n    to solve the implicit update equation of the solver if an implicit solver \n    (numerical integrator) is used.\n\n    It returns the relative difference between the new updated solution \n    and the previous iteration of the solution to track convergence within \n    an outer loop.\n\n    This only has to be implemented by blocks that have an internal \n    integration engine with an implicit solver.\n\n    Parameters\n    ----------\n    t : float\n        evaluation time\n    dt : float\n        integration timestep\n\n    Returns\n    ------- \n    error : float\n        solver residual norm\n    \"\"\"\n    return 0.0",
              "signature": "(t, dt)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time"
                },
                {
                  "name": "dt",
                  "type": null,
                  "default": null,
                  "description": "integration timestep"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "step",
              "description": "The 'step' method is used in transient simulations and performs an action",
              "docstring_html": "<p>The 'step' method is used in transient simulations and performs an action\n(numeric integration timestep, recording data, etc.) based on the current\ninputs and the current internal state.</p>\n<p>It performs one timestep for the internal states. For instant time blocks,\nthe 'step' method does not has to be implemented specifically.</p>\n<p>The method handles timestepping for dynamic blocks with internal states\nsuch as 'Integrator', 'StateSpace', etc.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time</dd>\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>integration timestep</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>success <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>step was successful</dd>\n<dt>error <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>local truncation error from adaptive integrators</dd>\n<dt>scale <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float | None</span></dt>\n<dd>timestep rescale from adaptive integrators, None if no rescale needed</dd>\n</dl>\n",
              "source": "def step(self, t, dt):\n    \"\"\"The 'step' method is used in transient simulations and performs an action \n    (numeric integration timestep, recording data, etc.) based on the current \n    inputs and the current internal state. \n\n    It performs one timestep for the internal states. For instant time blocks,\n    the 'step' method does not has to be implemented specifically. \n\n    The method handles timestepping for dynamic blocks with internal states\n    such as 'Integrator', 'StateSpace', etc.\n\n    Parameters\n    ----------\n    t : float\n        evaluation time\n    dt : float\n        integration timestep\n\n    Returns\n    -------\n    success : bool\n        step was successful\n    error : float\n        local truncation error from adaptive integrators\n    scale : float | None\n        timestep rescale from adaptive integrators, None if no rescale needed\n    \"\"\"\n\n    #by default no error estimate (error norm -> 0.0)\n    return True, 0.0, None",
              "signature": "(t, dt)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time"
                },
                {
                  "name": "dt",
                  "type": null,
                  "default": null,
                  "description": "integration timestep"
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "input_port_labels",
              "description": "",
              "type": null,
              "value": "None"
            },
            {
              "name": "output_port_labels",
              "description": "",
              "type": null,
              "value": "None"
            },
            {
              "name": "inputs",
              "description": "",
              "type": null,
              "value": "Register(mapping=(self.input_port_labels and self.input_port_labels.copy()))"
            },
            {
              "name": "outputs",
              "description": "",
              "type": null,
              "value": "Register(mapping=(self.output_port_labels and self.output_port_labels.copy()))"
            },
            {
              "name": "engine",
              "description": "",
              "type": null,
              "value": "None"
            },
            {
              "name": "_active",
              "description": "",
              "type": null,
              "value": "True"
            },
            {
              "name": "events",
              "description": "",
              "type": null,
              "value": "[]"
            },
            {
              "name": "op_alg",
              "description": "",
              "type": null,
              "value": "None"
            },
            {
              "name": "op_dyn",
              "description": "",
              "type": null,
              "value": "None"
            },
            {
              "name": "size",
              "description": "Get size information from block, such as",
              "type": null,
              "value": null
            },
            {
              "name": "shape",
              "description": "Get the number of input and output ports of the block",
              "type": null,
              "value": null
            }
          ],
          "parameters": []
        }
      ],
      "functions": []
    },
    "pathsim.blocks.adder": {
      "name": "pathsim.blocks.adder",
      "description": "",
      "docstring_html": "",
      "classes": [
        {
          "name": "Adder",
          "description": "Summs / adds up all input signals to a single output signal (MISO)",
          "docstring_html": "<p>Summs / adds up all input signals to a single output signal (MISO)</p>\n<p>This is how it works in the default case</p>\n<pre class=\"math\">\ny(t) = \\sum_i u_i(t)\n</pre>\n<p>and like this when additional operations are defined</p>\n<pre class=\"math\">\ny(t) = \\sum_i \\mathrm{op}_i \\cdot u_i(t)\n</pre>\n<div class=\"section\" id=\"example\">\n<h4>Example</h4>\n<p>This is the default initialization that just adds up all the inputs:</p>\n<pre class=\"code python literal-block\">\n<span class=\"n\">A</span> <span class=\"o\">=</span> <span class=\"n\">Adder</span><span class=\"p\">()</span>\n</pre>\n<p>and this is the initialization with specific operations that subtracts\nthe second from first input and neglects all others:</p>\n<pre class=\"code python literal-block\">\n<span class=\"n\">A</span> <span class=\"o\">=</span> <span class=\"n\">Adder</span><span class=\"p\">(</span><span class=\"s1\">'+-'</span><span class=\"p\">)</span>\n</pre>\n</div>\n<div class=\"section\" id=\"note\">\n<h4>Note</h4>\n<p>This block is purely algebraic and its operation (<cite>op_alg</cite>) will be called\nmultiple times per timestep, each time when <cite>Simulation._update(t)</cite> is\ncalled in the global simulation loop.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>operations <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">str, optional</span></dt>\n<dd>optional string of operations to be applied before\nsummation, i.e. '+-' will compute the difference,\n'None' will just perform regular sum</dd>\n</dl>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>_ops <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">dict</span></dt>\n<dd>dict that maps string operations to numerical</dd>\n<dt>_ops_array <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array_like</span></dt>\n<dd>operations converted to array</dd>\n<dt>op_alg <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">Operator</span></dt>\n<dd>internal algebraic operator</dd>\n</dl>\n</div>\n",
          "source": "class Adder(Block):\n    \"\"\"Summs / adds up all input signals to a single output signal (MISO)\n\n    This is how it works in the default case\n\n    .. math::\n\n        y(t) = \\\\sum_i u_i(t)\n\n    and like this when additional operations are defined\n\n    .. math::\n\n        y(t) = \\\\sum_i \\\\mathrm{op}_i \\\\cdot u_i(t)\n\n\n    Example\n    -------\n    This is the default initialization that just adds up all the inputs:\n\n    .. code-block:: python\n\n        A = Adder()\n\n    and this is the initialization with specific operations that subtracts \n    the second from first input and neglects all others:\n\n    .. code-block:: python\n\n        A = Adder('+-')\n\n\n    Note\n    ----\n    This block is purely algebraic and its operation (`op_alg`) will be called \n    multiple times per timestep, each time when `Simulation._update(t)` is \n    called in the global simulation loop.\n\n\n    Parameters\n    ----------\n    operations : str, optional\n        optional string of operations to be applied before \n        summation, i.e. '+-' will compute the difference, \n        'None' will just perform regular sum\n\n\n    Attributes\n    ----------\n    _ops : dict\n        dict that maps string operations to numerical\n    _ops_array : array_like\n        operations converted to array\n    op_alg : Operator\n        internal algebraic operator\n    \"\"\"\n\n    input_port_labels = None\n    output_port_labels = {\"out\":0}\n\n    def __init__(self, operations=None):\n        super().__init__()\n\n        #allowed arithmetic operations\n        self._ops = {\"+\":1.0, \"-\":-1.0, \"0\":0.0}\n        self.operations = operations    \n\n        #are special operations defined?\n        if self.operations is None:\n\n            #create internal algebraic operator\n            self.op_alg = Operator(\n                func=sum,\n                jac=lambda x: np.ones((1, len(x)))\n                )\n\n        else:\n\n            #input validation\n            if not isinstance(self.operations, str):\n                raise ValueError(\"'operations' must be string or 'None'\")\n            for op in self.operations:\n                if op not in self._ops:\n                    raise ValueError(f\"operation '{op}' not in {self._ops}\")\n\n            #construct array from operations\n            self._ops_array = np.array([self._ops[op] for op in self.operations])\n\n            def sum_ops(X):\n                return sum(x*op for x, op in zip(X, self._ops_array))\n            def jac_ops(X):\n                nx, no = len(X), len(self._ops_array)\n                if nx <= no:\n                    return self._ops_array[:nx].reshape(1, -1)\n                return np.pad(self._ops_array, (0, nx-no), mode=\"constant\").reshape(1, -1)\n\n            #create internal algebraic operator\n            self.op_alg = Operator(\n                func=sum_ops, \n                jac=jac_ops\n                )\n\n\n    def __len__(self):\n        \"\"\"Purely algebraic block\"\"\"\n        return 1\n\n\n    def update(self, t):\n        \"\"\"update system equation in fixed point loop for \n        algebraic loops, with optional error control\n\n        Parameters\n        ----------\n        t : float\n            evaluation time\n        \"\"\"\n        u = self.inputs.to_array()\n        y = self.op_alg(u)\n        self.outputs.update_from_array(y)",
          "bases": [
            "pathsim.blocks._block.Block"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, operations=None):\n    super().__init__()\n\n    #allowed arithmetic operations\n    self._ops = {\"+\":1.0, \"-\":-1.0, \"0\":0.0}\n    self.operations = operations    \n\n    #are special operations defined?\n    if self.operations is None:\n\n        #create internal algebraic operator\n        self.op_alg = Operator(\n            func=sum,\n            jac=lambda x: np.ones((1, len(x)))\n            )\n\n    else:\n\n        #input validation\n        if not isinstance(self.operations, str):\n            raise ValueError(\"'operations' must be string or 'None'\")\n        for op in self.operations:\n            if op not in self._ops:\n                raise ValueError(f\"operation '{op}' not in {self._ops}\")\n\n        #construct array from operations\n        self._ops_array = np.array([self._ops[op] for op in self.operations])\n\n        def sum_ops(X):\n            return sum(x*op for x, op in zip(X, self._ops_array))\n        def jac_ops(X):\n            nx, no = len(X), len(self._ops_array)\n            if nx <= no:\n                return self._ops_array[:nx].reshape(1, -1)\n            return np.pad(self._ops_array, (0, nx-no), mode=\"constant\").reshape(1, -1)\n\n        #create internal algebraic operator\n        self.op_alg = Operator(\n            func=sum_ops, \n            jac=jac_ops\n            )",
              "signature": "(operations = None)",
              "parameters": [
                {
                  "name": "operations",
                  "type": null,
                  "default": "None",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "update",
              "description": "update system equation in fixed point loop for",
              "docstring_html": "<p>update system equation in fixed point loop for\nalgebraic loops, with optional error control</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time</dd>\n</dl>\n",
              "source": "def update(self, t):\n    \"\"\"update system equation in fixed point loop for \n    algebraic loops, with optional error control\n\n    Parameters\n    ----------\n    t : float\n        evaluation time\n    \"\"\"\n    u = self.inputs.to_array()\n    y = self.op_alg(u)\n    self.outputs.update_from_array(y)",
              "signature": "(t)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time"
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "input_port_labels",
              "description": "",
              "type": null,
              "value": "None"
            },
            {
              "name": "output_port_labels",
              "description": "",
              "type": null,
              "value": "{'out': 0}"
            },
            {
              "name": "_ops",
              "description": "",
              "type": null,
              "value": "{'+': 1.0, '-': -1.0, '0': 0.0}"
            },
            {
              "name": "operations",
              "description": "",
              "type": null,
              "value": "operations"
            },
            {
              "name": "op_alg",
              "description": "",
              "type": null,
              "value": "Operator(func=sum, jac=(lambda x: np.ones((1, len(x)))))"
            },
            {
              "name": "_ops_array",
              "description": "",
              "type": null,
              "value": "np.array([(self._ops[op]) for op in (self.operations)])"
            }
          ],
          "parameters": [
            {
              "name": "operations",
              "type": null,
              "default": "None",
              "description": "optional string of operations to be applied before summation, i.e. '+-' will compute the difference, 'None' will just perform regular sum"
            }
          ]
        }
      ],
      "functions": []
    },
    "pathsim.blocks.amplifier": {
      "name": "pathsim.blocks.amplifier",
      "description": "",
      "docstring_html": "",
      "classes": [
        {
          "name": "Amplifier",
          "description": "Amplifies the input signal by multiplication with a constant gain term.",
          "docstring_html": "<p>Amplifies the input signal by multiplication with a constant gain term.</p>\n<p>Like this:</p>\n<pre class=\"math\">\ny(t) = \\mathrm{gain} \\cdot u(t)\n</pre>\n<div class=\"section\" id=\"note\">\n<h4>Note</h4>\n<p>This block is purely algebraic and its operation (<cite>op_alg</cite>) will be called\nmultiple times per timestep, each time when <cite>Simulation._update(t)</cite> is\ncalled in the global simulation loop.</p>\n</div>\n<div class=\"section\" id=\"example\">\n<h4>Example</h4>\n<p>The block is initialized like this:</p>\n<pre class=\"code python literal-block\">\n<span class=\"c1\">#amplification by factor 5</span><span class=\"w\">\n</span><span class=\"n\">A</span> <span class=\"o\">=</span> <span class=\"n\">Amplifier</span><span class=\"p\">(</span><span class=\"n\">gain</span><span class=\"o\">=</span><span class=\"mi\">5</span><span class=\"p\">)</span>\n</pre>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>gain <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>amplifier gain</dd>\n</dl>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>op_alg <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">Operator</span></dt>\n<dd>internal algebraic operator</dd>\n</dl>\n</div>\n",
          "source": "class Amplifier(Block):\n    \"\"\"Amplifies the input signal by multiplication with a constant gain term.\n\n    Like this:\n\n    .. math::\n\n        y(t) = \\\\mathrm{gain} \\\\cdot u(t)\n\n\n    Note\n    ----\n    This block is purely algebraic and its operation (`op_alg`) will be called \n    multiple times per timestep, each time when `Simulation._update(t)` is \n    called in the global simulation loop.\n\n\n    Example\n    -------\n    The block is initialized like this:\n\n    .. code-block:: python\n\n        #amplification by factor 5\n        A = Amplifier(gain=5)\n\n\n    Parameters\n    ----------\n    gain : float\n        amplifier gain\n\n\n    Attributes\n    ----------\n    op_alg : Operator\n        internal algebraic operator\n    \"\"\"\n\n    def __init__(self, gain=1.0):\n        super().__init__()\n        self.gain = gain\n\n        self.op_alg = Operator(\n            func=lambda x: x*self.gain, \n            jac=lambda x: self.gain*np.eye(len(x))\n            )\n\n\n    def update(self, t):\n        \"\"\"update system equation in fixed point loop\n\n        Parameters\n        ----------\n        t : float\n            evaluation time\n        \"\"\"\n        u = self.inputs.to_array()\n        y = self.op_alg(u)\n        self.outputs.update_from_array(y)",
          "bases": [
            "pathsim.blocks._block.Block"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, gain=1.0):\n    super().__init__()\n    self.gain = gain\n\n    self.op_alg = Operator(\n        func=lambda x: x*self.gain, \n        jac=lambda x: self.gain*np.eye(len(x))\n        )",
              "signature": "(gain = 1.0)",
              "parameters": [
                {
                  "name": "gain",
                  "type": null,
                  "default": "1.0",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "update",
              "description": "update system equation in fixed point loop",
              "docstring_html": "<p>update system equation in fixed point loop</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time</dd>\n</dl>\n",
              "source": "def update(self, t):\n    \"\"\"update system equation in fixed point loop\n\n    Parameters\n    ----------\n    t : float\n        evaluation time\n    \"\"\"\n    u = self.inputs.to_array()\n    y = self.op_alg(u)\n    self.outputs.update_from_array(y)",
              "signature": "(t)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time"
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "gain",
              "description": "",
              "type": null,
              "value": "gain"
            },
            {
              "name": "op_alg",
              "description": "",
              "type": null,
              "value": "Operator(func=(lambda x: x * self.gain), jac=(lambda x: self.gain * np.eye(len(x))))"
            }
          ],
          "parameters": [
            {
              "name": "gain",
              "type": null,
              "default": "1.0",
              "description": "amplifier gain"
            }
          ]
        }
      ],
      "functions": []
    },
    "pathsim.blocks.comparator": {
      "name": "pathsim.blocks.comparator",
      "description": "",
      "docstring_html": "",
      "classes": [
        {
          "name": "Comparator",
          "description": "Comparator block that sets output depending on predefined thresholds for the input.",
          "docstring_html": "<p>Comparator block that sets output depending on predefined thresholds for the input.</p>\n<p>Sets the output to '1' if the input signal crosses a predefined threshold and to '-1'\nif it crosses in the reverse direction.</p>\n<p>This is realized by the block spawning a zero-crossing event detector that watches\nthe input of the block and locates the transition up to a tolerance.</p>\n<p>The block output is determined by a simple sign check in\nthe 'update' method.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>threshold <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>threshold value for the comparator</dd>\n<dt>tolerance <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>tolerance for zero crossing detection</dd>\n<dt>span <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">list[float] or tuple[float], optional</span></dt>\n<dd>output value range [min, max]</dd>\n</dl>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>events <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">list[ZeroCrossing]</span></dt>\n<dd>internal zero crossing event</dd>\n</dl>\n",
          "source": "class Comparator(Block):\n    \"\"\"Comparator block that sets output depending on predefined thresholds for the input.\n\n    Sets the output to '1' if the input signal crosses a predefined threshold and to '-1' \n    if it crosses in the reverse direction. \n\n    This is realized by the block spawning a zero-crossing event detector that watches \n    the input of the block and locates the transition up to a tolerance. \n\n    The block output is determined by a simple sign check in\n    the 'update' method.\n\n    Parameters\n    ----------\n    threshold : float\n        threshold value for the comparator\n    tolerance : float\n        tolerance for zero crossing detection    \n    span : list[float] or tuple[float], optional\n        output value range [min, max]\n\n    Attributes\n    ----------\n    events : list[ZeroCrossing]\n        internal zero crossing event\n    \"\"\"\n\n    input_port_labels = {\"in\": 0}\n    output_port_labels = {\"out\":0}\n\n\n    def __init__(self, threshold=0, tolerance=1e-4, span=[-1, 1]):\n        super().__init__()\n\n        #block parameters\n        self.threshold = threshold\n        self.tolerance = tolerance\n        self.span = span\n\n        def func_evt(t):\n            return self.inputs[0] - self.threshold\n\n        #internal event for transition detection\n        self.events = [\n            ZeroCrossing(\n                func_evt=func_evt, \n                tolerance=tolerance\n                )\n            ]\n\n\n    def update(self, t):\n        \"\"\"update system equation for fixed point loop, \n        here just setting the outputs\n\n        Note\n        ----\n        no direct passthrough, so the 'update' method \n        is optimized for this case        \n\n        Parameters\n        ----------\n        t : float\n            evaluation time\n\n        Returns\n        -------\n        error : float\n            absolute error to previous iteration for convergence \n            control (here '0.0' because discrete block)\n        \"\"\"\n\n        if self.inputs[0] >= self.threshold:\n            self.outputs[0] = max(self.span)\n        else:\n            self.outputs[0] = min(self.span)",
          "bases": [
            "pathsim.blocks._block.Block"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, threshold=0, tolerance=1e-4, span=[-1, 1]):\n    super().__init__()\n\n    #block parameters\n    self.threshold = threshold\n    self.tolerance = tolerance\n    self.span = span\n\n    def func_evt(t):\n        return self.inputs[0] - self.threshold\n\n    #internal event for transition detection\n    self.events = [\n        ZeroCrossing(\n            func_evt=func_evt, \n            tolerance=tolerance\n            )\n        ]",
              "signature": "(threshold = 0, tolerance = 0.0001, span = [-1, 1])",
              "parameters": [
                {
                  "name": "threshold",
                  "type": null,
                  "default": "0",
                  "description": ""
                },
                {
                  "name": "tolerance",
                  "type": null,
                  "default": "0.0001",
                  "description": ""
                },
                {
                  "name": "span",
                  "type": null,
                  "default": "[-1, 1]",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "update",
              "description": "update system equation for fixed point loop,",
              "docstring_html": "<p>update system equation for fixed point loop,\nhere just setting the outputs</p>\n<div class=\"section\" id=\"note\">\n<h4>Note</h4>\n<p>no direct passthrough, so the 'update' method\nis optimized for this case</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>error <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>absolute error to previous iteration for convergence\ncontrol (here '0.0' because discrete block)</dd>\n</dl>\n</div>\n",
              "source": "def update(self, t):\n    \"\"\"update system equation for fixed point loop, \n    here just setting the outputs\n\n    Note\n    ----\n    no direct passthrough, so the 'update' method \n    is optimized for this case        \n\n    Parameters\n    ----------\n    t : float\n        evaluation time\n\n    Returns\n    -------\n    error : float\n        absolute error to previous iteration for convergence \n        control (here '0.0' because discrete block)\n    \"\"\"\n\n    if self.inputs[0] >= self.threshold:\n        self.outputs[0] = max(self.span)\n    else:\n        self.outputs[0] = min(self.span)",
              "signature": "(t)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time"
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "input_port_labels",
              "description": "",
              "type": null,
              "value": "{'in': 0}"
            },
            {
              "name": "output_port_labels",
              "description": "",
              "type": null,
              "value": "{'out': 0}"
            },
            {
              "name": "threshold",
              "description": "",
              "type": null,
              "value": "threshold"
            },
            {
              "name": "tolerance",
              "description": "",
              "type": null,
              "value": "tolerance"
            },
            {
              "name": "span",
              "description": "",
              "type": null,
              "value": "span"
            },
            {
              "name": "events",
              "description": "",
              "type": null,
              "value": "[ZeroCrossing(func_evt=func_evt, tolerance=tolerance)]"
            }
          ],
          "parameters": [
            {
              "name": "threshold",
              "type": null,
              "default": "0",
              "description": "threshold value for the comparator"
            },
            {
              "name": "tolerance",
              "type": null,
              "default": "0.0001",
              "description": "tolerance for zero crossing detection"
            },
            {
              "name": "span",
              "type": null,
              "default": "[-1, 1]",
              "description": "output value range [min, max]"
            }
          ]
        }
      ],
      "functions": []
    },
    "pathsim.blocks.converters": {
      "name": "pathsim.blocks.converters",
      "description": "",
      "docstring_html": "",
      "classes": [
        {
          "name": "ADC",
          "description": "Models an ideal Analog-to-Digital Converter (ADC).",
          "docstring_html": "<p>Models an ideal Analog-to-Digital Converter (ADC).</p>\n<p>This block samples an analog input signal periodically, quantizes it\naccording to the specified number of bits and input span, and outputs\nthe resulting digital code on multiple output ports. The sampling\nis triggered by a scheduled event.</p>\n<p>Functionality:</p>\n<ol class=\"arabic simple\">\n<li>Samples the analog input <cite>inputs[0]</cite> at intervals of <cite>T</cite>, starting after delay <cite>tau</cite>.</li>\n<li>Clips the input voltage to the defined <cite>span</cite> [min_voltage, max_voltage].</li>\n<li>Scales the clipped voltage to the range [0, 1].</li>\n<li>Quantizes the scaled value to an integer code between 0 and 2^n_bits - 1 using flooring.</li>\n<li>Converts the integer code to an n_bits binary representation.</li>\n<li>Outputs the binary code on ports 0 (LSB) to n_bits-1 (MSB).</li>\n</ol>\n<p>Ideal characteristics:</p>\n<ul class=\"simple\">\n<li>Instantaneous sampling at scheduled times.</li>\n<li>Perfect, noise-free quantization.</li>\n<li>No aperture jitter or other dynamic errors.</li>\n</ul>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>n_bits <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int, optional</span></dt>\n<dd>Number of bits for the digital output code. Default is 4.</dd>\n<dt>span <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">list[float] or tuple[float], optional</span></dt>\n<dd>The valid analog input value range [min_voltage, max_voltage].\nInputs outside this range will be clipped. Default is [-1, 1].</dd>\n<dt>T <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float, optional</span></dt>\n<dd>Sampling period (time between samples). Default is 1 time unit.</dd>\n<dt>tau <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float, optional</span></dt>\n<dd>Initial delay before the first sample is taken. Default is 0.</dd>\n</dl>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>events <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">list[Schedule]</span></dt>\n<dd>Internal scheduled event responsible for periodic sampling and conversion.</dd>\n</dl>\n",
          "source": "class ADC(Block):\n    \"\"\"Models an ideal Analog-to-Digital Converter (ADC).\n\n    This block samples an analog input signal periodically, quantizes it\n    according to the specified number of bits and input span, and outputs\n    the resulting digital code on multiple output ports. The sampling\n    is triggered by a scheduled event.\n\n    Functionality:\n\n    1. Samples the analog input `inputs[0]` at intervals of `T`, starting after delay `tau`.\n    2. Clips the input voltage to the defined `span` [min_voltage, max_voltage].\n    3. Scales the clipped voltage to the range [0, 1].\n    4. Quantizes the scaled value to an integer code between 0 and 2^n_bits - 1 using flooring.\n    5. Converts the integer code to an n_bits binary representation.\n    6. Outputs the binary code on ports 0 (LSB) to n_bits-1 (MSB).\n\n    Ideal characteristics:\n\n    - Instantaneous sampling at scheduled times.\n    - Perfect, noise-free quantization.\n    - No aperture jitter or other dynamic errors.\n\n\n    Parameters\n    ----------\n    n_bits : int, optional\n        Number of bits for the digital output code. Default is 4.\n    span : list[float] or tuple[float], optional\n        The valid analog input value range [min_voltage, max_voltage].\n        Inputs outside this range will be clipped. Default is [-1, 1].\n    T : float, optional\n        Sampling period (time between samples). Default is 1 time unit.\n    tau : float, optional\n        Initial delay before the first sample is taken. Default is 0.\n\n\n    Attributes\n    ----------\n    events : list[Schedule]\n        Internal scheduled event responsible for periodic sampling and conversion.\n    \"\"\"\n\n    input_port_labels = {\"in\": 0}\n    output_port_labels = None\n\n    def __init__(self, n_bits=4, span=[-1, 1], T=1, tau=0):\n        super().__init__()\n\n        #block params\n        self.n_bits = n_bits\n        self.span = span\n        self.T = T\n        self.tau = tau\n\n        def _sample(t):\n\n            #clip and scale to ADC span\n            lower, upper = self.span\n            analog_in = self.inputs[0]\n\n            clipped_val = np.clip(analog_in, lower, upper)\n            scaled_val = (clipped_val - lower) / (upper - lower)\n            int_val = np.floor(scaled_val * (2**self.n_bits))\n            int_val = min(int_val, 2**self.n_bits - 1)\n\n            #convert to bits\n            bits = format(int(int_val), \"b\").zfill(self.n_bits)\n\n            #set bits to block outputs LSB -> MSB\n            for i, b in enumerate(bits):\n                self.outputs[self.n_bits-1-i] = int(b)\n\n        #internal scheduled events\n        self.events = [\n            Schedule(\n                t_start=tau,\n                t_period=T,\n                func_act=_sample\n                ),\n            ]\n\n\n    def __len__(self):\n        \"\"\"This block has no direct passthrough\"\"\"\n        return 0",
          "bases": [
            "pathsim.blocks._block.Block"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, n_bits=4, span=[-1, 1], T=1, tau=0):\n    super().__init__()\n\n    #block params\n    self.n_bits = n_bits\n    self.span = span\n    self.T = T\n    self.tau = tau\n\n    def _sample(t):\n\n        #clip and scale to ADC span\n        lower, upper = self.span\n        analog_in = self.inputs[0]\n\n        clipped_val = np.clip(analog_in, lower, upper)\n        scaled_val = (clipped_val - lower) / (upper - lower)\n        int_val = np.floor(scaled_val * (2**self.n_bits))\n        int_val = min(int_val, 2**self.n_bits - 1)\n\n        #convert to bits\n        bits = format(int(int_val), \"b\").zfill(self.n_bits)\n\n        #set bits to block outputs LSB -> MSB\n        for i, b in enumerate(bits):\n            self.outputs[self.n_bits-1-i] = int(b)\n\n    #internal scheduled events\n    self.events = [\n        Schedule(\n            t_start=tau,\n            t_period=T,\n            func_act=_sample\n            ),\n        ]",
              "signature": "(n_bits = 4, span = [-1, 1], T = 1, tau = 0)",
              "parameters": [
                {
                  "name": "n_bits",
                  "type": null,
                  "default": "4",
                  "description": ""
                },
                {
                  "name": "span",
                  "type": null,
                  "default": "[-1, 1]",
                  "description": ""
                },
                {
                  "name": "T",
                  "type": null,
                  "default": "1",
                  "description": ""
                },
                {
                  "name": "tau",
                  "type": null,
                  "default": "0",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "input_port_labels",
              "description": "",
              "type": null,
              "value": "{'in': 0}"
            },
            {
              "name": "output_port_labels",
              "description": "",
              "type": null,
              "value": "None"
            },
            {
              "name": "n_bits",
              "description": "",
              "type": null,
              "value": "n_bits"
            },
            {
              "name": "span",
              "description": "",
              "type": null,
              "value": "span"
            },
            {
              "name": "T",
              "description": "",
              "type": null,
              "value": "T"
            },
            {
              "name": "tau",
              "description": "",
              "type": null,
              "value": "tau"
            },
            {
              "name": "events",
              "description": "",
              "type": null,
              "value": "[Schedule(t_start=tau, t_period=T, func_act=_sample)]"
            }
          ],
          "parameters": [
            {
              "name": "n_bits",
              "type": null,
              "default": "4",
              "description": "Number of bits for the digital output code. Default is 4."
            },
            {
              "name": "span",
              "type": null,
              "default": "[-1, 1]",
              "description": "The valid analog input value range [min_voltage, max_voltage]. Inputs outside this range will be clipped. Default is [-1, 1]."
            },
            {
              "name": "T",
              "type": null,
              "default": "1",
              "description": "Sampling period (time between samples). Default is 1 time unit."
            },
            {
              "name": "tau",
              "type": null,
              "default": "0",
              "description": "Initial delay before the first sample is taken. Default is 0."
            }
          ]
        },
        {
          "name": "DAC",
          "description": "Models an ideal Digital-to-Analog Converter (DAC).",
          "docstring_html": "<p>Models an ideal Digital-to-Analog Converter (DAC).</p>\n<p>This block reads a digital input code periodically from its input ports,\nreconstructs the corresponding analog value based on the number of bits\nand output span, and holds the output constant between updates. The update\nis triggered by a scheduled event.</p>\n<p>Functionality:</p>\n<ol class=\"arabic simple\">\n<li>Reads the digital code from input ports 0 (LSB) to n_bits-1 (MSB) at intervals of <cite>T</cite>, starting after delay <cite>tau</cite>.</li>\n<li>Interprets the inputs as an unsigned binary integer code.</li>\n<li>Converts the integer code to a fractional value between 0 and (2^n_bits - 1) / 2^n_bits.</li>\n<li>Scales this fractional value to the specified analog output <cite>span</cite>.</li>\n<li>Outputs the resulting analog value on <cite>outputs[0]</cite>.</li>\n<li>Holds the output value constant until the next scheduled update.</li>\n</ol>\n<p>Ideal characteristics:</p>\n<ul class=\"simple\">\n<li>Instantaneous update at scheduled times.</li>\n<li>Perfect, noise-free reconstruction.</li>\n<li>No glitches or settling time.</li>\n</ul>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>n_bits <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int, optional</span></dt>\n<dd>Number of digital input bits expected. Default is 4.</dd>\n<dt>span <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">list[float] or tuple[float], optional</span></dt>\n<dd>The analog output value range [min_voltage, max_voltage] corresponding\nto the digital codes 0 and 2^n_bits - 1, respectively (approximately).\nDefault is [-1, 1].</dd>\n<dt>T <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float, optional</span></dt>\n<dd>Update period (time between output updates). Default is 1 time unit.</dd>\n<dt>tau <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float, optional</span></dt>\n<dd>Initial delay before the first output update. Default is 0.</dd>\n</dl>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>events <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">list[Schedule]</span></dt>\n<dd>Internal scheduled event responsible for periodic updates.</dd>\n</dl>\n",
          "source": "class DAC(Block):\n    \"\"\"Models an ideal Digital-to-Analog Converter (DAC).\n\n    This block reads a digital input code periodically from its input ports,\n    reconstructs the corresponding analog value based on the number of bits\n    and output span, and holds the output constant between updates. The update\n    is triggered by a scheduled event.\n\n    Functionality:\n\n    1. Reads the digital code from input ports 0 (LSB) to n_bits-1 (MSB) at intervals of `T`, starting after delay `tau`.\n    2. Interprets the inputs as an unsigned binary integer code.\n    3. Converts the integer code to a fractional value between 0 and (2^n_bits - 1) / 2^n_bits.\n    4. Scales this fractional value to the specified analog output `span`.\n    5. Outputs the resulting analog value on `outputs[0]`.\n    6. Holds the output value constant until the next scheduled update.\n\n    Ideal characteristics:\n\n    - Instantaneous update at scheduled times.\n    - Perfect, noise-free reconstruction.\n    - No glitches or settling time.\n\n\n    Parameters\n    ----------\n    n_bits : int, optional\n        Number of digital input bits expected. Default is 4.\n    span : list[float] or tuple[float], optional\n        The analog output value range [min_voltage, max_voltage] corresponding\n        to the digital codes 0 and 2^n_bits - 1, respectively (approximately).\n        Default is [-1, 1].\n    T : float, optional\n        Update period (time between output updates). Default is 1 time unit.\n    tau : float, optional\n        Initial delay before the first output update. Default is 0.\n\n\n    Attributes\n    ----------\n    events : list[Schedule]\n        Internal scheduled event responsible for periodic updates.\n    \"\"\"\n\n    input_port_labels = None\n    output_port_labels = {\"out\": 0}\n\n    def __init__(self, n_bits=4, span=[-1, 1], T=1, tau=0):\n        super().__init__()\n\n        self.n_bits = n_bits\n        self.span = span\n        self.T = T\n        self.tau = tau\n\n        def _sample(t):\n\n            #convert bits to integer LSB -> MSB\n            val = sum(self.inputs[i] * (2**i) for i in range(self.n_bits))\n\n            #scale to DAC span and set output\n            lower, upper = self.span\n            levels = 2**self.n_bits\n\n            scaled_val =  val / (levels - 1) if levels > 1 else 0.0\n            self.outputs[0] = lower + (upper - lower) * scaled_val\n\n        #internal scheduled events\n        self.events = [\n            Schedule(\n                t_start=tau,\n                t_period=T,\n                func_act=_sample\n                ),\n            ]\n\n\n    def __len__(self):\n        \"\"\"This block has no direct passthrough\"\"\"\n        return 0",
          "bases": [
            "pathsim.blocks._block.Block"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, n_bits=4, span=[-1, 1], T=1, tau=0):\n    super().__init__()\n\n    self.n_bits = n_bits\n    self.span = span\n    self.T = T\n    self.tau = tau\n\n    def _sample(t):\n\n        #convert bits to integer LSB -> MSB\n        val = sum(self.inputs[i] * (2**i) for i in range(self.n_bits))\n\n        #scale to DAC span and set output\n        lower, upper = self.span\n        levels = 2**self.n_bits\n\n        scaled_val =  val / (levels - 1) if levels > 1 else 0.0\n        self.outputs[0] = lower + (upper - lower) * scaled_val\n\n    #internal scheduled events\n    self.events = [\n        Schedule(\n            t_start=tau,\n            t_period=T,\n            func_act=_sample\n            ),\n        ]",
              "signature": "(n_bits = 4, span = [-1, 1], T = 1, tau = 0)",
              "parameters": [
                {
                  "name": "n_bits",
                  "type": null,
                  "default": "4",
                  "description": ""
                },
                {
                  "name": "span",
                  "type": null,
                  "default": "[-1, 1]",
                  "description": ""
                },
                {
                  "name": "T",
                  "type": null,
                  "default": "1",
                  "description": ""
                },
                {
                  "name": "tau",
                  "type": null,
                  "default": "0",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "input_port_labels",
              "description": "",
              "type": null,
              "value": "None"
            },
            {
              "name": "output_port_labels",
              "description": "",
              "type": null,
              "value": "{'out': 0}"
            },
            {
              "name": "n_bits",
              "description": "",
              "type": null,
              "value": "n_bits"
            },
            {
              "name": "span",
              "description": "",
              "type": null,
              "value": "span"
            },
            {
              "name": "T",
              "description": "",
              "type": null,
              "value": "T"
            },
            {
              "name": "tau",
              "description": "",
              "type": null,
              "value": "tau"
            },
            {
              "name": "events",
              "description": "",
              "type": null,
              "value": "[Schedule(t_start=tau, t_period=T, func_act=_sample)]"
            }
          ],
          "parameters": [
            {
              "name": "n_bits",
              "type": null,
              "default": "4",
              "description": "Number of digital input bits expected. Default is 4."
            },
            {
              "name": "span",
              "type": null,
              "default": "[-1, 1]",
              "description": "The analog output value range [min_voltage, max_voltage] corresponding to the digital codes 0 and 2^n_bits - 1, respectively (approximately). Default is [-1, 1]."
            },
            {
              "name": "T",
              "type": null,
              "default": "1",
              "description": "Update period (time between output updates). Default is 1 time unit."
            },
            {
              "name": "tau",
              "type": null,
              "default": "0",
              "description": "Initial delay before the first output update. Default is 0."
            }
          ]
        }
      ],
      "functions": []
    },
    "pathsim.blocks.counter": {
      "name": "pathsim.blocks.counter",
      "description": "",
      "docstring_html": "",
      "classes": [
        {
          "name": "Counter",
          "description": "Counts the number of detected bidirectional threshold crossings.",
          "docstring_html": "<p>Counts the number of detected bidirectional threshold crossings.</p>\n<p>Uses zero-crossing events for the detection and sets the output\naccordingly.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>start <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>counter start (initial condition)</dd>\n<dt>threshold <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>threshold for zero crossing</dd>\n</dl>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>E <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">ZeroCrossing</span></dt>\n<dd>internal event manager</dd>\n<dt>events <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">list[ZeroCrossing]</span></dt>\n<dd>internal zero crossing event</dd>\n</dl>\n",
          "source": "class Counter(Block):\n    \"\"\"Counts the number of detected bidirectional threshold crossings.\n\n    Uses zero-crossing events for the detection and sets the output \n    accordingly.\n\n    Parameters\n    ----------\n    start : int\n        counter start (initial condition)\n    threshold : float\n        threshold for zero crossing\n\n    Attributes\n    ----------\n    E : ZeroCrossing\n        internal event manager\n    events : list[ZeroCrossing]\n        internal zero crossing event\n    \"\"\"\n\n    input_port_labels = {\"in\": 0}\n    output_port_labels = {\"out\": 0}\n\n\n    def __init__(self, start=0, threshold=0.0):\n        super().__init__()\n\n        self.start = start\n        self.threshold = threshold\n\n        #internal event\n        self.E = ZeroCrossing(\n            func_evt=lambda t: self.inputs[0] - self.threshold\n            )\n\n        #internal event for transition detection\n        self.events = [self.E]\n\n\n    def __len__(self):\n        \"\"\"This block has no direct passthrough\"\"\"\n        return 0\n\n\n    def update(self, t):\n        \"\"\"update system equation for fixed point loop, \n        here just setting the outputs\n\n        Note\n        ----\n        no direct passthrough, so the 'update' method \n        is optimized for this case        \n\n        Parameters\n        ----------\n        t : float\n            evaluation time\n        \"\"\"\n\n        #start + number of detected events\n        self.outputs[0] = self.start + len(self.E)",
          "bases": [
            "pathsim.blocks._block.Block"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, start=0, threshold=0.0):\n    super().__init__()\n\n    self.start = start\n    self.threshold = threshold\n\n    #internal event\n    self.E = ZeroCrossing(\n        func_evt=lambda t: self.inputs[0] - self.threshold\n        )\n\n    #internal event for transition detection\n    self.events = [self.E]",
              "signature": "(start = 0, threshold = 0.0)",
              "parameters": [
                {
                  "name": "start",
                  "type": null,
                  "default": "0",
                  "description": ""
                },
                {
                  "name": "threshold",
                  "type": null,
                  "default": "0.0",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "update",
              "description": "update system equation for fixed point loop,",
              "docstring_html": "<p>update system equation for fixed point loop,\nhere just setting the outputs</p>\n<div class=\"section\" id=\"note\">\n<h4>Note</h4>\n<p>no direct passthrough, so the 'update' method\nis optimized for this case</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time</dd>\n</dl>\n</div>\n",
              "source": "def update(self, t):\n    \"\"\"update system equation for fixed point loop, \n    here just setting the outputs\n\n    Note\n    ----\n    no direct passthrough, so the 'update' method \n    is optimized for this case        \n\n    Parameters\n    ----------\n    t : float\n        evaluation time\n    \"\"\"\n\n    #start + number of detected events\n    self.outputs[0] = self.start + len(self.E)",
              "signature": "(t)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time"
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "input_port_labels",
              "description": "",
              "type": null,
              "value": "{'in': 0}"
            },
            {
              "name": "output_port_labels",
              "description": "",
              "type": null,
              "value": "{'out': 0}"
            },
            {
              "name": "start",
              "description": "",
              "type": null,
              "value": "start"
            },
            {
              "name": "threshold",
              "description": "",
              "type": null,
              "value": "threshold"
            },
            {
              "name": "E",
              "description": "",
              "type": null,
              "value": "ZeroCrossing(func_evt=(lambda t: self.inputs[0] - self.threshold))"
            },
            {
              "name": "events",
              "description": "",
              "type": null,
              "value": "[self.E]"
            }
          ],
          "parameters": [
            {
              "name": "start",
              "type": null,
              "default": "0",
              "description": "counter start (initial condition)"
            },
            {
              "name": "threshold",
              "type": null,
              "default": "0.0",
              "description": "threshold for zero crossing"
            }
          ]
        },
        {
          "name": "CounterUp",
          "description": "Counts the number of detected unidirectional (lo->hi) threshold crossings.",
          "docstring_html": "<p>Counts the number of detected unidirectional (lo-&gt;hi) threshold crossings.</p>\n<div class=\"section\" id=\"note\">\n<h4>Note</h4>\n<p>This is a modification of 'Counter' which only counts\nunidirectional zero-crossings (low -&gt; high)</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>start <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>counter start (initial condition)</dd>\n<dt>threshold <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>threshold for zero crossing</dd>\n</dl>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>E <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">ZeroCrossingUp</span></dt>\n<dd>internal event manager</dd>\n<dt>events <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">list[ZeroCrossing]</span></dt>\n<dd>internal zero crossing event</dd>\n</dl>\n</div>\n",
          "source": "class CounterUp(Counter):\n    \"\"\"Counts the number of detected unidirectional (lo->hi) threshold crossings.\n\n    Note\n    ----\n    This is a modification of 'Counter' which only counts \n    unidirectional zero-crossings (low -> high)\n\n    Parameters\n    ----------\n    start : int\n        counter start (initial condition)\n    threshold : float\n        threshold for zero crossing\n\n    Attributes\n    ----------\n    E : ZeroCrossingUp\n        internal event manager\n    events : list[ZeroCrossing]\n        internal zero crossing event\n    \"\"\"\n\n    def __init__(self, start=0, threshold=0.0):\n        super().__init__(start, threshold)\n\n        #internal event\n        self.E = ZeroCrossingUp(\n            func_evt=lambda t: self.inputs[0] - self.threshold\n            )\n\n        #internal event for transition detection\n        self.events = [self.E]",
          "bases": [
            "pathsim.blocks.counter.Counter"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, start=0, threshold=0.0):\n    super().__init__(start, threshold)\n\n    #internal event\n    self.E = ZeroCrossingUp(\n        func_evt=lambda t: self.inputs[0] - self.threshold\n        )\n\n    #internal event for transition detection\n    self.events = [self.E]",
              "signature": "(start = 0, threshold = 0.0)",
              "parameters": [
                {
                  "name": "start",
                  "type": null,
                  "default": "0",
                  "description": ""
                },
                {
                  "name": "threshold",
                  "type": null,
                  "default": "0.0",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "E",
              "description": "",
              "type": null,
              "value": "ZeroCrossingUp(func_evt=(lambda t: self.inputs[0] - self.threshold))"
            },
            {
              "name": "events",
              "description": "",
              "type": null,
              "value": "[self.E]"
            }
          ],
          "parameters": [
            {
              "name": "start",
              "type": null,
              "default": "0",
              "description": "counter start (initial condition)"
            },
            {
              "name": "threshold",
              "type": null,
              "default": "0.0",
              "description": "threshold for zero crossing"
            }
          ]
        },
        {
          "name": "CounterDown",
          "description": "Counts the number of detected unidirectional (hi->lo) threshold crossings.",
          "docstring_html": "<p>Counts the number of detected unidirectional (hi-&gt;lo) threshold crossings.</p>\n<div class=\"section\" id=\"note\">\n<h4>Note</h4>\n<p>This is a modification of 'Counter' which only counts\nunidirectional zero-crossings (high -&gt; low)</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>start <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>counter start (initial condition)</dd>\n<dt>threshold <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>threshold for zero crossing</dd>\n</dl>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>E <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">ZeroCrossingDown</span></dt>\n<dd>internal event manager</dd>\n<dt>events <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">list[ZeroCrossing]</span></dt>\n<dd>internal zero crossing event</dd>\n</dl>\n</div>\n",
          "source": "class CounterDown(Counter):\n    \"\"\"Counts the number of detected unidirectional (hi->lo) threshold crossings.\n\n    Note\n    ----\n    This is a modification of 'Counter' which only counts \n    unidirectional zero-crossings (high -> low)\n\n    Parameters\n    ----------\n    start : int\n        counter start (initial condition)\n    threshold : float\n        threshold for zero crossing\n\n    Attributes\n    ----------\n    E : ZeroCrossingDown\n        internal event manager\n    events : list[ZeroCrossing]\n        internal zero crossing event\n    \"\"\"\n\n    def __init__(self, start=0, threshold=0.0):\n        super().__init__(start, threshold)\n\n        #internal event\n        self.E = ZeroCrossingDown(\n            func_evt=lambda t: self.inputs[0] - self.threshold\n            )\n\n        #internal event for transition detection\n        self.events = [self.E]",
          "bases": [
            "pathsim.blocks.counter.Counter"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, start=0, threshold=0.0):\n    super().__init__(start, threshold)\n\n    #internal event\n    self.E = ZeroCrossingDown(\n        func_evt=lambda t: self.inputs[0] - self.threshold\n        )\n\n    #internal event for transition detection\n    self.events = [self.E]",
              "signature": "(start = 0, threshold = 0.0)",
              "parameters": [
                {
                  "name": "start",
                  "type": null,
                  "default": "0",
                  "description": ""
                },
                {
                  "name": "threshold",
                  "type": null,
                  "default": "0.0",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "E",
              "description": "",
              "type": null,
              "value": "ZeroCrossingDown(func_evt=(lambda t: self.inputs[0] - self.threshold))"
            },
            {
              "name": "events",
              "description": "",
              "type": null,
              "value": "[self.E]"
            }
          ],
          "parameters": [
            {
              "name": "start",
              "type": null,
              "default": "0",
              "description": "counter start (initial condition)"
            },
            {
              "name": "threshold",
              "type": null,
              "default": "0.0",
              "description": "threshold for zero crossing"
            }
          ]
        }
      ],
      "functions": []
    },
    "pathsim.blocks.ctrl": {
      "name": "pathsim.blocks.ctrl",
      "description": "",
      "docstring_html": "",
      "classes": [
        {
          "name": "PID",
          "description": "Proportional-Integral-Differntiation (PID) controller.",
          "docstring_html": "<p>Proportional-Integral-Differntiation (PID) controller.</p>\n<p>The transfer function is defined as</p>\n<pre class=\"math\">\nH_\\mathrm{diff}(s) = K_p + K_i \\frac{1}{s} + K_d \\frac{s}{1 + s / f_\\mathrm{max}}\n</pre>\n<p>where the differentiation is approximated by a high pass filter that holds\nfor signals up to a frequency of approximately <cite>f_max</cite>.</p>\n<div class=\"section\" id=\"note\">\n<h4>Note</h4>\n<p>Depending on <cite>f_max</cite>, the resulting system might become stiff or ill conditioned!\nAs a practical choice set <cite>f_max</cite> to 3x the highest expected signal frequency.\nSince this block uses an approximation of real differentiation, the approximation will\nnot hold if there are high frequency components present in the signal. For example if\nyou have discontinuities such as steps or square waves.</p>\n</div>\n<div class=\"section\" id=\"note-1\">\n<h4>Note</h4>\n<p>This block supports vector input, meaning we can have multiple parallel\nPID paths through this block.</p>\n</div>\n<div class=\"section\" id=\"example\">\n<h4>Example</h4>\n<p>The block is initialized like this:</p>\n<pre class=\"code python literal-block\">\n<span class=\"c1\">#cutoff at 1kHz</span><span class=\"w\">\n</span><span class=\"n\">pid</span> <span class=\"o\">=</span> <span class=\"n\">PID</span><span class=\"p\">(</span><span class=\"n\">Kp</span><span class=\"o\">=</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"n\">Ki</span><span class=\"o\">=</span><span class=\"mf\">0.5</span><span class=\"p\">,</span> <span class=\"n\">Kd</span><span class=\"o\">=</span><span class=\"mf\">0.1</span><span class=\"p\">,</span> <span class=\"n\">f_max</span><span class=\"o\">=</span><span class=\"mf\">1e3</span><span class=\"p\">)</span>\n</pre>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>Kp <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>poroportional controller coefficient</dd>\n<dt>Ki <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>integral controller coefficient</dd>\n<dt>Kd <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>differentiator controller coefficient</dd>\n<dt>f_max <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>highest expected signal frequency</dd>\n</dl>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>op_dyn <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">DynamicOperator</span></dt>\n<dd>internal dynamic operator for ODE component</dd>\n<dt>op_alg <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">DynamicOperator</span></dt>\n<dd>internal algebraic operator</dd>\n</dl>\n</div>\n",
          "source": "class PID(Block):\n    \"\"\"Proportional-Integral-Differntiation (PID) controller.\n\n    The transfer function is defined as\n\n    .. math::\n\n        H_\\\\mathrm{diff}(s) = K_p + K_i \\\\frac{1}{s} + K_d \\\\frac{s}{1 + s / f_\\\\mathrm{max}} \n\n    where the differentiation is approximated by a high pass filter that holds \n    for signals up to a frequency of approximately `f_max`.\n\n\n    Note\n    ----\n    Depending on `f_max`, the resulting system might become stiff or ill conditioned!\n    As a practical choice set `f_max` to 3x the highest expected signal frequency.\n    Since this block uses an approximation of real differentiation, the approximation will \n    not hold if there are high frequency components present in the signal. For example if \n    you have discontinuities such as steps or square waves.\n\n\n    Note\n    ----\n    This block supports vector input, meaning we can have multiple parallel \n    PID paths through this block.\n\n\n    Example\n    -------\n    The block is initialized like this:\n\n    .. code-block:: python\n\n        #cutoff at 1kHz\n        pid = PID(Kp=2, Ki=0.5, Kd=0.1, f_max=1e3)\n\n\n    Parameters\n    ----------\n    Kp : float\n        poroportional controller coefficient\n    Ki : float\n        integral controller coefficient\n    Kd : float\n        differentiator controller coefficient\n    f_max : float\n        highest expected signal frequency\n\n\n    Attributes\n    ----------\n    op_dyn : DynamicOperator\n        internal dynamic operator for ODE component\n    op_alg : DynamicOperator\n        internal algebraic operator\n\n    \"\"\"\n\n    def __init__(self, Kp=0, Ki=0, Kd=0, f_max=100):\n        super().__init__()\n\n        #pid controller coefficients\n        self.Kp = Kp\n        self.Ki = Ki\n        self.Kd = Kd\n\n        #maximum frequency for differentiator approximation\n        self.f_max = f_max\n\n        #initial state for integration engine (differentiator + integrator states)\n        self.initial_value = np.zeros(2)\n\n        def _g_pid(x, u, t):\n            x1, x2 = x\n            yp = self.Kp * u\n            yi = self.Ki * x2\n            yd = self.Kd * self.f_max * (u - x1)\n            return yp + yi + yd\n\n        def _jac_x_g_pid(x, u, t):\n            return np.array([-self.Kd * self.f_max, self.Ki])\n\n        def _jac_u_g_pid(x, u, t):\n            return self.Kd * self.f_max + self.Kp\n\n        def _f_pid(x, u, t):\n            x1, x2 = x\n            dx1, dx2 = self.f_max * (u - x1), u\n            return np.array([dx1, dx2])\n\n        #internal operators\n        self.op_dyn = DynamicOperator(\n            func=_f_pid,\n            )\n        self.op_alg = DynamicOperator(\n            func=_g_pid,\n            jac_x=_jac_x_g_pid,\n            jac_u=_jac_u_g_pid,\n            )\n\n\n    def __len__(self):\n        return 1 if self._active and (self.Kp or self.Kd) else 0\n\n\n    def update(self, t):\n        \"\"\"update system equation fixed point loop, with convergence control\n\n        Parameters\n        ----------\n        t : float\n            evaluation time\n        \"\"\"\n        x, u = self.engine.state, self.inputs[0]\n        y = self.op_alg(x, u, t)\n        self.outputs.update_from_array(y)\n\n\n    def solve(self, t, dt):\n        \"\"\"advance solution of implicit update equation\n\n        Parameters\n        ----------\n        t : float\n            evaluation time\n        dt : float\n            integration timestep\n\n        Returns\n        ------- \n        error : float\n            solver residual norm\n        \"\"\"\n        x, u = self.engine.state, self.inputs[0]\n        f, J = self.op_dyn(x, u, t), self.op_dyn.jac_x(x, u, t)\n        return self.engine.solve(f, J, dt)\n\n\n    def step(self, t, dt):\n        \"\"\"compute update step with integration engine\n\n        Parameters\n        ----------\n        t : float\n            evaluation time\n        dt : float\n            integration timestep\n\n        Returns\n        ------- \n        success : bool\n            step was successful\n        error : float\n            local truncation error from adaptive integrators\n        scale : float\n            timestep rescale from adaptive integrators\n        \"\"\"\n        x, u = self.engine.state, self.inputs[0]\n        f = self.op_dyn(x, u, t)\n        return self.engine.step(f, dt)",
          "bases": [
            "pathsim.blocks._block.Block"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, Kp=0, Ki=0, Kd=0, f_max=100):\n    super().__init__()\n\n    #pid controller coefficients\n    self.Kp = Kp\n    self.Ki = Ki\n    self.Kd = Kd\n\n    #maximum frequency for differentiator approximation\n    self.f_max = f_max\n\n    #initial state for integration engine (differentiator + integrator states)\n    self.initial_value = np.zeros(2)\n\n    def _g_pid(x, u, t):\n        x1, x2 = x\n        yp = self.Kp * u\n        yi = self.Ki * x2\n        yd = self.Kd * self.f_max * (u - x1)\n        return yp + yi + yd\n\n    def _jac_x_g_pid(x, u, t):\n        return np.array([-self.Kd * self.f_max, self.Ki])\n\n    def _jac_u_g_pid(x, u, t):\n        return self.Kd * self.f_max + self.Kp\n\n    def _f_pid(x, u, t):\n        x1, x2 = x\n        dx1, dx2 = self.f_max * (u - x1), u\n        return np.array([dx1, dx2])\n\n    #internal operators\n    self.op_dyn = DynamicOperator(\n        func=_f_pid,\n        )\n    self.op_alg = DynamicOperator(\n        func=_g_pid,\n        jac_x=_jac_x_g_pid,\n        jac_u=_jac_u_g_pid,\n        )",
              "signature": "(Kp = 0, Ki = 0, Kd = 0, f_max = 100)",
              "parameters": [
                {
                  "name": "Kp",
                  "type": null,
                  "default": "0",
                  "description": ""
                },
                {
                  "name": "Ki",
                  "type": null,
                  "default": "0",
                  "description": ""
                },
                {
                  "name": "Kd",
                  "type": null,
                  "default": "0",
                  "description": ""
                },
                {
                  "name": "f_max",
                  "type": null,
                  "default": "100",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "update",
              "description": "update system equation fixed point loop, with convergence control",
              "docstring_html": "<p>update system equation fixed point loop, with convergence control</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time</dd>\n</dl>\n",
              "source": "def update(self, t):\n    \"\"\"update system equation fixed point loop, with convergence control\n\n    Parameters\n    ----------\n    t : float\n        evaluation time\n    \"\"\"\n    x, u = self.engine.state, self.inputs[0]\n    y = self.op_alg(x, u, t)\n    self.outputs.update_from_array(y)",
              "signature": "(t)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "solve",
              "description": "advance solution of implicit update equation",
              "docstring_html": "<p>advance solution of implicit update equation</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time</dd>\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>integration timestep</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>error <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>solver residual norm</dd>\n</dl>\n",
              "source": "def solve(self, t, dt):\n    \"\"\"advance solution of implicit update equation\n\n    Parameters\n    ----------\n    t : float\n        evaluation time\n    dt : float\n        integration timestep\n\n    Returns\n    ------- \n    error : float\n        solver residual norm\n    \"\"\"\n    x, u = self.engine.state, self.inputs[0]\n    f, J = self.op_dyn(x, u, t), self.op_dyn.jac_x(x, u, t)\n    return self.engine.solve(f, J, dt)",
              "signature": "(t, dt)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time"
                },
                {
                  "name": "dt",
                  "type": null,
                  "default": null,
                  "description": "integration timestep"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "step",
              "description": "compute update step with integration engine",
              "docstring_html": "<p>compute update step with integration engine</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time</dd>\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>integration timestep</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>success <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>step was successful</dd>\n<dt>error <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>local truncation error from adaptive integrators</dd>\n<dt>scale <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>timestep rescale from adaptive integrators</dd>\n</dl>\n",
              "source": "def step(self, t, dt):\n    \"\"\"compute update step with integration engine\n\n    Parameters\n    ----------\n    t : float\n        evaluation time\n    dt : float\n        integration timestep\n\n    Returns\n    ------- \n    success : bool\n        step was successful\n    error : float\n        local truncation error from adaptive integrators\n    scale : float\n        timestep rescale from adaptive integrators\n    \"\"\"\n    x, u = self.engine.state, self.inputs[0]\n    f = self.op_dyn(x, u, t)\n    return self.engine.step(f, dt)",
              "signature": "(t, dt)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time"
                },
                {
                  "name": "dt",
                  "type": null,
                  "default": null,
                  "description": "integration timestep"
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "Kp",
              "description": "",
              "type": null,
              "value": "Kp"
            },
            {
              "name": "Ki",
              "description": "",
              "type": null,
              "value": "Ki"
            },
            {
              "name": "Kd",
              "description": "",
              "type": null,
              "value": "Kd"
            },
            {
              "name": "f_max",
              "description": "",
              "type": null,
              "value": "f_max"
            },
            {
              "name": "initial_value",
              "description": "",
              "type": null,
              "value": "np.zeros(2)"
            },
            {
              "name": "op_dyn",
              "description": "",
              "type": null,
              "value": "DynamicOperator(func=_f_pid)"
            },
            {
              "name": "op_alg",
              "description": "",
              "type": null,
              "value": "DynamicOperator(func=_g_pid, jac_x=_jac_x_g_pid, jac_u=_jac_u_g_pid)"
            }
          ],
          "parameters": [
            {
              "name": "Kp",
              "type": null,
              "default": "0",
              "description": "poroportional controller coefficient"
            },
            {
              "name": "Ki",
              "type": null,
              "default": "0",
              "description": "integral controller coefficient"
            },
            {
              "name": "Kd",
              "type": null,
              "default": "0",
              "description": "differentiator controller coefficient"
            },
            {
              "name": "f_max",
              "type": null,
              "default": "100",
              "description": "highest expected signal frequency"
            }
          ]
        },
        {
          "name": "AntiWindupPID",
          "description": "Proportional-Integral-Differntiation (PID) controller with anti-windup mechanism (back-calculation).",
          "docstring_html": "<p>Proportional-Integral-Differntiation (PID) controller with anti-windup mechanism (back-calculation).</p>\n<p>Anti-windup mechanisms are needed when the magnitude of the control signal\nfrom the PID controller is limited by some real world saturation. In these cases,\nthe integrator will continue to acumulate the control error and &quot;wind itself up&quot;.\nOnce the setpoint is reached, this can result in significant overshoots. This\nimplementation adds a conditional feedback term to the internal integrator that\n&quot;unwinds&quot; it when the PID output crosses some limits. This is pretty much a\ndeadzone feedback element for the integrator.</p>\n<p>Mathematically, this block implements the following set of ODEs</p>\n<pre class=\"math\">\n\\begin{align}\n\\dot{x}_1 &amp;= f_\\mathrm{max} (u - x_1) \\\\\n\\dot{x}_2 &amp;= u - w\n\\end{align}\n</pre>\n<p>with the anti-windup feedback (depending on the pid output)</p>\n<pre class=\"math\">\nw = K_s (y - \\min(\\max(y, y_\\mathrm{min}), y_\\mathrm{max}))\n</pre>\n<p>and the output itself</p>\n<pre class=\"math\">\ny = K_p u - K_d f_\\mathrm{max} x_1 + K_i x_2\n</pre>\n<div class=\"section\" id=\"note\">\n<h4>Note</h4>\n<p>Depending on <cite>f_max</cite>, the resulting system might become stiff or ill conditioned!\nAs a practical choice set <cite>f_max</cite> to 3x the highest expected signal frequency.\nSince this block uses an approximation of real differentiation, the approximation will\nnot hold if there are high frequency components present in the signal. For example if\nyou have discontinuities such as steps or squere waves.</p>\n</div>\n<div class=\"section\" id=\"example\">\n<h4>Example</h4>\n<p>The block is initialized like this:</p>\n<pre class=\"code python literal-block\">\n<span class=\"c1\">#cutoff at 1kHz, windup limits at [-5, 5]</span><span class=\"w\">\n</span><span class=\"n\">pid</span> <span class=\"o\">=</span> <span class=\"n\">AntiWindupPID</span><span class=\"p\">(</span><span class=\"n\">Kp</span><span class=\"o\">=</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"n\">Ki</span><span class=\"o\">=</span><span class=\"mf\">0.5</span><span class=\"p\">,</span> <span class=\"n\">Kd</span><span class=\"o\">=</span><span class=\"mf\">0.1</span><span class=\"p\">,</span> <span class=\"n\">f_max</span><span class=\"o\">=</span><span class=\"mf\">1e3</span><span class=\"p\">,</span> <span class=\"n\">limits</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"o\">-</span><span class=\"mi\">5</span><span class=\"p\">,</span> <span class=\"mi\">5</span><span class=\"p\">])</span>\n</pre>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>Kp <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>poroportional controller coefficient</dd>\n<dt>Ki <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>integral controller coefficient</dd>\n<dt>Kd <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>differentiator controller coefficient</dd>\n<dt>f_max <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>highest expected signal frequency</dd>\n<dt>Ks <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>feedback term for back calculation for anti-windup control of integrator</dd>\n<dt>limits <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array_like[float]</span></dt>\n<dd>lower and upper limit for PID output that triggers anti-windup of integrator</dd>\n</dl>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>op_dyn <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">DynamicOperator</span></dt>\n<dd>internal dynamic operator for ODE component</dd>\n<dt>op_alg <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">DynamicOperator</span></dt>\n<dd>internal algebraic operator</dd>\n</dl>\n</div>\n",
          "source": "class AntiWindupPID(PID):\n    \"\"\"Proportional-Integral-Differntiation (PID) controller with anti-windup mechanism (back-calculation).\n\n    Anti-windup mechanisms are needed when the magnitude of the control signal \n    from the PID controller is limited by some real world saturation. In these cases, \n    the integrator will continue to acumulate the control error and \"wind itself up\". \n    Once the setpoint is reached, this can result in significant overshoots. This \n    implementation adds a conditional feedback term to the internal integrator that \n    \"unwinds\" it when the PID output crosses some limits. This is pretty much a \n    deadzone feedback element for the integrator.\n\n    Mathematically, this block implements the following set of ODEs \n\n    .. math::\n\n        \\\\begin{align}\n        \\\\dot{x}_1 &= f_\\\\mathrm{max} (u - x_1) \\\\\\\\\n        \\\\dot{x}_2 &= u - w\n        \\\\end{align}\n\n    with the anti-windup feedback (depending on the pid output)\n\n    .. math::\n\n        w = K_s (y - \\\\min(\\\\max(y, y_\\\\mathrm{min}), y_\\\\mathrm{max}))\n\n    and the output itself\n\n    .. math::\n\n        y = K_p u - K_d f_\\\\mathrm{max} x_1 + K_i x_2\n\n\n    Note\n    ----\n    Depending on `f_max`, the resulting system might become stiff or ill conditioned!\n    As a practical choice set `f_max` to 3x the highest expected signal frequency.\n    Since this block uses an approximation of real differentiation, the approximation will \n    not hold if there are high frequency components present in the signal. For example if \n    you have discontinuities such as steps or squere waves.\n\n\n    Example\n    -------\n    The block is initialized like this:\n\n    .. code-block:: python\n\n        #cutoff at 1kHz, windup limits at [-5, 5]\n        pid = AntiWindupPID(Kp=2, Ki=0.5, Kd=0.1, f_max=1e3, limits=[-5, 5])\n\n\n    Parameters\n    ----------\n    Kp : float\n        poroportional controller coefficient\n    Ki : float\n        integral controller coefficient\n    Kd : float\n        differentiator controller coefficient\n    f_max : float\n        highest expected signal frequency\n    Ks : float\n        feedback term for back calculation for anti-windup control of integrator\n    limits : array_like[float]\n        lower and upper limit for PID output that triggers anti-windup of integrator\n\n\n    Attributes\n    ----------\n    op_dyn : DynamicOperator\n        internal dynamic operator for ODE component\n    op_alg : DynamicOperator\n        internal algebraic operator\n\n    \"\"\"\n\n    def __init__(self, Kp=0, Ki=0, Kd=0, f_max=100, Ks=10, limits=[-10, 10]):\n        super().__init__(Kp, Ki, Kd, f_max)\n\n        #anti-windup control\n        self.Ks = Ks\n        self.limits = limits\n\n        def _g_pid(x, u, t):\n            x1, x2 = x\n            yp = self.Kp * u\n            yi = self.Ki * x2\n            yd = self.Kd * self.f_max * (u - x1)\n            return yp + yi + yd\n\n        def _jac_x_g_pid(x, u, t):\n            return np.array([-self.Kd * self.f_max, self.Ki])\n\n        def _jac_u_g_pid(x, u, t):\n            return self.Kd * self.f_max + self.Kp\n\n        def _f_pid(x, u, t):\n            x1, x2 = x\n\n            #differentiator state\n            dx1 = self.f_max * (u - x1) \n\n            #integrator state with windup control\n            y = _g_pid(x, u, t) #pid output\n            w = self.Ks * (y - np.clip(y, *self.limits)) #anti-windup feedback\n            dx2 = u - w\n\n            return np.array([dx1, dx2])\n\n        #internal operators\n        self.op_dyn = DynamicOperator(\n            func=_f_pid,\n            )\n        self.op_alg = DynamicOperator(\n            func=_g_pid,\n            jac_x=_jac_x_g_pid,\n            jac_u=_jac_u_g_pid,\n            )",
          "bases": [
            "pathsim.blocks.ctrl.PID"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, Kp=0, Ki=0, Kd=0, f_max=100, Ks=10, limits=[-10, 10]):\n    super().__init__(Kp, Ki, Kd, f_max)\n\n    #anti-windup control\n    self.Ks = Ks\n    self.limits = limits\n\n    def _g_pid(x, u, t):\n        x1, x2 = x\n        yp = self.Kp * u\n        yi = self.Ki * x2\n        yd = self.Kd * self.f_max * (u - x1)\n        return yp + yi + yd\n\n    def _jac_x_g_pid(x, u, t):\n        return np.array([-self.Kd * self.f_max, self.Ki])\n\n    def _jac_u_g_pid(x, u, t):\n        return self.Kd * self.f_max + self.Kp\n\n    def _f_pid(x, u, t):\n        x1, x2 = x\n\n        #differentiator state\n        dx1 = self.f_max * (u - x1) \n\n        #integrator state with windup control\n        y = _g_pid(x, u, t) #pid output\n        w = self.Ks * (y - np.clip(y, *self.limits)) #anti-windup feedback\n        dx2 = u - w\n\n        return np.array([dx1, dx2])\n\n    #internal operators\n    self.op_dyn = DynamicOperator(\n        func=_f_pid,\n        )\n    self.op_alg = DynamicOperator(\n        func=_g_pid,\n        jac_x=_jac_x_g_pid,\n        jac_u=_jac_u_g_pid,\n        )",
              "signature": "(Kp = 0, Ki = 0, Kd = 0, f_max = 100, Ks = 10, limits = [-10, 10])",
              "parameters": [
                {
                  "name": "Kp",
                  "type": null,
                  "default": "0",
                  "description": ""
                },
                {
                  "name": "Ki",
                  "type": null,
                  "default": "0",
                  "description": ""
                },
                {
                  "name": "Kd",
                  "type": null,
                  "default": "0",
                  "description": ""
                },
                {
                  "name": "f_max",
                  "type": null,
                  "default": "100",
                  "description": ""
                },
                {
                  "name": "Ks",
                  "type": null,
                  "default": "10",
                  "description": ""
                },
                {
                  "name": "limits",
                  "type": null,
                  "default": "[-10, 10]",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "Ks",
              "description": "",
              "type": null,
              "value": "Ks"
            },
            {
              "name": "limits",
              "description": "",
              "type": null,
              "value": "limits"
            },
            {
              "name": "op_dyn",
              "description": "",
              "type": null,
              "value": "DynamicOperator(func=_f_pid)"
            },
            {
              "name": "op_alg",
              "description": "",
              "type": null,
              "value": "DynamicOperator(func=_g_pid, jac_x=_jac_x_g_pid, jac_u=_jac_u_g_pid)"
            }
          ],
          "parameters": [
            {
              "name": "Kp",
              "type": null,
              "default": "0",
              "description": "poroportional controller coefficient"
            },
            {
              "name": "Ki",
              "type": null,
              "default": "0",
              "description": "integral controller coefficient"
            },
            {
              "name": "Kd",
              "type": null,
              "default": "0",
              "description": "differentiator controller coefficient"
            },
            {
              "name": "f_max",
              "type": null,
              "default": "100",
              "description": "highest expected signal frequency"
            },
            {
              "name": "Ks",
              "type": null,
              "default": "10",
              "description": "feedback term for back calculation for anti-windup control of integrator"
            },
            {
              "name": "limits",
              "type": null,
              "default": "[-10, 10]",
              "description": "lower and upper limit for PID output that triggers anti-windup of integrator"
            }
          ]
        }
      ],
      "functions": []
    },
    "pathsim.blocks.delay": {
      "name": "pathsim.blocks.delay",
      "description": "",
      "docstring_html": "",
      "classes": [
        {
          "name": "Delay",
          "description": "Delays the input signal by a time constant 'tau' in seconds.",
          "docstring_html": "<p>Delays the input signal by a time constant 'tau' in seconds.</p>\n<p>Mathematically this block creates a time delay of the input signal like this:</p>\n<pre class=\"math\">\ny(t) =\n\\begin{cases}\nx(t - \\tau) &amp; , t \\geq \\tau \\\\\n0            &amp; , t &lt; \\tau\n\\end{cases}\n</pre>\n<div class=\"section\" id=\"note\">\n<h4>Note</h4>\n<p>The internal adaptive buffer uses interpolation for the evaluation. This is\nrequired to be compatible with variable step solvers. It has a drawback however.\nThe order of the ode solver used will degrade when this block is used, due to\nthe interpolation.</p>\n</div>\n<div class=\"section\" id=\"note-1\">\n<h4>Note</h4>\n<p>This block supports vector input, meaning we can have multiple parallel\ndelay paths through this block.</p>\n</div>\n<div class=\"section\" id=\"example\">\n<h4>Example</h4>\n<p>The block is initialized like this:</p>\n<pre class=\"code python literal-block\">\n<span class=\"c1\">#5 time units delay</span><span class=\"w\">\n</span><span class=\"n\">D</span> <span class=\"o\">=</span> <span class=\"n\">Delay</span><span class=\"p\">(</span><span class=\"n\">tau</span><span class=\"o\">=</span><span class=\"mi\">5</span><span class=\"p\">)</span>\n</pre>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>tau <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>delay time constant</dd>\n</dl>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>_buffer <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">AdaptiveBuffer</span></dt>\n<dd>internal interpolatable adaptive rolling buffer</dd>\n</dl>\n</div>\n",
          "source": "class Delay(Block):\n    \"\"\"Delays the input signal by a time constant 'tau' in seconds. \n\n    Mathematically this block creates a time delay of the input signal like this:\n\n    .. math::\n\n        y(t) = \n        \\\\begin{cases}\n        x(t - \\\\tau) & , t \\\\geq \\\\tau \\\\\\\\\n        0            & , t < \\\\tau\n        \\\\end{cases}\n\n    Note\n    ----\n    The internal adaptive buffer uses interpolation for the evaluation. This is \n    required to be compatible with variable step solvers. It has a drawback however. \n    The order of the ode solver used will degrade when this block is used, due to \n    the interpolation.\n\n\n    Note\n    ----\n    This block supports vector input, meaning we can have multiple parallel \n    delay paths through this block.\n\n\n    Example\n    -------\n    The block is initialized like this:\n\n    .. code-block:: python\n\n        #5 time units delay\n        D = Delay(tau=5)\n\n    Parameters\n    ----------\n    tau : float\n        delay time constant\n\n    Attributes\n    ----------\n    _buffer : AdaptiveBuffer\n        internal interpolatable adaptive rolling buffer\n    \"\"\"\n\n    def __init__(self, tau=1e-3):\n        super().__init__()\n\n        #time delay in seconds \n        self.tau = tau\n\n        #create adaptive buffer\n        self._buffer = AdaptiveBuffer(self.tau)\n\n\n    def __len__(self):\n        #no passthrough by definition\n        return 0\n\n\n    def reset(self):\n        super().reset()\n\n        #clear the buffer\n        self._buffer.clear()\n\n\n    def update(self, t):\n        \"\"\"Evaluation of the buffer at different times \n        via interpolation.\n\n        Parameters\n        ----------\n        t : float\n            evaluation time\n        \"\"\"\n\n        #retrieve value from buffer\n        y = self._buffer.get(t)\n        self.outputs.update_from_array(y)\n\n\n    def sample(self, t, dt):\n        \"\"\"Sample input values and time of sampling \n        and add them to the buffer.\n\n        Parameters\n        ----------\n        t : float\n            evaluation time for sampling\n        dt : float\n            integration timestep\n        \"\"\"\n\n        #add new value to buffer\n        self._buffer.add(t, self.inputs.to_array())",
          "bases": [
            "pathsim.blocks._block.Block"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, tau=1e-3):\n    super().__init__()\n\n    #time delay in seconds \n    self.tau = tau\n\n    #create adaptive buffer\n    self._buffer = AdaptiveBuffer(self.tau)",
              "signature": "(tau = 0.001)",
              "parameters": [
                {
                  "name": "tau",
                  "type": null,
                  "default": "0.001",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "reset",
              "description": "",
              "docstring_html": "",
              "source": "def reset(self):\n    super().reset()\n\n    #clear the buffer\n    self._buffer.clear()",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "update",
              "description": "Evaluation of the buffer at different times",
              "docstring_html": "<p>Evaluation of the buffer at different times\nvia interpolation.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time</dd>\n</dl>\n",
              "source": "def update(self, t):\n    \"\"\"Evaluation of the buffer at different times \n    via interpolation.\n\n    Parameters\n    ----------\n    t : float\n        evaluation time\n    \"\"\"\n\n    #retrieve value from buffer\n    y = self._buffer.get(t)\n    self.outputs.update_from_array(y)",
              "signature": "(t)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "sample",
              "description": "Sample input values and time of sampling",
              "docstring_html": "<p>Sample input values and time of sampling\nand add them to the buffer.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time for sampling</dd>\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>integration timestep</dd>\n</dl>\n",
              "source": "def sample(self, t, dt):\n    \"\"\"Sample input values and time of sampling \n    and add them to the buffer.\n\n    Parameters\n    ----------\n    t : float\n        evaluation time for sampling\n    dt : float\n        integration timestep\n    \"\"\"\n\n    #add new value to buffer\n    self._buffer.add(t, self.inputs.to_array())",
              "signature": "(t, dt)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time for sampling"
                },
                {
                  "name": "dt",
                  "type": null,
                  "default": null,
                  "description": "integration timestep"
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "tau",
              "description": "",
              "type": null,
              "value": "tau"
            },
            {
              "name": "_buffer",
              "description": "",
              "type": null,
              "value": "AdaptiveBuffer(self.tau)"
            }
          ],
          "parameters": [
            {
              "name": "tau",
              "type": null,
              "default": "0.001",
              "description": "delay time constant"
            }
          ]
        }
      ],
      "functions": []
    },
    "pathsim.blocks.differentiator": {
      "name": "pathsim.blocks.differentiator",
      "description": "",
      "docstring_html": "",
      "classes": [
        {
          "name": "Differentiator",
          "description": "Differentiates the input signal.",
          "docstring_html": "<p>Differentiates the input signal.</p>\n<p>Uses a first order transfer function with a pole at the origin which implements\na high pass filter. Supports vector input.</p>\n<pre class=\"math\">\nH_\\mathrm{diff}(s) = \\frac{s}{1 + s / f_\\mathrm{max}}\n</pre>\n<p>The approximation holds for signals up to a frequency of approximately f_max.</p>\n<div class=\"section\" id=\"note\">\n<h4>Note</h4>\n<p>Depending on <cite>f_max</cite>, the resulting system might become stiff or ill conditioned!\nAs a practical choice set <cite>f_max</cite> to 3x the highest expected signal frequency.</p>\n</div>\n<div class=\"section\" id=\"note-1\">\n<h4>Note</h4>\n<p>Since this is an approximation of real differentiation, the approximation will not hold\nif there are high frequency components present in the signal. For example if you have\ndiscontinuities such as steps or squere waves.</p>\n</div>\n<div class=\"section\" id=\"example\">\n<h4>Example</h4>\n<p>The block is initialized like this:</p>\n<pre class=\"code python literal-block\">\n<span class=\"c1\">#cutoff at 1kHz</span><span class=\"w\">\n</span><span class=\"n\">D</span> <span class=\"o\">=</span> <span class=\"n\">Differentiator</span><span class=\"p\">(</span><span class=\"n\">f_max</span><span class=\"o\">=</span><span class=\"mf\">1e3</span><span class=\"p\">)</span>\n</pre>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>f_max <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>highest expected signal frequency</dd>\n</dl>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>op_dyn <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">DynamicOperator</span></dt>\n<dd>internal dynamic operator for ODE component</dd>\n<dt>op_alg <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">DynamicOperator</span></dt>\n<dd>internal algebraic operator</dd>\n</dl>\n</div>\n",
          "source": "class Differentiator(Block):\n    \"\"\"Differentiates the input signal. \n\n    Uses a first order transfer function with a pole at the origin which implements \n    a high pass filter. Supports vector input. \n\n    .. math::\n\n        H_\\\\mathrm{diff}(s) = \\\\frac{s}{1 + s / f_\\\\mathrm{max}} \n\n    The approximation holds for signals up to a frequency of approximately f_max.\n\n    Note\n    -----\n    Depending on `f_max`, the resulting system might become stiff or ill conditioned!\n    As a practical choice set `f_max` to 3x the highest expected signal frequency.\n\n    Note\n    ----\n    Since this is an approximation of real differentiation, the approximation will not hold \n    if there are high frequency components present in the signal. For example if you have \n    discontinuities such as steps or squere waves.\n\n    Example\n    -------\n    The block is initialized like this:\n\n    .. code-block:: python\n\n        #cutoff at 1kHz\n        D = Differentiator(f_max=1e3)\n\n    Parameters\n    ----------\n    f_max : float\n        highest expected signal frequency\n\n    Attributes\n    ----------\n    op_dyn : DynamicOperator\n        internal dynamic operator for ODE component\n    op_alg : DynamicOperator\n        internal algebraic operator\n\n    \"\"\"\n\n    def __init__(self, f_max=1e2):\n        super().__init__()\n\n        #maximum frequency for differentiator approximation\n        self.f_max = f_max\n\n        #initial state for integration engine\n        self.initial_value = 0.0\n\n        self.op_dyn = DynamicOperator(\n            func=lambda x, u, t: self.f_max * (u - x),\n            jac_x=lambda x, u, t: -self.f_max*np.eye(len(u))\n            )\n        self.op_alg = DynamicOperator(\n            func=lambda x, u, t: self.f_max * (u - x),\n            jac_x=lambda x, u, t: -self.f_max*np.eye(len(u)),\n            jac_u=lambda x, u, t: self.f_max*np.eye(len(u)),\n            )\n\n    def __len__(self):\n        return 1 if self._active else 0\n\n\n    def update(self, t):\n        \"\"\"update system equation fixed point loop,\n        with convergence control\n\n        Parameters\n        ----------\n        t : float\n            evaluation time\n        \"\"\"\n        x, u = self.engine.state, self.inputs.to_array()\n        y = self.op_alg(x, u, t)\n        self.outputs.update_from_array(y)\n\n\n    def solve(self, t, dt):\n        \"\"\"advance solution of implicit update equation\n\n        Parameters\n        ----------\n        t : float\n            evaluation time\n        dt : float\n            integration timestep\n\n        Returns\n        ------- \n        error : float\n            solver residual norm\n        \"\"\"\n        x, u = self.engine.state, self.inputs.to_array()\n        f, J = self.op_dyn(x, u, t), self.op_dyn.jac_x(x, u, t)\n        return self.engine.solve(f, J, dt)\n\n\n    def step(self, t, dt):\n        \"\"\"compute update step with integration engine\n\n        Parameters\n        ----------\n        t : float\n            evaluation time\n        dt : float\n            integration timestep\n\n        Returns\n        ------- \n        success : bool\n            step was successful\n        error : float\n            local truncation error from adaptive integrators\n        scale : float\n            timestep rescale from adaptive integrators\n        \"\"\"\n        x, u = self.engine.state, self.inputs.to_array()\n        f = self.op_dyn(x, u, t)\n        return self.engine.step(f, dt)",
          "bases": [
            "pathsim.blocks._block.Block"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, f_max=1e2):\n    super().__init__()\n\n    #maximum frequency for differentiator approximation\n    self.f_max = f_max\n\n    #initial state for integration engine\n    self.initial_value = 0.0\n\n    self.op_dyn = DynamicOperator(\n        func=lambda x, u, t: self.f_max * (u - x),\n        jac_x=lambda x, u, t: -self.f_max*np.eye(len(u))\n        )\n    self.op_alg = DynamicOperator(\n        func=lambda x, u, t: self.f_max * (u - x),\n        jac_x=lambda x, u, t: -self.f_max*np.eye(len(u)),\n        jac_u=lambda x, u, t: self.f_max*np.eye(len(u)),\n        )",
              "signature": "(f_max = 100.0)",
              "parameters": [
                {
                  "name": "f_max",
                  "type": null,
                  "default": "100.0",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "update",
              "description": "update system equation fixed point loop,",
              "docstring_html": "<p>update system equation fixed point loop,\nwith convergence control</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time</dd>\n</dl>\n",
              "source": "def update(self, t):\n    \"\"\"update system equation fixed point loop,\n    with convergence control\n\n    Parameters\n    ----------\n    t : float\n        evaluation time\n    \"\"\"\n    x, u = self.engine.state, self.inputs.to_array()\n    y = self.op_alg(x, u, t)\n    self.outputs.update_from_array(y)",
              "signature": "(t)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "solve",
              "description": "advance solution of implicit update equation",
              "docstring_html": "<p>advance solution of implicit update equation</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time</dd>\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>integration timestep</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>error <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>solver residual norm</dd>\n</dl>\n",
              "source": "def solve(self, t, dt):\n    \"\"\"advance solution of implicit update equation\n\n    Parameters\n    ----------\n    t : float\n        evaluation time\n    dt : float\n        integration timestep\n\n    Returns\n    ------- \n    error : float\n        solver residual norm\n    \"\"\"\n    x, u = self.engine.state, self.inputs.to_array()\n    f, J = self.op_dyn(x, u, t), self.op_dyn.jac_x(x, u, t)\n    return self.engine.solve(f, J, dt)",
              "signature": "(t, dt)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time"
                },
                {
                  "name": "dt",
                  "type": null,
                  "default": null,
                  "description": "integration timestep"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "step",
              "description": "compute update step with integration engine",
              "docstring_html": "<p>compute update step with integration engine</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time</dd>\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>integration timestep</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>success <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>step was successful</dd>\n<dt>error <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>local truncation error from adaptive integrators</dd>\n<dt>scale <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>timestep rescale from adaptive integrators</dd>\n</dl>\n",
              "source": "def step(self, t, dt):\n    \"\"\"compute update step with integration engine\n\n    Parameters\n    ----------\n    t : float\n        evaluation time\n    dt : float\n        integration timestep\n\n    Returns\n    ------- \n    success : bool\n        step was successful\n    error : float\n        local truncation error from adaptive integrators\n    scale : float\n        timestep rescale from adaptive integrators\n    \"\"\"\n    x, u = self.engine.state, self.inputs.to_array()\n    f = self.op_dyn(x, u, t)\n    return self.engine.step(f, dt)",
              "signature": "(t, dt)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time"
                },
                {
                  "name": "dt",
                  "type": null,
                  "default": null,
                  "description": "integration timestep"
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "f_max",
              "description": "",
              "type": null,
              "value": "f_max"
            },
            {
              "name": "initial_value",
              "description": "",
              "type": null,
              "value": "0.0"
            },
            {
              "name": "op_dyn",
              "description": "",
              "type": null,
              "value": "DynamicOperator(func=(lambda x, u, t: self.f_max * (u - x)), jac_x=(lambda x, u, t: -self.f_max * np.eye(len(u))))"
            },
            {
              "name": "op_alg",
              "description": "",
              "type": null,
              "value": "DynamicOperator(func=(lambda x, u, t: self.f_max * (u - x)), jac_x=(lambda x, u, t: -self.f_max * np.eye(len(u))), jac_u=(lambda x, u, t: self.f_max * np.eye(len(u))))"
            }
          ],
          "parameters": [
            {
              "name": "f_max",
              "type": null,
              "default": "100.0",
              "description": "highest expected signal frequency"
            }
          ]
        }
      ],
      "functions": []
    },
    "pathsim.blocks.dynsys": {
      "name": "pathsim.blocks.dynsys",
      "description": "",
      "docstring_html": "",
      "classes": [
        {
          "name": "DynamicalSystem",
          "description": "This block implements a nonlinear dynamical system / nonlinear state space model.",
          "docstring_html": "<p>This block implements a nonlinear dynamical system / nonlinear state space model.</p>\n<p>Its basically the same as the <cite>ODE</cite> block with the addition of an output equation\nthat takes the state, input and time as arguments:</p>\n<pre class=\"math\">\n\\begin{align}\n    \\dot{x}(t) &amp;= \\mathrm{func}_\\mathrm{dyn}(x(t), u(t), t) \\\\\n           y(t) &amp;= \\mathrm{func}_\\mathrm{alg}(x(t), u(t), t)\n\\end{align}\n</pre>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>func_dyn <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">callable</span></dt>\n<dd>right hand side function of ode-part of the system</dd>\n<dt>func_alg <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">callable</span></dt>\n<dd>output function of the system</dd>\n<dt>initial_value <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array[float]</span></dt>\n<dd>initial state / initial condition</dd>\n<dt>jac_dyn <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">callable | None</span></dt>\n<dd>optional jacobian of <cite>func_dyn</cite> to improve convergence\nfor implicit ode solvers</dd>\n</dl>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>op_dyn <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">DynamicOperator</span></dt>\n<dd>internal dynamic operator for <cite>func_dyn</cite></dd>\n<dt>op_alg <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">DynamicOperator</span></dt>\n<dd>internal dynamic operator for <cite>func_alg</cite></dd>\n</dl>\n",
          "source": "class DynamicalSystem(Block):\n    \"\"\"This block implements a nonlinear dynamical system / nonlinear state space model.\n\n    Its basically the same as the `ODE` block with the addition of an output equation\n    that takes the state, input and time as arguments:\n\n    .. math::\n\n        \\\\begin{align}\n            \\\\dot{x}(t) &= \\\\mathrm{func}_\\\\mathrm{dyn}(x(t), u(t), t) \\\\\\\\\n                   y(t) &= \\\\mathrm{func}_\\\\mathrm{alg}(x(t), u(t), t)\n        \\\\end{align}\n\n\n    Parameters\n    ----------\n    func_dyn : callable\n        right hand side function of ode-part of the system\n    func_alg : callable\n        output function of the system\n    initial_value : array[float]\n        initial state / initial condition\n    jac_dyn : callable | None\n        optional jacobian of `func_dyn` to improve convergence \n        for implicit ode solvers\n\n\n    Attributes\n    ----------\n    op_dyn : DynamicOperator\n        internal dynamic operator for `func_dyn`\n    op_alg : DynamicOperator\n        internal dynamic operator for `func_alg`\n    \"\"\"\n\n    def __init__(\n        self,\n        func_dyn=lambda x, u, t: -x,\n        func_alg=lambda x, u, t: x,\n        initial_value=0.0,\n        jac_dyn=None\n        ):\n\n        super().__init__()\n\n        #functions\n        self.func_dyn = func_dyn\n        self.func_alg = func_alg\n\n        #jacobian\n        self.jac_dyn = jac_dyn\n\n        #initial condition\n        self.initial_value = initial_value\n\n        #operators\n        self.op_dyn = DynamicOperator(\n            func=func_dyn,\n            jac_x=jac_dyn\n            )\n        self.op_alg = DynamicOperator(\n            func=func_alg\n            )\n\n\n    def __len__(self):\n        \"\"\"Potential passthrough due to `func_alg` being dependent on `u`.\n\n        This is checked by evaluating the jacobian of the algebraic output \n        equation with respect to `u`. If there are any non-zero entries, an \n        algebraic passthrouh exists.\n\n        Returns\n        -------\n        alg_length : int\n            length of algebraic path\n        \"\"\"\n        x, u = self.engine.state, self.inputs.to_array()\n        has_passthrough = np.any(self.op_alg.jac_u(x, u, 0.0))\n        return int(has_passthrough)\n\n\n    def update(self, t):\n        \"\"\"update system equation for fixed point loop, by evaluating the\n        output function of the system\n\n        Parameters\n        ----------\n        t : float\n            evaluation time\n        \"\"\"\n        x, u = self.engine.state, self.inputs.to_array()\n        self.outputs.update_from_array(self.op_alg(x, u, t))\n\n\n    def solve(self, t, dt):\n        \"\"\"advance solution of implicit update equation of the solver\n\n        Parameters\n        ----------\n        t : float\n            evaluation time\n        dt : float\n            integration timestep\n\n        Returns\n        ------- \n        error : float\n            solver residual norm\n        \"\"\"\n        x, u = self.engine.state, self.inputs.to_array()\n        f, J = self.op_dyn(x, u, t), self.op_dyn.jac_x(x, u, t)\n        return self.engine.solve(f, J, dt)\n\n\n    def step(self, t, dt):\n        \"\"\"compute timestep update with integration engine\n\n        Parameters\n        ----------\n        t : float\n            evaluation time\n        dt : float\n            integration timestep\n\n        Returns\n        ------- \n        success : bool\n            step was successful\n        error : float\n            local truncation error from adaptive integrators\n        scale : float\n            timestep rescale from adaptive integrators\n        \"\"\"\n        x, u = self.engine.state, self.inputs.to_array()\n        f = self.op_dyn(x, u, t)\n        return self.engine.step(f, dt)",
          "bases": [
            "pathsim.blocks._block.Block"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(\n    self,\n    func_dyn=lambda x, u, t: -x,\n    func_alg=lambda x, u, t: x,\n    initial_value=0.0,\n    jac_dyn=None\n    ):\n\n    super().__init__()\n\n    #functions\n    self.func_dyn = func_dyn\n    self.func_alg = func_alg\n\n    #jacobian\n    self.jac_dyn = jac_dyn\n\n    #initial condition\n    self.initial_value = initial_value\n\n    #operators\n    self.op_dyn = DynamicOperator(\n        func=func_dyn,\n        jac_x=jac_dyn\n        )\n    self.op_alg = DynamicOperator(\n        func=func_alg\n        )",
              "signature": "(func_dyn = lambda x, u, t: -x, func_alg = lambda x, u, t: x, initial_value = 0.0, jac_dyn = None)",
              "parameters": [
                {
                  "name": "func_dyn",
                  "type": null,
                  "default": "lambda x, u, t: -x",
                  "description": ""
                },
                {
                  "name": "func_alg",
                  "type": null,
                  "default": "lambda x, u, t: x",
                  "description": ""
                },
                {
                  "name": "initial_value",
                  "type": null,
                  "default": "0.0",
                  "description": ""
                },
                {
                  "name": "jac_dyn",
                  "type": null,
                  "default": "None",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "update",
              "description": "update system equation for fixed point loop, by evaluating the",
              "docstring_html": "<p>update system equation for fixed point loop, by evaluating the\noutput function of the system</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time</dd>\n</dl>\n",
              "source": "def update(self, t):\n    \"\"\"update system equation for fixed point loop, by evaluating the\n    output function of the system\n\n    Parameters\n    ----------\n    t : float\n        evaluation time\n    \"\"\"\n    x, u = self.engine.state, self.inputs.to_array()\n    self.outputs.update_from_array(self.op_alg(x, u, t))",
              "signature": "(t)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "solve",
              "description": "advance solution of implicit update equation of the solver",
              "docstring_html": "<p>advance solution of implicit update equation of the solver</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time</dd>\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>integration timestep</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>error <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>solver residual norm</dd>\n</dl>\n",
              "source": "def solve(self, t, dt):\n    \"\"\"advance solution of implicit update equation of the solver\n\n    Parameters\n    ----------\n    t : float\n        evaluation time\n    dt : float\n        integration timestep\n\n    Returns\n    ------- \n    error : float\n        solver residual norm\n    \"\"\"\n    x, u = self.engine.state, self.inputs.to_array()\n    f, J = self.op_dyn(x, u, t), self.op_dyn.jac_x(x, u, t)\n    return self.engine.solve(f, J, dt)",
              "signature": "(t, dt)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time"
                },
                {
                  "name": "dt",
                  "type": null,
                  "default": null,
                  "description": "integration timestep"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "step",
              "description": "compute timestep update with integration engine",
              "docstring_html": "<p>compute timestep update with integration engine</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time</dd>\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>integration timestep</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>success <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>step was successful</dd>\n<dt>error <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>local truncation error from adaptive integrators</dd>\n<dt>scale <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>timestep rescale from adaptive integrators</dd>\n</dl>\n",
              "source": "def step(self, t, dt):\n    \"\"\"compute timestep update with integration engine\n\n    Parameters\n    ----------\n    t : float\n        evaluation time\n    dt : float\n        integration timestep\n\n    Returns\n    ------- \n    success : bool\n        step was successful\n    error : float\n        local truncation error from adaptive integrators\n    scale : float\n        timestep rescale from adaptive integrators\n    \"\"\"\n    x, u = self.engine.state, self.inputs.to_array()\n    f = self.op_dyn(x, u, t)\n    return self.engine.step(f, dt)",
              "signature": "(t, dt)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time"
                },
                {
                  "name": "dt",
                  "type": null,
                  "default": null,
                  "description": "integration timestep"
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "func_dyn",
              "description": "",
              "type": null,
              "value": "func_dyn"
            },
            {
              "name": "func_alg",
              "description": "",
              "type": null,
              "value": "func_alg"
            },
            {
              "name": "jac_dyn",
              "description": "",
              "type": null,
              "value": "jac_dyn"
            },
            {
              "name": "initial_value",
              "description": "",
              "type": null,
              "value": "initial_value"
            },
            {
              "name": "op_dyn",
              "description": "",
              "type": null,
              "value": "DynamicOperator(func=func_dyn, jac_x=jac_dyn)"
            },
            {
              "name": "op_alg",
              "description": "",
              "type": null,
              "value": "DynamicOperator(func=func_alg)"
            }
          ],
          "parameters": [
            {
              "name": "func_dyn",
              "type": null,
              "default": "lambda x, u, t: -x",
              "description": "right hand side function of ode-part of the system"
            },
            {
              "name": "func_alg",
              "type": null,
              "default": "lambda x, u, t: x",
              "description": "output function of the system"
            },
            {
              "name": "initial_value",
              "type": null,
              "default": "0.0",
              "description": "initial state / initial condition"
            },
            {
              "name": "jac_dyn",
              "type": null,
              "default": "None",
              "description": "optional jacobian of `func_dyn` to improve convergence for implicit ode solvers"
            }
          ]
        }
      ],
      "functions": []
    },
    "pathsim.blocks.filters": {
      "name": "pathsim.blocks.filters",
      "description": "",
      "docstring_html": "",
      "classes": [
        {
          "name": "ButterworthLowpassFilter",
          "description": "Direct implementation of a low pass butterworth filter block.",
          "docstring_html": "<p>Direct implementation of a low pass butterworth filter block.</p>\n<p>Follows the same structure as the 'StateSpace' block in the\n'pathsim.blocks' module. The numerator and denominator of the\nfilter transfer function are generated and then the transfer\nfunction is realized as a state space model.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>Fc <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>corner frequency of the filter in [Hz]</dd>\n<dt>n <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>filter order</dd>\n</dl>\n",
          "source": "class ButterworthLowpassFilter(StateSpace):\n    \"\"\"Direct implementation of a low pass butterworth filter block.\n\n    Follows the same structure as the 'StateSpace' block in the \n    'pathsim.blocks' module. The numerator and denominator of the \n    filter transfer function are generated and then the transfer \n    function is realized as a state space model. \n\n    Parameters\n    ----------\n    Fc : float\n        corner frequency of the filter in [Hz]\n    n : int\n        filter order\n    \"\"\"\n\n    input_port_labels = {\"in\":0}\n    output_port_labels = {\"out\":0}\n\n    def __init__(self, Fc=100, n=2):\n\n        #filter parameters\n        self.Fc = Fc\n        self.n = n\n\n        #use scipy.signal for filter design for unit frequency\n        num, den = butter(n, 1.0, btype=\"low\", analog=True, output=\"ba\")\n        A, B, C, D = tf2ss(num, den)\n\n        #rescale to actual bandwidth and make statespace model\n        omega_c = 2*np.pi*self.Fc\n        super().__init__(omega_c*A, omega_c*B, C, D)",
          "bases": [
            "pathsim.blocks.lti.StateSpace"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, Fc=100, n=2):\n\n    #filter parameters\n    self.Fc = Fc\n    self.n = n\n\n    #use scipy.signal for filter design for unit frequency\n    num, den = butter(n, 1.0, btype=\"low\", analog=True, output=\"ba\")\n    A, B, C, D = tf2ss(num, den)\n\n    #rescale to actual bandwidth and make statespace model\n    omega_c = 2*np.pi*self.Fc\n    super().__init__(omega_c*A, omega_c*B, C, D)",
              "signature": "(Fc = 100, n = 2)",
              "parameters": [
                {
                  "name": "Fc",
                  "type": null,
                  "default": "100",
                  "description": ""
                },
                {
                  "name": "n",
                  "type": null,
                  "default": "2",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "input_port_labels",
              "description": "",
              "type": null,
              "value": "{'in': 0}"
            },
            {
              "name": "output_port_labels",
              "description": "",
              "type": null,
              "value": "{'out': 0}"
            },
            {
              "name": "Fc",
              "description": "",
              "type": null,
              "value": "Fc"
            },
            {
              "name": "n",
              "description": "",
              "type": null,
              "value": "n"
            }
          ],
          "parameters": [
            {
              "name": "Fc",
              "type": null,
              "default": "100",
              "description": "corner frequency of the filter in [Hz]"
            },
            {
              "name": "n",
              "type": null,
              "default": "2",
              "description": "filter order"
            }
          ]
        },
        {
          "name": "ButterworthHighpassFilter",
          "description": "Direct implementation of a high pass butterworth filter block.",
          "docstring_html": "<p>Direct implementation of a high pass butterworth filter block.</p>\n<p>Follows the same structure as the 'StateSpace' block in the\n'pathsim.blocks' module. The numerator and denominator of the\nfilter transfer function are generated and then the transfer\nfunction is realized as a state space model.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>Fc <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>corner frequency of the filter in [Hz]</dd>\n<dt>n <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>filter order</dd>\n</dl>\n",
          "source": "class ButterworthHighpassFilter(StateSpace):\n    \"\"\"Direct implementation of a high pass butterworth filter block.\n\n    Follows the same structure as the 'StateSpace' block in the \n    'pathsim.blocks' module. The numerator and denominator of the \n    filter transfer function are generated and then the transfer \n    function is realized as a state space model. \n\n    Parameters\n    ----------\n    Fc : float\n        corner frequency of the filter in [Hz]\n    n : int\n        filter order\n    \"\"\"\n    input_port_labels = {\"in\":0}\n    output_port_labels = {\"out\":0}\n\n    def __init__(self, Fc=100, n=2):\n\n        #filter parameters\n        self.Fc = Fc\n        self.n = n\n\n        #use scipy.signal for filter design for unit frequency\n        num, den = butter(n, 1.0, btype=\"high\", analog=True, output=\"ba\")\n        A, B, C, D = tf2ss(num, den)\n\n        #rescale to actual bandwidth and make statespace model\n        omega_c = 2*np.pi*self.Fc\n        super().__init__(omega_c*A, omega_c*B, C, D)",
          "bases": [
            "pathsim.blocks.lti.StateSpace"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, Fc=100, n=2):\n\n    #filter parameters\n    self.Fc = Fc\n    self.n = n\n\n    #use scipy.signal for filter design for unit frequency\n    num, den = butter(n, 1.0, btype=\"high\", analog=True, output=\"ba\")\n    A, B, C, D = tf2ss(num, den)\n\n    #rescale to actual bandwidth and make statespace model\n    omega_c = 2*np.pi*self.Fc\n    super().__init__(omega_c*A, omega_c*B, C, D)",
              "signature": "(Fc = 100, n = 2)",
              "parameters": [
                {
                  "name": "Fc",
                  "type": null,
                  "default": "100",
                  "description": ""
                },
                {
                  "name": "n",
                  "type": null,
                  "default": "2",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "input_port_labels",
              "description": "",
              "type": null,
              "value": "{'in': 0}"
            },
            {
              "name": "output_port_labels",
              "description": "",
              "type": null,
              "value": "{'out': 0}"
            },
            {
              "name": "Fc",
              "description": "",
              "type": null,
              "value": "Fc"
            },
            {
              "name": "n",
              "description": "",
              "type": null,
              "value": "n"
            }
          ],
          "parameters": [
            {
              "name": "Fc",
              "type": null,
              "default": "100",
              "description": "corner frequency of the filter in [Hz]"
            },
            {
              "name": "n",
              "type": null,
              "default": "2",
              "description": "filter order"
            }
          ]
        },
        {
          "name": "ButterworthBandpassFilter",
          "description": "Direct implementation of a bandpass butterworth filter block.",
          "docstring_html": "<p>Direct implementation of a bandpass butterworth filter block.</p>\n<p>Follows the same structure as the 'StateSpace' block in the\n'pathsim.blocks' module. The numerator and denominator of the\nfilter transfer function are generated and then the transfer\nfunction is realized as a state space model.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>Fc <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">list[float]</span></dt>\n<dd>corner frequencies (left, right) of the filter in [Hz]</dd>\n<dt>n <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>filter order</dd>\n</dl>\n",
          "source": "class ButterworthBandpassFilter(StateSpace):\n    \"\"\"Direct implementation of a bandpass butterworth filter block.\n\n    Follows the same structure as the 'StateSpace' block in the \n    'pathsim.blocks' module. The numerator and denominator of the \n    filter transfer function are generated and then the transfer \n    function is realized as a state space model. \n\n    Parameters\n    ----------\n    Fc : list[float]\n        corner frequencies (left, right) of the filter in [Hz]\n    n : int\n        filter order\n    \"\"\"\n    input_port_labels = {\"in\":0}\n    output_port_labels = {\"out\":0}\n\n    def __init__(self, Fc=[50, 100], n=2):\n\n        #filter parameters\n        self.Fc = np.asarray(Fc)\n        self.n = n\n\n        if len(Fc) != 2:\n            raise ValueError(\"'ButterworthBandpassFilter' requires two corner frequencies!\")\n\n        #use scipy.signal for filter design\n        num, den = butter(n, 2*np.pi*self.Fc, btype=\"bandpass\", analog=True, output=\"ba\")\n\n        #initialize parent block\n        super().__init__(*tf2ss(num, den))",
          "bases": [
            "pathsim.blocks.lti.StateSpace"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, Fc=[50, 100], n=2):\n\n    #filter parameters\n    self.Fc = np.asarray(Fc)\n    self.n = n\n\n    if len(Fc) != 2:\n        raise ValueError(\"'ButterworthBandpassFilter' requires two corner frequencies!\")\n\n    #use scipy.signal for filter design\n    num, den = butter(n, 2*np.pi*self.Fc, btype=\"bandpass\", analog=True, output=\"ba\")\n\n    #initialize parent block\n    super().__init__(*tf2ss(num, den))",
              "signature": "(Fc = [50, 100], n = 2)",
              "parameters": [
                {
                  "name": "Fc",
                  "type": null,
                  "default": "[50, 100]",
                  "description": ""
                },
                {
                  "name": "n",
                  "type": null,
                  "default": "2",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "input_port_labels",
              "description": "",
              "type": null,
              "value": "{'in': 0}"
            },
            {
              "name": "output_port_labels",
              "description": "",
              "type": null,
              "value": "{'out': 0}"
            },
            {
              "name": "Fc",
              "description": "",
              "type": null,
              "value": "np.asarray(Fc)"
            },
            {
              "name": "n",
              "description": "",
              "type": null,
              "value": "n"
            }
          ],
          "parameters": [
            {
              "name": "Fc",
              "type": null,
              "default": "[50, 100]",
              "description": "corner frequencies (left, right) of the filter in [Hz]"
            },
            {
              "name": "n",
              "type": null,
              "default": "2",
              "description": "filter order"
            }
          ]
        },
        {
          "name": "ButterworthBandstopFilter",
          "description": "Direct implementation of a bandstop butterworth filter block.",
          "docstring_html": "<p>Direct implementation of a bandstop butterworth filter block.</p>\n<p>Follows the same structure as the 'StateSpace' block in the\n'pathsim.blocks' module. The numerator and denominator of the\nfilter transfer function are generated and then the transfer\nfunction is realized as a state space model.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>Fc <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">tuple[float], list[float]</span></dt>\n<dd>corner frequencies (left, right) of the filter in [Hz]</dd>\n<dt>n <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>filter order</dd>\n</dl>\n",
          "source": "class ButterworthBandstopFilter(StateSpace):\n    \"\"\"Direct implementation of a bandstop butterworth filter block.\n\n    Follows the same structure as the 'StateSpace' block in the \n    'pathsim.blocks' module. The numerator and denominator of the \n    filter transfer function are generated and then the transfer \n    function is realized as a state space model. \n\n    Parameters\n    ----------\n    Fc : tuple[float], list[float]\n        corner frequencies (left, right) of the filter in [Hz]\n    n : int\n        filter order\n    \"\"\"\n    input_port_labels = {\"in\":0}\n    output_port_labels = {\"out\":0}\n\n    def __init__(self, Fc=[50, 100], n=2):\n\n        #filter parameters\n        self.Fc = np.asarray(Fc)\n        self.n = n\n\n        if len(Fc) != 2:\n            raise ValueError(\"'ButterworthBandstopFilter' requires two corner frequencies!\")\n\n        #use scipy.signal for filter design\n        num, den = butter(n, 2*np.pi*self.Fc, btype=\"bandstop\", analog=True, output=\"ba\")\n\n        #initialize parent block\n        super().__init__(*tf2ss(num, den))",
          "bases": [
            "pathsim.blocks.lti.StateSpace"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, Fc=[50, 100], n=2):\n\n    #filter parameters\n    self.Fc = np.asarray(Fc)\n    self.n = n\n\n    if len(Fc) != 2:\n        raise ValueError(\"'ButterworthBandstopFilter' requires two corner frequencies!\")\n\n    #use scipy.signal for filter design\n    num, den = butter(n, 2*np.pi*self.Fc, btype=\"bandstop\", analog=True, output=\"ba\")\n\n    #initialize parent block\n    super().__init__(*tf2ss(num, den))",
              "signature": "(Fc = [50, 100], n = 2)",
              "parameters": [
                {
                  "name": "Fc",
                  "type": null,
                  "default": "[50, 100]",
                  "description": ""
                },
                {
                  "name": "n",
                  "type": null,
                  "default": "2",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "input_port_labels",
              "description": "",
              "type": null,
              "value": "{'in': 0}"
            },
            {
              "name": "output_port_labels",
              "description": "",
              "type": null,
              "value": "{'out': 0}"
            },
            {
              "name": "Fc",
              "description": "",
              "type": null,
              "value": "np.asarray(Fc)"
            },
            {
              "name": "n",
              "description": "",
              "type": null,
              "value": "n"
            }
          ],
          "parameters": [
            {
              "name": "Fc",
              "type": null,
              "default": "[50, 100]",
              "description": "corner frequencies (left, right) of the filter in [Hz]"
            },
            {
              "name": "n",
              "type": null,
              "default": "2",
              "description": "filter order"
            }
          ]
        },
        {
          "name": "AllpassFilter",
          "description": "Direct implementation of a first order allpass filter, or a cascade",
          "docstring_html": "<p>Direct implementation of a first order allpass filter, or a cascade\nof n 1st order allpass filters</p>\n<pre class=\"math\">\nH(s) = \\frac{s - 2\\pi f_s}{s + 2\\pi f_s}\n</pre>\n<p>where f_s is the frequency, where the 1st order allpass has a 90 deg phase shift.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>fs <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>frequency for 90 deg phase shift of 1st order allpass</dd>\n<dt>n <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>number of cascades</dd>\n</dl>\n",
          "source": "class AllpassFilter(StateSpace):\n    \"\"\"Direct implementation of a first order allpass filter, or a cascade \n    of n 1st order allpass filters\n\n    .. math:: \n\n        H(s) = \\\\frac{s - 2\\\\pi f_s}{s + 2\\\\pi f_s}\n\n    where f_s is the frequency, where the 1st order allpass has a 90 deg phase shift.\n\n    Parameters\n    ----------\n    fs : float\n        frequency for 90 deg phase shift of 1st order allpass\n    n : int\n        number of cascades\n    \"\"\"\n    input_port_labels = {\"in\":0}\n    output_port_labels = {\"out\":0}\n\n    def __init__(self, fs=100, n=1):\n\n        #filter parameters\n        self.fs = fs\n        self.n = n\n\n        #1st order allpass for numerator and denominator (normalized frequency)\n        num = [-1, 1]\n        den = [1, 1]\n\n        #higher order by convolution\n        for _ in range(1, self.n):\n            num = np.convolve(num, [-1, 1])\n            den = np.convolve(den, [1, 1])\n\n        #create statespace model\n        A, B, C, D = tf2ss(num, den)\n\n        #rescale to actual frequency and make statespace model\n        omega_s = 2*np.pi*fs\n\n        #initialize parent block\n        super().__init__(omega_s*A, omega_s*B, C, D)",
          "bases": [
            "pathsim.blocks.lti.StateSpace"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, fs=100, n=1):\n\n    #filter parameters\n    self.fs = fs\n    self.n = n\n\n    #1st order allpass for numerator and denominator (normalized frequency)\n    num = [-1, 1]\n    den = [1, 1]\n\n    #higher order by convolution\n    for _ in range(1, self.n):\n        num = np.convolve(num, [-1, 1])\n        den = np.convolve(den, [1, 1])\n\n    #create statespace model\n    A, B, C, D = tf2ss(num, den)\n\n    #rescale to actual frequency and make statespace model\n    omega_s = 2*np.pi*fs\n\n    #initialize parent block\n    super().__init__(omega_s*A, omega_s*B, C, D)",
              "signature": "(fs = 100, n = 1)",
              "parameters": [
                {
                  "name": "fs",
                  "type": null,
                  "default": "100",
                  "description": ""
                },
                {
                  "name": "n",
                  "type": null,
                  "default": "1",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "input_port_labels",
              "description": "",
              "type": null,
              "value": "{'in': 0}"
            },
            {
              "name": "output_port_labels",
              "description": "",
              "type": null,
              "value": "{'out': 0}"
            },
            {
              "name": "fs",
              "description": "",
              "type": null,
              "value": "fs"
            },
            {
              "name": "n",
              "description": "",
              "type": null,
              "value": "n"
            }
          ],
          "parameters": [
            {
              "name": "fs",
              "type": null,
              "default": "100",
              "description": "frequency for 90 deg phase shift of 1st order allpass"
            },
            {
              "name": "n",
              "type": null,
              "default": "1",
              "description": "number of cascades"
            }
          ]
        }
      ],
      "functions": []
    },
    "pathsim.blocks.fir": {
      "name": "pathsim.blocks.fir",
      "description": "",
      "docstring_html": "",
      "classes": [
        {
          "name": "FIR",
          "description": "Models a discrete-time Finite-Impulse-Response (FIR) filter.",
          "docstring_html": "<p>Models a discrete-time Finite-Impulse-Response (FIR) filter.</p>\n<p>This block applies an FIR filter to an input signal sampled periodically.\nThe output at each sample time is a weighted sum of the current and a finite number\nof past input samples. The operation is triggered by a scheduled event.</p>\n<p>Functionality:</p>\n<pre class=\"math\">\ny[n] = b[0] x[n] + b[1] x[n-1] + \\dots + b[N] x[n-N]\n</pre>\n<p>where <cite>b</cite> are the filter coefficients and <cite>N</cite> is the filter order (number of\ncoefficients - 1).</p>\n<ol class=\"arabic simple\">\n<li>Samples the input <cite>inputs[0]</cite> at intervals of <cite>T</cite>, starting after delay <cite>tau</cite>.</li>\n<li>Stores the current and past <cite>len(coefficients) - 1</cite> input samples in an internal buffer.</li>\n<li>Computes the filter output using the dot product of the coefficients\nand the buffered input samples.</li>\n<li>Outputs the result on <cite>outputs[0]</cite>.</li>\n<li>Holds the output constant between updates.</li>\n</ol>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>coeffs <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array_like</span></dt>\n<dd>List or numpy array of FIR filter coefficients [b0, b1, ..., bN].\nThe number of coefficients determines the filter's order and memory.</dd>\n<dt>T <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float, optional</span></dt>\n<dd>Sampling period (time between input samples and output updates). Default is 1.</dd>\n<dt>tau <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float, optional</span></dt>\n<dd>Initial delay before the first sample is processed. Default is 0.</dd>\n</dl>\n<div class=\"section\" id=\"input-ports\">\n<h4>Input Ports</h4>\n<dl class=\"docutils\">\n<dt>inputs[0] <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>Input signal sample at the current time step.</dd>\n</dl>\n</div>\n<div class=\"section\" id=\"output-ports\">\n<h4>Output Ports</h4>\n<dl class=\"docutils\">\n<dt>outputs[0] <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>Filtered output signal sample.</dd>\n</dl>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>buffer <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">deque</span></dt>\n<dd>Internal buffer storing the most recent input samples.</dd>\n<dt>events <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">list[Schedule]</span></dt>\n<dd>Internal scheduled event triggering the filter calculation.</dd>\n</dl>\n</div>\n",
          "source": "class FIR(Block):\n    \"\"\"Models a discrete-time Finite-Impulse-Response (FIR) filter.\n\n    This block applies an FIR filter to an input signal sampled periodically.\n    The output at each sample time is a weighted sum of the current and a finite number \n    of past input samples. The operation is triggered by a scheduled event.\n\n    Functionality:\n\n    .. math::\n\n        y[n] = b[0] x[n] + b[1] x[n-1] + \\\\dots + b[N] x[n-N]\n\n    where `b` are the filter coefficients and `N` is the filter order (number of \n    coefficients - 1).\n\n    1. Samples the input `inputs[0]` at intervals of `T`, starting after delay `tau`.\n    2. Stores the current and past `len(coefficients) - 1` input samples in an internal buffer.\n    3. Computes the filter output using the dot product of the coefficients\n       and the buffered input samples.\n    4. Outputs the result on `outputs[0]`.\n    5. Holds the output constant between updates.\n\n    Parameters\n    ----------\n    coeffs : array_like\n        List or numpy array of FIR filter coefficients [b0, b1, ..., bN].\n        The number of coefficients determines the filter's order and memory.\n    T : float, optional\n        Sampling period (time between input samples and output updates). Default is 1.\n    tau : float, optional\n        Initial delay before the first sample is processed. Default is 0.\n\n    Input Ports\n    -----------\n    inputs[0] : float\n        Input signal sample at the current time step.\n\n    Output Ports\n    ------------\n    outputs[0] : float\n        Filtered output signal sample.\n\n    Attributes\n    ----------\n    buffer : deque\n        Internal buffer storing the most recent input samples.\n    events : list[Schedule]\n        Internal scheduled event triggering the filter calculation.\n    \"\"\"\n\n    input_port_labels = {\"in\": 0}\n    output_port_labels = {\"out\": 0}\n\n\n    def __init__(self, coeffs=[1.0], T=1, tau=0):\n        super().__init__()\n\n        #block params\n        self.coeffs = np.array(coeffs)\n        self.T = T\n        self.tau = tau\n\n        #buffer to store the last N+1 input samples (current + N past)\n        n = len(self.coeffs)\n        self._buffer = deque([0.0]*n, maxlen=n)\n\n        def _update_fir(t):\n\n            #update internal buffer\n            self._buffer.appendleft(self.inputs[0])\n\n            #compute the FIR output: y[n] = sum(b[k] * x[n-k])\n            current_output = np.dot(self.coeffs, self._buffer)\n\n            #update the block's output port\n            self.outputs[0] = current_output\n\n        #internal scheduled event\n        self.events = [\n            Schedule(\n                t_start=self.tau,\n                t_period=self.T,\n                func_act=_update_fir\n                )\n            ]\n\n\n    def reset(self):\n        \"\"\"Resets the filter state (buffer) and output.\"\"\"\n        super().reset()\n        n = len(self.coeffs)\n        self._buffer = deque([0.0]*n, maxlen=n)\n\n\n    def __len__(self):\n        \"\"\"This block has no direct passthrough\"\"\"\n        return 0",
          "bases": [
            "pathsim.blocks._block.Block"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, coeffs=[1.0], T=1, tau=0):\n    super().__init__()\n\n    #block params\n    self.coeffs = np.array(coeffs)\n    self.T = T\n    self.tau = tau\n\n    #buffer to store the last N+1 input samples (current + N past)\n    n = len(self.coeffs)\n    self._buffer = deque([0.0]*n, maxlen=n)\n\n    def _update_fir(t):\n\n        #update internal buffer\n        self._buffer.appendleft(self.inputs[0])\n\n        #compute the FIR output: y[n] = sum(b[k] * x[n-k])\n        current_output = np.dot(self.coeffs, self._buffer)\n\n        #update the block's output port\n        self.outputs[0] = current_output\n\n    #internal scheduled event\n    self.events = [\n        Schedule(\n            t_start=self.tau,\n            t_period=self.T,\n            func_act=_update_fir\n            )\n        ]",
              "signature": "(coeffs = [1.0], T = 1, tau = 0)",
              "parameters": [
                {
                  "name": "coeffs",
                  "type": null,
                  "default": "[1.0]",
                  "description": ""
                },
                {
                  "name": "T",
                  "type": null,
                  "default": "1",
                  "description": ""
                },
                {
                  "name": "tau",
                  "type": null,
                  "default": "0",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "reset",
              "description": "Resets the filter state (buffer) and output.",
              "docstring_html": "<p>Resets the filter state (buffer) and output.</p>\n",
              "source": "def reset(self):\n    \"\"\"Resets the filter state (buffer) and output.\"\"\"\n    super().reset()\n    n = len(self.coeffs)\n    self._buffer = deque([0.0]*n, maxlen=n)",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "input_port_labels",
              "description": "",
              "type": null,
              "value": "{'in': 0}"
            },
            {
              "name": "output_port_labels",
              "description": "",
              "type": null,
              "value": "{'out': 0}"
            },
            {
              "name": "coeffs",
              "description": "",
              "type": null,
              "value": "np.array(coeffs)"
            },
            {
              "name": "T",
              "description": "",
              "type": null,
              "value": "T"
            },
            {
              "name": "tau",
              "description": "",
              "type": null,
              "value": "tau"
            },
            {
              "name": "_buffer",
              "description": "",
              "type": null,
              "value": "deque([0.0] * n, maxlen=n)"
            },
            {
              "name": "events",
              "description": "",
              "type": null,
              "value": "[Schedule(t_start=(self.tau), t_period=(self.T), func_act=_update_fir)]"
            }
          ],
          "parameters": [
            {
              "name": "coeffs",
              "type": null,
              "default": "[1.0]",
              "description": "List or numpy array of FIR filter coefficients [b0, b1, ..., bN]. The number of coefficients determines the filter's order and memory."
            },
            {
              "name": "T",
              "type": null,
              "default": "1",
              "description": "Sampling period (time between input samples and output updates). Default is 1."
            },
            {
              "name": "tau",
              "type": null,
              "default": "0",
              "description": "Initial delay before the first sample is processed. Default is 0."
            }
          ]
        }
      ],
      "functions": []
    },
    "pathsim.blocks.fmu": {
      "name": "pathsim.blocks.fmu",
      "description": "",
      "docstring_html": "",
      "classes": [
        {
          "name": "CoSimulationFMU",
          "description": "Co-Simulation FMU block using FMPy with support for FMI 2.0 and FMI 3.0.",
          "docstring_html": "<p>Co-Simulation FMU block using FMPy with support for FMI 2.0 and FMI 3.0.</p>\n<p>This block wraps an FMU (Functional Mock-up Unit) for co-simulation.\nThe FMU encapsulates a simulation model that can be executed independently\nand synchronized with the main simulation at discrete communication points.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>fmu_path <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">str</span></dt>\n<dd>path to the FMU file (.fmu)</dd>\n<dt>instance_name <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">str, optional</span></dt>\n<dd>name for the FMU instance (default: 'fmu_instance')</dd>\n<dt>start_values <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">dict, optional</span></dt>\n<dd>dictionary of variable names and their initial values</dd>\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float, optional</span></dt>\n<dd>communication step size for co-simulation. If None, uses the FMU's\ndefault experiment step size if available.</dd>\n</dl>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>fmu_wrapper <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">FMUWrapper</span></dt>\n<dd>version-agnostic FMU wrapper instance providing access to model_description,\nfmu, and other FMPy objects for advanced usage</dd>\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>communication step size</dd>\n</dl>\n",
          "source": "class CoSimulationFMU(Block):\n    \"\"\"Co-Simulation FMU block using FMPy with support for FMI 2.0 and FMI 3.0.\n\n    This block wraps an FMU (Functional Mock-up Unit) for co-simulation.\n    The FMU encapsulates a simulation model that can be executed independently\n    and synchronized with the main simulation at discrete communication points.\n\n    Parameters\n    ----------\n    fmu_path : str\n        path to the FMU file (.fmu)\n    instance_name : str, optional\n        name for the FMU instance (default: 'fmu_instance')\n    start_values : dict, optional\n        dictionary of variable names and their initial values\n    dt : float, optional\n        communication step size for co-simulation. If None, uses the FMU's\n        default experiment step size if available.\n\n    Attributes\n    ----------\n    fmu_wrapper : FMUWrapper\n        version-agnostic FMU wrapper instance providing access to model_description,\n        fmu, and other FMPy objects for advanced usage\n    dt : float\n        communication step size\n    \"\"\"\n\n    def __init__(self, fmu_path, instance_name=\"fmu_instance\", start_values=None, dt=None):\n        super().__init__()\n\n        self.start_values = start_values\n\n        # Create and initialize FMU wrapper\n        self.fmu_wrapper = FMUWrapper(fmu_path, instance_name, mode='cosimulation')\n        self.fmu_wrapper.initialize(start_values, start_time=0.0)\n\n        # Determine step size\n        self.dt = dt if dt is not None else self.fmu_wrapper.default_step_size\n        if self.dt is None:\n            raise ValueError(\"No step size provided and FMU has no default experiment step size\")\n\n        # Setup block I/O from FMU variables\n        self.inputs, self.outputs = self.fmu_wrapper.create_port_registers()\n\n        # Scheduled co-simulation step\n        self.events = [\n            Schedule(\n                t_start=0, \n                t_period=self.dt, \n                func_act=self._step_fmu\n                )\n            ]\n\n        # Read initial outputs\n        self.outputs.update_from_array(self.fmu_wrapper.get_outputs_as_array())\n\n\n    def _step_fmu(self, t):\n        \"\"\"Perform one FMU co-simulation step.\"\"\"\n        self.fmu_wrapper.set_inputs_from_array(self.inputs.to_array())\n\n        result = self.fmu_wrapper.do_step(\n            current_time=t, \n            step_size=self.dt\n            )\n\n        if result.terminate_simulation:\n            raise RuntimeError(\"FMU requested simulation termination\")\n\n        self.outputs.update_from_array(self.fmu_wrapper.get_outputs_as_array())\n\n\n    def reset(self):\n        \"\"\"Reset the FMU instance.\"\"\"\n        super().reset()\n        self.fmu_wrapper.reset()\n        self.fmu_wrapper.initialize(self.start_values, start_time=0.0)\n        self.outputs.update_from_array(self.fmu_wrapper.get_outputs_as_array())\n\n\n    def __len__(self):\n        \"\"\"FMU is a discrete time source-like block without direct passthrough.\"\"\"\n        return 0",
          "bases": [
            "pathsim.blocks._block.Block"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, fmu_path, instance_name=\"fmu_instance\", start_values=None, dt=None):\n    super().__init__()\n\n    self.start_values = start_values\n\n    # Create and initialize FMU wrapper\n    self.fmu_wrapper = FMUWrapper(fmu_path, instance_name, mode='cosimulation')\n    self.fmu_wrapper.initialize(start_values, start_time=0.0)\n\n    # Determine step size\n    self.dt = dt if dt is not None else self.fmu_wrapper.default_step_size\n    if self.dt is None:\n        raise ValueError(\"No step size provided and FMU has no default experiment step size\")\n\n    # Setup block I/O from FMU variables\n    self.inputs, self.outputs = self.fmu_wrapper.create_port_registers()\n\n    # Scheduled co-simulation step\n    self.events = [\n        Schedule(\n            t_start=0, \n            t_period=self.dt, \n            func_act=self._step_fmu\n            )\n        ]\n\n    # Read initial outputs\n    self.outputs.update_from_array(self.fmu_wrapper.get_outputs_as_array())",
              "signature": "(fmu_path, instance_name = 'fmu_instance', start_values = None, dt = None)",
              "parameters": [
                {
                  "name": "fmu_path",
                  "type": null,
                  "default": null,
                  "description": ""
                },
                {
                  "name": "instance_name",
                  "type": null,
                  "default": "'fmu_instance'",
                  "description": ""
                },
                {
                  "name": "start_values",
                  "type": null,
                  "default": "None",
                  "description": ""
                },
                {
                  "name": "dt",
                  "type": null,
                  "default": "None",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "_step_fmu",
              "description": "Perform one FMU co-simulation step.",
              "docstring_html": "<p>Perform one FMU co-simulation step.</p>\n",
              "source": "def _step_fmu(self, t):\n    \"\"\"Perform one FMU co-simulation step.\"\"\"\n    self.fmu_wrapper.set_inputs_from_array(self.inputs.to_array())\n\n    result = self.fmu_wrapper.do_step(\n        current_time=t, \n        step_size=self.dt\n        )\n\n    if result.terminate_simulation:\n        raise RuntimeError(\"FMU requested simulation termination\")\n\n    self.outputs.update_from_array(self.fmu_wrapper.get_outputs_as_array())",
              "signature": "(t)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "reset",
              "description": "Reset the FMU instance.",
              "docstring_html": "<p>Reset the FMU instance.</p>\n",
              "source": "def reset(self):\n    \"\"\"Reset the FMU instance.\"\"\"\n    super().reset()\n    self.fmu_wrapper.reset()\n    self.fmu_wrapper.initialize(self.start_values, start_time=0.0)\n    self.outputs.update_from_array(self.fmu_wrapper.get_outputs_as_array())",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "start_values",
              "description": "",
              "type": null,
              "value": "start_values"
            },
            {
              "name": "fmu_wrapper",
              "description": "",
              "type": null,
              "value": "FMUWrapper(fmu_path, instance_name, mode='cosimulation')"
            },
            {
              "name": "dt",
              "description": "",
              "type": null,
              "value": "dt if dt is not None else self.fmu_wrapper.default_step_size"
            },
            {
              "name": "events",
              "description": "",
              "type": null,
              "value": "[Schedule(t_start=0, t_period=(self.dt), func_act=(self._step_fmu))]"
            }
          ],
          "parameters": [
            {
              "name": "fmu_path",
              "type": null,
              "default": null,
              "description": "path to the FMU file (.fmu)"
            },
            {
              "name": "instance_name",
              "type": null,
              "default": "'fmu_instance'",
              "description": "name for the FMU instance (default: 'fmu_instance')"
            },
            {
              "name": "start_values",
              "type": null,
              "default": "None",
              "description": "dictionary of variable names and their initial values"
            },
            {
              "name": "dt",
              "type": null,
              "default": "None",
              "description": "communication step size for co-simulation. If None, uses the FMU's default experiment step size if available."
            }
          ]
        },
        {
          "name": "ModelExchangeFMU",
          "description": "Model Exchange FMU block using FMPy with support for FMI 2.0 and FMI 3.0.",
          "docstring_html": "<p>Model Exchange FMU block using FMPy with support for FMI 2.0 and FMI 3.0.</p>\n<p>This block wraps an FMU (Functional Mock-up Unit) for model exchange.\nThe FMU provides the right-hand side of an ODE system that is integrated\nby PathSim's numerical solvers. Internal FMU events (state events, time\nevents, and step completion events) are translated to PathSim events.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>fmu_path <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">str</span></dt>\n<dd>path to the FMU file (.fmu)</dd>\n<dt>instance_name <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">str, optional</span></dt>\n<dd>name for the FMU instance (default: 'fmu_instance')</dd>\n<dt>start_values <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">dict, optional</span></dt>\n<dd>dictionary of variable names and their initial values</dd>\n<dt>tolerance <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float, optional</span></dt>\n<dd>tolerance for event detection (default: 1e-10)</dd>\n<dt>verbose <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool, optional</span></dt>\n<dd>enable verbose output (default: False)</dd>\n</dl>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>fmu_wrapper <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">FMUWrapper</span></dt>\n<dd>version-agnostic FMU wrapper instance providing access to model_description,\nfmu, and other FMPy objects for advanced usage</dd>\n<dt>time_event <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">ScheduleList or None</span></dt>\n<dd>dynamic time event for FMU-scheduled events</dd>\n</dl>\n",
          "source": "class ModelExchangeFMU(DynamicalSystem):\n    \"\"\"Model Exchange FMU block using FMPy with support for FMI 2.0 and FMI 3.0.\n\n    This block wraps an FMU (Functional Mock-up Unit) for model exchange.\n    The FMU provides the right-hand side of an ODE system that is integrated\n    by PathSim's numerical solvers. Internal FMU events (state events, time\n    events, and step completion events) are translated to PathSim events.\n\n    Parameters\n    ----------\n    fmu_path : str\n        path to the FMU file (.fmu)\n    instance_name : str, optional\n        name for the FMU instance (default: 'fmu_instance')\n    start_values : dict, optional\n        dictionary of variable names and their initial values\n    tolerance : float, optional\n        tolerance for event detection (default: 1e-10)\n    verbose : bool, optional\n        enable verbose output (default: False)\n\n    Attributes\n    ----------\n    fmu_wrapper : FMUWrapper\n        version-agnostic FMU wrapper instance providing access to model_description,\n        fmu, and other FMPy objects for advanced usage\n    time_event : ScheduleList or None\n        dynamic time event for FMU-scheduled events\n    \"\"\"\n\n    def __init__(self, fmu_path, instance_name=\"fmu_instance\", start_values=None,\n                 tolerance=1e-10, verbose=False):\n\n        self.tolerance = tolerance\n        self.verbose = verbose\n        self.start_values = start_values\n\n        # Create and initialize FMU wrapper\n        self.fmu_wrapper = FMUWrapper(fmu_path, instance_name, mode='model_exchange')\n        event_info = self.fmu_wrapper.initialize(start_values, start_time=0.0, tolerance=tolerance)\n\n        # Store initial time event if defined\n        self._initial_time_event = (\n            event_info.next_event_time\n            if event_info and event_info.next_event_time_defined\n            else None\n        )\n\n        # Enter continuous time mode\n        self.fmu_wrapper.enter_continuous_time_mode()\n\n        # Initialize parent DynamicalSystem with FMU dynamics\n        # Use FMU's Jacobian if available (providesDirectionalDerivative=true)\n        jac_func = self._get_jacobian if self.fmu_wrapper.provides_jacobian else None\n\n        super().__init__(\n            func_dyn=self._get_derivatives,\n            func_alg=self._get_outputs,\n            initial_value=self.fmu_wrapper.get_continuous_states(),\n            jac_dyn=jac_func\n        )\n\n        # Setup block I/O from FMU variables\n        self.inputs, self.outputs = self.fmu_wrapper.create_port_registers()\n\n        # Initialize time event manager\n        self.time_event = None\n\n        # Create state event (zero-crossing) for each event indicator\n        for i in range(self.fmu_wrapper.n_event_indicators):\n            self.events.append(\n                ZeroCrossing(\n                    func_evt=lambda t, idx=i: self._get_event_indicator(idx),\n                    func_act=self._handle_event,\n                    tolerance=self.tolerance\n                    )\n                )\n\n        # Cache capability flag for sample() performance\n        self._needs_completed_integrator_step = self.fmu_wrapper.needs_completed_integrator_step\n\n        # Schedule initial time event if any\n        if self._initial_time_event is not None:\n            self._update_time_events(self._initial_time_event)\n\n\n    def _get_derivatives(self, x, u, t):\n        \"\"\"Evaluate FMU derivatives (RHS of ODE).\"\"\"\n        if self.fmu_wrapper.n_states == 0:\n            return []\n\n        self.fmu_wrapper.set_time(t)\n        self.fmu_wrapper.set_continuous_states(x)\n        self.fmu_wrapper.set_inputs_from_array(u)\n\n        return self.fmu_wrapper.get_derivatives()\n\n\n    def _get_jacobian(self, x, u, t):\n        \"\"\"Evaluate Jacobian of FMU derivatives w.r.t. states (∂ẋ/∂x).\"\"\"\n        self.fmu_wrapper.set_time(t)\n        self.fmu_wrapper.set_continuous_states(x)\n        self.fmu_wrapper.set_inputs_from_array(u)\n\n        return self.fmu_wrapper.get_state_jacobian()\n\n\n    def _get_outputs(self, x, u, t):\n        \"\"\"Evaluate FMU outputs (algebraic part).\"\"\"\n        self.fmu_wrapper.set_time(t)\n        self.fmu_wrapper.set_continuous_states(x)\n        self.fmu_wrapper.set_inputs_from_array(u)\n\n        return self.fmu_wrapper.get_outputs_as_array()\n\n\n    def _get_event_indicator(self, idx):\n        \"\"\"Get value of a specific event indicator.\"\"\"\n        return self.fmu_wrapper.get_event_indicators()[idx]\n\n\n    def _handle_event(self, t):\n        \"\"\"Handle FMU event with fixed-point iteration for discrete states.\"\"\"\n        if self.verbose:\n            print(f\"FMU event detected at t={t}\")\n\n        self.fmu_wrapper.enter_event_mode()\n\n        # Iterate until discrete states stabilize\n        while True:\n            event_info = self.fmu_wrapper.update_discrete_states()\n\n            if event_info.terminate_simulation:\n                raise RuntimeError(\"FMU requested simulation termination\")\n\n            if not event_info.discrete_states_need_update:\n                break\n\n        self.fmu_wrapper.enter_continuous_time_mode()\n\n        # Update continuous states if changed\n        if event_info.values_changed:\n            x_new = self.fmu_wrapper.get_continuous_states()\n            self.engine.set(x_new)\n            if self.verbose:\n                print(f\"Continuous states updated after event: {x_new}\")\n\n        # Schedule new time events\n        if event_info.next_event_time_defined:\n            self._update_time_events(event_info.next_event_time)\n            if self.verbose:\n                print(f\"Next time event scheduled at t={event_info.next_event_time}\")\n\n\n    def _update_time_events(self, next_time):\n        \"\"\"Update or create time event schedule.\"\"\"\n        if self.time_event is None:\n            self.time_event = ScheduleList(\n                times_evt=[next_time],\n                func_act=self._handle_event,\n                tolerance=self.tolerance\n            )\n            self.events.append(self.time_event)\n        elif next_time not in self.time_event.times_evt:\n            bisect.insort(self.time_event.times_evt, next_time)\n\n\n    def sample(self, t, dt):\n        \"\"\"Sample block after successful timestep and handle FMU step completion events.\"\"\"\n        super().sample(t, dt)\n\n        if self._needs_completed_integrator_step:\n            enter_event_mode, terminate_simulation = self.fmu_wrapper.completed_integrator_step()\n\n            if terminate_simulation:\n                raise RuntimeError(\"FMU requested simulation termination\")\n\n            if enter_event_mode:\n                if self.verbose:\n                    print(f\"Step completion event at t={t}\")\n                self._handle_event(t)\n\n\n    def reset(self):\n        \"\"\"Reset the FMU instance.\"\"\"\n        super().reset()\n        self.fmu_wrapper.reset()\n\n        # Re-initialize FMU\n        event_info = self.fmu_wrapper.initialize(\n            self.start_values, start_time=0.0, tolerance=self.tolerance\n        )\n        self.fmu_wrapper.enter_continuous_time_mode()\n\n        # Reset to initial states\n        self.engine.set(self.fmu_wrapper.get_continuous_states())\n\n        # Reset time events\n        if self.time_event is not None:\n            self.time_event.times_evt.clear()\n\n        # Schedule initial time event from re-initialization or cached initial\n        if event_info and event_info.next_event_time_defined:\n            self._update_time_events(event_info.next_event_time)\n        elif self._initial_time_event is not None:\n            self._update_time_events(self._initial_time_event)",
          "bases": [
            "pathsim.blocks.dynsys.DynamicalSystem"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, fmu_path, instance_name=\"fmu_instance\", start_values=None,\n             tolerance=1e-10, verbose=False):\n\n    self.tolerance = tolerance\n    self.verbose = verbose\n    self.start_values = start_values\n\n    # Create and initialize FMU wrapper\n    self.fmu_wrapper = FMUWrapper(fmu_path, instance_name, mode='model_exchange')\n    event_info = self.fmu_wrapper.initialize(start_values, start_time=0.0, tolerance=tolerance)\n\n    # Store initial time event if defined\n    self._initial_time_event = (\n        event_info.next_event_time\n        if event_info and event_info.next_event_time_defined\n        else None\n    )\n\n    # Enter continuous time mode\n    self.fmu_wrapper.enter_continuous_time_mode()\n\n    # Initialize parent DynamicalSystem with FMU dynamics\n    # Use FMU's Jacobian if available (providesDirectionalDerivative=true)\n    jac_func = self._get_jacobian if self.fmu_wrapper.provides_jacobian else None\n\n    super().__init__(\n        func_dyn=self._get_derivatives,\n        func_alg=self._get_outputs,\n        initial_value=self.fmu_wrapper.get_continuous_states(),\n        jac_dyn=jac_func\n    )\n\n    # Setup block I/O from FMU variables\n    self.inputs, self.outputs = self.fmu_wrapper.create_port_registers()\n\n    # Initialize time event manager\n    self.time_event = None\n\n    # Create state event (zero-crossing) for each event indicator\n    for i in range(self.fmu_wrapper.n_event_indicators):\n        self.events.append(\n            ZeroCrossing(\n                func_evt=lambda t, idx=i: self._get_event_indicator(idx),\n                func_act=self._handle_event,\n                tolerance=self.tolerance\n                )\n            )\n\n    # Cache capability flag for sample() performance\n    self._needs_completed_integrator_step = self.fmu_wrapper.needs_completed_integrator_step\n\n    # Schedule initial time event if any\n    if self._initial_time_event is not None:\n        self._update_time_events(self._initial_time_event)",
              "signature": "(fmu_path, instance_name = 'fmu_instance', start_values = None, tolerance = 1e-10, verbose = False)",
              "parameters": [
                {
                  "name": "fmu_path",
                  "type": null,
                  "default": null,
                  "description": ""
                },
                {
                  "name": "instance_name",
                  "type": null,
                  "default": "'fmu_instance'",
                  "description": ""
                },
                {
                  "name": "start_values",
                  "type": null,
                  "default": "None",
                  "description": ""
                },
                {
                  "name": "tolerance",
                  "type": null,
                  "default": "1e-10",
                  "description": ""
                },
                {
                  "name": "verbose",
                  "type": null,
                  "default": "False",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "_get_derivatives",
              "description": "Evaluate FMU derivatives (RHS of ODE).",
              "docstring_html": "<p>Evaluate FMU derivatives (RHS of ODE).</p>\n",
              "source": "def _get_derivatives(self, x, u, t):\n    \"\"\"Evaluate FMU derivatives (RHS of ODE).\"\"\"\n    if self.fmu_wrapper.n_states == 0:\n        return []\n\n    self.fmu_wrapper.set_time(t)\n    self.fmu_wrapper.set_continuous_states(x)\n    self.fmu_wrapper.set_inputs_from_array(u)\n\n    return self.fmu_wrapper.get_derivatives()",
              "signature": "(x, u, t)",
              "parameters": [
                {
                  "name": "x",
                  "type": null,
                  "default": null,
                  "description": ""
                },
                {
                  "name": "u",
                  "type": null,
                  "default": null,
                  "description": ""
                },
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "_get_jacobian",
              "description": "Evaluate Jacobian of FMU derivatives w.r.t. states (∂ẋ/∂x).",
              "docstring_html": "<p>Evaluate Jacobian of FMU derivatives w.r.t. states (∂ẋ/∂x).</p>\n",
              "source": "def _get_jacobian(self, x, u, t):\n    \"\"\"Evaluate Jacobian of FMU derivatives w.r.t. states (∂ẋ/∂x).\"\"\"\n    self.fmu_wrapper.set_time(t)\n    self.fmu_wrapper.set_continuous_states(x)\n    self.fmu_wrapper.set_inputs_from_array(u)\n\n    return self.fmu_wrapper.get_state_jacobian()",
              "signature": "(x, u, t)",
              "parameters": [
                {
                  "name": "x",
                  "type": null,
                  "default": null,
                  "description": ""
                },
                {
                  "name": "u",
                  "type": null,
                  "default": null,
                  "description": ""
                },
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "_get_outputs",
              "description": "Evaluate FMU outputs (algebraic part).",
              "docstring_html": "<p>Evaluate FMU outputs (algebraic part).</p>\n",
              "source": "def _get_outputs(self, x, u, t):\n    \"\"\"Evaluate FMU outputs (algebraic part).\"\"\"\n    self.fmu_wrapper.set_time(t)\n    self.fmu_wrapper.set_continuous_states(x)\n    self.fmu_wrapper.set_inputs_from_array(u)\n\n    return self.fmu_wrapper.get_outputs_as_array()",
              "signature": "(x, u, t)",
              "parameters": [
                {
                  "name": "x",
                  "type": null,
                  "default": null,
                  "description": ""
                },
                {
                  "name": "u",
                  "type": null,
                  "default": null,
                  "description": ""
                },
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "_get_event_indicator",
              "description": "Get value of a specific event indicator.",
              "docstring_html": "<p>Get value of a specific event indicator.</p>\n",
              "source": "def _get_event_indicator(self, idx):\n    \"\"\"Get value of a specific event indicator.\"\"\"\n    return self.fmu_wrapper.get_event_indicators()[idx]",
              "signature": "(idx)",
              "parameters": [
                {
                  "name": "idx",
                  "type": null,
                  "default": null,
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "_handle_event",
              "description": "Handle FMU event with fixed-point iteration for discrete states.",
              "docstring_html": "<p>Handle FMU event with fixed-point iteration for discrete states.</p>\n",
              "source": "def _handle_event(self, t):\n    \"\"\"Handle FMU event with fixed-point iteration for discrete states.\"\"\"\n    if self.verbose:\n        print(f\"FMU event detected at t={t}\")\n\n    self.fmu_wrapper.enter_event_mode()\n\n    # Iterate until discrete states stabilize\n    while True:\n        event_info = self.fmu_wrapper.update_discrete_states()\n\n        if event_info.terminate_simulation:\n            raise RuntimeError(\"FMU requested simulation termination\")\n\n        if not event_info.discrete_states_need_update:\n            break\n\n    self.fmu_wrapper.enter_continuous_time_mode()\n\n    # Update continuous states if changed\n    if event_info.values_changed:\n        x_new = self.fmu_wrapper.get_continuous_states()\n        self.engine.set(x_new)\n        if self.verbose:\n            print(f\"Continuous states updated after event: {x_new}\")\n\n    # Schedule new time events\n    if event_info.next_event_time_defined:\n        self._update_time_events(event_info.next_event_time)\n        if self.verbose:\n            print(f\"Next time event scheduled at t={event_info.next_event_time}\")",
              "signature": "(t)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "_update_time_events",
              "description": "Update or create time event schedule.",
              "docstring_html": "<p>Update or create time event schedule.</p>\n",
              "source": "def _update_time_events(self, next_time):\n    \"\"\"Update or create time event schedule.\"\"\"\n    if self.time_event is None:\n        self.time_event = ScheduleList(\n            times_evt=[next_time],\n            func_act=self._handle_event,\n            tolerance=self.tolerance\n        )\n        self.events.append(self.time_event)\n    elif next_time not in self.time_event.times_evt:\n        bisect.insort(self.time_event.times_evt, next_time)",
              "signature": "(next_time)",
              "parameters": [
                {
                  "name": "next_time",
                  "type": null,
                  "default": null,
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "sample",
              "description": "Sample block after successful timestep and handle FMU step completion events.",
              "docstring_html": "<p>Sample block after successful timestep and handle FMU step completion events.</p>\n",
              "source": "def sample(self, t, dt):\n    \"\"\"Sample block after successful timestep and handle FMU step completion events.\"\"\"\n    super().sample(t, dt)\n\n    if self._needs_completed_integrator_step:\n        enter_event_mode, terminate_simulation = self.fmu_wrapper.completed_integrator_step()\n\n        if terminate_simulation:\n            raise RuntimeError(\"FMU requested simulation termination\")\n\n        if enter_event_mode:\n            if self.verbose:\n                print(f\"Step completion event at t={t}\")\n            self._handle_event(t)",
              "signature": "(t, dt)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": ""
                },
                {
                  "name": "dt",
                  "type": null,
                  "default": null,
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "reset",
              "description": "Reset the FMU instance.",
              "docstring_html": "<p>Reset the FMU instance.</p>\n",
              "source": "def reset(self):\n    \"\"\"Reset the FMU instance.\"\"\"\n    super().reset()\n    self.fmu_wrapper.reset()\n\n    # Re-initialize FMU\n    event_info = self.fmu_wrapper.initialize(\n        self.start_values, start_time=0.0, tolerance=self.tolerance\n    )\n    self.fmu_wrapper.enter_continuous_time_mode()\n\n    # Reset to initial states\n    self.engine.set(self.fmu_wrapper.get_continuous_states())\n\n    # Reset time events\n    if self.time_event is not None:\n        self.time_event.times_evt.clear()\n\n    # Schedule initial time event from re-initialization or cached initial\n    if event_info and event_info.next_event_time_defined:\n        self._update_time_events(event_info.next_event_time)\n    elif self._initial_time_event is not None:\n        self._update_time_events(self._initial_time_event)",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "tolerance",
              "description": "",
              "type": null,
              "value": "tolerance"
            },
            {
              "name": "verbose",
              "description": "",
              "type": null,
              "value": "verbose"
            },
            {
              "name": "start_values",
              "description": "",
              "type": null,
              "value": "start_values"
            },
            {
              "name": "fmu_wrapper",
              "description": "",
              "type": null,
              "value": "FMUWrapper(fmu_path, instance_name, mode='model_exchange')"
            },
            {
              "name": "_initial_time_event",
              "description": "",
              "type": null,
              "value": "event_info.next_event_time if event_info and event_info.next_event_time_defined else None"
            },
            {
              "name": "time_event",
              "description": "",
              "type": null,
              "value": "None"
            },
            {
              "name": "_needs_completed_integrator_step",
              "description": "",
              "type": null,
              "value": "self.fmu_wrapper.needs_completed_integrator_step"
            }
          ],
          "parameters": [
            {
              "name": "fmu_path",
              "type": null,
              "default": null,
              "description": "path to the FMU file (.fmu)"
            },
            {
              "name": "instance_name",
              "type": null,
              "default": "'fmu_instance'",
              "description": "name for the FMU instance (default: 'fmu_instance')"
            },
            {
              "name": "start_values",
              "type": null,
              "default": "None",
              "description": "dictionary of variable names and their initial values"
            },
            {
              "name": "tolerance",
              "type": null,
              "default": "1e-10",
              "description": "tolerance for event detection (default: 1e-10)"
            },
            {
              "name": "verbose",
              "type": null,
              "default": "False",
              "description": "enable verbose output (default: False)"
            }
          ]
        }
      ],
      "functions": []
    },
    "pathsim.blocks.function": {
      "name": "pathsim.blocks.function",
      "description": "",
      "docstring_html": "",
      "classes": [
        {
          "name": "Function",
          "description": "Arbitrary MIMO function block, defined by a function or `lambda` expression.",
          "docstring_html": "<p>Arbitrary MIMO function block, defined by a function or <cite>lambda</cite> expression.</p>\n<p>The function can have multiple arguments that are then provided\nby the input channels of the function block.</p>\n<p>Form multi input, the function has to specify multiple arguments\nand for multi output, the aoutputs have to be provided as a\ntuple or list.</p>\n<p>In the context of the global system, this block implements algebraic\ncomponents of the global system ODE/DAE.</p>\n<pre class=\"math\">\n\\vec{y} = \\mathrm{func}(\\vec{u})\n</pre>\n<div class=\"section\" id=\"note\">\n<h4>Note</h4>\n<p>This block is purely algebraic and its operation (<cite>op_alg</cite>) will be called\nmultiple times per timestep, each time when <cite>Simulation._update(t)</cite> is\ncalled in the global simulation loop.\nTherefore <cite>func</cite> must be purely algebraic and not introduce states,\ndelay, etc. For interfacing with external stateful APIs, use the\n<cite>Wrapper</cite> block.</p>\n</div>\n<div class=\"section\" id=\"note-1\">\n<h4>Note</h4>\n<p>If the outputs are provided as a single numpy array, they are\nconsidered a single output. For MIMO, output has to be tuple.</p>\n</div>\n<div class=\"section\" id=\"example\">\n<h4>Example</h4>\n<p>consider the function:</p>\n<pre class=\"code python literal-block\">\n<span class=\"kn\">from</span><span class=\"w\"> </span><span class=\"nn\">pathsim.blocks</span><span class=\"w\"> </span><span class=\"kn\">import</span> <span class=\"n\">Function</span><span class=\"w\">\n\n</span><span class=\"k\">def</span><span class=\"w\"> </span><span class=\"nf\">f</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">,</span> <span class=\"n\">b</span><span class=\"p\">,</span> <span class=\"n\">c</span><span class=\"p\">):</span><span class=\"w\">\n</span>    <span class=\"k\">return</span> <span class=\"n\">a</span><span class=\"o\">**</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"n\">a</span><span class=\"o\">*</span><span class=\"n\">b</span><span class=\"p\">,</span> <span class=\"n\">b</span><span class=\"o\">/</span><span class=\"n\">c</span><span class=\"w\">\n\n</span><span class=\"n\">fn</span> <span class=\"o\">=</span> <span class=\"n\">Function</span><span class=\"p\">(</span><span class=\"n\">f</span><span class=\"p\">)</span>\n</pre>\n<p>then, when the block is updated, the input channels of the block are\nassigned to the function arguments following this scheme:</p>\n<pre class=\"code literal-block\">\ninputs[0] -&gt; a\ninputs[1] -&gt; b\ninputs[2] -&gt; c\n</pre>\n<p>and the function outputs are assigned to the\noutput channels of the block in the same way:</p>\n<pre class=\"code literal-block\">\na**2 -&gt; outputs[0]\na*b  -&gt; outputs[1]\nb/c  -&gt; outputs[2]\n</pre>\n<p>Because the <cite>Function</cite> block only has a single argument, it can be\nused to decorate a function and make it a <cite>PathSim</cite> block. This might\nbe handy in some cases to keep definitions concise and localized\nin the code:</p>\n<pre class=\"code python literal-block\">\n<span class=\"kn\">from</span><span class=\"w\"> </span><span class=\"nn\">pathsim.blocks</span><span class=\"w\"> </span><span class=\"kn\">import</span> <span class=\"n\">Function</span><span class=\"w\">\n\n</span><span class=\"c1\">#does the same as the definition above</span><span class=\"w\">\n\n</span><span class=\"nd\">&#64;Function</span><span class=\"w\">\n</span><span class=\"k\">def</span><span class=\"w\"> </span><span class=\"nf\">fn</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">,</span> <span class=\"n\">b</span><span class=\"p\">,</span> <span class=\"n\">c</span><span class=\"p\">):</span><span class=\"w\">\n</span>    <span class=\"k\">return</span> <span class=\"n\">a</span><span class=\"o\">**</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"n\">a</span><span class=\"o\">*</span><span class=\"n\">b</span><span class=\"p\">,</span> <span class=\"n\">b</span><span class=\"o\">/</span><span class=\"n\">c</span><span class=\"w\">\n\n</span><span class=\"c1\">#'fn' is now a PathSim block</span>\n</pre>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>func <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">callable</span></dt>\n<dd>MIMO function that defines algebraic block IO behaviour, signature <cite>func(*tuple)</cite></dd>\n</dl>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>op_alg <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">Operator</span></dt>\n<dd>internal algebraic operator that wraps <cite>func</cite></dd>\n</dl>\n</div>\n",
          "source": "class Function(Block):\n    \"\"\"Arbitrary MIMO function block, defined by a function or `lambda` expression.\n\n    The function can have multiple arguments that are then provided \n    by the input channels of the function block.\n\n    Form multi input, the function has to specify multiple arguments\n    and for multi output, the aoutputs have to be provided as a \n    tuple or list. \n\n    In the context of the global system, this block implements algebraic \n    components of the global system ODE/DAE.\n\n    .. math::\n\n        \\\\vec{y} = \\\\mathrm{func}(\\\\vec{u})\n\n\n    Note\n    ----\n    This block is purely algebraic and its operation (`op_alg`) will be called \n    multiple times per timestep, each time when `Simulation._update(t)` is \n    called in the global simulation loop.\n    Therefore `func` must be purely algebraic and not introduce states, \n    delay, etc. For interfacing with external stateful APIs, use the \n    `Wrapper` block.\n\n\n    Note\n    -----\n    If the outputs are provided as a single numpy array, they are \n    considered a single output. For MIMO, output has to be tuple.\n\n\n    Example\n    -------\n    consider the function: \n\n    .. code-block:: python\n\n        from pathsim.blocks import Function\n\n        def f(a, b, c):\n            return a**2, a*b, b/c\n\n        fn = Function(f)\n\n\n    then, when the block is updated, the input channels of the block are \n    assigned to the function arguments following this scheme:\n\n    .. code-block::\n\n        inputs[0] -> a\n        inputs[1] -> b\n        inputs[2] -> c\n\n    and the function outputs are assigned to the \n    output channels of the block in the same way:\n\n    .. code-block::\n\n        a**2 -> outputs[0]\n        a*b  -> outputs[1]\n        b/c  -> outputs[2]\n\n    Because the `Function` block only has a single argument, it can be \n    used to decorate a function and make it a `PathSim` block. This might \n    be handy in some cases to keep definitions concise and localized \n    in the code:\n\n    .. code-block:: python\n\n        from pathsim.blocks import Function\n\n        #does the same as the definition above\n\n        @Function\n        def fn(a, b, c):\n            return a**2, a*b, b/c\n\n        #'fn' is now a PathSim block\n\n\n    Parameters\n    ---------- \n    func : callable\n        MIMO function that defines algebraic block IO behaviour, signature `func(*tuple)`\n\n\n    Attributes\n    ----------\n    op_alg : Operator\n        internal algebraic operator that wraps `func`\n\n    \"\"\"\n\n    def __init__(self, func=lambda x: x):\n        super().__init__()\n\n        #some checks to ensure that function works correctly\n        if not callable(func):  \n            raise ValueError(f\"'{func}' is not callable\")\n\n        #function defining the block update\n        self.func = func\n        self.op_alg = Operator(func=lambda x: func(*x))\n\n\n    def update(self, t):\n        \"\"\"Evaluate function block as part of algebraic component \n        of global system DAE. \n\n        Parameters\n        ----------\n        t : float\n            evaluation time\n        \"\"\"\n\n        #apply operator to get output\n        y = self.op_alg(self.inputs.to_array())\n        self.outputs.update_from_array(y)",
          "bases": [
            "pathsim.blocks._block.Block"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, func=lambda x: x):\n    super().__init__()\n\n    #some checks to ensure that function works correctly\n    if not callable(func):  \n        raise ValueError(f\"'{func}' is not callable\")\n\n    #function defining the block update\n    self.func = func\n    self.op_alg = Operator(func=lambda x: func(*x))",
              "signature": "(func = lambda x: x)",
              "parameters": [
                {
                  "name": "func",
                  "type": null,
                  "default": "lambda x: x",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "update",
              "description": "Evaluate function block as part of algebraic component",
              "docstring_html": "<p>Evaluate function block as part of algebraic component\nof global system DAE.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time</dd>\n</dl>\n",
              "source": "def update(self, t):\n    \"\"\"Evaluate function block as part of algebraic component \n    of global system DAE. \n\n    Parameters\n    ----------\n    t : float\n        evaluation time\n    \"\"\"\n\n    #apply operator to get output\n    y = self.op_alg(self.inputs.to_array())\n    self.outputs.update_from_array(y)",
              "signature": "(t)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time"
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "func",
              "description": "",
              "type": null,
              "value": "func"
            },
            {
              "name": "op_alg",
              "description": "",
              "type": null,
              "value": "Operator(func=(lambda x: func(*x)))"
            }
          ],
          "parameters": [
            {
              "name": "func",
              "type": null,
              "default": "lambda x: x",
              "description": "MIMO function that defines algebraic block IO behaviour, signature `func(*tuple)`"
            }
          ]
        },
        {
          "name": "DynamicalFunction",
          "description": "Arbitrary MIMO time and input dependent function block.",
          "docstring_html": "<p>Arbitrary MIMO time and input dependent function block.</p>\n<p>The function signature needs two arguments <cite>f(u, t)</cite> where <cite>u</cite> is\nthe (possibly vectorial) block input and <cite>t</cite> is a time dependency.</p>\n<pre class=\"math\">\n\\vec{y} = \\mathrm{func}(\\vec{u}, t)\n</pre>\n<div class=\"section\" id=\"note\">\n<h4>Note</h4>\n<p>This block does essentially the same as <cite>Function</cite> but with different\nrequirements for the signature of the function to be wrapped.\nBlock inputs are packed into an array <cite>u</cite> and this block additionally\naccepts time dependency in the function provided.\nThats where the prefix <cite>Dynamical..</cite> comes from.</p>\n</div>\n<div class=\"section\" id=\"example\">\n<h4>Example</h4>\n<p>Lets say we want to implement a super simple model for a voltage controlled\noscillator (VCO), where the block input controls the frequency of a sine wave\nat the output.</p>\n<pre class=\"code python literal-block\">\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"nn\">numpy</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"nn\">np</span><span class=\"w\">\n</span><span class=\"kn\">from</span><span class=\"w\"> </span><span class=\"nn\">pathsim.blocks</span><span class=\"w\"> </span><span class=\"kn\">import</span> <span class=\"n\">DynamicalFunction</span><span class=\"w\">\n\n</span><span class=\"n\">f_0</span> <span class=\"o\">=</span> <span class=\"mi\">100</span><span class=\"w\">\n\n</span><span class=\"k\">def</span><span class=\"w\"> </span><span class=\"nf\">f_vco</span><span class=\"p\">(</span><span class=\"n\">u</span><span class=\"p\">,</span> <span class=\"n\">t</span><span class=\"p\">):</span><span class=\"w\">\n</span>    <span class=\"k\">return</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">sin</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"o\">*</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">pi</span><span class=\"o\">*</span><span class=\"n\">f_0</span><span class=\"o\">*</span><span class=\"n\">u</span><span class=\"o\">*</span><span class=\"n\">t</span><span class=\"p\">)</span><span class=\"w\">\n\n</span><span class=\"n\">vco</span> <span class=\"o\">=</span> <span class=\"n\">DynamicalFunction</span><span class=\"p\">(</span><span class=\"n\">f_vco</span><span class=\"p\">)</span>\n</pre>\n<p>Using it as a decorator also works:</p>\n<pre class=\"code python literal-block\">\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"nn\">numpy</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"nn\">np</span><span class=\"w\">\n</span><span class=\"kn\">from</span><span class=\"w\"> </span><span class=\"nn\">pathsim.blocks</span><span class=\"w\"> </span><span class=\"kn\">import</span> <span class=\"n\">DynamicalFunction</span><span class=\"w\">\n\n</span><span class=\"n\">f_0</span> <span class=\"o\">=</span> <span class=\"mi\">100</span><span class=\"w\">\n\n</span><span class=\"nd\">&#64;DynamicalFunction</span><span class=\"w\">\n</span><span class=\"k\">def</span><span class=\"w\"> </span><span class=\"nf\">vco</span><span class=\"p\">(</span><span class=\"n\">u</span><span class=\"p\">,</span> <span class=\"n\">t</span><span class=\"p\">):</span><span class=\"w\">\n</span>    <span class=\"k\">return</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">sin</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"o\">*</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">pi</span><span class=\"o\">*</span><span class=\"n\">f_0</span><span class=\"o\">*</span><span class=\"n\">u</span><span class=\"o\">*</span><span class=\"n\">t</span><span class=\"p\">)</span><span class=\"w\">\n\n</span><span class=\"c1\">#'vco' is now a PathSim block</span>\n</pre>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>func <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">callable</span></dt>\n<dd>function that defines algebraic block IO behaviour with time dependency,\nsignature <cite>func(u, t)</cite> where <cite>u</cite> is <cite>numpy.ndarray</cite> and <cite>t</cite> is <cite>float</cite></dd>\n</dl>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>op_alg <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">DynamicOperator</span></dt>\n<dd>internal operator that wraps <cite>func</cite></dd>\n</dl>\n</div>\n",
          "source": "class DynamicalFunction(Block):\n    \"\"\"Arbitrary MIMO time and input dependent function block.\n\n    The function signature needs two arguments `f(u, t)` where `u` is \n    the (possibly vectorial) block input and `t` is a time dependency.\n\n    .. math::\n\n        \\\\vec{y} = \\\\mathrm{func}(\\\\vec{u}, t)\n\n\n    Note\n    ----\n    This block does essentially the same as `Function` but with different \n    requirements for the signature of the function to be wrapped. \n    Block inputs are packed into an array `u` and this block additionally \n    accepts time dependency in the function provided. \n    Thats where the prefix `Dynamical..` comes from.\n\n\n    Example\n    -------\n    Lets say we want to implement a super simple model for a voltage controlled \n    oscillator (VCO), where the block input controls the frequency of a sine wave \n    at the output. \n\n    .. code-block:: python\n\n        import numpy as np\n        from pathsim.blocks import DynamicalFunction\n\n        f_0 = 100\n\n        def f_vco(u, t):\n            return np.sin(2*np.pi*f_0*u*t)\n\n        vco = DynamicalFunction(f_vco)        \n\n\n    Using it as a decorator also works:\n\n    .. code-block:: python\n\n        import numpy as np\n        from pathsim.blocks import DynamicalFunction\n\n        f_0 = 100\n\n        @DynamicalFunction\n        def vco(u, t):\n            return np.sin(2*np.pi*f_0*u*t)\n\n        #'vco' is now a PathSim block \n\n\n    Parameters\n    ----------\n    func : callable\n        function that defines algebraic block IO behaviour with time dependency, \n        signature `func(u, t)` where `u` is `numpy.ndarray` and `t` is `float`\n\n\n    Attributes\n    ----------\n    op_alg : DynamicOperator\n        internal operator that wraps `func`\n\n    \"\"\"\n\n    def __init__(self, func=lambda u, t: u):\n        super().__init__()\n\n        #some checks to ensure that function works correctly\n        if not callable(func):  \n            raise ValueError(f\"'{func}' is not callable\")\n\n        #function defining the block update\n        self.func = func\n        self.op_alg = DynamicOperator(lambda x, u, t: func(u, t))\n\n\n    def update(self, t):\n        \"\"\"Evaluate function with time dependency as part of algebraic \n        component of global system DAE. \n\n        Parameters\n        ----------\n        t : float\n            evaluation time\n        \"\"\"\n\n        #apply operator to get output\n        y = self.op_alg(None, self.inputs.to_array(), t)\n        self.outputs.update_from_array(y)",
          "bases": [
            "pathsim.blocks._block.Block"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, func=lambda u, t: u):\n    super().__init__()\n\n    #some checks to ensure that function works correctly\n    if not callable(func):  \n        raise ValueError(f\"'{func}' is not callable\")\n\n    #function defining the block update\n    self.func = func\n    self.op_alg = DynamicOperator(lambda x, u, t: func(u, t))",
              "signature": "(func = lambda u, t: u)",
              "parameters": [
                {
                  "name": "func",
                  "type": null,
                  "default": "lambda u, t: u",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "update",
              "description": "Evaluate function with time dependency as part of algebraic",
              "docstring_html": "<p>Evaluate function with time dependency as part of algebraic\ncomponent of global system DAE.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time</dd>\n</dl>\n",
              "source": "def update(self, t):\n    \"\"\"Evaluate function with time dependency as part of algebraic \n    component of global system DAE. \n\n    Parameters\n    ----------\n    t : float\n        evaluation time\n    \"\"\"\n\n    #apply operator to get output\n    y = self.op_alg(None, self.inputs.to_array(), t)\n    self.outputs.update_from_array(y)",
              "signature": "(t)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time"
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "func",
              "description": "",
              "type": null,
              "value": "func"
            },
            {
              "name": "op_alg",
              "description": "",
              "type": null,
              "value": "DynamicOperator(lambda x, u, t: func(u, t))"
            }
          ],
          "parameters": [
            {
              "name": "func",
              "type": null,
              "default": "lambda u, t: u",
              "description": "function that defines algebraic block IO behaviour with time dependency, signature `func(u, t)` where `u` is `numpy.ndarray` and `t` is `float`"
            }
          ]
        }
      ],
      "functions": []
    },
    "pathsim.blocks.integrator": {
      "name": "pathsim.blocks.integrator",
      "description": "",
      "docstring_html": "",
      "classes": [
        {
          "name": "Integrator",
          "description": "Integrates the input signal.",
          "docstring_html": "<p>Integrates the input signal.</p>\n<p>Uses a numerical integration engine like this:</p>\n<pre class=\"math\">\ny(t) = \\int_0^t u(\\tau) \\ d \\tau\n</pre>\n<p>or in differential form like this:</p>\n<pre class=\"math\">\n\\begin{align}\n    \\dot{x}(t) &amp;= u(t) \\\\\n           y(t) &amp;= x(t)\n\\end{align}\n</pre>\n<p>The Integrator block is inherently MIMO capable, so <cite>u</cite>\nand <cite>y</cite> can be vectors.</p>\n<div class=\"section\" id=\"example\">\n<h4>Example</h4>\n<p>This is how to initialize the integrator:</p>\n<pre class=\"code python literal-block\">\n<span class=\"c1\">#initial value 0.0</span><span class=\"w\">\n</span><span class=\"n\">i1</span> <span class=\"o\">=</span> <span class=\"n\">Integrator</span><span class=\"p\">()</span><span class=\"w\">\n\n</span><span class=\"c1\">#initial value 2.5</span><span class=\"w\">\n</span><span class=\"n\">i2</span> <span class=\"o\">=</span> <span class=\"n\">Integrator</span><span class=\"p\">(</span><span class=\"mf\">2.5</span><span class=\"p\">)</span>\n</pre>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>initial_value <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float, array</span></dt>\n<dd>initial value of integrator</dd>\n</dl>\n</div>\n",
          "source": "class Integrator(Block):\n    \"\"\"Integrates the input signal.\n\n    Uses a numerical integration engine like this:\n\n    .. math::\n\n        y(t) = \\\\int_0^t u(\\\\tau) \\\\ d \\\\tau\n\n    or in differential form like this:\n\n    .. math::\n        \\\\begin{align}\n            \\\\dot{x}(t) &= u(t) \\\\\\\\\n                   y(t) &= x(t)\n        \\\\end{align}\n\n    The Integrator block is inherently MIMO capable, so `u` \n    and `y` can be vectors.\n\n    Example\n    -------\n    This is how to initialize the integrator: \n\n    .. code-block:: python\n\n        #initial value 0.0\n        i1 = Integrator()\n\n        #initial value 2.5\n        i2 = Integrator(2.5)\n\n\n    Parameters\n    ----------\n    initial_value : float, array\n        initial value of integrator\n    \"\"\"\n\n    def __init__(self, initial_value=0.0):\n        super().__init__()\n\n        #save initial value\n        self.initial_value = initial_value\n\n\n    def __len__(self):\n        return 0\n\n\n    def update(self, t):\n        \"\"\"update system equation fixed point loop\n\n        Note\n        ----\n        integrator does not have passthrough, therefore this \n        method is performance optimized for this case\n\n        Parameters\n        ----------\n        t : float\n            evaluation time\n        \"\"\"\n        self.outputs.update_from_array(self.engine.state)\n\n\n    def solve(self, t, dt):\n        \"\"\"advance solution of implicit update equation of the solver\n\n        Parameters\n        ----------\n        t : float\n            evaluation time\n        dt : float\n            integration timestep\n\n        Returns\n        ------- \n        error : float\n            solver residual norm\n        \"\"\"\n        f = self.inputs.to_array()\n        return self.engine.solve(f, None, dt)\n\n\n    def step(self, t, dt):\n        \"\"\"compute timestep update with integration engine\n\n        Parameters\n        ----------\n        t : float\n            evaluation time\n        dt : float\n            integration timestep\n\n        Returns\n        ------- \n        success : bool\n            step was successful\n        error : float\n            local truncation error from adaptive integrators\n        scale : float\n            timestep rescale from adaptive integrators\n        \"\"\"\n        f = self.inputs.to_array()\n        return self.engine.step(f, dt)",
          "bases": [
            "pathsim.blocks._block.Block"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, initial_value=0.0):\n    super().__init__()\n\n    #save initial value\n    self.initial_value = initial_value",
              "signature": "(initial_value = 0.0)",
              "parameters": [
                {
                  "name": "initial_value",
                  "type": null,
                  "default": "0.0",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "update",
              "description": "update system equation fixed point loop",
              "docstring_html": "<p>update system equation fixed point loop</p>\n<div class=\"section\" id=\"note\">\n<h4>Note</h4>\n<p>integrator does not have passthrough, therefore this\nmethod is performance optimized for this case</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time</dd>\n</dl>\n</div>\n",
              "source": "def update(self, t):\n    \"\"\"update system equation fixed point loop\n\n    Note\n    ----\n    integrator does not have passthrough, therefore this \n    method is performance optimized for this case\n\n    Parameters\n    ----------\n    t : float\n        evaluation time\n    \"\"\"\n    self.outputs.update_from_array(self.engine.state)",
              "signature": "(t)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "solve",
              "description": "advance solution of implicit update equation of the solver",
              "docstring_html": "<p>advance solution of implicit update equation of the solver</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time</dd>\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>integration timestep</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>error <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>solver residual norm</dd>\n</dl>\n",
              "source": "def solve(self, t, dt):\n    \"\"\"advance solution of implicit update equation of the solver\n\n    Parameters\n    ----------\n    t : float\n        evaluation time\n    dt : float\n        integration timestep\n\n    Returns\n    ------- \n    error : float\n        solver residual norm\n    \"\"\"\n    f = self.inputs.to_array()\n    return self.engine.solve(f, None, dt)",
              "signature": "(t, dt)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time"
                },
                {
                  "name": "dt",
                  "type": null,
                  "default": null,
                  "description": "integration timestep"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "step",
              "description": "compute timestep update with integration engine",
              "docstring_html": "<p>compute timestep update with integration engine</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time</dd>\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>integration timestep</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>success <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>step was successful</dd>\n<dt>error <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>local truncation error from adaptive integrators</dd>\n<dt>scale <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>timestep rescale from adaptive integrators</dd>\n</dl>\n",
              "source": "def step(self, t, dt):\n    \"\"\"compute timestep update with integration engine\n\n    Parameters\n    ----------\n    t : float\n        evaluation time\n    dt : float\n        integration timestep\n\n    Returns\n    ------- \n    success : bool\n        step was successful\n    error : float\n        local truncation error from adaptive integrators\n    scale : float\n        timestep rescale from adaptive integrators\n    \"\"\"\n    f = self.inputs.to_array()\n    return self.engine.step(f, dt)",
              "signature": "(t, dt)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time"
                },
                {
                  "name": "dt",
                  "type": null,
                  "default": null,
                  "description": "integration timestep"
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "initial_value",
              "description": "",
              "type": null,
              "value": "initial_value"
            }
          ],
          "parameters": [
            {
              "name": "initial_value",
              "type": null,
              "default": "0.0",
              "description": "initial value of integrator"
            }
          ]
        }
      ],
      "functions": []
    },
    "pathsim.blocks.kalman": {
      "name": "pathsim.blocks.kalman",
      "description": "",
      "docstring_html": "",
      "classes": [
        {
          "name": "KalmanFilter",
          "description": "Discrete-time Kalman filter for state estimation.",
          "docstring_html": "<p>Discrete-time Kalman filter for state estimation.</p>\n<p>Implements the standard Kalman filter algorithm to estimate the state of a\nlinear dynamic system from noisy measurements. The filter recursively updates\nstate estimates by combining predictions from a system model with incoming\nmeasurements, weighted by their respective uncertainties.</p>\n<p>The filter processes measurements at each time step through a two-stage process:\nprediction (using the system model) and update (incorporating measurements).</p>\n<p>The system model is:</p>\n<pre class=\"math\">\nx_{k+1} = F x_k + B u_k + w_k\n</pre>\n<pre class=\"math\">\nz_k = H x_k + v_k\n</pre>\n<p>where <tt class=\"math\">w_k \\sim \\mathcal{N}(0, Q)</tt> is process noise and\n<tt class=\"math\">v_k \\sim \\mathcal{N}(0, R)</tt> is measurement noise.</p>\n<p>At each time step, the filter performs:</p>\n<p><strong>Prediction:</strong></p>\n<pre class=\"math\">\n\\hat{x}_{k|k-1} = F \\hat{x}_{k-1} + B u_k\n</pre>\n<pre class=\"math\">\nP_{k|k-1} = F P_{k-1} F^T + Q\n</pre>\n<p><strong>Update:</strong></p>\n<pre class=\"math\">\ny_k = z_k - H \\hat{x}_{k|k-1}\n</pre>\n<pre class=\"math\">\nS_k = H P_{k|k-1} H^T + R\n</pre>\n<pre class=\"math\">\nK_k = P_{k|k-1} H^T S_k^{-1}\n</pre>\n<pre class=\"math\">\n\\hat{x}_k = \\hat{x}_{k|k-1} + K_k y_k\n</pre>\n<pre class=\"math\">\nP_k = (I - K_k H) P_{k|k-1}\n</pre>\n<div class=\"section\" id=\"note\">\n<h4>Note</h4>\n<p>The block expects inputs in the following order:</p>\n<ul class=\"simple\">\n<li>First m inputs: measurements <tt class=\"math\">z</tt></li>\n<li>Next p inputs (if B is provided): control inputs <tt class=\"math\">u</tt></li>\n</ul>\n<p>The block outputs the n-dimensional state estimate <tt class=\"math\">\\hat{x}</tt>.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>F <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">ndarray</span></dt>\n<dd>State transition matrix (n x n). Describes how the state evolves from one\ntime step to the next.</dd>\n<dt>H <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">ndarray</span></dt>\n<dd>Measurement matrix (m x n). Maps the state space to the measurement space.</dd>\n<dt>Q <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">ndarray</span></dt>\n<dd>Process noise covariance matrix (n x n). Represents uncertainty in the\nsystem model.</dd>\n<dt>R <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">ndarray</span></dt>\n<dd>Measurement noise covariance matrix (m x m). Represents uncertainty in\nthe measurements.</dd>\n<dt>B <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">ndarray, optional</span></dt>\n<dd>Control input matrix (n x p). Maps control inputs to state changes.\nDefault is None (no control input).</dd>\n<dt>x0 <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">ndarray, optional</span></dt>\n<dd>Initial state estimate (n,). Default is zero vector.</dd>\n<dt>P0 <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">ndarray, optional</span></dt>\n<dd>Initial error covariance matrix (n x n). Default is identity matrix.</dd>\n</dl>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>x <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">ndarray</span></dt>\n<dd>Current state estimate <tt class=\"math\">\\hat{x}_k</tt></dd>\n<dt>P <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">ndarray</span></dt>\n<dd>Current error covariance matrix <tt class=\"math\">P_k</tt></dd>\n<dt>n <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>State dimension</dd>\n<dt>m <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>Measurement dimension</dd>\n<dt>p <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>Control input dimension</dd>\n</dl>\n</div>\n",
          "source": "class KalmanFilter(Block):\n    \"\"\"Discrete-time Kalman filter for state estimation.\n\n    Implements the standard Kalman filter algorithm to estimate the state of a \n    linear dynamic system from noisy measurements. The filter recursively updates \n    state estimates by combining predictions from a system model with incoming \n    measurements, weighted by their respective uncertainties.\n\n    The filter processes measurements at each time step through a two-stage process:\n    prediction (using the system model) and update (incorporating measurements).\n\n    The system model is:\n\n    .. math::\n        x_{k+1} = F x_k + B u_k + w_k\n\n        z_k = H x_k + v_k\n\n    where :math:`w_k \\\\sim \\\\mathcal{N}(0, Q)` is process noise and \n    :math:`v_k \\\\sim \\\\mathcal{N}(0, R)` is measurement noise.\n\n    At each time step, the filter performs:\n\n    **Prediction:**\n\n    .. math::\n        \\\\hat{x}_{k|k-1} = F \\\\hat{x}_{k-1} + B u_k\n\n        P_{k|k-1} = F P_{k-1} F^T + Q\n\n    **Update:**\n\n    .. math::\n        y_k = z_k - H \\\\hat{x}_{k|k-1}\n\n        S_k = H P_{k|k-1} H^T + R\n\n        K_k = P_{k|k-1} H^T S_k^{-1}\n\n        \\\\hat{x}_k = \\\\hat{x}_{k|k-1} + K_k y_k\n\n        P_k = (I - K_k H) P_{k|k-1}\n\n    Note\n    ----\n    The block expects inputs in the following order:\n\n    - First m inputs: measurements :math:`z`\n    - Next p inputs (if B is provided): control inputs :math:`u`\n\n    The block outputs the n-dimensional state estimate :math:`\\\\hat{x}`.\n\n    Parameters\n    ----------\n    F : ndarray\n        State transition matrix (n x n). Describes how the state evolves from one\n        time step to the next.\n    H : ndarray\n        Measurement matrix (m x n). Maps the state space to the measurement space.\n    Q : ndarray\n        Process noise covariance matrix (n x n). Represents uncertainty in the\n        system model.\n    R : ndarray\n        Measurement noise covariance matrix (m x m). Represents uncertainty in\n        the measurements.\n    B : ndarray, optional\n        Control input matrix (n x p). Maps control inputs to state changes.\n        Default is None (no control input).\n    x0 : ndarray, optional\n        Initial state estimate (n,). Default is zero vector.\n    P0 : ndarray, optional\n        Initial error covariance matrix (n x n). Default is identity matrix.\n\n    Attributes\n    ----------\n    x : ndarray\n        Current state estimate :math:`\\\\hat{x}_k`\n    P : ndarray\n        Current error covariance matrix :math:`P_k`\n    n : int\n        State dimension\n    m : int\n        Measurement dimension\n    p : int\n        Control input dimension \n    \"\"\"\n\n    def __init__(self, F, H, Q, R, B=None, x0=None, P0=None, dt=None):\n        super().__init__()\n\n        self.F = F\n        self.H = H\n        self.Q = Q\n        self.R = R\n        self.B = B\n\n        # Sampling\n        self.dt = dt \n\n        # Dimensions\n        self.n, _ = F.shape  # state dimension\n        self.m, _ = H.shape  # measurement dimension\n        _, self.p = (0, 0) if B is None else B.shape # control dimension\n\n        # Initial states\n        self.x = np.zeros(self.n) if x0 is None else x0\n        self.P = np.eye(self.n) if P0 is None else P0\n\n        # Initialize io\n        self.inputs = Register(size=self.m+self.p)\n        self.outputs = Register(size=self.n)\n\n        # Scheduled event if 'dt' is provided\n        if self.dt is not None:\n            self.events = [\n                Schedule(\n                    t_period=self.dt,\n                    func_act=lambda _: self._kf_update()\n                    )\n                ]\n\n\n    def __len__(self):\n        #no passthrough by definition\n        return 0\n\n\n    def _kf_update(self):\n        \"\"\"Perform one Kalman filter update step.\"\"\"\n\n        # Unpack inputs\n        zu = self.inputs.to_array()\n        z, u = np.split(zu, [self.m])\n\n        # Prediction\n        x_pred = self.F @ self.x + (self.B @ u if self.B is not None else 0.0)\n        P_pred = self.F @ self.P @ self.F.T + self.Q\n\n        # Innovation\n        y = z - self.H @ x_pred\n        S = self.H @ P_pred @ self.H.T + self.R   \n\n        # Kalman gain\n        K = np.linalg.solve(S.T, (P_pred @ self.H.T).T).T\n\n        # Update state\n        self.x = x_pred + K @ y        \n        self.P = (np.eye(self.n) - K @ self.H) @ P_pred \n\n        # Update outputs\n        self.outputs.update_from_array(self.x)\n\n\n    def sample(self, t, dt):\n        \"\"\"Sample after successful timestep.\n\n        Updates the internal state estimate using the current measurements and\n        control inputs, then outputs the updated state estimate.\n\n        Parameters\n        ----------\n        t : float\n            evaluation time for sampling\n        dt : float\n            integration timestep\n        \"\"\"\n        if self.dt is None:\n            self._kf_update()",
          "bases": [
            "pathsim.blocks._block.Block"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, F, H, Q, R, B=None, x0=None, P0=None, dt=None):\n    super().__init__()\n\n    self.F = F\n    self.H = H\n    self.Q = Q\n    self.R = R\n    self.B = B\n\n    # Sampling\n    self.dt = dt \n\n    # Dimensions\n    self.n, _ = F.shape  # state dimension\n    self.m, _ = H.shape  # measurement dimension\n    _, self.p = (0, 0) if B is None else B.shape # control dimension\n\n    # Initial states\n    self.x = np.zeros(self.n) if x0 is None else x0\n    self.P = np.eye(self.n) if P0 is None else P0\n\n    # Initialize io\n    self.inputs = Register(size=self.m+self.p)\n    self.outputs = Register(size=self.n)\n\n    # Scheduled event if 'dt' is provided\n    if self.dt is not None:\n        self.events = [\n            Schedule(\n                t_period=self.dt,\n                func_act=lambda _: self._kf_update()\n                )\n            ]",
              "signature": "(F, H, Q, R, B = None, x0 = None, P0 = None, dt = None)",
              "parameters": [
                {
                  "name": "F",
                  "type": null,
                  "default": null,
                  "description": ""
                },
                {
                  "name": "H",
                  "type": null,
                  "default": null,
                  "description": ""
                },
                {
                  "name": "Q",
                  "type": null,
                  "default": null,
                  "description": ""
                },
                {
                  "name": "R",
                  "type": null,
                  "default": null,
                  "description": ""
                },
                {
                  "name": "B",
                  "type": null,
                  "default": "None",
                  "description": ""
                },
                {
                  "name": "x0",
                  "type": null,
                  "default": "None",
                  "description": ""
                },
                {
                  "name": "P0",
                  "type": null,
                  "default": "None",
                  "description": ""
                },
                {
                  "name": "dt",
                  "type": null,
                  "default": "None",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "_kf_update",
              "description": "Perform one Kalman filter update step.",
              "docstring_html": "<p>Perform one Kalman filter update step.</p>\n",
              "source": "def _kf_update(self):\n    \"\"\"Perform one Kalman filter update step.\"\"\"\n\n    # Unpack inputs\n    zu = self.inputs.to_array()\n    z, u = np.split(zu, [self.m])\n\n    # Prediction\n    x_pred = self.F @ self.x + (self.B @ u if self.B is not None else 0.0)\n    P_pred = self.F @ self.P @ self.F.T + self.Q\n\n    # Innovation\n    y = z - self.H @ x_pred\n    S = self.H @ P_pred @ self.H.T + self.R   \n\n    # Kalman gain\n    K = np.linalg.solve(S.T, (P_pred @ self.H.T).T).T\n\n    # Update state\n    self.x = x_pred + K @ y        \n    self.P = (np.eye(self.n) - K @ self.H) @ P_pred \n\n    # Update outputs\n    self.outputs.update_from_array(self.x)",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "sample",
              "description": "Sample after successful timestep.",
              "docstring_html": "<p>Sample after successful timestep.</p>\n<p>Updates the internal state estimate using the current measurements and\ncontrol inputs, then outputs the updated state estimate.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time for sampling</dd>\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>integration timestep</dd>\n</dl>\n",
              "source": "def sample(self, t, dt):\n    \"\"\"Sample after successful timestep.\n\n    Updates the internal state estimate using the current measurements and\n    control inputs, then outputs the updated state estimate.\n\n    Parameters\n    ----------\n    t : float\n        evaluation time for sampling\n    dt : float\n        integration timestep\n    \"\"\"\n    if self.dt is None:\n        self._kf_update()",
              "signature": "(t, dt)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time for sampling"
                },
                {
                  "name": "dt",
                  "type": null,
                  "default": null,
                  "description": "integration timestep"
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "F",
              "description": "",
              "type": null,
              "value": "F"
            },
            {
              "name": "H",
              "description": "",
              "type": null,
              "value": "H"
            },
            {
              "name": "Q",
              "description": "",
              "type": null,
              "value": "Q"
            },
            {
              "name": "R",
              "description": "",
              "type": null,
              "value": "R"
            },
            {
              "name": "B",
              "description": "",
              "type": null,
              "value": "B"
            },
            {
              "name": "dt",
              "description": "",
              "type": null,
              "value": "dt"
            },
            {
              "name": "x",
              "description": "",
              "type": null,
              "value": "np.zeros(self.n) if x0 is None else x0"
            },
            {
              "name": "P",
              "description": "",
              "type": null,
              "value": "np.eye(self.n) if P0 is None else P0"
            },
            {
              "name": "inputs",
              "description": "",
              "type": null,
              "value": "Register(size=(self.m + self.p))"
            },
            {
              "name": "outputs",
              "description": "",
              "type": null,
              "value": "Register(size=(self.n))"
            },
            {
              "name": "events",
              "description": "",
              "type": null,
              "value": "[Schedule(t_period=(self.dt), func_act=(lambda _: self._kf_update()))]"
            }
          ],
          "parameters": [
            {
              "name": "F",
              "type": null,
              "default": null,
              "description": "State transition matrix (n x n). Describes how the state evolves from one time step to the next."
            },
            {
              "name": "H",
              "type": null,
              "default": null,
              "description": "Measurement matrix (m x n). Maps the state space to the measurement space."
            },
            {
              "name": "Q",
              "type": null,
              "default": null,
              "description": "Process noise covariance matrix (n x n). Represents uncertainty in the system model."
            },
            {
              "name": "R",
              "type": null,
              "default": null,
              "description": "Measurement noise covariance matrix (m x m). Represents uncertainty in the measurements."
            },
            {
              "name": "B",
              "type": null,
              "default": "None",
              "description": "Control input matrix (n x p). Maps control inputs to state changes. Default is None (no control input)."
            },
            {
              "name": "x0",
              "type": null,
              "default": "None",
              "description": "Initial state estimate (n,). Default is zero vector."
            },
            {
              "name": "P0",
              "type": null,
              "default": "None",
              "description": "Initial error covariance matrix (n x n). Default is identity matrix."
            },
            {
              "name": "dt",
              "type": null,
              "default": "None",
              "description": ""
            }
          ]
        }
      ],
      "functions": []
    },
    "pathsim.blocks.lti": {
      "name": "pathsim.blocks.lti",
      "description": "",
      "docstring_html": "",
      "classes": [
        {
          "name": "StateSpace",
          "description": "Linear time invariant (LTI) multi input multi output (MIMO) state space model.",
          "docstring_html": "<p>Linear time invariant (LTI) multi input multi output (MIMO) state space model.</p>\n<pre class=\"math\">\n\\begin{align}\n    \\dot{x} &amp;= \\mathbf{A} x + \\mathbf{B} u \\\\\n           y &amp;= \\mathbf{C} x + \\mathbf{D} u\n\\end{align}\n</pre>\n<p>where <cite>A</cite>, <cite>B</cite>, <cite>C</cite> and <cite>D</cite> are the state space matrices, <cite>x</cite> is the state,\n<cite>u</cite> the input and <cite>y</cite> the output vector.</p>\n<div class=\"section\" id=\"example\">\n<h4>Example</h4>\n<p>A SISO state space block with two internal states can be initialized\nlike this:</p>\n<pre class=\"code python literal-block\">\n<span class=\"n\">S</span> <span class=\"o\">=</span> <span class=\"n\">StateSpace</span><span class=\"p\">(</span><span class=\"w\">\n</span>    <span class=\"n\">A</span><span class=\"o\">=-</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">eye</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">),</span><span class=\"w\">\n</span>    <span class=\"n\">B</span><span class=\"o\">=</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">ones</span><span class=\"p\">((</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">)),</span><span class=\"w\">\n</span>    <span class=\"n\">C</span><span class=\"o\">=</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">ones</span><span class=\"p\">((</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">)),</span><span class=\"w\">\n</span>    <span class=\"n\">D</span><span class=\"o\">=</span><span class=\"mf\">1.0</span><span class=\"w\">\n</span>    <span class=\"p\">)</span>\n</pre>\n<p>and a MIMO (2 in, 2 out) state space block with three internal states\ncan be initialized like this:</p>\n<pre class=\"code python literal-block\">\n<span class=\"n\">S</span> <span class=\"o\">=</span> <span class=\"n\">StateSpace</span><span class=\"p\">(</span><span class=\"w\">\n</span>    <span class=\"n\">A</span><span class=\"o\">=-</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">eye</span><span class=\"p\">(</span><span class=\"mi\">3</span><span class=\"p\">),</span><span class=\"w\">\n</span>    <span class=\"n\">B</span><span class=\"o\">=</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">ones</span><span class=\"p\">((</span><span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">)),</span><span class=\"w\">\n</span>    <span class=\"n\">C</span><span class=\"o\">=</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">ones</span><span class=\"p\">((</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">)),</span><span class=\"w\">\n</span>    <span class=\"n\">D</span><span class=\"o\">=</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">ones</span><span class=\"p\">((</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">))</span><span class=\"w\">\n</span>    <span class=\"p\">)</span>\n</pre>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>A, B, C, D <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array_like</span></dt>\n<dd>real valued state space matrices</dd>\n<dt>initial_value <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array_like, None</span></dt>\n<dd>initial state / initial condition</dd>\n</dl>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>op_dyn <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">DynamicOperator</span></dt>\n<dd>internal dynamic operator for state equation</dd>\n<dt>op_alg <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">DynamicOperator</span></dt>\n<dd>internal algebraic operator for mapping to outputs</dd>\n</dl>\n</div>\n",
          "source": "class StateSpace(Block):\n    \"\"\"Linear time invariant (LTI) multi input multi output (MIMO) state space model.\n\n    .. math::\n\n        \\\\begin{align}\n            \\\\dot{x} &= \\\\mathbf{A} x + \\\\mathbf{B} u \\\\\\\\\n                   y &= \\\\mathbf{C} x + \\\\mathbf{D} u\n        \\\\end{align}\n\n    where `A`, `B`, `C` and `D` are the state space matrices, `x` is the state, \n    `u` the input and `y` the output vector.\n\n    Example\n    -------\n    A SISO state space block with two internal states can be initialized \n    like this:\n\n    .. code-block:: python\n\n        S = StateSpace(\n            A=-np.eye(2), \n            B=np.ones((2, 1)), \n            C=np.ones((1, 2)), \n            D=1.0\n            )\n\n    and a MIMO (2 in, 2 out) state space block with three internal states \n    can be initialized like this:\n\n    .. code-block:: python\n\n        S = StateSpace(\n            A=-np.eye(3), \n            B=np.ones((3, 2)), \n            C=np.ones((2, 3)), \n            D=np.ones((2, 2))\n            )\n\n    Parameters\n    ----------\n    A, B, C, D : array_like\n        real valued state space matrices\n    initial_value : array_like, None\n        initial state / initial condition\n\n    Attributes\n    ----------\n    op_dyn : DynamicOperator\n        internal dynamic operator for state equation\n    op_alg : DynamicOperator\n        internal algebraic operator for mapping to outputs\n    \"\"\"\n\n    def __init__(self, \n                 A=-1.0, B=1.0, C=-1.0, D=1.0, \n                 initial_value=None):\n        super().__init__()\n\n        #statespace matrices with input shape validation\n        self.A = np.atleast_2d(A)\n        self.B = np.atleast_1d(B)\n        self.C = np.atleast_1d(C)\n        self.D = np.atleast_1d(D)\n\n        #get statespace dimensions\n        n, _ = self.A.shape \n        if self.B.ndim == 1: n_in = 1 \n        else: _, n_in = self.B.shape \n        if self.C.ndim == 1: n_out = 1 \n        else: n_out, _ = self.C.shape\n\n        #set io channels\n        self.inputs = Register(n_in)\n        self.outputs = Register(n_out)\n\n        #initial condition and shape validation\n        if initial_value is None:\n            self.initial_value = np.zeros(n)\n        else: \n            self.initial_value = np.atleast_1d(initial_value)\n\n        #operators\n        self.op_dyn = DynamicOperator(\n            func=lambda x, u, t: np.dot(self.A, x) + np.dot(self.B, u),\n            jac_x=lambda x, u, t: self.A,\n            jac_u=lambda x, u, t: self.B\n            )\n        self.op_alg = DynamicOperator(\n            func=lambda x, u, t: np.dot(self.C, x) + np.dot(self.D, u),\n            jac_x=lambda x, u, t: self.C,\n            jac_u=lambda x, u, t: self.D\n            )\n\n\n    def __len__(self):\n        #check if direct passthrough exists\n        return int(np.any(self.D)) if self._active else 0\n\n    def solve(self, t, dt):\n        \"\"\"advance solution of implicit update equation of the solver\n\n        Parameters\n        ----------\n        t : float\n            evaluation time\n        dt : float\n            integration timestep\n\n        Returns\n        ------- \n        error : float\n            solver residual norm\n        \"\"\"\n        x, u = self.engine.state, self.inputs.to_array()\n        f, J = self.op_dyn(x, u, t), self.op_dyn.jac_x(x, u, t)\n        return self.engine.solve(f, J, dt)\n\n\n    def step(self, t, dt):\n        \"\"\"compute timestep update with integration engine\n\n        Parameters\n        ----------\n        t : float\n            evaluation time\n        dt : float\n            integration timestep\n\n        Returns\n        ------- \n        success : bool\n            step was successful\n        error : float\n            local truncation error from adaptive integrators\n        scale : float\n            timestep rescale from adaptive integrators\n        \"\"\"\n        x, u = self.engine.state, self.inputs.to_array()\n        f = self.op_dyn(x, u, t)\n        return self.engine.step(f, dt)",
          "bases": [
            "pathsim.blocks._block.Block"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, \n             A=-1.0, B=1.0, C=-1.0, D=1.0, \n             initial_value=None):\n    super().__init__()\n\n    #statespace matrices with input shape validation\n    self.A = np.atleast_2d(A)\n    self.B = np.atleast_1d(B)\n    self.C = np.atleast_1d(C)\n    self.D = np.atleast_1d(D)\n\n    #get statespace dimensions\n    n, _ = self.A.shape \n    if self.B.ndim == 1: n_in = 1 \n    else: _, n_in = self.B.shape \n    if self.C.ndim == 1: n_out = 1 \n    else: n_out, _ = self.C.shape\n\n    #set io channels\n    self.inputs = Register(n_in)\n    self.outputs = Register(n_out)\n\n    #initial condition and shape validation\n    if initial_value is None:\n        self.initial_value = np.zeros(n)\n    else: \n        self.initial_value = np.atleast_1d(initial_value)\n\n    #operators\n    self.op_dyn = DynamicOperator(\n        func=lambda x, u, t: np.dot(self.A, x) + np.dot(self.B, u),\n        jac_x=lambda x, u, t: self.A,\n        jac_u=lambda x, u, t: self.B\n        )\n    self.op_alg = DynamicOperator(\n        func=lambda x, u, t: np.dot(self.C, x) + np.dot(self.D, u),\n        jac_x=lambda x, u, t: self.C,\n        jac_u=lambda x, u, t: self.D\n        )",
              "signature": "(A = -1.0, B = 1.0, C = -1.0, D = 1.0, initial_value = None)",
              "parameters": [
                {
                  "name": "A",
                  "type": null,
                  "default": "-1.0",
                  "description": ""
                },
                {
                  "name": "B",
                  "type": null,
                  "default": "1.0",
                  "description": ""
                },
                {
                  "name": "C",
                  "type": null,
                  "default": "-1.0",
                  "description": ""
                },
                {
                  "name": "D",
                  "type": null,
                  "default": "1.0",
                  "description": ""
                },
                {
                  "name": "initial_value",
                  "type": null,
                  "default": "None",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "solve",
              "description": "advance solution of implicit update equation of the solver",
              "docstring_html": "<p>advance solution of implicit update equation of the solver</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time</dd>\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>integration timestep</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>error <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>solver residual norm</dd>\n</dl>\n",
              "source": "def solve(self, t, dt):\n    \"\"\"advance solution of implicit update equation of the solver\n\n    Parameters\n    ----------\n    t : float\n        evaluation time\n    dt : float\n        integration timestep\n\n    Returns\n    ------- \n    error : float\n        solver residual norm\n    \"\"\"\n    x, u = self.engine.state, self.inputs.to_array()\n    f, J = self.op_dyn(x, u, t), self.op_dyn.jac_x(x, u, t)\n    return self.engine.solve(f, J, dt)",
              "signature": "(t, dt)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time"
                },
                {
                  "name": "dt",
                  "type": null,
                  "default": null,
                  "description": "integration timestep"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "step",
              "description": "compute timestep update with integration engine",
              "docstring_html": "<p>compute timestep update with integration engine</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time</dd>\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>integration timestep</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>success <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>step was successful</dd>\n<dt>error <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>local truncation error from adaptive integrators</dd>\n<dt>scale <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>timestep rescale from adaptive integrators</dd>\n</dl>\n",
              "source": "def step(self, t, dt):\n    \"\"\"compute timestep update with integration engine\n\n    Parameters\n    ----------\n    t : float\n        evaluation time\n    dt : float\n        integration timestep\n\n    Returns\n    ------- \n    success : bool\n        step was successful\n    error : float\n        local truncation error from adaptive integrators\n    scale : float\n        timestep rescale from adaptive integrators\n    \"\"\"\n    x, u = self.engine.state, self.inputs.to_array()\n    f = self.op_dyn(x, u, t)\n    return self.engine.step(f, dt)",
              "signature": "(t, dt)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time"
                },
                {
                  "name": "dt",
                  "type": null,
                  "default": null,
                  "description": "integration timestep"
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "A",
              "description": "",
              "type": null,
              "value": "np.atleast_2d(A)"
            },
            {
              "name": "B",
              "description": "",
              "type": null,
              "value": "np.atleast_1d(B)"
            },
            {
              "name": "C",
              "description": "",
              "type": null,
              "value": "np.atleast_1d(C)"
            },
            {
              "name": "D",
              "description": "",
              "type": null,
              "value": "np.atleast_1d(D)"
            },
            {
              "name": "inputs",
              "description": "",
              "type": null,
              "value": "Register(n_in)"
            },
            {
              "name": "outputs",
              "description": "",
              "type": null,
              "value": "Register(n_out)"
            },
            {
              "name": "initial_value",
              "description": "",
              "type": null,
              "value": "np.zeros(n)"
            },
            {
              "name": "op_dyn",
              "description": "",
              "type": null,
              "value": "DynamicOperator(func=(lambda x, u, t: np.dot(self.A, x) + np.dot(self.B, u)), jac_x=(lambda x, u, t: self.A), jac_u=(lambda x, u, t: self.B))"
            },
            {
              "name": "op_alg",
              "description": "",
              "type": null,
              "value": "DynamicOperator(func=(lambda x, u, t: np.dot(self.C, x) + np.dot(self.D, u)), jac_x=(lambda x, u, t: self.C), jac_u=(lambda x, u, t: self.D))"
            }
          ],
          "parameters": [
            {
              "name": "A",
              "type": null,
              "default": "-1.0",
              "description": ""
            },
            {
              "name": "B",
              "type": null,
              "default": "1.0",
              "description": ""
            },
            {
              "name": "C",
              "type": null,
              "default": "-1.0",
              "description": ""
            },
            {
              "name": "D",
              "type": null,
              "default": "1.0",
              "description": "real valued state space matrices"
            },
            {
              "name": "initial_value",
              "type": null,
              "default": "None",
              "description": "initial state / initial condition"
            }
          ]
        },
        {
          "name": "TransferFunctionPRC",
          "description": "This block defines a LTI (MIMO for pole residue) transfer function.",
          "docstring_html": "<p>This block defines a LTI (MIMO for pole residue) transfer function.</p>\n<p>The transfer function is defined in pole-residue-constant (PRC) form</p>\n<pre class=\"math\">\n\\mathbf{H}(s) = \\mathbf{C} + \\sum_n^N \\frac{\\mathbf{R}_n}{s - p_n}\n</pre>\n<p>where 'Poles' are the scalar (possibly complex conjugate) poles of the\ntransfer function and 'Residues' are the possibly matrix valued (in MIMO case)\nand complex conjugate residues of the transfer function. 'Const' has same\nshape as 'Residues'.</p>\n<p>Upon initialization, the state space realization of the transfer\nfunction is computed using a minimal gilbert realization.</p>\n<p>The resulting state space model of the form</p>\n<pre class=\"math\">\n\\begin{align}\n    \\dot{x} &amp;= \\mathbf{A} x + \\mathbf{B} u \\\\\n           y &amp;= \\mathbf{C} x + \\mathbf{D} u\n\\end{align}\n</pre>\n<p>is handled the same as the 'StateSpace' block, where <cite>A</cite>, <cite>B</cite>, <cite>C</cite> and <cite>D</cite>\nare the state space matrices, <cite>x</cite> is the internal state, <cite>u</cite> the input and\n<cite>y</cite> the output vector.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>Poles <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array</span></dt>\n<dd>transfer function poles</dd>\n<dt>Residues <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array</span></dt>\n<dd>transfer function residues</dd>\n<dt>Const <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array, float</span></dt>\n<dd>constant term of transfer function</dd>\n</dl>\n",
          "source": "class TransferFunctionPRC(StateSpace):\n    \"\"\"This block defines a LTI (MIMO for pole residue) transfer function.\n\n    The transfer function is defined in pole-residue-constant (PRC) form\n\n    .. math::\n\n        \\\\mathbf{H}(s) = \\\\mathbf{C} + \\\\sum_n^N \\\\frac{\\\\mathbf{R}_n}{s - p_n}\n\n    where 'Poles' are the scalar (possibly complex conjugate) poles of the \n    transfer function and 'Residues' are the possibly matrix valued (in MIMO case) \n    and complex conjugate residues of the transfer function. 'Const' has same \n    shape as 'Residues'.\n\n    Upon initialization, the state space realization of the transfer \n    function is computed using a minimal gilbert realization.\n\n    The resulting state space model of the form\n\n    .. math::\n\n        \\\\begin{align}\n            \\\\dot{x} &= \\\\mathbf{A} x + \\\\mathbf{B} u \\\\\\\\\n                   y &= \\\\mathbf{C} x + \\\\mathbf{D} u\n        \\\\end{align}\n\n    is handled the same as the 'StateSpace' block, where `A`, `B`, `C` and `D` \n    are the state space matrices, `x` is the internal state, `u` the input and \n    `y` the output vector.\n\n    Parameters\n    ----------\n    Poles : array\n        transfer function poles\n    Residues : array\n        transfer function residues\n    Const : array, float\n        constant term of transfer function\n    \"\"\"\n\n    def __init__(self, Poles=[], Residues=[], Const=0.0):\n\n        #parameters of transfer function in pole-residue-const form\n        self.Const, self.Poles, self.Residues = Const, Poles, Residues\n\n        #Statespace realization of transfer function\n        A, B, C, D = gilbert_realization(Poles, Residues, Const)\n\n        #initialize statespace model\n        super().__init__(A, B, C, D)",
          "bases": [
            "pathsim.blocks.lti.StateSpace"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, Poles=[], Residues=[], Const=0.0):\n\n    #parameters of transfer function in pole-residue-const form\n    self.Const, self.Poles, self.Residues = Const, Poles, Residues\n\n    #Statespace realization of transfer function\n    A, B, C, D = gilbert_realization(Poles, Residues, Const)\n\n    #initialize statespace model\n    super().__init__(A, B, C, D)",
              "signature": "(Poles = [], Residues = [], Const = 0.0)",
              "parameters": [
                {
                  "name": "Poles",
                  "type": null,
                  "default": "[]",
                  "description": ""
                },
                {
                  "name": "Residues",
                  "type": null,
                  "default": "[]",
                  "description": ""
                },
                {
                  "name": "Const",
                  "type": null,
                  "default": "0.0",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [],
          "parameters": [
            {
              "name": "Poles",
              "type": null,
              "default": "[]",
              "description": "transfer function poles"
            },
            {
              "name": "Residues",
              "type": null,
              "default": "[]",
              "description": "transfer function residues"
            },
            {
              "name": "Const",
              "type": null,
              "default": "0.0",
              "description": "constant term of transfer function"
            }
          ]
        },
        {
          "name": "TransferFunction",
          "description": "Alias for TransferFunctionPRC.",
          "docstring_html": "<p>Alias for TransferFunctionPRC.</p>\n",
          "source": "@deprecated(version=\"1.0.0\", replacement=\"TransferFunctionPRC\")\nclass TransferFunction(TransferFunctionPRC):\n    \"\"\"Alias for TransferFunctionPRC.\"\"\"\n    pass",
          "bases": [
            "pathsim.blocks.lti.TransferFunctionPRC"
          ],
          "methods": [],
          "attributes": [],
          "parameters": []
        },
        {
          "name": "TransferFunctionZPG",
          "description": "This block defines a LTI (SISO) transfer function.",
          "docstring_html": "<p>This block defines a LTI (SISO) transfer function.</p>\n<p>The transfer function is defined in zeros-poles-gain (ZPG) form</p>\n<pre class=\"math\">\n\\mathbf{H}(s) = k \\frac{(s - z_1)(s - z_2)\\cdots(s - z_m)}{(s - p_1)(s - p_2)\\cdots(s - p_n)}\n</pre>\n<p>where <cite>Zeros</cite> are the scalar (possibly complex conjugate) zeros of the\ntransfer function, and <cite>Poles</cite> are the poles (denominator zeros) of the\ntransfer function. <cite>Gain</cite> is the scalar factor <cite>k</cite>.</p>\n<p>Upon initialization, the state space realization of the transfer function is\ncomputed using <cite>scipy.signal.ZerosPolesGain(Zeros, Poles, Gain).to_ss()</cite>.</p>\n<p>The resulting state space model of the form</p>\n<pre class=\"math\">\n\\begin{align}\n    \\dot{x} &amp;= \\mathbf{A} x + \\mathbf{B} u \\\\\n           y &amp;= \\mathbf{C} x + \\mathbf{D} u\n\\end{align}\n</pre>\n<p>is handled the same as the 'StateSpace' block, where <cite>A</cite>, <cite>B</cite>, <cite>C</cite> and <cite>D</cite>\nare the state space matrices, <cite>x</cite> is the internal state, <cite>u</cite> the input and\n<cite>y</cite> the output vector.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>Poles <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array_like</span></dt>\n<dd>transfer function poles</dd>\n<dt>Zeros <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array_like</span></dt>\n<dd>transfer function zeros</dd>\n<dt>Gain <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>gain term of transfer function</dd>\n</dl>\n",
          "source": "class TransferFunctionZPG(StateSpace):\n    \"\"\"This block defines a LTI (SISO) transfer function.\n\n    The transfer function is defined in zeros-poles-gain (ZPG) form\n\n    .. math::\n\n        \\\\mathbf{H}(s) = k \\\\frac{(s - z_1)(s - z_2)\\\\cdots(s - z_m)}{(s - p_1)(s - p_2)\\\\cdots(s - p_n)}\n\n    where `Zeros` are the scalar (possibly complex conjugate) zeros of the \n    transfer function, and `Poles` are the poles (denominator zeros) of the \n    transfer function. `Gain` is the scalar factor `k`.\n\n    Upon initialization, the state space realization of the transfer function is \n    computed using `scipy.signal.ZerosPolesGain(Zeros, Poles, Gain).to_ss()`.\n\n    The resulting state space model of the form\n\n    .. math::\n\n        \\\\begin{align}\n            \\\\dot{x} &= \\\\mathbf{A} x + \\\\mathbf{B} u \\\\\\\\\n                   y &= \\\\mathbf{C} x + \\\\mathbf{D} u\n        \\\\end{align}\n\n    is handled the same as the 'StateSpace' block, where `A`, `B`, `C` and `D` \n    are the state space matrices, `x` is the internal state, `u` the input and \n    `y` the output vector.\n\n    Parameters\n    ----------\n    Poles : array_like\n        transfer function poles\n    Zeros : array_like\n        transfer function zeros\n    Gain : float\n        gain term of transfer function \n    \"\"\"\n\n    input_port_labels = {\"in\": 0}\n    output_port_labels = {\"out\":0}\n\n    def __init__(self, Zeros=[], Poles=[-1], Gain=1.0):\n\n        #parameters of transfer function in zeros-poles-gain form\n        self.Zeros, self.Poles, self.Gain = Zeros, Poles, Gain\n\n        #build scipy object -> convert to statespace\n        sp_SS = ZerosPolesGain(Zeros, Poles, Gain).to_ss()\n\n        #initialize statespace model\n        super().__init__(sp_SS.A, sp_SS.B, sp_SS.C, sp_SS.D)",
          "bases": [
            "pathsim.blocks.lti.StateSpace"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, Zeros=[], Poles=[-1], Gain=1.0):\n\n    #parameters of transfer function in zeros-poles-gain form\n    self.Zeros, self.Poles, self.Gain = Zeros, Poles, Gain\n\n    #build scipy object -> convert to statespace\n    sp_SS = ZerosPolesGain(Zeros, Poles, Gain).to_ss()\n\n    #initialize statespace model\n    super().__init__(sp_SS.A, sp_SS.B, sp_SS.C, sp_SS.D)",
              "signature": "(Zeros = [], Poles = [-1], Gain = 1.0)",
              "parameters": [
                {
                  "name": "Zeros",
                  "type": null,
                  "default": "[]",
                  "description": ""
                },
                {
                  "name": "Poles",
                  "type": null,
                  "default": "[-1]",
                  "description": ""
                },
                {
                  "name": "Gain",
                  "type": null,
                  "default": "1.0",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "input_port_labels",
              "description": "",
              "type": null,
              "value": "{'in': 0}"
            },
            {
              "name": "output_port_labels",
              "description": "",
              "type": null,
              "value": "{'out': 0}"
            }
          ],
          "parameters": [
            {
              "name": "Zeros",
              "type": null,
              "default": "[]",
              "description": "transfer function zeros"
            },
            {
              "name": "Poles",
              "type": null,
              "default": "[-1]",
              "description": "transfer function poles"
            },
            {
              "name": "Gain",
              "type": null,
              "default": "1.0",
              "description": "gain term of transfer function"
            }
          ]
        },
        {
          "name": "TransferFunctionNumDen",
          "description": "This block defines a LTI (SISO) transfer function.",
          "docstring_html": "<p>This block defines a LTI (SISO) transfer function.</p>\n<p>The transfer function is defined in polynomial (numerator-denominator) form</p>\n<pre class=\"math\">\n\\mathbf{H}(s) = \\frac{b_n + b_{n-1} s + \\dots + b_{0} s^n}{a_m + a_{m-1} s + \\dots + a_{0} s^m}\n</pre>\n<p>where <cite>Num</cite> is the list of numerator polynomial coefficients and <cite>Den</cite> the\nlist of denominator coefficients.</p>\n<p>Upon initialization, the state space realization of the transfer function is\ncomputed using <cite>scipy.signal.TransferFunction(Num, Den).to_ss()</cite>.</p>\n<p>The resulting state space model of the form</p>\n<pre class=\"math\">\n\\begin{align}\n    \\dot{x} &amp;= \\mathbf{A} x + \\mathbf{B} u \\\\\n           y &amp;= \\mathbf{C} x + \\mathbf{D} u\n\\end{align}\n</pre>\n<p>is handled the same as the 'StateSpace' block, where <cite>A</cite>, <cite>B</cite>, <cite>C</cite> and <cite>D</cite>\nare the state space matrices, <cite>x</cite> is the internal state, <cite>u</cite> the input and\n<cite>y</cite> the output vector.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>Num <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array_like</span></dt>\n<dd>numerator polynomial coefficients</dd>\n<dt>Den <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array_like</span></dt>\n<dd>denominator polynomial coefficients</dd>\n</dl>\n",
          "source": "class TransferFunctionNumDen(StateSpace):\n    \"\"\"This block defines a LTI (SISO) transfer function.\n\n    The transfer function is defined in polynomial (numerator-denominator) form\n\n    .. math::\n\n        \\\\mathbf{H}(s) = \\\\frac{b_n + b_{n-1} s + \\\\dots + b_{0} s^n}{a_m + a_{m-1} s + \\\\dots + a_{0} s^m}\n\n    where `Num` is the list of numerator polynomial coefficients and `Den` the \n    list of denominator coefficients.\n\n    Upon initialization, the state space realization of the transfer function is \n    computed using `scipy.signal.TransferFunction(Num, Den).to_ss()`.\n\n    The resulting state space model of the form\n\n    .. math::\n\n        \\\\begin{align}\n            \\\\dot{x} &= \\\\mathbf{A} x + \\\\mathbf{B} u \\\\\\\\\n                   y &= \\\\mathbf{C} x + \\\\mathbf{D} u\n        \\\\end{align}\n\n    is handled the same as the 'StateSpace' block, where `A`, `B`, `C` and `D` \n    are the state space matrices, `x` is the internal state, `u` the input and \n    `y` the output vector.\n\n    Parameters\n    ----------\n    Num : array_like\n        numerator polynomial coefficients\n    Den : array_like\n        denominator polynomial coefficients\n    \"\"\"\n\n    input_port_labels = {\"in\": 0}\n    output_port_labels = {\"out\":0}\n\n    def __init__(self, Num=[1], Den=[1, 1]):\n\n        #parameters of transfer function in numerator-denominator\n        self.Num, self.Den = Num, Den\n\n        #build scipy object -> convert to statespace\n        sp_SS = _TransferFunction(Num, Den).to_ss()\n\n        #initialize statespace model\n        super().__init__(sp_SS.A, sp_SS.B, sp_SS.C, sp_SS.D)",
          "bases": [
            "pathsim.blocks.lti.StateSpace"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, Num=[1], Den=[1, 1]):\n\n    #parameters of transfer function in numerator-denominator\n    self.Num, self.Den = Num, Den\n\n    #build scipy object -> convert to statespace\n    sp_SS = _TransferFunction(Num, Den).to_ss()\n\n    #initialize statespace model\n    super().__init__(sp_SS.A, sp_SS.B, sp_SS.C, sp_SS.D)",
              "signature": "(Num = [1], Den = [1, 1])",
              "parameters": [
                {
                  "name": "Num",
                  "type": null,
                  "default": "[1]",
                  "description": ""
                },
                {
                  "name": "Den",
                  "type": null,
                  "default": "[1, 1]",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "input_port_labels",
              "description": "",
              "type": null,
              "value": "{'in': 0}"
            },
            {
              "name": "output_port_labels",
              "description": "",
              "type": null,
              "value": "{'out': 0}"
            }
          ],
          "parameters": [
            {
              "name": "Num",
              "type": null,
              "default": "[1]",
              "description": "numerator polynomial coefficients"
            },
            {
              "name": "Den",
              "type": null,
              "default": "[1, 1]",
              "description": "denominator polynomial coefficients"
            }
          ]
        }
      ],
      "functions": []
    },
    "pathsim.blocks.math": {
      "name": "pathsim.blocks.math",
      "description": "",
      "docstring_html": "",
      "classes": [
        {
          "name": "Math",
          "description": "Base math block.",
          "docstring_html": "<p>Base math block.</p>\n<div class=\"section\" id=\"note\">\n<h4>Note</h4>\n<p>This block doesnt implement any functionality itself.\nIts intended to be used as a base for the elementary math blocks.\nIts <strong>not</strong> intended to be used directly!</p>\n</div>\n",
          "source": "class Math(Block):\n    \"\"\"Base math block.\n\n    Note\n    ----\n    This block doesnt implement any functionality itself. \n    Its intended to be used as a base for the elementary math blocks. \n    Its **not** intended to be used directly!\n\n    \"\"\"\n\n    def __len__(self):\n        \"\"\"Purely algebraic block\"\"\"\n        return 1\n\n\n    def update(self, t):\n        \"\"\"update algebraic component of system equation \n\n        Parameters\n        ----------\n        t : float\n            evaluation time\n        \"\"\"\n        u = self.inputs.to_array()\n        y = self.op_alg(u)\n        self.outputs.update_from_array(y)",
          "bases": [
            "pathsim.blocks._block.Block"
          ],
          "methods": [
            {
              "name": "update",
              "description": "update algebraic component of system equation",
              "docstring_html": "<p>update algebraic component of system equation</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time</dd>\n</dl>\n",
              "source": "def update(self, t):\n    \"\"\"update algebraic component of system equation \n\n    Parameters\n    ----------\n    t : float\n        evaluation time\n    \"\"\"\n    u = self.inputs.to_array()\n    y = self.op_alg(u)\n    self.outputs.update_from_array(y)",
              "signature": "(t)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time"
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [],
          "parameters": []
        },
        {
          "name": "Sin",
          "description": "Sine operator block.",
          "docstring_html": "<p>Sine operator block.</p>\n<p>This block supports vector inputs. This is the operation it does:</p>\n<pre class=\"math\">\n\\vec{y} = \\sin(\\vec{u})\n</pre>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>op_alg <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">Operator</span></dt>\n<dd>internal algebraic operator</dd>\n</dl>\n",
          "source": "class Sin(Math):\n    \"\"\"Sine operator block.\n\n    This block supports vector inputs. This is the operation it does:\n\n    .. math::\n\n        \\\\vec{y} = \\\\sin(\\\\vec{u}) \n\n\n    Attributes\n    ----------\n    op_alg : Operator\n        internal algebraic operator\n    \"\"\"\n\n    def __init__(self):\n        super().__init__()\n\n        #create internal algebraic operator\n        self.op_alg = Operator(\n            func=np.sin, \n            jac=lambda x: np.diag(np.cos(x))\n            )",
          "bases": [
            "pathsim.blocks.math.Math"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self):\n    super().__init__()\n\n    #create internal algebraic operator\n    self.op_alg = Operator(\n        func=np.sin, \n        jac=lambda x: np.diag(np.cos(x))\n        )",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "op_alg",
              "description": "",
              "type": null,
              "value": "Operator(func=(np.sin), jac=(lambda x: np.diag(np.cos(x))))"
            }
          ],
          "parameters": []
        },
        {
          "name": "Cos",
          "description": "Cosine operator block.",
          "docstring_html": "<p>Cosine operator block.</p>\n<p>This block supports vector inputs. This is the operation it does:</p>\n<pre class=\"math\">\n\\vec{y} = \\cos(\\vec{u})\n</pre>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>op_alg <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">Operator</span></dt>\n<dd>internal algebraic operator</dd>\n</dl>\n",
          "source": "class Cos(Math):\n    \"\"\"Cosine operator block.\n\n    This block supports vector inputs. This is the operation it does:\n\n    .. math::\n\n        \\\\vec{y} = \\\\cos(\\\\vec{u}) \n\n    Attributes\n    ----------\n    op_alg : Operator\n        internal algebraic operator\n    \"\"\"\n\n    def __init__(self):\n        super().__init__()\n\n        #create internal algebraic operator\n        self.op_alg = Operator(\n            func=np.cos, \n            jac=lambda x: -np.diag(np.sin(x))\n            )",
          "bases": [
            "pathsim.blocks.math.Math"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self):\n    super().__init__()\n\n    #create internal algebraic operator\n    self.op_alg = Operator(\n        func=np.cos, \n        jac=lambda x: -np.diag(np.sin(x))\n        )",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "op_alg",
              "description": "",
              "type": null,
              "value": "Operator(func=(np.cos), jac=(lambda x: -np.diag(np.sin(x))))"
            }
          ],
          "parameters": []
        },
        {
          "name": "Sqrt",
          "description": "Square root operator block.",
          "docstring_html": "<p>Square root operator block.</p>\n<p>This block supports vector inputs. This is the operation it does:</p>\n<pre class=\"math\">\n\\vec{y} = \\sqrt{|\\vec{u}|}\n</pre>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>op_alg <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">Operator</span></dt>\n<dd>internal algebraic operator</dd>\n</dl>\n",
          "source": "class Sqrt(Math):\n    \"\"\"Square root operator block.\n\n    This block supports vector inputs. This is the operation it does:\n\n    .. math::\n\n        \\\\vec{y} = \\\\sqrt{|\\\\vec{u}|} \n\n    Attributes\n    ----------\n    op_alg : Operator\n        internal algebraic operator\n    \"\"\"\n\n    def __init__(self):\n        super().__init__()\n\n        #create internal algebraic operator\n        self.op_alg = Operator(\n            func=lambda x: np.sqrt(abs(x)), \n            jac=lambda x: np.diag(1/np.sqrt(abs(x)))\n            )",
          "bases": [
            "pathsim.blocks.math.Math"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self):\n    super().__init__()\n\n    #create internal algebraic operator\n    self.op_alg = Operator(\n        func=lambda x: np.sqrt(abs(x)), \n        jac=lambda x: np.diag(1/np.sqrt(abs(x)))\n        )",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "op_alg",
              "description": "",
              "type": null,
              "value": "Operator(func=(lambda x: np.sqrt(abs(x))), jac=(lambda x: np.diag(1 / np.sqrt(abs(x)))))"
            }
          ],
          "parameters": []
        },
        {
          "name": "Abs",
          "description": "Absolute value operator block.",
          "docstring_html": "<p>Absolute value operator block.</p>\n<p>This block supports vector inputs. This is the operation it does:</p>\n<pre class=\"math\">\n\\vec{y} = \\vert| \\vec{u} \\vert|\n</pre>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>op_alg <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">Operator</span></dt>\n<dd>internal algebraic operator</dd>\n</dl>\n",
          "source": "class Abs(Math):\n    \"\"\"Absolute value operator block.\n\n    This block supports vector inputs. This is the operation it does:\n\n    .. math::\n\n        \\\\vec{y} = \\\\vert| \\\\vec{u} \\\\vert| \n\n    Attributes\n    ----------\n    op_alg : Operator\n        internal algebraic operator\n    \"\"\"\n\n    def __init__(self):\n        super().__init__()\n\n        #create internal algebraic operator\n        self.op_alg = Operator(\n            func=lambda x: abs(x), \n            jac=lambda x: np.diag(np.sign(x))\n            )",
          "bases": [
            "pathsim.blocks.math.Math"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self):\n    super().__init__()\n\n    #create internal algebraic operator\n    self.op_alg = Operator(\n        func=lambda x: abs(x), \n        jac=lambda x: np.diag(np.sign(x))\n        )",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "op_alg",
              "description": "",
              "type": null,
              "value": "Operator(func=(lambda x: abs(x)), jac=(lambda x: np.diag(np.sign(x))))"
            }
          ],
          "parameters": []
        },
        {
          "name": "Pow",
          "description": "Raise to power operator block.",
          "docstring_html": "<p>Raise to power operator block.</p>\n<p>This block supports vector inputs. This is the operation it does:</p>\n<pre class=\"math\">\n\\vec{y} = \\vec{u}^{p}\n</pre>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>exponent <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float, array_like</span></dt>\n<dd>exponent to raise the input to the power of</dd>\n</dl>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>op_alg <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">Operator</span></dt>\n<dd>internal algebraic operator</dd>\n</dl>\n",
          "source": "class Pow(Math):\n    \"\"\"Raise to power operator block.\n\n    This block supports vector inputs. This is the operation it does:\n\n    .. math::\n\n        \\\\vec{y} = \\\\vec{u}^{p} \n\n    Parameters\n    ----------\n    exponent : float, array_like\n        exponent to raise the input to the power of\n\n    Attributes\n    ----------\n    op_alg : Operator\n        internal algebraic operator\n    \"\"\"\n\n    def __init__(self, exponent=2):\n        super().__init__()\n\n        self.exponent = exponent\n\n        #create internal algebraic operator\n        self.op_alg = Operator(\n            func=lambda x: np.power(x, self.exponent), \n            jac=lambda x: np.diag(self.exponent * np.power(x, self.exponent - 1))\n            )",
          "bases": [
            "pathsim.blocks.math.Math"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, exponent=2):\n    super().__init__()\n\n    self.exponent = exponent\n\n    #create internal algebraic operator\n    self.op_alg = Operator(\n        func=lambda x: np.power(x, self.exponent), \n        jac=lambda x: np.diag(self.exponent * np.power(x, self.exponent - 1))\n        )",
              "signature": "(exponent = 2)",
              "parameters": [
                {
                  "name": "exponent",
                  "type": null,
                  "default": "2",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "exponent",
              "description": "",
              "type": null,
              "value": "exponent"
            },
            {
              "name": "op_alg",
              "description": "",
              "type": null,
              "value": "Operator(func=(lambda x: np.power(x, self.exponent)), jac=(lambda x: np.diag(self.exponent * np.power(x, self.exponent - 1))))"
            }
          ],
          "parameters": [
            {
              "name": "exponent",
              "type": null,
              "default": "2",
              "description": "exponent to raise the input to the power of Attributes ----------"
            }
          ]
        },
        {
          "name": "PowProd",
          "description": "Power-Product operator block.",
          "docstring_html": "<p>Power-Product operator block.</p>\n<p>This block raises each input to a power and then multiplies all results together:</p>\n<pre class=\"math\">\ny = \\prod_i u_i^{p_i}\n</pre>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>exponents <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float, array_like</span></dt>\n<dd>exponent(s) to raise the inputs to the power of. If scalar,\napplies same exponent to all inputs.</dd>\n</dl>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>op_alg <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">Operator</span></dt>\n<dd>internal algebraic operator</dd>\n</dl>\n",
          "source": "class PowProd(Math):\n    \"\"\"Power-Product operator block.\n\n    This block raises each input to a power and then multiplies all results together:\n\n    .. math::\n\n        y = \\\\prod_i u_i^{p_i}\n\n    Parameters\n    ----------\n    exponents : float, array_like\n        exponent(s) to raise the inputs to the power of. If scalar, \n        applies same exponent to all inputs.\n\n    Attributes\n    ----------\n    op_alg : Operator\n        internal algebraic operator\n    \"\"\"\n\n    def __init__(self, exponents=2):\n        super().__init__()\n\n        self.exponents = exponents    \n\n        def _jac(x):\n            if np.isscalar(self.exponents):\n                exps = np.full_like(x, self.exponents)\n            else:\n                exps = np.array(self.exponents)\n\n            product = np.prod(np.power(x, exps))\n\n            # Jacobian is a row vector since output is scalar\n            jac = np.zeros((1, len(x)))\n            for j in range(len(x)):\n                if x[j] != 0:\n                    jac[0, j] = product * exps[j] / x[j]\n                else:\n                    jac[0, j] = 0\n\n            return jac\n\n        #create internal algebraic operator\n        self.op_alg = Operator(\n            func=lambda x: np.prod(np.power(x, self.exponents)), \n            jac=_jac\n            )",
          "bases": [
            "pathsim.blocks.math.Math"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, exponents=2):\n    super().__init__()\n\n    self.exponents = exponents    \n\n    def _jac(x):\n        if np.isscalar(self.exponents):\n            exps = np.full_like(x, self.exponents)\n        else:\n            exps = np.array(self.exponents)\n\n        product = np.prod(np.power(x, exps))\n\n        # Jacobian is a row vector since output is scalar\n        jac = np.zeros((1, len(x)))\n        for j in range(len(x)):\n            if x[j] != 0:\n                jac[0, j] = product * exps[j] / x[j]\n            else:\n                jac[0, j] = 0\n\n        return jac\n\n    #create internal algebraic operator\n    self.op_alg = Operator(\n        func=lambda x: np.prod(np.power(x, self.exponents)), \n        jac=_jac\n        )",
              "signature": "(exponents = 2)",
              "parameters": [
                {
                  "name": "exponents",
                  "type": null,
                  "default": "2",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "exponents",
              "description": "",
              "type": null,
              "value": "exponents"
            },
            {
              "name": "op_alg",
              "description": "",
              "type": null,
              "value": "Operator(func=(lambda x: np.prod(np.power(x, self.exponents))), jac=_jac)"
            }
          ],
          "parameters": [
            {
              "name": "exponents",
              "type": null,
              "default": "2",
              "description": "exponent(s) to raise the inputs to the power of. If scalar, applies same exponent to all inputs. Attributes ----------"
            }
          ]
        },
        {
          "name": "Exp",
          "description": "Exponential operator block.",
          "docstring_html": "<p>Exponential operator block.</p>\n<p>This block supports vector inputs. This is the operation it does:</p>\n<pre class=\"math\">\n\\vec{y} = e^{\\vec{u}}\n</pre>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>op_alg <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">Operator</span></dt>\n<dd>internal algebraic operator</dd>\n</dl>\n",
          "source": "class Exp(Math):\n    \"\"\"Exponential operator block.\n\n    This block supports vector inputs. This is the operation it does:\n\n    .. math::\n\n        \\\\vec{y} = e^{\\\\vec{u}} \n\n    Attributes\n    ----------\n    op_alg : Operator\n        internal algebraic operator\n    \"\"\"\n\n    def __init__(self):\n        super().__init__()\n\n        #create internal algebraic operator\n        self.op_alg = Operator(\n            func=np.exp, \n            jac=lambda x: np.diag(np.exp(x))\n            )",
          "bases": [
            "pathsim.blocks.math.Math"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self):\n    super().__init__()\n\n    #create internal algebraic operator\n    self.op_alg = Operator(\n        func=np.exp, \n        jac=lambda x: np.diag(np.exp(x))\n        )",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "op_alg",
              "description": "",
              "type": null,
              "value": "Operator(func=(np.exp), jac=(lambda x: np.diag(np.exp(x))))"
            }
          ],
          "parameters": []
        },
        {
          "name": "Log",
          "description": "Natural logarithm operator block.",
          "docstring_html": "<p>Natural logarithm operator block.</p>\n<p>This block supports vector inputs. This is the operation it does:</p>\n<pre class=\"math\">\n\\vec{y} = \\ln(\\vec{u})\n</pre>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>op_alg <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">Operator</span></dt>\n<dd>internal algebraic operator</dd>\n</dl>\n",
          "source": "class Log(Math):\n    \"\"\"Natural logarithm operator block.\n\n    This block supports vector inputs. This is the operation it does:\n\n    .. math::\n\n        \\\\vec{y} = \\\\ln(\\\\vec{u}) \n\n    Attributes\n    ----------\n    op_alg : Operator\n        internal algebraic operator\n    \"\"\"\n\n    def __init__(self):\n        super().__init__()\n\n        #create internal algebraic operator\n        self.op_alg = Operator(\n            func=np.log, \n            jac=lambda x: np.diag(1/x)\n            )",
          "bases": [
            "pathsim.blocks.math.Math"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self):\n    super().__init__()\n\n    #create internal algebraic operator\n    self.op_alg = Operator(\n        func=np.log, \n        jac=lambda x: np.diag(1/x)\n        )",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "op_alg",
              "description": "",
              "type": null,
              "value": "Operator(func=(np.log), jac=(lambda x: np.diag(1 / x)))"
            }
          ],
          "parameters": []
        },
        {
          "name": "Log10",
          "description": "Base-10 logarithm operator block.",
          "docstring_html": "<p>Base-10 logarithm operator block.</p>\n<p>This block supports vector inputs. This is the operation it does:</p>\n<pre class=\"math\">\n\\vec{y} = \\log_{10}(\\vec{u})\n</pre>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>op_alg <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">Operator</span></dt>\n<dd>internal algebraic operator</dd>\n</dl>\n",
          "source": "class Log10(Math):\n    \"\"\"Base-10 logarithm operator block.\n\n    This block supports vector inputs. This is the operation it does:\n\n    .. math::\n\n        \\\\vec{y} = \\\\log_{10}(\\\\vec{u}) \n\n    Attributes\n    ----------\n    op_alg : Operator\n        internal algebraic operator\n    \"\"\"\n\n    def __init__(self):\n        super().__init__()\n\n        #create internal algebraic operator\n        self.op_alg = Operator(\n            func=np.log10, \n            jac=lambda x: np.diag(1/(x * np.log(10)))\n            )",
          "bases": [
            "pathsim.blocks.math.Math"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self):\n    super().__init__()\n\n    #create internal algebraic operator\n    self.op_alg = Operator(\n        func=np.log10, \n        jac=lambda x: np.diag(1/(x * np.log(10)))\n        )",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "op_alg",
              "description": "",
              "type": null,
              "value": "Operator(func=(np.log10), jac=(lambda x: np.diag(1 / (x * np.log(10)))))"
            }
          ],
          "parameters": []
        },
        {
          "name": "Tan",
          "description": "Tangent operator block.",
          "docstring_html": "<p>Tangent operator block.</p>\n<p>This block supports vector inputs. This is the operation it does:</p>\n<pre class=\"math\">\n\\vec{y} = \\tan(\\vec{u})\n</pre>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>op_alg <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">Operator</span></dt>\n<dd>internal algebraic operator</dd>\n</dl>\n",
          "source": "class Tan(Math):\n    \"\"\"Tangent operator block.\n\n    This block supports vector inputs. This is the operation it does:\n\n    .. math::\n\n        \\\\vec{y} = \\\\tan(\\\\vec{u}) \n\n    Attributes\n    ----------\n    op_alg : Operator\n        internal algebraic operator\n    \"\"\"\n\n    def __init__(self):\n        super().__init__()\n\n        #create internal algebraic operator\n        self.op_alg = Operator(\n            func=np.tan, \n            jac=lambda x: np.diag(1/np.cos(x)**2)\n            )",
          "bases": [
            "pathsim.blocks.math.Math"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self):\n    super().__init__()\n\n    #create internal algebraic operator\n    self.op_alg = Operator(\n        func=np.tan, \n        jac=lambda x: np.diag(1/np.cos(x)**2)\n        )",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "op_alg",
              "description": "",
              "type": null,
              "value": "Operator(func=(np.tan), jac=(lambda x: np.diag(1 / np.cos(x) ** 2)))"
            }
          ],
          "parameters": []
        },
        {
          "name": "Sinh",
          "description": "Hyperbolic sine operator block.",
          "docstring_html": "<p>Hyperbolic sine operator block.</p>\n<p>This block supports vector inputs. This is the operation it does:</p>\n<pre class=\"math\">\n\\vec{y} = \\sinh(\\vec{u})\n</pre>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>op_alg <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">Operator</span></dt>\n<dd>internal algebraic operator</dd>\n</dl>\n",
          "source": "class Sinh(Math):\n    \"\"\"Hyperbolic sine operator block.\n\n    This block supports vector inputs. This is the operation it does:\n\n    .. math::\n\n        \\\\vec{y} = \\\\sinh(\\\\vec{u}) \n\n    Attributes\n    ----------\n    op_alg : Operator\n        internal algebraic operator\n    \"\"\"\n\n    def __init__(self):\n        super().__init__()\n\n        #create internal algebraic operator\n        self.op_alg = Operator(\n            func=np.sinh, \n            jac=lambda x: np.diag(np.cosh(x))\n            )",
          "bases": [
            "pathsim.blocks.math.Math"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self):\n    super().__init__()\n\n    #create internal algebraic operator\n    self.op_alg = Operator(\n        func=np.sinh, \n        jac=lambda x: np.diag(np.cosh(x))\n        )",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "op_alg",
              "description": "",
              "type": null,
              "value": "Operator(func=(np.sinh), jac=(lambda x: np.diag(np.cosh(x))))"
            }
          ],
          "parameters": []
        },
        {
          "name": "Cosh",
          "description": "Hyperbolic cosine operator block.",
          "docstring_html": "<p>Hyperbolic cosine operator block.</p>\n<p>This block supports vector inputs. This is the operation it does:</p>\n<pre class=\"math\">\n\\vec{y} = \\cosh(\\vec{u})\n</pre>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>op_alg <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">Operator</span></dt>\n<dd>internal algebraic operator</dd>\n</dl>\n",
          "source": "class Cosh(Math):\n    \"\"\"Hyperbolic cosine operator block.\n\n    This block supports vector inputs. This is the operation it does:\n\n    .. math::\n\n        \\\\vec{y} = \\\\cosh(\\\\vec{u}) \n\n    Attributes\n    ----------\n    op_alg : Operator\n        internal algebraic operator\n    \"\"\"\n\n    def __init__(self):\n        super().__init__()\n\n        #create internal algebraic operator\n        self.op_alg = Operator(\n            func=np.cosh, \n            jac=lambda x: np.diag(np.sinh(x))\n            )",
          "bases": [
            "pathsim.blocks.math.Math"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self):\n    super().__init__()\n\n    #create internal algebraic operator\n    self.op_alg = Operator(\n        func=np.cosh, \n        jac=lambda x: np.diag(np.sinh(x))\n        )",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "op_alg",
              "description": "",
              "type": null,
              "value": "Operator(func=(np.cosh), jac=(lambda x: np.diag(np.sinh(x))))"
            }
          ],
          "parameters": []
        },
        {
          "name": "Tanh",
          "description": "Hyperbolic tangent operator block.",
          "docstring_html": "<p>Hyperbolic tangent operator block.</p>\n<p>This block supports vector inputs. This is the operation it does:</p>\n<pre class=\"math\">\n\\vec{y} = \\tanh(\\vec{u})\n</pre>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>op_alg <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">Operator</span></dt>\n<dd>internal algebraic operator</dd>\n</dl>\n",
          "source": "class Tanh(Math):\n    \"\"\"Hyperbolic tangent operator block.\n\n    This block supports vector inputs. This is the operation it does:\n\n    .. math::\n\n        \\\\vec{y} = \\\\tanh(\\\\vec{u}) \n\n    Attributes\n    ----------\n    op_alg : Operator\n        internal algebraic operator\n    \"\"\"\n\n    def __init__(self):\n        super().__init__()\n\n        #create internal algebraic operator\n        self.op_alg = Operator(\n            func=np.tanh, \n            jac=lambda x: np.diag(1 - np.tanh(x)**2)\n            )",
          "bases": [
            "pathsim.blocks.math.Math"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self):\n    super().__init__()\n\n    #create internal algebraic operator\n    self.op_alg = Operator(\n        func=np.tanh, \n        jac=lambda x: np.diag(1 - np.tanh(x)**2)\n        )",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "op_alg",
              "description": "",
              "type": null,
              "value": "Operator(func=(np.tanh), jac=(lambda x: np.diag(1 - np.tanh(x) ** 2)))"
            }
          ],
          "parameters": []
        },
        {
          "name": "Atan",
          "description": "Arctangent operator block.",
          "docstring_html": "<p>Arctangent operator block.</p>\n<p>This block supports vector inputs. This is the operation it does:</p>\n<pre class=\"math\">\n\\vec{y} = \\arctan(\\vec{u})\n</pre>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>op_alg <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">Operator</span></dt>\n<dd>internal algebraic operator</dd>\n</dl>\n",
          "source": "class Atan(Math):\n    \"\"\"Arctangent operator block.\n\n    This block supports vector inputs. This is the operation it does:\n\n    .. math::\n\n        \\\\vec{y} = \\\\arctan(\\\\vec{u}) \n\n    Attributes\n    ----------\n    op_alg : Operator\n        internal algebraic operator\n    \"\"\"\n\n    def __init__(self):\n        super().__init__()\n\n        #create internal algebraic operator\n        self.op_alg = Operator(\n            func=np.arctan, \n            jac=lambda x: np.diag(1/(1 + x**2))\n            )",
          "bases": [
            "pathsim.blocks.math.Math"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self):\n    super().__init__()\n\n    #create internal algebraic operator\n    self.op_alg = Operator(\n        func=np.arctan, \n        jac=lambda x: np.diag(1/(1 + x**2))\n        )",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "op_alg",
              "description": "",
              "type": null,
              "value": "Operator(func=(np.arctan), jac=(lambda x: np.diag(1 / (1 + x ** 2))))"
            }
          ],
          "parameters": []
        },
        {
          "name": "Norm",
          "description": "Vector norm operator block.",
          "docstring_html": "<p>Vector norm operator block.</p>\n<p>This block computes the Euclidean norm of the input vector:</p>\n<pre class=\"math\">\ny = \\|\\vec{u}\\|_2 = \\sqrt{\\sum_i u_i^2}\n</pre>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>op_alg <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">Operator</span></dt>\n<dd>internal algebraic operator</dd>\n</dl>\n",
          "source": "class Norm(Math):\n    \"\"\"Vector norm operator block.\n\n    This block computes the Euclidean norm of the input vector:\n\n    .. math::\n\n        y = \\\\|\\\\vec{u}\\\\|_2 = \\\\sqrt{\\\\sum_i u_i^2}\n\n    Attributes\n    ----------\n    op_alg : Operator\n        internal algebraic operator\n    \"\"\"\n\n    def __init__(self):\n        super().__init__()\n\n        #create internal algebraic operator\n        self.op_alg = Operator(\n            func=np.linalg.norm,\n            jac=lambda x: (x/np.linalg.norm(x)).reshape(1, -1)\n            )",
          "bases": [
            "pathsim.blocks.math.Math"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self):\n    super().__init__()\n\n    #create internal algebraic operator\n    self.op_alg = Operator(\n        func=np.linalg.norm,\n        jac=lambda x: (x/np.linalg.norm(x)).reshape(1, -1)\n        )",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "op_alg",
              "description": "",
              "type": null,
              "value": "Operator(func=(np.linalg.norm), jac=(lambda x: (x / np.linalg.norm(x)).reshape(1, -1)))"
            }
          ],
          "parameters": []
        },
        {
          "name": "Mod",
          "description": "Modulo operator block.",
          "docstring_html": "<p>Modulo operator block.</p>\n<p>This block supports vector inputs. This is the operation it does:</p>\n<pre class=\"math\">\n\\vec{y} = \\vec{u} \\bmod m\n</pre>\n<div class=\"section\" id=\"note\">\n<h4>Note</h4>\n<p>modulo is not differentiable at discontinuities</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>modulus <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>modulus value</dd>\n</dl>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>op_alg <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">Operator</span></dt>\n<dd>internal algebraic operator</dd>\n</dl>\n</div>\n",
          "source": "class Mod(Math):\n    \"\"\"Modulo operator block.\n\n    This block supports vector inputs. This is the operation it does:\n\n    .. math::\n\n        \\\\vec{y} = \\\\vec{u} \\\\bmod m\n\n\n    Note\n    ----\n    modulo is not differentiable at discontinuities\n\n    Parameters\n    ----------\n    modulus : float\n        modulus value\n\n    Attributes\n    ----------\n    op_alg : Operator\n        internal algebraic operator\n    \"\"\"\n\n    def __init__(self, modulus=1.0):\n        super().__init__()\n\n        self.modulus = modulus\n\n        #create internal algebraic operator\n        self.op_alg = Operator(\n            func=lambda x: np.mod(x, self.modulus), \n            jac=lambda x: np.diag(np.ones_like(x)) \n            )",
          "bases": [
            "pathsim.blocks.math.Math"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, modulus=1.0):\n    super().__init__()\n\n    self.modulus = modulus\n\n    #create internal algebraic operator\n    self.op_alg = Operator(\n        func=lambda x: np.mod(x, self.modulus), \n        jac=lambda x: np.diag(np.ones_like(x)) \n        )",
              "signature": "(modulus = 1.0)",
              "parameters": [
                {
                  "name": "modulus",
                  "type": null,
                  "default": "1.0",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "modulus",
              "description": "",
              "type": null,
              "value": "modulus"
            },
            {
              "name": "op_alg",
              "description": "",
              "type": null,
              "value": "Operator(func=(lambda x: np.mod(x, self.modulus)), jac=(lambda x: np.diag(np.ones_like(x))))"
            }
          ],
          "parameters": [
            {
              "name": "modulus",
              "type": null,
              "default": "1.0",
              "description": "modulus value Attributes ----------"
            }
          ]
        },
        {
          "name": "Clip",
          "description": "Clipping/saturation operator block.",
          "docstring_html": "<p>Clipping/saturation operator block.</p>\n<p>This block supports vector inputs. This is the operation it does:</p>\n<pre class=\"math\">\n\\vec{y} = \\text{clip}(\\vec{u}, u_{min}, u_{max})\n</pre>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>min_val <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float, array_like</span></dt>\n<dd>minimum clipping value</dd>\n<dt>max_val <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float, array_like</span></dt>\n<dd>maximum clipping value</dd>\n</dl>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>op_alg <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">Operator</span></dt>\n<dd>internal algebraic operator</dd>\n</dl>\n",
          "source": "class Clip(Math):\n    \"\"\"Clipping/saturation operator block.\n\n    This block supports vector inputs. This is the operation it does:\n\n    .. math::\n\n        \\\\vec{y} = \\\\text{clip}(\\\\vec{u}, u_{min}, u_{max}) \n\n    Parameters\n    ----------\n    min_val : float, array_like\n        minimum clipping value\n    max_val : float, array_like\n        maximum clipping value\n\n    Attributes\n    ----------\n    op_alg : Operator\n        internal algebraic operator\n    \"\"\"\n\n    def __init__(self, min_val=-1.0, max_val=1.0):\n        super().__init__()\n\n        self.min_val = min_val\n        self.max_val = max_val\n\n        #create internal algebraic operator\n        def _clip_jac(x):\n            \"\"\"Jacobian is 1 where not clipped, 0 where clipped\"\"\"\n            mask = (x >= self.min_val) & (x <= self.max_val)\n            return np.diag(mask.astype(float))\n\n        self.op_alg = Operator(\n            func=lambda x: np.clip(x, self.min_val, self.max_val), \n            jac=_clip_jac\n            )",
          "bases": [
            "pathsim.blocks.math.Math"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, min_val=-1.0, max_val=1.0):\n    super().__init__()\n\n    self.min_val = min_val\n    self.max_val = max_val\n\n    #create internal algebraic operator\n    def _clip_jac(x):\n        \"\"\"Jacobian is 1 where not clipped, 0 where clipped\"\"\"\n        mask = (x >= self.min_val) & (x <= self.max_val)\n        return np.diag(mask.astype(float))\n\n    self.op_alg = Operator(\n        func=lambda x: np.clip(x, self.min_val, self.max_val), \n        jac=_clip_jac\n        )",
              "signature": "(min_val = -1.0, max_val = 1.0)",
              "parameters": [
                {
                  "name": "min_val",
                  "type": null,
                  "default": "-1.0",
                  "description": ""
                },
                {
                  "name": "max_val",
                  "type": null,
                  "default": "1.0",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "min_val",
              "description": "",
              "type": null,
              "value": "min_val"
            },
            {
              "name": "max_val",
              "description": "",
              "type": null,
              "value": "max_val"
            },
            {
              "name": "op_alg",
              "description": "",
              "type": null,
              "value": "Operator(func=(lambda x: np.clip(x, self.min_val, self.max_val)), jac=_clip_jac)"
            }
          ],
          "parameters": [
            {
              "name": "min_val",
              "type": null,
              "default": "-1.0",
              "description": "minimum clipping value"
            },
            {
              "name": "max_val",
              "type": null,
              "default": "1.0",
              "description": "maximum clipping value Attributes ----------"
            }
          ]
        },
        {
          "name": "Matrix",
          "description": "Linear matrix operation (matrix-vector product).",
          "docstring_html": "<p>Linear matrix operation (matrix-vector product).</p>\n<p>This block supports vector inputs. This is the operation it does:</p>\n<pre class=\"math\">\n\\vec{y} = \\mathbf{A} \\vec{u}\n</pre>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>A <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">np.ndarray</span></dt>\n<dd>matrix, 2d array with dim=2</dd>\n</dl>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>op_alg <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">Operator</span></dt>\n<dd>internal algebraic operator</dd>\n</dl>\n",
          "source": "class Matrix(Math):\n    \"\"\"Linear matrix operation (matrix-vector product).\n\n    This block supports vector inputs. This is the operation it does:\n\n    .. math::\n\n        \\\\vec{y} = \\\\mathbf{A} \\\\vec{u} \n\n    Parameters\n    ----------\n    A : np.ndarray\n        matrix, 2d array with dim=2\n\n    Attributes\n    ----------\n    op_alg : Operator\n        internal algebraic operator\n    \"\"\"\n\n    def __init__(self, A=np.eye(1)):\n        super().__init__()\n\n        # check matrix dimension and shape\n        if not A.ndim == 2:\n            raise ValueError(\"'A' must be dim 2\")\n        n, m = A.shape\n\n        # initialize io registers\n        self.inputs = Register(size=m)\n        self.outputs = Register(size=n)\n\n        # block matrix\n        self.A = A\n\n        self.op_alg = Operator(\n            func=lambda u: np.dot(self.A, u),\n            jac=lambda u: self.A\n            )",
          "bases": [
            "pathsim.blocks.math.Math"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, A=np.eye(1)):\n    super().__init__()\n\n    # check matrix dimension and shape\n    if not A.ndim == 2:\n        raise ValueError(\"'A' must be dim 2\")\n    n, m = A.shape\n\n    # initialize io registers\n    self.inputs = Register(size=m)\n    self.outputs = Register(size=n)\n\n    # block matrix\n    self.A = A\n\n    self.op_alg = Operator(\n        func=lambda u: np.dot(self.A, u),\n        jac=lambda u: self.A\n        )",
              "signature": "(A = np.eye(1))",
              "parameters": [
                {
                  "name": "A",
                  "type": null,
                  "default": "np.eye(1)",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "inputs",
              "description": "",
              "type": null,
              "value": "Register(size=m)"
            },
            {
              "name": "outputs",
              "description": "",
              "type": null,
              "value": "Register(size=n)"
            },
            {
              "name": "A",
              "description": "",
              "type": null,
              "value": "A"
            },
            {
              "name": "op_alg",
              "description": "",
              "type": null,
              "value": "Operator(func=(lambda u: np.dot(self.A, u)), jac=(lambda u: self.A))"
            }
          ],
          "parameters": [
            {
              "name": "A",
              "type": null,
              "default": "np.eye(1)",
              "description": "matrix, 2d array with dim=2 Attributes ----------"
            }
          ]
        }
      ],
      "functions": []
    },
    "pathsim.blocks.multiplier": {
      "name": "pathsim.blocks.multiplier",
      "description": "",
      "docstring_html": "",
      "classes": [
        {
          "name": "Multiplier",
          "description": "Multiplies all signals from all input ports (MISO).",
          "docstring_html": "<p>Multiplies all signals from all input ports (MISO).</p>\n<pre class=\"math\">\ny(t) = \\prod_i u_i(t)\n</pre>\n<div class=\"section\" id=\"note\">\n<h4>Note</h4>\n<p>This block is purely algebraic and its operation (<cite>op_alg</cite>) will be called\nmultiple times per timestep, each time when <cite>Simulation._update(t)</cite> is\ncalled in the global simulation loop.</p>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>op_alg <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">Operator</span></dt>\n<dd>internal algebraic operator that wraps 'prod'</dd>\n</dl>\n</div>\n",
          "source": "class Multiplier(Block):\n    \"\"\"Multiplies all signals from all input ports (MISO).\n\n    .. math::\n\n        y(t) = \\\\prod_i u_i(t)\n\n\n    Note\n    ----\n    This block is purely algebraic and its operation (`op_alg`) will be called \n    multiple times per timestep, each time when `Simulation._update(t)` is \n    called in the global simulation loop.\n\n\n    Attributes\n    ----------\n    op_alg : Operator\n        internal algebraic operator that wraps 'prod'\n    \"\"\"\n    input_port_labels = None\n    output_port_labels = {\"out\":0}\n\n    def __init__(self):\n        super().__init__()\n\n        self.op_alg = Operator(\n            func=prod,\n            jac=lambda x: np.array([[\n                prod(np.delete(x, i)) for i in range(len(x))\n                ]])\n            )\n\n\n    def update(self, t):\n        \"\"\"update system equation\n\n        Parameters\n        ----------\n        t : float\n            evaluation time\n        \"\"\"\n        u = self.inputs.to_array()\n        self.outputs.update_from_array(self.op_alg(u))",
          "bases": [
            "pathsim.blocks._block.Block"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self):\n    super().__init__()\n\n    self.op_alg = Operator(\n        func=prod,\n        jac=lambda x: np.array([[\n            prod(np.delete(x, i)) for i in range(len(x))\n            ]])\n        )",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "update",
              "description": "update system equation",
              "docstring_html": "<p>update system equation</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time</dd>\n</dl>\n",
              "source": "def update(self, t):\n    \"\"\"update system equation\n\n    Parameters\n    ----------\n    t : float\n        evaluation time\n    \"\"\"\n    u = self.inputs.to_array()\n    self.outputs.update_from_array(self.op_alg(u))",
              "signature": "(t)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time"
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "input_port_labels",
              "description": "",
              "type": null,
              "value": "None"
            },
            {
              "name": "output_port_labels",
              "description": "",
              "type": null,
              "value": "{'out': 0}"
            },
            {
              "name": "op_alg",
              "description": "",
              "type": null,
              "value": "Operator(func=prod, jac=(lambda x: np.array([[(prod(np.delete(x, i))) for i in (range(len(x)))]])))"
            }
          ],
          "parameters": []
        }
      ],
      "functions": []
    },
    "pathsim.blocks.noise": {
      "name": "pathsim.blocks.noise",
      "description": "",
      "docstring_html": "",
      "classes": [
        {
          "name": "WhiteNoise",
          "description": "White noise source with Gaussian distribution.",
          "docstring_html": "<p>White noise source with Gaussian distribution.</p>\n<p>Generates uncorrelated random samples with either constant amplitude\n(<tt class=\"docutils literal\">standard_deviation</tt> mode) or timestep-scaled amplitude for stochastic\nintegration (<tt class=\"docutils literal\">spectral_density</tt> mode).</p>\n<p>In spectral density mode, output is scaled as √(S₀/dt) so that integrating\nthe noise yields correct statistical properties (Wiener process).</p>\n<div class=\"section\" id=\"note\">\n<h4>Note</h4>\n<p>If <tt class=\"docutils literal\">spectral_density</tt> is provided, it takes precedence over <tt class=\"docutils literal\">standard_deviation</tt>.\nIf <tt class=\"docutils literal\">sampling_period</tt> is set, noise is sampled at fixed intervals (zero-order hold).</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>standard_deviation <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>output standard deviation for constant-amplitude mode (default: 1.0)</dd>\n<dt>spectral_density <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float, optional</span></dt>\n<dd>power spectral density S₀ in [signal²/Hz]</dd>\n<dt>sampling_period <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float, optional</span></dt>\n<dd>time between samples, if None samples every timestep</dd>\n<dt>seed <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int, optional</span></dt>\n<dd>random seed for reproducibility</dd>\n</dl>\n</div>\n",
          "source": "class WhiteNoise(Block):\n    \"\"\"White noise source with Gaussian distribution.\n\n    Generates uncorrelated random samples with either constant amplitude\n    (``standard_deviation`` mode) or timestep-scaled amplitude for stochastic\n    integration (``spectral_density`` mode).\n\n    In spectral density mode, output is scaled as √(S₀/dt) so that integrating\n    the noise yields correct statistical properties (Wiener process).\n\n\n    Note\n    ----\n    If ``spectral_density`` is provided, it takes precedence over ``standard_deviation``.\n    If ``sampling_period`` is set, noise is sampled at fixed intervals (zero-order hold).\n\n\n    Parameters\n    ----------\n    standard_deviation : float\n        output standard deviation for constant-amplitude mode (default: 1.0)\n    spectral_density : float, optional\n        power spectral density S₀ in [signal²/Hz]\n    sampling_period : float, optional\n        time between samples, if None samples every timestep\n    seed : int, optional\n        random seed for reproducibility\n    \"\"\"\n\n    input_port_labels = {}\n    output_port_labels = {\"out\": 0}\n\n    def __init__(self, standard_deviation=1.0, spectral_density=None,\n                 sampling_period=None, seed=None):\n        super().__init__()\n\n        #block parameters\n        self.standard_deviation = standard_deviation\n        self.spectral_density = spectral_density\n        self.sampling_period = sampling_period\n\n        #random number generator (with optional seed for reproducibility)\n        self._rng = np.random.default_rng(seed)\n\n        #current noise sample\n        self._current_sample = 0.0\n\n        #sampling produces discrete time behavior\n        if sampling_period is not None:\n\n            #generate initial sample for discrete mode\n            self._current_sample = self._generate_sample(sampling_period)\n            self.outputs[0] = self._current_sample\n\n            #internal scheduled event\n            def _set(t):\n                self._current_sample = self._generate_sample(self.sampling_period)\n                self.outputs[0] = self._current_sample\n\n            self.events = [\n                Schedule(\n                    t_start=0,\n                    t_period=sampling_period,\n                    func_act=_set\n                )\n            ]\n\n\n    def __len__(self):\n        return 0\n\n\n    def _generate_sample(self, dt):\n        \"\"\"Generate a random sample from the noise distribution.\n\n        Parameters\n        ----------\n        dt : float\n            integration timestep (used for spectral density scaling)\n        \"\"\"\n        if self.spectral_density is not None:\n            #spectral density mode: scale for correct integration\n            return self._rng.normal(0, 1) * np.sqrt(self.spectral_density / dt)\n        else:\n            #constant amplitude mode\n            return self._rng.normal(0, self.standard_deviation)\n\n\n    def sample(self, t, dt):\n        \"\"\"Generate new noise sample after successful timestep.\n\n        Only generates new samples in continuous mode (sampling_period=None).\n\n        Parameters\n        ----------\n        t : float\n            evaluation time\n        dt : float\n            integration timestep\n        \"\"\"\n        if self.sampling_period is None:\n            self._current_sample = self._generate_sample(dt)\n            self.outputs[0] = self._current_sample\n\n\n    def update(self, t):\n        pass",
          "bases": [
            "pathsim.blocks._block.Block"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, standard_deviation=1.0, spectral_density=None,\n             sampling_period=None, seed=None):\n    super().__init__()\n\n    #block parameters\n    self.standard_deviation = standard_deviation\n    self.spectral_density = spectral_density\n    self.sampling_period = sampling_period\n\n    #random number generator (with optional seed for reproducibility)\n    self._rng = np.random.default_rng(seed)\n\n    #current noise sample\n    self._current_sample = 0.0\n\n    #sampling produces discrete time behavior\n    if sampling_period is not None:\n\n        #generate initial sample for discrete mode\n        self._current_sample = self._generate_sample(sampling_period)\n        self.outputs[0] = self._current_sample\n\n        #internal scheduled event\n        def _set(t):\n            self._current_sample = self._generate_sample(self.sampling_period)\n            self.outputs[0] = self._current_sample\n\n        self.events = [\n            Schedule(\n                t_start=0,\n                t_period=sampling_period,\n                func_act=_set\n            )\n        ]",
              "signature": "(standard_deviation = 1.0, spectral_density = None, sampling_period = None, seed = None)",
              "parameters": [
                {
                  "name": "standard_deviation",
                  "type": null,
                  "default": "1.0",
                  "description": ""
                },
                {
                  "name": "spectral_density",
                  "type": null,
                  "default": "None",
                  "description": ""
                },
                {
                  "name": "sampling_period",
                  "type": null,
                  "default": "None",
                  "description": ""
                },
                {
                  "name": "seed",
                  "type": null,
                  "default": "None",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "_generate_sample",
              "description": "Generate a random sample from the noise distribution.",
              "docstring_html": "<p>Generate a random sample from the noise distribution.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>integration timestep (used for spectral density scaling)</dd>\n</dl>\n",
              "source": "def _generate_sample(self, dt):\n    \"\"\"Generate a random sample from the noise distribution.\n\n    Parameters\n    ----------\n    dt : float\n        integration timestep (used for spectral density scaling)\n    \"\"\"\n    if self.spectral_density is not None:\n        #spectral density mode: scale for correct integration\n        return self._rng.normal(0, 1) * np.sqrt(self.spectral_density / dt)\n    else:\n        #constant amplitude mode\n        return self._rng.normal(0, self.standard_deviation)",
              "signature": "(dt)",
              "parameters": [
                {
                  "name": "dt",
                  "type": null,
                  "default": null,
                  "description": "integration timestep (used for spectral density scaling)"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "sample",
              "description": "Generate new noise sample after successful timestep.",
              "docstring_html": "<p>Generate new noise sample after successful timestep.</p>\n<p>Only generates new samples in continuous mode (sampling_period=None).</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time</dd>\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>integration timestep</dd>\n</dl>\n",
              "source": "def sample(self, t, dt):\n    \"\"\"Generate new noise sample after successful timestep.\n\n    Only generates new samples in continuous mode (sampling_period=None).\n\n    Parameters\n    ----------\n    t : float\n        evaluation time\n    dt : float\n        integration timestep\n    \"\"\"\n    if self.sampling_period is None:\n        self._current_sample = self._generate_sample(dt)\n        self.outputs[0] = self._current_sample",
              "signature": "(t, dt)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time"
                },
                {
                  "name": "dt",
                  "type": null,
                  "default": null,
                  "description": "integration timestep"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "update",
              "description": "",
              "docstring_html": "",
              "source": "def update(self, t):\n    pass",
              "signature": "(t)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "input_port_labels",
              "description": "",
              "type": null,
              "value": "{}"
            },
            {
              "name": "output_port_labels",
              "description": "",
              "type": null,
              "value": "{'out': 0}"
            },
            {
              "name": "standard_deviation",
              "description": "",
              "type": null,
              "value": "standard_deviation"
            },
            {
              "name": "spectral_density",
              "description": "",
              "type": null,
              "value": "spectral_density"
            },
            {
              "name": "sampling_period",
              "description": "",
              "type": null,
              "value": "sampling_period"
            },
            {
              "name": "_rng",
              "description": "",
              "type": null,
              "value": "np.random.default_rng(seed)"
            },
            {
              "name": "_current_sample",
              "description": "",
              "type": null,
              "value": "0.0"
            },
            {
              "name": "events",
              "description": "",
              "type": null,
              "value": "[Schedule(t_start=0, t_period=sampling_period, func_act=_set)]"
            }
          ],
          "parameters": [
            {
              "name": "standard_deviation",
              "type": null,
              "default": "1.0",
              "description": "output standard deviation for constant-amplitude mode (default: 1.0)"
            },
            {
              "name": "spectral_density",
              "type": null,
              "default": "None",
              "description": "power spectral density S₀ in [signal²/Hz]"
            },
            {
              "name": "sampling_period",
              "type": null,
              "default": "None",
              "description": "time between samples, if None samples every timestep"
            },
            {
              "name": "seed",
              "type": null,
              "default": "None",
              "description": "random seed for reproducibility"
            }
          ]
        },
        {
          "name": "PinkNoise",
          "description": "Pink noise (1/f noise) source using the Voss-McCartney algorithm.",
          "docstring_html": "<p>Pink noise (1/f noise) source using the Voss-McCartney algorithm.</p>\n<p>Generates noise with power spectral density proportional to 1/f, where\nlower frequencies have more power than higher frequencies.</p>\n<p>The algorithm maintains <tt class=\"docutils literal\">num_octaves</tt> independent random values representing\ndifferent frequency bands. At each sample, one octave is updated based on the\nbinary representation of the sample counter, creating the characteristic 1/f\nspectrum through the superposition of different update rates.</p>\n<div class=\"section\" id=\"note\">\n<h4>Note</h4>\n<p>If <tt class=\"docutils literal\">spectral_density</tt> is provided, it takes precedence over <tt class=\"docutils literal\">standard_deviation</tt>.\nIf <tt class=\"docutils literal\">sampling_period</tt> is set, noise is sampled at fixed intervals (zero-order hold).</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>standard_deviation <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>approximate output standard deviation (default: 1.0)</dd>\n<dt>spectral_density <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float, optional</span></dt>\n<dd>power spectral density, output scaled as √(S₀/(N·dt))</dd>\n<dt>num_octaves <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>number of frequency bands in algorithm (default: 16)</dd>\n<dt>sampling_period <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float, optional</span></dt>\n<dd>time between samples, if None samples every timestep</dd>\n<dt>seed <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int, optional</span></dt>\n<dd>random seed for reproducibility</dd>\n</dl>\n</div>\n",
          "source": "class PinkNoise(Block):\n    \"\"\"Pink noise (1/f noise) source using the Voss-McCartney algorithm.\n\n    Generates noise with power spectral density proportional to 1/f, where\n    lower frequencies have more power than higher frequencies.\n\n    The algorithm maintains ``num_octaves`` independent random values representing\n    different frequency bands. At each sample, one octave is updated based on the\n    binary representation of the sample counter, creating the characteristic 1/f\n    spectrum through the superposition of different update rates.\n\n\n    Note\n    ----\n    If ``spectral_density`` is provided, it takes precedence over ``standard_deviation``.\n    If ``sampling_period`` is set, noise is sampled at fixed intervals (zero-order hold).\n\n\n    Parameters\n    ----------\n    standard_deviation : float\n        approximate output standard deviation (default: 1.0)\n    spectral_density : float, optional\n        power spectral density, output scaled as √(S₀/(N·dt))\n    num_octaves : int\n        number of frequency bands in algorithm (default: 16)\n    sampling_period : float, optional\n        time between samples, if None samples every timestep\n    seed : int, optional\n        random seed for reproducibility\n    \"\"\"\n\n    input_port_labels = {}\n    output_port_labels = {\"out\": 0}\n\n    def __init__(self, standard_deviation=1.0, spectral_density=None,\n                 num_octaves=16, sampling_period=None, seed=None):\n        super().__init__()\n\n        #block parameters\n        self.standard_deviation = standard_deviation\n        self.spectral_density = spectral_density\n        self.num_octaves = num_octaves\n        self.sampling_period = sampling_period\n\n        #random number generator (with optional seed)\n        self._rng = np.random.default_rng(seed)\n\n        #algorithm state\n        self.n_samples = 0\n        self.octave_values = self._rng.normal(0, 1, self.num_octaves)\n\n        #current noise sample\n        self._current_sample = 0.0\n\n        #sampling produces discrete time behavior\n        if sampling_period is not None:\n\n            #generate initial sample for discrete mode\n            self._current_sample = self._generate_sample(sampling_period)\n            self.outputs[0] = self._current_sample\n\n            #internal scheduled event\n            def _set(t):\n                self._current_sample = self._generate_sample(self.sampling_period)\n                self.outputs[0] = self._current_sample\n\n            self.events = [\n                Schedule(\n                    t_start=0,\n                    t_period=sampling_period,\n                    func_act=_set\n                )\n            ]\n\n\n    def __len__(self):\n        return 0\n\n\n    def reset(self):\n        \"\"\"Reset the noise generator state.\n\n        Resets the sample counter and reinitializes all octave values.\n        \"\"\"\n        super().reset()\n        self.n_samples = 0\n        self.octave_values = self._rng.normal(0, 1, self.num_octaves)\n        self._current_sample = 0.0\n\n\n    def _generate_sample(self, dt):\n        \"\"\"Generate a pink noise sample using the Voss-McCartney algorithm.\n\n        Parameters\n        ----------\n        dt : float\n            integration timestep (used for spectral density scaling)\n        \"\"\"\n        #increment sample counter\n        self.n_samples += 1\n\n        #find position of least significant 1-bit (trailing zeros)\n        #this determines which octave to update\n        n = self.n_samples\n        octave_idx = 0\n        while (n & 1) == 0 and octave_idx < self.num_octaves - 1:\n            n >>= 1\n            octave_idx += 1\n\n        #update the selected octave\n        self.octave_values[octave_idx] = self._rng.normal(0, 1)\n\n        #sum all octaves for pink noise output\n        pink_sample = np.sum(self.octave_values)\n\n        #scale output based on parameterization mode\n        if self.spectral_density is not None:\n            #spectral density mode\n            return pink_sample * np.sqrt(self.spectral_density / self.num_octaves / dt)\n        else:\n            #constant amplitude mode\n            #normalize by sqrt(num_octaves) since Var(sum) ≈ num_octaves\n            return pink_sample * self.standard_deviation / np.sqrt(self.num_octaves)\n\n\n    def sample(self, t, dt):\n        \"\"\"Generate new noise sample after successful timestep.\n\n        Only generates new samples in continuous mode (sampling_period=None).\n\n        Parameters\n        ----------\n        t : float\n            evaluation time\n        dt : float\n            integration timestep\n        \"\"\"\n        if self.sampling_period is None:\n            self._current_sample = self._generate_sample(dt)\n            self.outputs[0] = self._current_sample\n\n\n    def update(self, t):\n        pass",
          "bases": [
            "pathsim.blocks._block.Block"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, standard_deviation=1.0, spectral_density=None,\n             num_octaves=16, sampling_period=None, seed=None):\n    super().__init__()\n\n    #block parameters\n    self.standard_deviation = standard_deviation\n    self.spectral_density = spectral_density\n    self.num_octaves = num_octaves\n    self.sampling_period = sampling_period\n\n    #random number generator (with optional seed)\n    self._rng = np.random.default_rng(seed)\n\n    #algorithm state\n    self.n_samples = 0\n    self.octave_values = self._rng.normal(0, 1, self.num_octaves)\n\n    #current noise sample\n    self._current_sample = 0.0\n\n    #sampling produces discrete time behavior\n    if sampling_period is not None:\n\n        #generate initial sample for discrete mode\n        self._current_sample = self._generate_sample(sampling_period)\n        self.outputs[0] = self._current_sample\n\n        #internal scheduled event\n        def _set(t):\n            self._current_sample = self._generate_sample(self.sampling_period)\n            self.outputs[0] = self._current_sample\n\n        self.events = [\n            Schedule(\n                t_start=0,\n                t_period=sampling_period,\n                func_act=_set\n            )\n        ]",
              "signature": "(standard_deviation = 1.0, spectral_density = None, num_octaves = 16, sampling_period = None, seed = None)",
              "parameters": [
                {
                  "name": "standard_deviation",
                  "type": null,
                  "default": "1.0",
                  "description": ""
                },
                {
                  "name": "spectral_density",
                  "type": null,
                  "default": "None",
                  "description": ""
                },
                {
                  "name": "num_octaves",
                  "type": null,
                  "default": "16",
                  "description": ""
                },
                {
                  "name": "sampling_period",
                  "type": null,
                  "default": "None",
                  "description": ""
                },
                {
                  "name": "seed",
                  "type": null,
                  "default": "None",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "reset",
              "description": "Reset the noise generator state.",
              "docstring_html": "<p>Reset the noise generator state.</p>\n<p>Resets the sample counter and reinitializes all octave values.</p>\n",
              "source": "def reset(self):\n    \"\"\"Reset the noise generator state.\n\n    Resets the sample counter and reinitializes all octave values.\n    \"\"\"\n    super().reset()\n    self.n_samples = 0\n    self.octave_values = self._rng.normal(0, 1, self.num_octaves)\n    self._current_sample = 0.0",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "_generate_sample",
              "description": "Generate a pink noise sample using the Voss-McCartney algorithm.",
              "docstring_html": "<p>Generate a pink noise sample using the Voss-McCartney algorithm.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>integration timestep (used for spectral density scaling)</dd>\n</dl>\n",
              "source": "def _generate_sample(self, dt):\n    \"\"\"Generate a pink noise sample using the Voss-McCartney algorithm.\n\n    Parameters\n    ----------\n    dt : float\n        integration timestep (used for spectral density scaling)\n    \"\"\"\n    #increment sample counter\n    self.n_samples += 1\n\n    #find position of least significant 1-bit (trailing zeros)\n    #this determines which octave to update\n    n = self.n_samples\n    octave_idx = 0\n    while (n & 1) == 0 and octave_idx < self.num_octaves - 1:\n        n >>= 1\n        octave_idx += 1\n\n    #update the selected octave\n    self.octave_values[octave_idx] = self._rng.normal(0, 1)\n\n    #sum all octaves for pink noise output\n    pink_sample = np.sum(self.octave_values)\n\n    #scale output based on parameterization mode\n    if self.spectral_density is not None:\n        #spectral density mode\n        return pink_sample * np.sqrt(self.spectral_density / self.num_octaves / dt)\n    else:\n        #constant amplitude mode\n        #normalize by sqrt(num_octaves) since Var(sum) ≈ num_octaves\n        return pink_sample * self.standard_deviation / np.sqrt(self.num_octaves)",
              "signature": "(dt)",
              "parameters": [
                {
                  "name": "dt",
                  "type": null,
                  "default": null,
                  "description": "integration timestep (used for spectral density scaling)"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "sample",
              "description": "Generate new noise sample after successful timestep.",
              "docstring_html": "<p>Generate new noise sample after successful timestep.</p>\n<p>Only generates new samples in continuous mode (sampling_period=None).</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time</dd>\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>integration timestep</dd>\n</dl>\n",
              "source": "def sample(self, t, dt):\n    \"\"\"Generate new noise sample after successful timestep.\n\n    Only generates new samples in continuous mode (sampling_period=None).\n\n    Parameters\n    ----------\n    t : float\n        evaluation time\n    dt : float\n        integration timestep\n    \"\"\"\n    if self.sampling_period is None:\n        self._current_sample = self._generate_sample(dt)\n        self.outputs[0] = self._current_sample",
              "signature": "(t, dt)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time"
                },
                {
                  "name": "dt",
                  "type": null,
                  "default": null,
                  "description": "integration timestep"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "update",
              "description": "",
              "docstring_html": "",
              "source": "def update(self, t):\n    pass",
              "signature": "(t)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "input_port_labels",
              "description": "",
              "type": null,
              "value": "{}"
            },
            {
              "name": "output_port_labels",
              "description": "",
              "type": null,
              "value": "{'out': 0}"
            },
            {
              "name": "standard_deviation",
              "description": "",
              "type": null,
              "value": "standard_deviation"
            },
            {
              "name": "spectral_density",
              "description": "",
              "type": null,
              "value": "spectral_density"
            },
            {
              "name": "num_octaves",
              "description": "",
              "type": null,
              "value": "num_octaves"
            },
            {
              "name": "sampling_period",
              "description": "",
              "type": null,
              "value": "sampling_period"
            },
            {
              "name": "_rng",
              "description": "",
              "type": null,
              "value": "np.random.default_rng(seed)"
            },
            {
              "name": "n_samples",
              "description": "",
              "type": null,
              "value": "0"
            },
            {
              "name": "octave_values",
              "description": "",
              "type": null,
              "value": "self._rng.normal(0, 1, self.num_octaves)"
            },
            {
              "name": "_current_sample",
              "description": "",
              "type": null,
              "value": "0.0"
            },
            {
              "name": "events",
              "description": "",
              "type": null,
              "value": "[Schedule(t_start=0, t_period=sampling_period, func_act=_set)]"
            }
          ],
          "parameters": [
            {
              "name": "standard_deviation",
              "type": null,
              "default": "1.0",
              "description": "approximate output standard deviation (default: 1.0)"
            },
            {
              "name": "spectral_density",
              "type": null,
              "default": "None",
              "description": "power spectral density, output scaled as √(S₀/(N·dt))"
            },
            {
              "name": "num_octaves",
              "type": null,
              "default": "16",
              "description": "number of frequency bands in algorithm (default: 16)"
            },
            {
              "name": "sampling_period",
              "type": null,
              "default": "None",
              "description": "time between samples, if None samples every timestep"
            },
            {
              "name": "seed",
              "type": null,
              "default": "None",
              "description": "random seed for reproducibility"
            }
          ]
        }
      ],
      "functions": []
    },
    "pathsim.blocks.ode": {
      "name": "pathsim.blocks.ode",
      "description": "",
      "docstring_html": "",
      "classes": [
        {
          "name": "ODE",
          "description": "Ordinary differential equation (ODE) defined by its right hand side function.",
          "docstring_html": "<p>Ordinary differential equation (ODE) defined by its right hand side function.</p>\n<pre class=\"math\">\n\\begin{align}\n    \\dot{x}(t) &amp;= \\mathrm{func}(x(t), u(t), t) \\\\\n           y(t) &amp;= x(t)\n\\end{align}\n</pre>\n<p>with inhomogenity (input) <cite>u</cite> and state vector <cite>x</cite>. The function can be nonlinear\nand the ODE can be of arbitrary order. The block utilizes the integration engine\nto solve the ODE by integrating the <cite>func</cite>, which is the right hand side function.</p>\n<div class=\"section\" id=\"example\">\n<h4>Example</h4>\n<p>For example a linear 1st order ODE:</p>\n<pre class=\"code python literal-block\">\n<span class=\"n\">ode</span> <span class=\"o\">=</span> <span class=\"n\">ODE</span><span class=\"p\">(</span><span class=\"k\">lambda</span> <span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">u</span><span class=\"p\">,</span> <span class=\"n\">t</span><span class=\"p\">:</span> <span class=\"o\">-</span><span class=\"n\">x</span><span class=\"p\">)</span>\n</pre>\n<p>Or something more complex like the <cite>Van der Pol</cite> system, where it makes sense to\nalso specify the jacobian, which improves convergence for implicit solvers but is\nnot needed in most cases:</p>\n<pre class=\"code python literal-block\">\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"nn\">numpy</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"nn\">np</span><span class=\"w\">\n\n</span><span class=\"c1\">#initial condition</span><span class=\"w\">\n</span><span class=\"n\">x0</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">array</span><span class=\"p\">([</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">])</span><span class=\"w\">\n\n</span><span class=\"c1\">#van der Pol parameter</span><span class=\"w\">\n</span><span class=\"n\">mu</span> <span class=\"o\">=</span> <span class=\"mi\">1000</span><span class=\"w\">\n\n</span><span class=\"k\">def</span><span class=\"w\"> </span><span class=\"nf\">func</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">u</span><span class=\"p\">,</span> <span class=\"n\">t</span><span class=\"p\">):</span><span class=\"w\">\n</span>    <span class=\"k\">return</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">array</span><span class=\"p\">([</span><span class=\"n\">x</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">],</span> <span class=\"n\">mu</span><span class=\"o\">*</span><span class=\"p\">(</span><span class=\"mi\">1</span> <span class=\"o\">-</span> <span class=\"n\">x</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">**</span><span class=\"mi\">2</span><span class=\"p\">)</span><span class=\"o\">*</span><span class=\"n\">x</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">-</span> <span class=\"n\">x</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]])</span><span class=\"w\">\n\n</span><span class=\"c1\">#analytical jacobian (optional)</span><span class=\"w\">\n</span><span class=\"k\">def</span><span class=\"w\"> </span><span class=\"nf\">jac</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">u</span><span class=\"p\">,</span> <span class=\"n\">t</span><span class=\"p\">):</span><span class=\"w\">\n</span>    <span class=\"k\">return</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">array</span><span class=\"p\">(</span><span class=\"w\">\n</span>        <span class=\"p\">[[</span><span class=\"mi\">0</span>                <span class=\"p\">,</span> <span class=\"mi\">1</span>               <span class=\"p\">],</span><span class=\"w\">\n</span>         <span class=\"p\">[</span><span class=\"o\">-</span><span class=\"n\">mu</span><span class=\"o\">*</span><span class=\"mi\">2</span><span class=\"o\">*</span><span class=\"n\">x</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">*</span><span class=\"n\">x</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">mu</span><span class=\"o\">*</span><span class=\"p\">(</span><span class=\"mi\">1</span> <span class=\"o\">-</span> <span class=\"n\">x</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">**</span><span class=\"mi\">2</span><span class=\"p\">)]]</span><span class=\"w\">\n</span>         <span class=\"p\">)</span><span class=\"w\">\n\n</span><span class=\"c1\">#finally the block</span><span class=\"w\">\n</span><span class=\"n\">vdp</span> <span class=\"o\">=</span> <span class=\"n\">ODE</span><span class=\"p\">(</span><span class=\"n\">func</span><span class=\"p\">,</span> <span class=\"n\">x0</span><span class=\"p\">,</span> <span class=\"n\">jac</span><span class=\"p\">)</span>\n</pre>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>func <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">callable</span></dt>\n<dd>right hand side function of ODE</dd>\n<dt>initial_value <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array[float]</span></dt>\n<dd>initial state / initial condition</dd>\n<dt>jac <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">callable, None</span></dt>\n<dd>jacobian of 'func' or 'None'</dd>\n</dl>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>op_dyn <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">DynamicOperator</span></dt>\n<dd>internal dynamic operator for ODE right hand side 'func'</dd>\n</dl>\n</div>\n",
          "source": "class ODE(Block):\n    \"\"\"Ordinary differential equation (ODE) defined by its right hand side function.\n\n    .. math::\n\n        \\\\begin{align}\n            \\\\dot{x}(t) &= \\\\mathrm{func}(x(t), u(t), t) \\\\\\\\\n                   y(t) &= x(t)\n        \\\\end{align}\n\n    with inhomogenity (input) `u` and state vector `x`. The function can be nonlinear \n    and the ODE can be of arbitrary order. The block utilizes the integration engine \n    to solve the ODE by integrating the `func`, which is the right hand side function.\n\n    Example\n    -------\n\n    For example a linear 1st order ODE:\n\n    .. code-block:: python\n\n        ode = ODE(lambda x, u, t: -x)\n\n    Or something more complex like the `Van der Pol` system, where it makes sense to \n    also specify the jacobian, which improves convergence for implicit solvers but is \n    not needed in most cases: \n\n    .. code-block:: python\n\n        import numpy as np\n\n        #initial condition\n        x0 = np.array([2, 0])\n\n        #van der Pol parameter\n        mu = 1000\n\n        def func(x, u, t):\n            return np.array([x[1], mu*(1 - x[0]**2)*x[1] - x[0]])\n\n        #analytical jacobian (optional)\n        def jac(x, u, t):\n            return np.array(\n                [[0                , 1               ], \n                 [-mu*2*x[0]*x[1]-1, mu*(1 - x[0]**2)]]\n                 )\n\n        #finally the block\n        vdp = ODE(func, x0, jac) \n\n    Parameters\n    ----------\n    func : callable\n        right hand side function of ODE\n    initial_value : array[float]\n        initial state / initial condition\n    jac : callable, None\n        jacobian of 'func' or 'None'\n\n    Attributes\n    ----------\n    op_dyn : DynamicOperator\n        internal dynamic operator for ODE right hand side 'func'\n    \"\"\"\n\n    def __init__(\n        self,\n        func=lambda x, u, t: -x,\n        initial_value=0.0,\n        jac=None\n        ):\n\n        super().__init__()\n\n        #right hand side function of ODE\n        self.func = func\n\n        #initial condition\n        self.initial_value = initial_value\n\n        #jacobian of 'func'\n        self.jac = jac\n\n        #operators\n        self.op_dyn = DynamicOperator(\n            func=func,\n            jac_x=jac\n            )\n\n\n    def __len__(self):\n        return 0\n\n\n    def update(self, t):\n        \"\"\"update system equation for fixed point loop, \n        here just setting the outputs\n\n        Note\n        ----\n        the ODE block has no direct passthrough, so the \n        'update' method is optimized for this case        \n\n        Parameters\n        ----------\n        t : float\n            evaluation time\n        \"\"\"\n        self.outputs.update_from_array(self.engine.state)\n\n\n    def solve(self, t, dt):\n        \"\"\"advance solution of implicit update equation of the solver\n\n        Parameters\n        ----------\n        t : float\n            evaluation time\n        dt : float\n            integration timestep\n\n        Returns\n        ------- \n        error : float\n            solver residual norm\n        \"\"\"\n        x, u = self.engine.state, self.inputs.to_array()\n        f, J = self.op_dyn(x, u, t), self.op_dyn.jac_x(x, u, t)\n        return self.engine.solve(f, J, dt)\n\n\n    def step(self, t, dt):\n        \"\"\"compute timestep update with integration engine\n\n        Parameters\n        ----------\n        t : float\n            evaluation time\n        dt : float\n            integration timestep\n\n        Returns\n        ------- \n        success : bool\n            step was successful\n        error : float\n            local truncation error from adaptive integrators\n        scale : float\n            timestep rescale from adaptive integrators\n        \"\"\"\n        x, u = self.engine.state, self.inputs.to_array()\n        f = self.op_dyn(x, u, t)\n        return self.engine.step(f, dt)",
          "bases": [
            "pathsim.blocks._block.Block"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(\n    self,\n    func=lambda x, u, t: -x,\n    initial_value=0.0,\n    jac=None\n    ):\n\n    super().__init__()\n\n    #right hand side function of ODE\n    self.func = func\n\n    #initial condition\n    self.initial_value = initial_value\n\n    #jacobian of 'func'\n    self.jac = jac\n\n    #operators\n    self.op_dyn = DynamicOperator(\n        func=func,\n        jac_x=jac\n        )",
              "signature": "(func = lambda x, u, t: -x, initial_value = 0.0, jac = None)",
              "parameters": [
                {
                  "name": "func",
                  "type": null,
                  "default": "lambda x, u, t: -x",
                  "description": ""
                },
                {
                  "name": "initial_value",
                  "type": null,
                  "default": "0.0",
                  "description": ""
                },
                {
                  "name": "jac",
                  "type": null,
                  "default": "None",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "update",
              "description": "update system equation for fixed point loop,",
              "docstring_html": "<p>update system equation for fixed point loop,\nhere just setting the outputs</p>\n<div class=\"section\" id=\"note\">\n<h4>Note</h4>\n<p>the ODE block has no direct passthrough, so the\n'update' method is optimized for this case</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time</dd>\n</dl>\n</div>\n",
              "source": "def update(self, t):\n    \"\"\"update system equation for fixed point loop, \n    here just setting the outputs\n\n    Note\n    ----\n    the ODE block has no direct passthrough, so the \n    'update' method is optimized for this case        \n\n    Parameters\n    ----------\n    t : float\n        evaluation time\n    \"\"\"\n    self.outputs.update_from_array(self.engine.state)",
              "signature": "(t)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "solve",
              "description": "advance solution of implicit update equation of the solver",
              "docstring_html": "<p>advance solution of implicit update equation of the solver</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time</dd>\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>integration timestep</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>error <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>solver residual norm</dd>\n</dl>\n",
              "source": "def solve(self, t, dt):\n    \"\"\"advance solution of implicit update equation of the solver\n\n    Parameters\n    ----------\n    t : float\n        evaluation time\n    dt : float\n        integration timestep\n\n    Returns\n    ------- \n    error : float\n        solver residual norm\n    \"\"\"\n    x, u = self.engine.state, self.inputs.to_array()\n    f, J = self.op_dyn(x, u, t), self.op_dyn.jac_x(x, u, t)\n    return self.engine.solve(f, J, dt)",
              "signature": "(t, dt)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time"
                },
                {
                  "name": "dt",
                  "type": null,
                  "default": null,
                  "description": "integration timestep"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "step",
              "description": "compute timestep update with integration engine",
              "docstring_html": "<p>compute timestep update with integration engine</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time</dd>\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>integration timestep</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>success <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>step was successful</dd>\n<dt>error <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>local truncation error from adaptive integrators</dd>\n<dt>scale <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>timestep rescale from adaptive integrators</dd>\n</dl>\n",
              "source": "def step(self, t, dt):\n    \"\"\"compute timestep update with integration engine\n\n    Parameters\n    ----------\n    t : float\n        evaluation time\n    dt : float\n        integration timestep\n\n    Returns\n    ------- \n    success : bool\n        step was successful\n    error : float\n        local truncation error from adaptive integrators\n    scale : float\n        timestep rescale from adaptive integrators\n    \"\"\"\n    x, u = self.engine.state, self.inputs.to_array()\n    f = self.op_dyn(x, u, t)\n    return self.engine.step(f, dt)",
              "signature": "(t, dt)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time"
                },
                {
                  "name": "dt",
                  "type": null,
                  "default": null,
                  "description": "integration timestep"
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "func",
              "description": "",
              "type": null,
              "value": "func"
            },
            {
              "name": "initial_value",
              "description": "",
              "type": null,
              "value": "initial_value"
            },
            {
              "name": "jac",
              "description": "",
              "type": null,
              "value": "jac"
            },
            {
              "name": "op_dyn",
              "description": "",
              "type": null,
              "value": "DynamicOperator(func=func, jac_x=jac)"
            }
          ],
          "parameters": [
            {
              "name": "func",
              "type": null,
              "default": "lambda x, u, t: -x",
              "description": "right hand side function of ODE"
            },
            {
              "name": "initial_value",
              "type": null,
              "default": "0.0",
              "description": "initial state / initial condition"
            },
            {
              "name": "jac",
              "type": null,
              "default": "None",
              "description": "jacobian of 'func' or 'None'"
            }
          ]
        }
      ],
      "functions": []
    },
    "pathsim.blocks.relay": {
      "name": "pathsim.blocks.relay",
      "description": "",
      "docstring_html": "",
      "classes": [
        {
          "name": "Relay",
          "description": "Relay block with hysteresis (Schmitt trigger).",
          "docstring_html": "<p>Relay block with hysteresis (Schmitt trigger).</p>\n<p>Switches output between two values based on input crossing upper and lower\nthresholds. The hysteresis prevents rapid switching when input is noisy.</p>\n<p>When input rises above <cite>threshold_up</cite>, output switches to <cite>value_up</cite>.\nWhen input falls below <cite>threshold_down</cite>, output switches to <cite>value_down</cite>.</p>\n<p><strong>Examples</strong></p>\n<p>Basic thermostat that turns heater on below 19°C, off above 21°C:</p>\n<pre class=\"code python literal-block\">\n<span class=\"kn\">from</span><span class=\"w\"> </span><span class=\"nn\">pathsim.blocks</span><span class=\"w\"> </span><span class=\"kn\">import</span> <span class=\"n\">Relay</span><span class=\"w\">\n\n</span><span class=\"n\">thermostat</span> <span class=\"o\">=</span> <span class=\"n\">Relay</span><span class=\"p\">(</span><span class=\"w\">\n</span>    <span class=\"n\">threshold_up</span><span class=\"o\">=</span><span class=\"mf\">21.0</span><span class=\"p\">,</span><span class=\"w\">\n</span>    <span class=\"n\">threshold_down</span><span class=\"o\">=</span><span class=\"mf\">19.0</span><span class=\"p\">,</span><span class=\"w\">\n</span>    <span class=\"n\">value_up</span><span class=\"o\">=</span><span class=\"mf\">0.0</span><span class=\"p\">,</span><span class=\"w\">\n</span>    <span class=\"n\">value_down</span><span class=\"o\">=</span><span class=\"mf\">1.0</span><span class=\"w\">\n</span>    <span class=\"p\">)</span>\n</pre>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>threshold_up <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>threshold for transitioning to upper relay state <cite>value_up</cite> (default: 1.0)</dd>\n<dt>threshold_down <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>threshold for transitioning to lower relay state <cite>value_down</cite> (default: 0.0)</dd>\n<dt>value_up <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>value for upper relay state (default: 1.0)</dd>\n<dt>value_down <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>value for lower relay state (default: 0.0)</dd>\n</dl>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>events <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">list[ZeroCrossingUp, ZeroCrossingDown]</span></dt>\n<dd>internal zero crossing events for relay state transitions</dd>\n</dl>\n",
          "source": "class Relay(Block):\n    \"\"\"Relay block with hysteresis (Schmitt trigger).\n\n    Switches output between two values based on input crossing upper and lower \n    thresholds. The hysteresis prevents rapid switching when input is noisy.\n\n    When input rises above `threshold_up`, output switches to `value_up`.\n    When input falls below `threshold_down`, output switches to `value_down`.\n\n    Examples\n    --------\n    Basic thermostat that turns heater on below 19°C, off above 21°C:\n\n    .. code-block:: python\n\n        from pathsim.blocks import Relay\n\n        thermostat = Relay(\n            threshold_up=21.0, \n            threshold_down=19.0,\n            value_up=0.0, \n            value_down=1.0\n            )\n\n    Parameters\n    ----------\n    threshold_up : float\n        threshold for transitioning to upper relay state `value_up` (default: 1.0)\n    threshold_down : float\n        threshold for transitioning to lower relay state `value_down` (default: 0.0)\n    value_up : float\n        value for upper relay state (default: 1.0)\n    value_down : float\n        value for lower relay state (default: 0.0)\n\n    Attributes\n    ----------\n    events : list[ZeroCrossingUp, ZeroCrossingDown]\n        internal zero crossing events for relay state transitions\n    \"\"\"\n\n    input_port_labels = {\"in\":0}\n    output_port_labels = {\"out\":0}\n\n    def __init__(\n        self, \n        threshold_up=1.0, \n        threshold_down=0.0, \n        value_up=1.0, \n        value_down=0.0\n        ):\n        super().__init__()\n\n        # block params\n        self.threshold_up = threshold_up \n        self.threshold_down = threshold_down \n        self.value_up = value_up \n        self.value_down = value_down \n\n        # internal event function factories\n        def _check(val):\n            return lambda t: self.inputs[0] - val\n        def _set(val):\n            def __set(t):\n                self.outputs[0] = val\n            return __set \n\n        # internal events for transition detection\n        self.events = [\n            ZeroCrossingUp(\n                func_evt=_check(self.threshold_up),\n                func_act=_set(self.value_up)\n                ),\n            ZeroCrossingDown(\n                func_evt=_check(self.threshold_down),\n                func_act=_set(self.value_down)\n                ),\n            ]\n\n\n    def __len__(self):\n        \"\"\"This block has no direct passthrough\"\"\"\n        return 0\n\n\n    def update(self, t):\n        \"\"\"update system equation for fixed point loop, \n        here just setting the outputs\n\n        Note\n        ----\n        No pasthrough, setting block outputs is done \n        by the internal events.\n\n        Parameters\n        ----------\n        t : float\n            evaluation time\n        \"\"\"\n        pass",
          "bases": [
            "pathsim.blocks._block.Block"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(\n    self, \n    threshold_up=1.0, \n    threshold_down=0.0, \n    value_up=1.0, \n    value_down=0.0\n    ):\n    super().__init__()\n\n    # block params\n    self.threshold_up = threshold_up \n    self.threshold_down = threshold_down \n    self.value_up = value_up \n    self.value_down = value_down \n\n    # internal event function factories\n    def _check(val):\n        return lambda t: self.inputs[0] - val\n    def _set(val):\n        def __set(t):\n            self.outputs[0] = val\n        return __set \n\n    # internal events for transition detection\n    self.events = [\n        ZeroCrossingUp(\n            func_evt=_check(self.threshold_up),\n            func_act=_set(self.value_up)\n            ),\n        ZeroCrossingDown(\n            func_evt=_check(self.threshold_down),\n            func_act=_set(self.value_down)\n            ),\n        ]",
              "signature": "(threshold_up = 1.0, threshold_down = 0.0, value_up = 1.0, value_down = 0.0)",
              "parameters": [
                {
                  "name": "threshold_up",
                  "type": null,
                  "default": "1.0",
                  "description": ""
                },
                {
                  "name": "threshold_down",
                  "type": null,
                  "default": "0.0",
                  "description": ""
                },
                {
                  "name": "value_up",
                  "type": null,
                  "default": "1.0",
                  "description": ""
                },
                {
                  "name": "value_down",
                  "type": null,
                  "default": "0.0",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "update",
              "description": "update system equation for fixed point loop,",
              "docstring_html": "<p>update system equation for fixed point loop,\nhere just setting the outputs</p>\n<div class=\"section\" id=\"note\">\n<h4>Note</h4>\n<p>No pasthrough, setting block outputs is done\nby the internal events.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time</dd>\n</dl>\n</div>\n",
              "source": "def update(self, t):\n    \"\"\"update system equation for fixed point loop, \n    here just setting the outputs\n\n    Note\n    ----\n    No pasthrough, setting block outputs is done \n    by the internal events.\n\n    Parameters\n    ----------\n    t : float\n        evaluation time\n    \"\"\"\n    pass",
              "signature": "(t)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time"
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "input_port_labels",
              "description": "",
              "type": null,
              "value": "{'in': 0}"
            },
            {
              "name": "output_port_labels",
              "description": "",
              "type": null,
              "value": "{'out': 0}"
            },
            {
              "name": "threshold_up",
              "description": "",
              "type": null,
              "value": "threshold_up"
            },
            {
              "name": "threshold_down",
              "description": "",
              "type": null,
              "value": "threshold_down"
            },
            {
              "name": "value_up",
              "description": "",
              "type": null,
              "value": "value_up"
            },
            {
              "name": "value_down",
              "description": "",
              "type": null,
              "value": "value_down"
            },
            {
              "name": "events",
              "description": "",
              "type": null,
              "value": "[ZeroCrossingUp(func_evt=(_check(self.threshold_up)), func_act=(_set(self.value_up))), ZeroCrossingDown(func_evt=(_check(self.threshold_down)), func_act=(_set(self.value_down)))]"
            }
          ],
          "parameters": [
            {
              "name": "threshold_up",
              "type": null,
              "default": "1.0",
              "description": "threshold for transitioning to upper relay state `value_up` (default: 1.0)"
            },
            {
              "name": "threshold_down",
              "type": null,
              "default": "0.0",
              "description": "threshold for transitioning to lower relay state `value_down` (default: 0.0)"
            },
            {
              "name": "value_up",
              "type": null,
              "default": "1.0",
              "description": "value for upper relay state (default: 1.0)"
            },
            {
              "name": "value_down",
              "type": null,
              "default": "0.0",
              "description": "value for lower relay state (default: 0.0)"
            }
          ]
        }
      ],
      "functions": []
    },
    "pathsim.blocks.rf": {
      "name": "pathsim.blocks.rf",
      "description": "",
      "docstring_html": "",
      "classes": [
        {
          "name": "RFNetwork",
          "description": "N-port RF network linear time invariant (LTI) multi input multi output (MIMO) state-space model.",
          "docstring_html": "<p>N-port RF network linear time invariant (LTI) multi input multi output (MIMO) state-space model.</p>\n<p>Uses Vector Fitting for rational approximation of the frequency response using poles and residues.\nThe resulting approximation has guaranteed stable poles that are real or come in complex conjugate pairs.</p>\n<p>Assumes N inputs and N outputs, where N is the number of ports of the RF network.</p>\n<div class=\"section\" id=\"note\">\n<h4>Note</h4>\n<p>This block requires scikit-rf <a class=\"citation-reference\" href=\"#skrf\" id=\"citation-reference-1\">[skrf]</a> to be installed. Its an optional dependency of pathsim,\nto install it:</p>\n<pre class=\"code literal-block\">\npip install scikit-rf\n</pre>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>ntwk <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">can be :py:class:`~skrf.network.Network`, str, Path, or file-object.</span></dt>\n<dd>scikit-rf <a class=\"citation-reference\" href=\"#skrf\" id=\"citation-reference-2\">[skrf]</a> RF Network object, or file to load information from.\nSupported formats are touchstone file V1 (.s?p) or V2 (.ts).</dd>\n</dl>\n<p><strong>References</strong></p>\n<table class=\"docutils citation\" frame=\"void\" id=\"skrf\" rules=\"none\">\n<colgroup><col class=\"label\" /><col /></colgroup>\n<tbody valign=\"top\">\n<tr><td class=\"label\">[skrf]</td><td><em>(<a class=\"fn-backref\" href=\"#citation-reference-1\">1</a>, <a class=\"fn-backref\" href=\"#citation-reference-2\">2</a>)</em> scikit-rf webpage <a class=\"reference external\" href=\"https://scikit-rf.org/\">https://scikit-rf.org/</a></td></tr>\n</tbody>\n</table>\n</div>\n",
          "source": "class RFNetwork(StateSpace):\n    \"\"\"N-port RF network linear time invariant (LTI) multi input multi output (MIMO) state-space model.\n\n    Uses Vector Fitting for rational approximation of the frequency response using poles and residues.\n    The resulting approximation has guaranteed stable poles that are real or come in complex conjugate pairs.\n\n    Assumes N inputs and N outputs, where N is the number of ports of the RF network.\n\n    Note\n    ----\n    This block requires scikit-rf [skrf]_ to be installed. Its an optional dependency of pathsim,\n    to install it:\n\n    .. code-block::\n\n        pip install scikit-rf\n\n    Parameters\n    ----------\n    ntwk : can be :py:class:`~skrf.network.Network`, str, Path, or file-object.\n        scikit-rf [skrf]_ RF Network object, or file to load information from.\n        Supported formats are touchstone file V1 (.s?p) or V2 (.ts).\n\n    References\n    ----------\n    .. [skrf] scikit-rf webpage https://scikit-rf.org/\n\n    \"\"\"\n\n    def __init__(self, ntwk: NetworkType | str | Path, auto_fit: bool = True, **kwargs):\n        # Check if 'skrf' is installed, its an optional dependency,\n        # dont raise error at import but at initialization\n        if not HAS_SKRF:\n            _msg = \"The scikit-rf package is required to use this block -> 'pip install scikit-rf'\"\n            raise ImportError(_msg)\n\n        if isinstance(ntwk, Path) or isinstance(ntwk, str):\n            ntwk = rf.Network(ntwk)\n\n        # Select the vector fitting function from scikit-rf\n        vf_fun_name = \"auto_fit\" if auto_fit else \"vector_fit\"\n        vf_fun = getattr(rf.VectorFitting, vf_fun_name)\n        # Filter kwargs for the selected vf function\n        vf_fun_keys = signature(vf_fun).parameters\n        vf_kwargs = {k: v for k, v in kwargs.items() if k in vf_fun_keys}\n        # Apply vector fitting\n        vf = rf.VectorFitting(ntwk)\n        getattr(vf, vf_fun_name)(**vf_kwargs)\n        A, B, C, D, _ = vf._get_ABCDE()\n        # keep a copy of the network and VF\n        self.network = ntwk\n        self.vf = vf\n\n        super().__init__(A, B, C, D)\n\n    def s(self, freqs: np.ndarray) -> np.ndarray:\n        \"\"\"\n        S-matrix of the vector fitted N-port model calculated from its state-space representation.\n\n        Parameters\n        ----------\n        freqs : :py:class:`~numpy.ndarray`\n            Frequencies (in Hz) at which to calculate the S-matrices.\n\n        Returns\n        -------\n        s : :py:class:`~numpy.ndarray`\n            Complex-valued S-matrices (fxNxN) calculated at frequencies `freqs`.\n        \"\"\"\n        return rf.VectorFitting._get_s_from_ABCDE(\n            freqs, self.A, self.B, self.C, self.D, 0\n        )",
          "bases": [
            "pathsim.blocks.lti.StateSpace"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, ntwk: NetworkType | str | Path, auto_fit: bool = True, **kwargs):\n    # Check if 'skrf' is installed, its an optional dependency,\n    # dont raise error at import but at initialization\n    if not HAS_SKRF:\n        _msg = \"The scikit-rf package is required to use this block -> 'pip install scikit-rf'\"\n        raise ImportError(_msg)\n\n    if isinstance(ntwk, Path) or isinstance(ntwk, str):\n        ntwk = rf.Network(ntwk)\n\n    # Select the vector fitting function from scikit-rf\n    vf_fun_name = \"auto_fit\" if auto_fit else \"vector_fit\"\n    vf_fun = getattr(rf.VectorFitting, vf_fun_name)\n    # Filter kwargs for the selected vf function\n    vf_fun_keys = signature(vf_fun).parameters\n    vf_kwargs = {k: v for k, v in kwargs.items() if k in vf_fun_keys}\n    # Apply vector fitting\n    vf = rf.VectorFitting(ntwk)\n    getattr(vf, vf_fun_name)(**vf_kwargs)\n    A, B, C, D, _ = vf._get_ABCDE()\n    # keep a copy of the network and VF\n    self.network = ntwk\n    self.vf = vf\n\n    super().__init__(A, B, C, D)",
              "signature": "(ntwk: NetworkType | str | Path, auto_fit: bool = True, kwargs = {})",
              "parameters": [
                {
                  "name": "ntwk",
                  "type": "NetworkType | str | Path",
                  "default": null,
                  "description": ""
                },
                {
                  "name": "auto_fit",
                  "type": "bool",
                  "default": "True",
                  "description": ""
                },
                {
                  "name": "kwargs",
                  "type": null,
                  "default": "{}",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "s",
              "description": "S-matrix of the vector fitted N-port model calculated from its state-space representation.",
              "docstring_html": "<p>S-matrix of the vector fitted N-port model calculated from its state-space representation.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>freqs <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">:py:class:`~numpy.ndarray`</span></dt>\n<dd>Frequencies (in Hz) at which to calculate the S-matrices.</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>s <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">:py:class:`~numpy.ndarray`</span></dt>\n<dd>Complex-valued S-matrices (fxNxN) calculated at frequencies <cite>freqs</cite>.</dd>\n</dl>\n",
              "source": "def s(self, freqs: np.ndarray) -> np.ndarray:\n    \"\"\"\n    S-matrix of the vector fitted N-port model calculated from its state-space representation.\n\n    Parameters\n    ----------\n    freqs : :py:class:`~numpy.ndarray`\n        Frequencies (in Hz) at which to calculate the S-matrices.\n\n    Returns\n    -------\n    s : :py:class:`~numpy.ndarray`\n        Complex-valued S-matrices (fxNxN) calculated at frequencies `freqs`.\n    \"\"\"\n    return rf.VectorFitting._get_s_from_ABCDE(\n        freqs, self.A, self.B, self.C, self.D, 0\n    )",
              "signature": "(freqs: np.ndarray)",
              "parameters": [
                {
                  "name": "freqs",
                  "type": "np.ndarray",
                  "default": null,
                  "description": "Frequencies (in Hz) at which to calculate the S-matrices."
                }
              ],
              "returns": "np.ndarray",
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "network",
              "description": "",
              "type": null,
              "value": "ntwk"
            },
            {
              "name": "vf",
              "description": "",
              "type": null,
              "value": "vf"
            }
          ],
          "parameters": [
            {
              "name": "ntwk",
              "type": "NetworkType | str | Path",
              "default": null,
              "description": "scikit-rf [skrf]_ RF Network object, or file to load information from. Supported formats are touchstone file V1 (.s?p) or V2 (.ts)."
            },
            {
              "name": "auto_fit",
              "type": "bool",
              "default": "True",
              "description": ""
            },
            {
              "name": "kwargs",
              "type": null,
              "default": "{}",
              "description": ""
            }
          ]
        }
      ],
      "functions": []
    },
    "pathsim.blocks.rng": {
      "name": "pathsim.blocks.rng",
      "description": "",
      "docstring_html": "",
      "classes": [
        {
          "name": "RandomNumberGenerator",
          "description": "Generates a random output value using `numpy.random.rand`.",
          "docstring_html": "<p>Generates a random output value using <cite>numpy.random.rand</cite>.</p>\n<p>If no <cite>sampling_period</cite> (None) is specified, every simulation timestep gets\na random value. Otherwise an internal <cite>Schedule</cite> event is used to periodically\nsample a random value and set the output like a zero-order-hold stage.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>sampling_period <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float, None</span></dt>\n<dd>time between random samples</dd>\n</dl>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>_sample <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>internal random number state in case that\nno <cite>sampling_period</cite> is provided</dd>\n<dt>Evt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">Schedule</span></dt>\n<dd>internal event that periodically samples a random\nvalue in case <cite>sampling_period</cite> is provided</dd>\n</dl>\n",
          "source": "class RandomNumberGenerator(Block):\n    \"\"\"Generates a random output value using `numpy.random.rand`.\n\n    If no `sampling_period` (None) is specified, every simulation timestep gets\n    a random value. Otherwise an internal `Schedule` event is used to periodically\n    sample a random value and set the output like a zero-order-hold stage.\n\n    Parameters\n    ----------\n    sampling_period : float, None\n        time between random samples\n\n    Attributes\n    ----------\n    _sample : float\n        internal random number state in case that\n        no `sampling_period` is provided\n    Evt : Schedule\n        internal event that periodically samples a random\n        value in case `sampling_period` is provided\n    \"\"\"\n\n    input_port_labels = {}\n    output_port_labels = {\"out\":0}\n\n    def __init__(self, sampling_period=None):\n        super().__init__()\n\n        #block parameter\n        self.sampling_period = sampling_period \n\n        #sampling produces discrete time behavior\n        if sampling_period is None:\n\n            #initial sample for non-discrete block\n            self._sample = np.random.rand()\n\n        else:\n\n            #internal scheduled list event\n            def _set(t):\n                self.outputs[0] = np.random.rand()\n\n            self.Evt = Schedule(\n                t_start=0,\n                t_period=sampling_period,\n                func_act=_set\n                )\n            self.events = [self.Evt]\n\n\n    def update(self, t):\n        \"\"\"Setting output with random sample in case\n        of `sampling_period==None`, otherwise does nothing.\n\n        Parameters\n        ----------\n        t : float\n            evaluation time\n        \"\"\"\n        if self.sampling_period is None:\n            self.outputs[0] = self._sample\n\n\n    def sample(self, t, dt):\n        \"\"\"Generating a new random sample at each timestep\n        in case of `sampling_period==None`, otherwise does nothing.\n\n        Parameters\n        ----------\n        t : float\n            evaluation time\n        dt : float\n            integration timestep\n        \"\"\"\n        if self.sampling_period is None:\n            self._sample = np.random.rand()\n\n\n    def __len__(self):\n        \"\"\"Essentially a source-like block without passthrough\"\"\"\n        return 0",
          "bases": [
            "pathsim.blocks._block.Block"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, sampling_period=None):\n    super().__init__()\n\n    #block parameter\n    self.sampling_period = sampling_period \n\n    #sampling produces discrete time behavior\n    if sampling_period is None:\n\n        #initial sample for non-discrete block\n        self._sample = np.random.rand()\n\n    else:\n\n        #internal scheduled list event\n        def _set(t):\n            self.outputs[0] = np.random.rand()\n\n        self.Evt = Schedule(\n            t_start=0,\n            t_period=sampling_period,\n            func_act=_set\n            )\n        self.events = [self.Evt]",
              "signature": "(sampling_period = None)",
              "parameters": [
                {
                  "name": "sampling_period",
                  "type": null,
                  "default": "None",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "update",
              "description": "Setting output with random sample in case",
              "docstring_html": "<p>Setting output with random sample in case\nof <cite>sampling_period==None</cite>, otherwise does nothing.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time</dd>\n</dl>\n",
              "source": "def update(self, t):\n    \"\"\"Setting output with random sample in case\n    of `sampling_period==None`, otherwise does nothing.\n\n    Parameters\n    ----------\n    t : float\n        evaluation time\n    \"\"\"\n    if self.sampling_period is None:\n        self.outputs[0] = self._sample",
              "signature": "(t)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "sample",
              "description": "Generating a new random sample at each timestep",
              "docstring_html": "<p>Generating a new random sample at each timestep\nin case of <cite>sampling_period==None</cite>, otherwise does nothing.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time</dd>\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>integration timestep</dd>\n</dl>\n",
              "source": "def sample(self, t, dt):\n    \"\"\"Generating a new random sample at each timestep\n    in case of `sampling_period==None`, otherwise does nothing.\n\n    Parameters\n    ----------\n    t : float\n        evaluation time\n    dt : float\n        integration timestep\n    \"\"\"\n    if self.sampling_period is None:\n        self._sample = np.random.rand()",
              "signature": "(t, dt)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time"
                },
                {
                  "name": "dt",
                  "type": null,
                  "default": null,
                  "description": "integration timestep"
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "input_port_labels",
              "description": "",
              "type": null,
              "value": "{}"
            },
            {
              "name": "output_port_labels",
              "description": "",
              "type": null,
              "value": "{'out': 0}"
            },
            {
              "name": "sampling_period",
              "description": "",
              "type": null,
              "value": "sampling_period"
            },
            {
              "name": "_sample",
              "description": "",
              "type": null,
              "value": "np.random.rand()"
            },
            {
              "name": "Evt",
              "description": "",
              "type": null,
              "value": "Schedule(t_start=0, t_period=sampling_period, func_act=_set)"
            },
            {
              "name": "events",
              "description": "",
              "type": null,
              "value": "[self.Evt]"
            }
          ],
          "parameters": [
            {
              "name": "sampling_period",
              "type": null,
              "default": "None",
              "description": "time between random samples"
            }
          ]
        },
        {
          "name": "RNG",
          "description": "Alias for RandomNumberGenerator.",
          "docstring_html": "<p>Alias for RandomNumberGenerator.</p>\n",
          "source": "@deprecated(version=\"1.0.0\", replacement=\"RandomNumberGenerator\")\nclass RNG(RandomNumberGenerator):\n    \"\"\"Alias for RandomNumberGenerator.\"\"\"\n    pass",
          "bases": [
            "pathsim.blocks.rng.RandomNumberGenerator"
          ],
          "methods": [],
          "attributes": [],
          "parameters": []
        }
      ],
      "functions": []
    },
    "pathsim.blocks.samplehold": {
      "name": "pathsim.blocks.samplehold",
      "description": "",
      "docstring_html": "",
      "classes": [
        {
          "name": "SampleHold",
          "description": "Samples the inputs periodically and produces them at the output.",
          "docstring_html": "<p>Samples the inputs periodically and produces them at the output.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>T <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>sampling period</dd>\n<dt>tau <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>delay</dd>\n</dl>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>events <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">list[Schedule]</span></dt>\n<dd>internal scheduled event for periodic sampling</dd>\n</dl>\n",
          "source": "class SampleHold(Block):\n    \"\"\"Samples the inputs periodically and produces them at the output.\n\n    Parameters\n    ----------\n    T : float\n        sampling period\n    tau : float\n        delay \n\n    Attributes\n    ----------\n    events : list[Schedule]\n        internal scheduled event for periodic sampling\n    \"\"\"\n\n    def __init__(self, T=1, tau=0):\n        super().__init__()\n\n        self.T   = T\n        self.tau = tau\n\n        def _sample(t):\n            self.outputs.update_from_array(\n                self.inputs.to_array()\n                )\n\n        #internal scheduled events\n        self.events = [\n            Schedule(\n                t_start=tau,\n                t_period=T,\n                func_act=_sample\n                ),\n            ]\n\n    def __len__(self):\n        return 0",
          "bases": [
            "pathsim.blocks._block.Block"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, T=1, tau=0):\n    super().__init__()\n\n    self.T   = T\n    self.tau = tau\n\n    def _sample(t):\n        self.outputs.update_from_array(\n            self.inputs.to_array()\n            )\n\n    #internal scheduled events\n    self.events = [\n        Schedule(\n            t_start=tau,\n            t_period=T,\n            func_act=_sample\n            ),\n        ]",
              "signature": "(T = 1, tau = 0)",
              "parameters": [
                {
                  "name": "T",
                  "type": null,
                  "default": "1",
                  "description": ""
                },
                {
                  "name": "tau",
                  "type": null,
                  "default": "0",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "T",
              "description": "",
              "type": null,
              "value": "T"
            },
            {
              "name": "tau",
              "description": "",
              "type": null,
              "value": "tau"
            },
            {
              "name": "events",
              "description": "",
              "type": null,
              "value": "[Schedule(t_start=tau, t_period=T, func_act=_sample)]"
            }
          ],
          "parameters": [
            {
              "name": "T",
              "type": null,
              "default": "1",
              "description": "sampling period"
            },
            {
              "name": "tau",
              "type": null,
              "default": "0",
              "description": "delay Attributes ----------"
            }
          ]
        }
      ],
      "functions": []
    },
    "pathsim.blocks.scope": {
      "name": "pathsim.blocks.scope",
      "description": "",
      "docstring_html": "",
      "classes": [
        {
          "name": "Scope",
          "description": "Block for recording time domain data with variable sampling period.",
          "docstring_html": "<p>Block for recording time domain data with variable sampling period.</p>\n<p>A time threshold can be set by <cite>t_wait</cite> to start recording data after the simulation\ntime is larger then the specified waiting time, i.e. <cite>t - t_wait &gt; 0</cite>.\nThis is useful for recording data only after all the transients have settled.</p>\n<p>The block uses an internal <cite>Schedule</cite> event, when <cite>sampling_period</cite> is provided,\notherwise it just samples at every simulation timestep.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>sampling_period <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float, None</span></dt>\n<dd>time between samples, default is every timestep</dd>\n<dt>t_wait <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>wait time before starting recording, optional</dd>\n<dt>labels <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">list[str]</span></dt>\n<dd>labels for the scope traces, and for the csv, optional</dd>\n</dl>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>recording_time <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">list[float]</span></dt>\n<dd>recorded time points</dd>\n<dt>recording_data <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">list[float]</span></dt>\n<dd>recorded data points</dd>\n<dt>_incremental_idx <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>index for incremental reading of accumulated data since last\ncall of incremental read</dd>\n<dt>_sample_next_timestep <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>flag to indicate this is a timestep to sample, only used for\nevent based sampling when <cite>sampling_period</cite> is provided as an arg</dd>\n<dt>events <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">list[Schedule]</span></dt>\n<dd>internal scheduled event for periodic input sampling when\n<cite>sampling_period</cite> is provided</dd>\n</dl>\n",
          "source": "class Scope(Block):\n    \"\"\"Block for recording time domain data with variable sampling period.\n\n    A time threshold can be set by `t_wait` to start recording data after the simulation\n    time is larger then the specified waiting time, i.e. `t - t_wait > 0`.\n    This is useful for recording data only after all the transients have settled.\n\n    The block uses an internal `Schedule` event, when `sampling_period` is provided,\n    otherwise it just samples at every simulation timestep.\n\n    Parameters\n    ----------\n    sampling_period : float, None\n        time between samples, default is every timestep\n    t_wait : float\n        wait time before starting recording, optional\n    labels : list[str]\n        labels for the scope traces, and for the csv, optional\n\n    Attributes\n    ----------\n    recording_time : list[float]\n        recorded time points\n    recording_data : list[float]\n        recorded data points\n    _incremental_idx : int\n        index for incremental reading of accumulated data since last\n        call of incremental read\n    _sample_next_timestep : bool\n        flag to indicate this is a timestep to sample, only used for\n        event based sampling when `sampling_period` is provided as an arg\n    events : list[Schedule]\n        internal scheduled event for periodic input sampling when\n        `sampling_period` is provided\n    \"\"\"\n\n    input_port_labels = None\n    output_port_labels = {}\n\n    def __init__(self, sampling_period=None, t_wait=0.0, labels=None):\n        super().__init__()\n\n        #time delay until start recording\n        self.t_wait = t_wait\n\n        #params for sampling\n        self.sampling_period = sampling_period\n\n        #labels for plotting and saving data\n        self.labels = labels if labels is not None else []\n\n        #set recording data and time\n        self.recording_time = []\n        self.recording_data = []\n\n        #initial index for incremental reading\n        self._incremental_idx = 0\n\n        #sampling produces discrete time behavior\n        if not (sampling_period is None):\n\n            #flag to indicate this is a timestep to sample\n            self._sample_next_timestep = False\n\n            #internal scheduled list event\n            def _sample(t):\n                self._sample_next_timestep = True\n\n            self.events = [\n                Schedule(\n                    t_start=t_wait,\n                    t_period=sampling_period,\n                    func_act=_sample\n                    )\n            ]\n\n\n    def __len__(self):\n        return 0\n\n\n    def reset(self):\n        super().reset()\n\n        #reset recording data and time\n        self.recording_time.clear()\n        self.recording_data.clear()\n\n        #reset index for incremental read\n        self._incremental_idx = 0\n\n\n    def read(self, incremental=False):\n        \"\"\"Return the recorded time domain data and the corresponding \n        time for all input ports\n\n        Parameters\n        ----------\n        incremental : bool\n            read the data incrementally, only return new data \n            that has accumulated after the last incremental read call\n\n        Returns\n        -------\n        time : array[float]\n            recorded time points\n        data : array[obj]\n            recorded data points\n        \"\"\"\n\n        #just return 'None' if no recording available\n        if not self.recording_time or not self.recording_data: \n            return None, None\n\n        #return accumulated data since last incremental call\n        if incremental:\n\n            _idx, self._incremental_idx = self._incremental_idx, len(self.recording_time)\n\n            #no data accumulated -> exit same as empty recording\n            if _idx == self._incremental_idx:\n                return None, None\n\n            return np.array(self.recording_time[_idx:]), np.array(self.recording_data[_idx:]).T\n\n        return np.array(self.recording_time), np.array(self.recording_data).T\n\n\n    @deprecated(version=\"1.0.0\", reason=\"its against pathsims philosophy\")\n    def collect(self):\n        \"\"\"Yield (category, id, data) tuples for recording blocks to simplify \n        global data collection from all recording blocks.\n        \"\"\"\n        time, data = self.read()\n        if data is not None:\n            yield (\n                \"scope\", \n                id(self), \n                {\n                    \"time\": time,\n                    \"data\": data,\n                    \"labels\": self.labels,\n                    }\n                )\n\n\n    def sample(self, t, dt):\n        \"\"\"Sample the data from all inputs. Skips duplicate timestamps to maintain\n        unique time points in the recording.\n\n        If `sampling_period` is provided, this depends on the flag `_sample_next_timestep`,\n        set by the internal `Schedule` event.\n\n        Parameters\n        ----------\n        t : float\n            evaluation time for sampling\n        \"\"\"\n        #determine if we should sample\n        if self.sampling_period is None:\n            should_sample = t >= self.t_wait\n        elif self._sample_next_timestep:\n            should_sample = True\n            self._sample_next_timestep = False\n        else:\n            should_sample = False\n\n        if not should_sample:\n            return\n\n        #skip duplicate timestamps (can happen when continuing simulation)\n        if self.recording_time and self.recording_time[-1] == t:\n            return\n\n        self.recording_time.append(t)\n        self.recording_data.append(self.inputs.to_array())\n\n\n    def plot(self, *args, **kwargs):\n        \"\"\"Directly create a plot of the recorded data for quick visualization and debugging.\n\n        Parameters\n        ----------\n        args : tuple\n            args for ax.plot\n        kwargs : dict\n            kwargs for ax.plot\n\n        Returns\n        -------\n        fig : matplotlib.figure\n            internal figure instance\n        ax : matplotlib.axis\n            internal axis instance\n        \"\"\" \n\n        #get data\n        time, data = self.read() \n\n        #just return 'None' if no recording available\n        if time is None:\n            warnings.warn(\"no recording available for plotting in 'Scope.plot'\")\n            return None, None\n\n        #initialize figure\n        fig, ax = plt.subplots(nrows=1, ncols=1, figsize=(8,4), tight_layout=True, dpi=120)\n\n        #custom colors\n        ax.set_prop_cycle(color=COLORS_ALL)\n\n        #plot the recorded data\n        for p, d in enumerate(data):\n            lb = self.labels[p] if p < len(self.labels) else f\"port {p}\"\n            ax.plot(time, d, *args, **kwargs, label=lb)\n\n        #legend labels from ports\n        ax.legend(fancybox=False)\n\n        #other plot settings\n        ax.set_xlabel(\"time [s]\")\n        ax.grid()\n\n        # Legend picking functionality\n        lines = ax.get_lines()  # Get the lines from the plot\n        leg = ax.get_legend()   # Get the legend\n\n        # Map legend lines to original plot lines\n        lined = dict()  \n        for legline, origline in zip(leg.get_lines(), lines):\n            # Enable picking within 5 points tolerance\n            legline.set_picker(5)  \n            lined[legline] = origline\n\n        def on_pick(event):\n            legline = event.artist\n            origline = lined[legline]\n            visible = not origline.get_visible()\n            origline.set_visible(visible)\n            legline.set_alpha(1.0 if visible else 0.2)\n            # Redraw the figure\n            fig.canvas.draw()  \n\n        #enable picking\n        fig.canvas.mpl_connect(\"pick_event\", on_pick)\n\n        #show the plot without blocking following code\n        plt.show(block=False)\n\n        #return figure and axis for outside manipulation\n        return fig, ax\n\n\n    def plot2D(self, *args, axes=(0, 1), **kwargs):\n        \"\"\"Directly create a 2D plot of the recorded data for quick visualization and debugging.\n\n        Parameters\n        ----------\n        args : tuple\n            args for ax.plot\n        axes : tuple[int]\n            axes / ports to select for 2d plot\n        kwargs : dict\n            kwargs for ax.plot\n\n        Returns\n        -------\n        fig : matplotlib.figure\n            internal figure instance\n        ax : matplotlib.axis\n            internal axis instance\n        \"\"\" \n\n        #get data\n        time, data = self.read() \n\n        #just return 'None' if no recording available\n        if time is None:\n            warnings.warn(\"no recording available for plotting in 'Scope.plot2D'\")\n            return None, None\n\n        #not enough channels -> early exit\n        if len(data) < 2 or len(axes) != 2:\n            warnings.warn(\"not enough channels for plotting in 'Scope.plot2D'\")\n            return None, None\n\n        #axes selected not available -> early exit\n        ax1_idx, ax2_idx = axes\n        if not (0 <= ax1_idx < data.shape[0] and 0 <= ax2_idx < data.shape[0]):\n             warnings.warn(f\"Selected axes {axes} out of bounds for data shape {data.shape}\")\n             return None, None \n\n        #initialize figure\n        fig, ax = plt.subplots(nrows=1, ncols=1, figsize=(4, 4), tight_layout=True, dpi=120)\n\n        #custom colors\n        ax.set_prop_cycle(color=COLORS_ALL)\n\n        #unpack data for selected axes\n        d1 = data[ax1_idx]\n        d2 = data[ax2_idx]\n\n        #plot the data\n        ax.plot(d1, d2, *args, **kwargs)\n\n        #axis labels\n        l1 = self.labels[ax1_idx] if ax1_idx < len(self.labels) else f\"port {ax1_idx}\"\n        l2 = self.labels[ax2_idx] if ax2_idx < len(self.labels) else f\"port {ax2_idx}\"\n        ax.set_xlabel(l1)\n        ax.set_ylabel(l2)\n\n        ax.grid()\n\n        #show the plot without blocking following code\n        plt.show(block=False)\n\n        #return figure and axis for outside manipulation\n        return fig, ax\n\n\n    def plot3D(self, *args, axes=(0, 1, 2), **kwargs):\n        \"\"\"Directly create a 3D plot of the recorded data for quick visualization.\n\n        Parameters\n        ----------\n        args : tuple\n            args for ax.plot\n        axes : tuple[int]\n            indices of the three data channels (ports) to plot (default: (0, 1, 2)).\n        kwargs : dict\n            kwargs for ax.plot\n\n        Returns\n        -------\n        fig : matplotlib.figure\n            internal figure instance.\n        ax : matplotlib.axes._axes.Axes3D\n            internal 3D axis instance.\n        \"\"\"\n\n        #get data\n        time, data = self.read() \n\n        #just return 'None' if no recording available\n        if time is None:\n            warnings.warn(\"no recording available for plotting in 'Scope.plot3D'\")\n            return None, None\n\n        #check if enough channels are available\n        if data.shape[0] < 3 or len(axes) != 3:\n            warnings.warn(f\"Need at least 3 channels for plot3D, got {data.shape[0]}. Or axes argument length is not 3.\")\n            return None, None\n\n        #check if selected axes are valid\n        ax1_idx, ax2_idx, ax3_idx = axes\n        if not (0 <= ax1_idx < data.shape[0] and\n                0 <= ax2_idx < data.shape[0] and\n                0 <= ax3_idx < data.shape[0]):\n            warnings.warn(f\"Selected axes {axes} out of bounds for data shape {data.shape}\")\n            return None, None \n\n        #initialize 3D figure\n        fig = plt.figure(figsize=(6, 6), dpi=120)\n        ax = fig.add_subplot(111, projection='3d')\n\n        #custom colors\n        ax.set_prop_cycle(color=COLORS_ALL)\n\n        #unpack data for selected axes\n        d1 = data[ax1_idx]\n        d2 = data[ax2_idx]\n        d3 = data[ax3_idx]\n\n        #plot the 3D data\n        ax.plot(d1, d2, d3, *args, **kwargs)\n\n        #set axis labels using provided labels or default port numbers\n        label1 = self.labels[ax1_idx] if ax1_idx < len(self.labels) else f\"port {ax1_idx}\"\n        label2 = self.labels[ax2_idx] if ax2_idx < len(self.labels) else f\"port {ax2_idx}\"\n        label3 = self.labels[ax3_idx] if ax3_idx < len(self.labels) else f\"port {ax3_idx}\"\n        ax.set_xlabel(label1)\n        ax.set_ylabel(label2)\n        ax.set_zlabel(label3)\n\n        #show the plot without blocking\n        plt.show(block=False)\n\n        return fig, ax\n\n\n    def save(self, path=\"scope.csv\"):\n        \"\"\"Save the recording of the scope to a csv file.\n\n        Parameters\n        ----------\n        path : str\n            path where to save the recording as a csv file\n        \"\"\"\n\n        #check path ending\n        if not path.lower().endswith(\".csv\"):\n            path += \".csv\"\n\n        #get data\n        time, data = self.read() \n\n        #number of ports and labels\n        P, L = len(data), len(self.labels)\n\n        #make csv header\n        header = [\"time [s]\", *[self.labels[p] if p < L else f\"port {p}\" for p in range(P)]]\n\n        #write to csv file\n        with open(path, \"w\", newline=\"\") as file:\n            wrt = csv.writer(file)\n\n            #write the header to csv file\n            wrt.writerow(header)\n\n            #write each sample to the csv file\n            for sample in zip(time, *data):\n                wrt.writerow(sample)\n\n\n    def update(self, t):\n        \"\"\"update system equation for fixed point loop, \n        here just setting the outputs\n\n        Note\n        ----\n        Scope has no passthrough, so the 'update' method \n        is optimized for this case (does nothing)       \n\n        Parameters\n        ----------\n        t : float\n            evaluation time\n\n        Returns\n        -------\n        error : float\n            absolute error to previous iteration for convergence \n            control (always '0.0' because sink-type)\n        \"\"\"\n        return 0.0",
          "bases": [
            "pathsim.blocks._block.Block"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, sampling_period=None, t_wait=0.0, labels=None):\n    super().__init__()\n\n    #time delay until start recording\n    self.t_wait = t_wait\n\n    #params for sampling\n    self.sampling_period = sampling_period\n\n    #labels for plotting and saving data\n    self.labels = labels if labels is not None else []\n\n    #set recording data and time\n    self.recording_time = []\n    self.recording_data = []\n\n    #initial index for incremental reading\n    self._incremental_idx = 0\n\n    #sampling produces discrete time behavior\n    if not (sampling_period is None):\n\n        #flag to indicate this is a timestep to sample\n        self._sample_next_timestep = False\n\n        #internal scheduled list event\n        def _sample(t):\n            self._sample_next_timestep = True\n\n        self.events = [\n            Schedule(\n                t_start=t_wait,\n                t_period=sampling_period,\n                func_act=_sample\n                )\n        ]",
              "signature": "(sampling_period = None, t_wait = 0.0, labels = None)",
              "parameters": [
                {
                  "name": "sampling_period",
                  "type": null,
                  "default": "None",
                  "description": ""
                },
                {
                  "name": "t_wait",
                  "type": null,
                  "default": "0.0",
                  "description": ""
                },
                {
                  "name": "labels",
                  "type": null,
                  "default": "None",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "reset",
              "description": "",
              "docstring_html": "",
              "source": "def reset(self):\n    super().reset()\n\n    #reset recording data and time\n    self.recording_time.clear()\n    self.recording_data.clear()\n\n    #reset index for incremental read\n    self._incremental_idx = 0",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "read",
              "description": "Return the recorded time domain data and the corresponding",
              "docstring_html": "<p>Return the recorded time domain data and the corresponding\ntime for all input ports</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>incremental <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>read the data incrementally, only return new data\nthat has accumulated after the last incremental read call</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>time <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array[float]</span></dt>\n<dd>recorded time points</dd>\n<dt>data <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array[obj]</span></dt>\n<dd>recorded data points</dd>\n</dl>\n",
              "source": "def read(self, incremental=False):\n    \"\"\"Return the recorded time domain data and the corresponding \n    time for all input ports\n\n    Parameters\n    ----------\n    incremental : bool\n        read the data incrementally, only return new data \n        that has accumulated after the last incremental read call\n\n    Returns\n    -------\n    time : array[float]\n        recorded time points\n    data : array[obj]\n        recorded data points\n    \"\"\"\n\n    #just return 'None' if no recording available\n    if not self.recording_time or not self.recording_data: \n        return None, None\n\n    #return accumulated data since last incremental call\n    if incremental:\n\n        _idx, self._incremental_idx = self._incremental_idx, len(self.recording_time)\n\n        #no data accumulated -> exit same as empty recording\n        if _idx == self._incremental_idx:\n            return None, None\n\n        return np.array(self.recording_time[_idx:]), np.array(self.recording_data[_idx:]).T\n\n    return np.array(self.recording_time), np.array(self.recording_data).T",
              "signature": "(incremental = False)",
              "parameters": [
                {
                  "name": "incremental",
                  "type": null,
                  "default": "False",
                  "description": "read the data incrementally, only return new data that has accumulated after the last incremental read call"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "collect",
              "description": "Yield (category, id, data) tuples for recording blocks to simplify",
              "docstring_html": "<p>Yield (category, id, data) tuples for recording blocks to simplify\nglobal data collection from all recording blocks.</p>\n",
              "source": "@deprecated(version=\"1.0.0\", reason=\"its against pathsims philosophy\")\ndef collect(self):\n    \"\"\"Yield (category, id, data) tuples for recording blocks to simplify \n    global data collection from all recording blocks.\n    \"\"\"\n    time, data = self.read()\n    if data is not None:\n        yield (\n            \"scope\", \n            id(self), \n            {\n                \"time\": time,\n                \"data\": data,\n                \"labels\": self.labels,\n                }\n            )",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "sample",
              "description": "Sample the data from all inputs. Skips duplicate timestamps to maintain",
              "docstring_html": "<p>Sample the data from all inputs. Skips duplicate timestamps to maintain\nunique time points in the recording.</p>\n<p>If <cite>sampling_period</cite> is provided, this depends on the flag <cite>_sample_next_timestep</cite>,\nset by the internal <cite>Schedule</cite> event.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time for sampling</dd>\n</dl>\n",
              "source": "def sample(self, t, dt):\n    \"\"\"Sample the data from all inputs. Skips duplicate timestamps to maintain\n    unique time points in the recording.\n\n    If `sampling_period` is provided, this depends on the flag `_sample_next_timestep`,\n    set by the internal `Schedule` event.\n\n    Parameters\n    ----------\n    t : float\n        evaluation time for sampling\n    \"\"\"\n    #determine if we should sample\n    if self.sampling_period is None:\n        should_sample = t >= self.t_wait\n    elif self._sample_next_timestep:\n        should_sample = True\n        self._sample_next_timestep = False\n    else:\n        should_sample = False\n\n    if not should_sample:\n        return\n\n    #skip duplicate timestamps (can happen when continuing simulation)\n    if self.recording_time and self.recording_time[-1] == t:\n        return\n\n    self.recording_time.append(t)\n    self.recording_data.append(self.inputs.to_array())",
              "signature": "(t, dt)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time for sampling"
                },
                {
                  "name": "dt",
                  "type": null,
                  "default": null,
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "plot",
              "description": "Directly create a plot of the recorded data for quick visualization and debugging.",
              "docstring_html": "<p>Directly create a plot of the recorded data for quick visualization and debugging.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>args <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">tuple</span></dt>\n<dd>args for ax.plot</dd>\n<dt>kwargs <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">dict</span></dt>\n<dd>kwargs for ax.plot</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>fig <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">matplotlib.figure</span></dt>\n<dd>internal figure instance</dd>\n<dt>ax <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">matplotlib.axis</span></dt>\n<dd>internal axis instance</dd>\n</dl>\n",
              "source": "def plot(self, *args, **kwargs):\n    \"\"\"Directly create a plot of the recorded data for quick visualization and debugging.\n\n    Parameters\n    ----------\n    args : tuple\n        args for ax.plot\n    kwargs : dict\n        kwargs for ax.plot\n\n    Returns\n    -------\n    fig : matplotlib.figure\n        internal figure instance\n    ax : matplotlib.axis\n        internal axis instance\n    \"\"\" \n\n    #get data\n    time, data = self.read() \n\n    #just return 'None' if no recording available\n    if time is None:\n        warnings.warn(\"no recording available for plotting in 'Scope.plot'\")\n        return None, None\n\n    #initialize figure\n    fig, ax = plt.subplots(nrows=1, ncols=1, figsize=(8,4), tight_layout=True, dpi=120)\n\n    #custom colors\n    ax.set_prop_cycle(color=COLORS_ALL)\n\n    #plot the recorded data\n    for p, d in enumerate(data):\n        lb = self.labels[p] if p < len(self.labels) else f\"port {p}\"\n        ax.plot(time, d, *args, **kwargs, label=lb)\n\n    #legend labels from ports\n    ax.legend(fancybox=False)\n\n    #other plot settings\n    ax.set_xlabel(\"time [s]\")\n    ax.grid()\n\n    # Legend picking functionality\n    lines = ax.get_lines()  # Get the lines from the plot\n    leg = ax.get_legend()   # Get the legend\n\n    # Map legend lines to original plot lines\n    lined = dict()  \n    for legline, origline in zip(leg.get_lines(), lines):\n        # Enable picking within 5 points tolerance\n        legline.set_picker(5)  \n        lined[legline] = origline\n\n    def on_pick(event):\n        legline = event.artist\n        origline = lined[legline]\n        visible = not origline.get_visible()\n        origline.set_visible(visible)\n        legline.set_alpha(1.0 if visible else 0.2)\n        # Redraw the figure\n        fig.canvas.draw()  \n\n    #enable picking\n    fig.canvas.mpl_connect(\"pick_event\", on_pick)\n\n    #show the plot without blocking following code\n    plt.show(block=False)\n\n    #return figure and axis for outside manipulation\n    return fig, ax",
              "signature": "(args = (), kwargs = {})",
              "parameters": [
                {
                  "name": "args",
                  "type": null,
                  "default": "()",
                  "description": "args for ax.plot"
                },
                {
                  "name": "kwargs",
                  "type": null,
                  "default": "{}",
                  "description": "kwargs for ax.plot"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "plot2D",
              "description": "Directly create a 2D plot of the recorded data for quick visualization and debugging.",
              "docstring_html": "<p>Directly create a 2D plot of the recorded data for quick visualization and debugging.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>args <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">tuple</span></dt>\n<dd>args for ax.plot</dd>\n<dt>axes <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">tuple[int]</span></dt>\n<dd>axes / ports to select for 2d plot</dd>\n<dt>kwargs <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">dict</span></dt>\n<dd>kwargs for ax.plot</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>fig <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">matplotlib.figure</span></dt>\n<dd>internal figure instance</dd>\n<dt>ax <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">matplotlib.axis</span></dt>\n<dd>internal axis instance</dd>\n</dl>\n",
              "source": "def plot2D(self, *args, axes=(0, 1), **kwargs):\n    \"\"\"Directly create a 2D plot of the recorded data for quick visualization and debugging.\n\n    Parameters\n    ----------\n    args : tuple\n        args for ax.plot\n    axes : tuple[int]\n        axes / ports to select for 2d plot\n    kwargs : dict\n        kwargs for ax.plot\n\n    Returns\n    -------\n    fig : matplotlib.figure\n        internal figure instance\n    ax : matplotlib.axis\n        internal axis instance\n    \"\"\" \n\n    #get data\n    time, data = self.read() \n\n    #just return 'None' if no recording available\n    if time is None:\n        warnings.warn(\"no recording available for plotting in 'Scope.plot2D'\")\n        return None, None\n\n    #not enough channels -> early exit\n    if len(data) < 2 or len(axes) != 2:\n        warnings.warn(\"not enough channels for plotting in 'Scope.plot2D'\")\n        return None, None\n\n    #axes selected not available -> early exit\n    ax1_idx, ax2_idx = axes\n    if not (0 <= ax1_idx < data.shape[0] and 0 <= ax2_idx < data.shape[0]):\n         warnings.warn(f\"Selected axes {axes} out of bounds for data shape {data.shape}\")\n         return None, None \n\n    #initialize figure\n    fig, ax = plt.subplots(nrows=1, ncols=1, figsize=(4, 4), tight_layout=True, dpi=120)\n\n    #custom colors\n    ax.set_prop_cycle(color=COLORS_ALL)\n\n    #unpack data for selected axes\n    d1 = data[ax1_idx]\n    d2 = data[ax2_idx]\n\n    #plot the data\n    ax.plot(d1, d2, *args, **kwargs)\n\n    #axis labels\n    l1 = self.labels[ax1_idx] if ax1_idx < len(self.labels) else f\"port {ax1_idx}\"\n    l2 = self.labels[ax2_idx] if ax2_idx < len(self.labels) else f\"port {ax2_idx}\"\n    ax.set_xlabel(l1)\n    ax.set_ylabel(l2)\n\n    ax.grid()\n\n    #show the plot without blocking following code\n    plt.show(block=False)\n\n    #return figure and axis for outside manipulation\n    return fig, ax",
              "signature": "(args = (), axes = (0, 1), kwargs = {})",
              "parameters": [
                {
                  "name": "args",
                  "type": null,
                  "default": "()",
                  "description": "args for ax.plot"
                },
                {
                  "name": "axes",
                  "type": null,
                  "default": "(0, 1)",
                  "description": "axes / ports to select for 2d plot"
                },
                {
                  "name": "kwargs",
                  "type": null,
                  "default": "{}",
                  "description": "kwargs for ax.plot"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "plot3D",
              "description": "Directly create a 3D plot of the recorded data for quick visualization.",
              "docstring_html": "<p>Directly create a 3D plot of the recorded data for quick visualization.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>args <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">tuple</span></dt>\n<dd>args for ax.plot</dd>\n<dt>axes <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">tuple[int]</span></dt>\n<dd>indices of the three data channels (ports) to plot (default: (0, 1, 2)).</dd>\n<dt>kwargs <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">dict</span></dt>\n<dd>kwargs for ax.plot</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>fig <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">matplotlib.figure</span></dt>\n<dd>internal figure instance.</dd>\n<dt>ax <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">matplotlib.axes._axes.Axes3D</span></dt>\n<dd>internal 3D axis instance.</dd>\n</dl>\n",
              "source": "def plot3D(self, *args, axes=(0, 1, 2), **kwargs):\n    \"\"\"Directly create a 3D plot of the recorded data for quick visualization.\n\n    Parameters\n    ----------\n    args : tuple\n        args for ax.plot\n    axes : tuple[int]\n        indices of the three data channels (ports) to plot (default: (0, 1, 2)).\n    kwargs : dict\n        kwargs for ax.plot\n\n    Returns\n    -------\n    fig : matplotlib.figure\n        internal figure instance.\n    ax : matplotlib.axes._axes.Axes3D\n        internal 3D axis instance.\n    \"\"\"\n\n    #get data\n    time, data = self.read() \n\n    #just return 'None' if no recording available\n    if time is None:\n        warnings.warn(\"no recording available for plotting in 'Scope.plot3D'\")\n        return None, None\n\n    #check if enough channels are available\n    if data.shape[0] < 3 or len(axes) != 3:\n        warnings.warn(f\"Need at least 3 channels for plot3D, got {data.shape[0]}. Or axes argument length is not 3.\")\n        return None, None\n\n    #check if selected axes are valid\n    ax1_idx, ax2_idx, ax3_idx = axes\n    if not (0 <= ax1_idx < data.shape[0] and\n            0 <= ax2_idx < data.shape[0] and\n            0 <= ax3_idx < data.shape[0]):\n        warnings.warn(f\"Selected axes {axes} out of bounds for data shape {data.shape}\")\n        return None, None \n\n    #initialize 3D figure\n    fig = plt.figure(figsize=(6, 6), dpi=120)\n    ax = fig.add_subplot(111, projection='3d')\n\n    #custom colors\n    ax.set_prop_cycle(color=COLORS_ALL)\n\n    #unpack data for selected axes\n    d1 = data[ax1_idx]\n    d2 = data[ax2_idx]\n    d3 = data[ax3_idx]\n\n    #plot the 3D data\n    ax.plot(d1, d2, d3, *args, **kwargs)\n\n    #set axis labels using provided labels or default port numbers\n    label1 = self.labels[ax1_idx] if ax1_idx < len(self.labels) else f\"port {ax1_idx}\"\n    label2 = self.labels[ax2_idx] if ax2_idx < len(self.labels) else f\"port {ax2_idx}\"\n    label3 = self.labels[ax3_idx] if ax3_idx < len(self.labels) else f\"port {ax3_idx}\"\n    ax.set_xlabel(label1)\n    ax.set_ylabel(label2)\n    ax.set_zlabel(label3)\n\n    #show the plot without blocking\n    plt.show(block=False)\n\n    return fig, ax",
              "signature": "(args = (), axes = (0, 1, 2), kwargs = {})",
              "parameters": [
                {
                  "name": "args",
                  "type": null,
                  "default": "()",
                  "description": "args for ax.plot"
                },
                {
                  "name": "axes",
                  "type": null,
                  "default": "(0, 1, 2)",
                  "description": "indices of the three data channels (ports) to plot (default: (0, 1, 2))."
                },
                {
                  "name": "kwargs",
                  "type": null,
                  "default": "{}",
                  "description": "kwargs for ax.plot"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "save",
              "description": "Save the recording of the scope to a csv file.",
              "docstring_html": "<p>Save the recording of the scope to a csv file.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>path <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">str</span></dt>\n<dd>path where to save the recording as a csv file</dd>\n</dl>\n",
              "source": "def save(self, path=\"scope.csv\"):\n    \"\"\"Save the recording of the scope to a csv file.\n\n    Parameters\n    ----------\n    path : str\n        path where to save the recording as a csv file\n    \"\"\"\n\n    #check path ending\n    if not path.lower().endswith(\".csv\"):\n        path += \".csv\"\n\n    #get data\n    time, data = self.read() \n\n    #number of ports and labels\n    P, L = len(data), len(self.labels)\n\n    #make csv header\n    header = [\"time [s]\", *[self.labels[p] if p < L else f\"port {p}\" for p in range(P)]]\n\n    #write to csv file\n    with open(path, \"w\", newline=\"\") as file:\n        wrt = csv.writer(file)\n\n        #write the header to csv file\n        wrt.writerow(header)\n\n        #write each sample to the csv file\n        for sample in zip(time, *data):\n            wrt.writerow(sample)",
              "signature": "(path = 'scope.csv')",
              "parameters": [
                {
                  "name": "path",
                  "type": null,
                  "default": "'scope.csv'",
                  "description": "path where to save the recording as a csv file"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "update",
              "description": "update system equation for fixed point loop,",
              "docstring_html": "<p>update system equation for fixed point loop,\nhere just setting the outputs</p>\n<div class=\"section\" id=\"note\">\n<h4>Note</h4>\n<p>Scope has no passthrough, so the 'update' method\nis optimized for this case (does nothing)</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>error <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>absolute error to previous iteration for convergence\ncontrol (always '0.0' because sink-type)</dd>\n</dl>\n</div>\n",
              "source": "def update(self, t):\n    \"\"\"update system equation for fixed point loop, \n    here just setting the outputs\n\n    Note\n    ----\n    Scope has no passthrough, so the 'update' method \n    is optimized for this case (does nothing)       \n\n    Parameters\n    ----------\n    t : float\n        evaluation time\n\n    Returns\n    -------\n    error : float\n        absolute error to previous iteration for convergence \n        control (always '0.0' because sink-type)\n    \"\"\"\n    return 0.0",
              "signature": "(t)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time"
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "input_port_labels",
              "description": "",
              "type": null,
              "value": "None"
            },
            {
              "name": "output_port_labels",
              "description": "",
              "type": null,
              "value": "{}"
            },
            {
              "name": "t_wait",
              "description": "",
              "type": null,
              "value": "t_wait"
            },
            {
              "name": "sampling_period",
              "description": "",
              "type": null,
              "value": "sampling_period"
            },
            {
              "name": "labels",
              "description": "",
              "type": null,
              "value": "labels if labels is not None else []"
            },
            {
              "name": "recording_time",
              "description": "",
              "type": null,
              "value": "[]"
            },
            {
              "name": "recording_data",
              "description": "",
              "type": null,
              "value": "[]"
            },
            {
              "name": "_incremental_idx",
              "description": "",
              "type": null,
              "value": "0"
            },
            {
              "name": "_sample_next_timestep",
              "description": "",
              "type": null,
              "value": "False"
            },
            {
              "name": "events",
              "description": "",
              "type": null,
              "value": "[Schedule(t_start=t_wait, t_period=sampling_period, func_act=_sample)]"
            }
          ],
          "parameters": [
            {
              "name": "sampling_period",
              "type": null,
              "default": "None",
              "description": "time between samples, default is every timestep"
            },
            {
              "name": "t_wait",
              "type": null,
              "default": "0.0",
              "description": "wait time before starting recording, optional"
            },
            {
              "name": "labels",
              "type": null,
              "default": "None",
              "description": "labels for the scope traces, and for the csv, optional"
            }
          ]
        },
        {
          "name": "RealtimeScope",
          "description": "An extension of the 'Scope' block that initializes a realtime plotter.",
          "docstring_html": "<p>An extension of the 'Scope' block that initializes a realtime plotter.</p>\n<p>Creates an interactive plotting window while the simulation is running.\nOtherwise implements the same functionality as the regular 'Scope' block.</p>\n<div class=\"section\" id=\"note\">\n<h4>Note</h4>\n<p>Due to the plotting being relatively expensive, including this block\nslows down the simulation significantly but may still be valuable for\ndebugging and testing.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>sampling_period <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float, None</span></dt>\n<dd>time between samples, default is every timestep</dd>\n<dt>t_wait <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>wait time before starting recording</dd>\n<dt>labels <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">list[str]</span></dt>\n<dd>labels for the scope traces, and for the csv</dd>\n<dt>max_samples <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int, None</span></dt>\n<dd>number of samples for realtime display, all per default</dd>\n</dl>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>plotter <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">RealtimePlotter</span></dt>\n<dd>instance of a RealtimePlotter</dd>\n</dl>\n</div>\n",
          "source": "@deprecated(version=\"1.0.0\")\nclass RealtimeScope(Scope):\n    \"\"\"An extension of the 'Scope' block that initializes a realtime plotter.\n\n    Creates an interactive plotting window while the simulation is running.\n    Otherwise implements the same functionality as the regular 'Scope' block.\n\n    Note\n    -----\n    Due to the plotting being relatively expensive, including this block\n    slows down the simulation significantly but may still be valuable for\n    debugging and testing.\n\n    Parameters\n    ----------\n    sampling_period : float, None\n        time between samples, default is every timestep\n    t_wait : float\n        wait time before starting recording\n    labels : list[str]\n        labels for the scope traces, and for the csv\n    max_samples : int, None\n        number of samples for realtime display, all per default\n\n    Attributes\n    ----------\n    plotter : RealtimePlotter\n        instance of a RealtimePlotter\n    \"\"\"\n\n    def __init__(self, sampling_period=None, t_wait=0.0, labels=[], max_samples=None):\n        super().__init__(sampling_period, t_wait, labels)\n\n        #initialize realtime plotter\n        self.plotter = RealtimePlotter(\n            max_samples=max_samples,\n            update_interval=0.1,\n            labels=labels,\n            x_label=\"time [s]\",\n            y_label=\"\"\n            )\n\n\n    def sample(self, t, dt):\n        \"\"\"Sample the data from all inputs, and overwrites existing timepoints, \n        since we use a dict for storing the recorded data.\n\n        Parameters\n        ----------\n        t : float\n            evaluation time for sampling\n        \"\"\"\n        if (self.sampling_period is None):\n            self.plotter.update(t, self.inputs.to_array())\n            super().sample(t, dt)",
          "bases": [
            "pathsim.blocks.scope.Scope"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, sampling_period=None, t_wait=0.0, labels=[], max_samples=None):\n    super().__init__(sampling_period, t_wait, labels)\n\n    #initialize realtime plotter\n    self.plotter = RealtimePlotter(\n        max_samples=max_samples,\n        update_interval=0.1,\n        labels=labels,\n        x_label=\"time [s]\",\n        y_label=\"\"\n        )",
              "signature": "(sampling_period = None, t_wait = 0.0, labels = [], max_samples = None)",
              "parameters": [
                {
                  "name": "sampling_period",
                  "type": null,
                  "default": "None",
                  "description": ""
                },
                {
                  "name": "t_wait",
                  "type": null,
                  "default": "0.0",
                  "description": ""
                },
                {
                  "name": "labels",
                  "type": null,
                  "default": "[]",
                  "description": ""
                },
                {
                  "name": "max_samples",
                  "type": null,
                  "default": "None",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "sample",
              "description": "Sample the data from all inputs, and overwrites existing timepoints,",
              "docstring_html": "<p>Sample the data from all inputs, and overwrites existing timepoints,\nsince we use a dict for storing the recorded data.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time for sampling</dd>\n</dl>\n",
              "source": "def sample(self, t, dt):\n    \"\"\"Sample the data from all inputs, and overwrites existing timepoints, \n    since we use a dict for storing the recorded data.\n\n    Parameters\n    ----------\n    t : float\n        evaluation time for sampling\n    \"\"\"\n    if (self.sampling_period is None):\n        self.plotter.update(t, self.inputs.to_array())\n        super().sample(t, dt)",
              "signature": "(t, dt)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time for sampling"
                },
                {
                  "name": "dt",
                  "type": null,
                  "default": null,
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "plotter",
              "description": "",
              "type": null,
              "value": "RealtimePlotter(max_samples=max_samples, update_interval=0.1, labels=labels, x_label='time [s]', y_label='')"
            }
          ],
          "parameters": [
            {
              "name": "sampling_period",
              "type": null,
              "default": "None",
              "description": "time between samples, default is every timestep"
            },
            {
              "name": "t_wait",
              "type": null,
              "default": "0.0",
              "description": "wait time before starting recording"
            },
            {
              "name": "labels",
              "type": null,
              "default": "[]",
              "description": "labels for the scope traces, and for the csv"
            },
            {
              "name": "max_samples",
              "type": null,
              "default": "None",
              "description": "number of samples for realtime display, all per default"
            }
          ]
        }
      ],
      "functions": []
    },
    "pathsim.blocks.sources": {
      "name": "pathsim.blocks.sources",
      "description": "",
      "docstring_html": "",
      "classes": [
        {
          "name": "Constant",
          "description": "Produces a constant output signal (SISO).",
          "docstring_html": "<p>Produces a constant output signal (SISO).</p>\n<pre class=\"math\">\ny(t) = const.\n</pre>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>value <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>constant defining block output</dd>\n</dl>\n",
          "source": "class Constant(Block):\n    \"\"\"Produces a constant output signal (SISO).\n\n    .. math::\n\n        y(t) = const.\n\n\n    Parameters\n    ----------\n    value : float\n        constant defining block output\n    \"\"\"\n\n    input_port_labels = {}\n    output_port_labels = {\"out\":0}\n\n    def __init__(self, value=1):\n        super().__init__()\n\n        self.value = value\n\n\n    def __len__(self):\n        \"\"\"No algebraic passthrough\"\"\"\n        return 0\n\n\n    def update(self, t):\n        \"\"\"update system equation fixed point loop\n\n        Parameters\n        ----------\n        t : float\n            evaluation time\n\n        Returns\n        -------\n        error : float\n            absolute error to previous iteration for convergence \n            control (always '0.0' because source-type)\n        \"\"\"\n        self.outputs[0] = self.value\n        return 0.0",
          "bases": [
            "pathsim.blocks._block.Block"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, value=1):\n    super().__init__()\n\n    self.value = value",
              "signature": "(value = 1)",
              "parameters": [
                {
                  "name": "value",
                  "type": null,
                  "default": "1",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "update",
              "description": "update system equation fixed point loop",
              "docstring_html": "<p>update system equation fixed point loop</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>error <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>absolute error to previous iteration for convergence\ncontrol (always '0.0' because source-type)</dd>\n</dl>\n",
              "source": "def update(self, t):\n    \"\"\"update system equation fixed point loop\n\n    Parameters\n    ----------\n    t : float\n        evaluation time\n\n    Returns\n    -------\n    error : float\n        absolute error to previous iteration for convergence \n        control (always '0.0' because source-type)\n    \"\"\"\n    self.outputs[0] = self.value\n    return 0.0",
              "signature": "(t)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time"
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "input_port_labels",
              "description": "",
              "type": null,
              "value": "{}"
            },
            {
              "name": "output_port_labels",
              "description": "",
              "type": null,
              "value": "{'out': 0}"
            },
            {
              "name": "value",
              "description": "",
              "type": null,
              "value": "value"
            }
          ],
          "parameters": [
            {
              "name": "value",
              "type": null,
              "default": "1",
              "description": "constant defining block output"
            }
          ]
        },
        {
          "name": "Source",
          "description": "Source that produces an arbitrary time dependent output defined by `func` (callable).",
          "docstring_html": "<p>Source that produces an arbitrary time dependent output defined by <cite>func</cite> (callable).</p>\n<pre class=\"math\">\ny(t) = \\mathrm{func}(t)\n</pre>\n<div class=\"section\" id=\"note\">\n<h4>Note</h4>\n<p>This block is purely algebraic and its internal function (<cite>func</cite>) will\nbe called multiple times per timestep, each time when <cite>Simulation._update(t)</cite>\nis called in the global simulation loop.</p>\n</div>\n<div class=\"section\" id=\"example\">\n<h4>Example</h4>\n<p>For example a ramp:</p>\n<pre class=\"code python literal-block\">\n<span class=\"kn\">from</span><span class=\"w\"> </span><span class=\"nn\">pathsim.blocks</span><span class=\"w\"> </span><span class=\"kn\">import</span> <span class=\"n\">Source</span><span class=\"w\">\n\n</span><span class=\"n\">src</span> <span class=\"o\">=</span> <span class=\"n\">Source</span><span class=\"p\">(</span><span class=\"k\">lambda</span> <span class=\"n\">t</span> <span class=\"p\">:</span> <span class=\"n\">t</span><span class=\"p\">)</span>\n</pre>\n<p>or a simple sinusoid with some frequency:</p>\n<pre class=\"code python literal-block\">\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"nn\">numpy</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"nn\">np</span><span class=\"w\">\n</span><span class=\"kn\">from</span><span class=\"w\"> </span><span class=\"nn\">pathsim.blocks</span><span class=\"w\"> </span><span class=\"kn\">import</span> <span class=\"n\">Source</span><span class=\"w\">\n\n</span><span class=\"c1\">#some parameter</span><span class=\"w\">\n</span><span class=\"n\">omega</span> <span class=\"o\">=</span> <span class=\"mi\">100</span><span class=\"w\">\n\n</span><span class=\"c1\">#the function that gets evaluated</span><span class=\"w\">\n</span><span class=\"k\">def</span><span class=\"w\"> </span><span class=\"nf\">f</span><span class=\"p\">(</span><span class=\"n\">t</span><span class=\"p\">):</span><span class=\"w\">\n</span>    <span class=\"k\">return</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">sin</span><span class=\"p\">(</span><span class=\"n\">omega</span> <span class=\"o\">*</span> <span class=\"n\">t</span><span class=\"p\">)</span><span class=\"w\">\n\n</span><span class=\"n\">src</span> <span class=\"o\">=</span> <span class=\"n\">Source</span><span class=\"p\">(</span><span class=\"n\">f</span><span class=\"p\">)</span>\n</pre>\n<p>Because the <cite>Source</cite> block only has a single argument, it can be\nused to decorate a function and make it a <cite>PathSim</cite> block. This might\nbe handy in some cases to keep definitions concise and localized\nin the code:</p>\n<pre class=\"code python literal-block\">\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"nn\">numpy</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"nn\">np</span><span class=\"w\">\n</span><span class=\"kn\">from</span><span class=\"w\"> </span><span class=\"nn\">pathsim.blocks</span><span class=\"w\"> </span><span class=\"kn\">import</span> <span class=\"n\">Source</span><span class=\"w\">\n\n</span><span class=\"c1\">#does the same as the definition above</span><span class=\"w\">\n\n</span><span class=\"nd\">&#64;Source</span><span class=\"w\">\n</span><span class=\"k\">def</span><span class=\"w\"> </span><span class=\"nf\">src</span><span class=\"p\">(</span><span class=\"n\">t</span><span class=\"p\">):</span><span class=\"w\">\n</span>    <span class=\"n\">omega</span> <span class=\"o\">=</span> <span class=\"mi\">100</span><span class=\"w\">\n</span>    <span class=\"k\">return</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">sin</span><span class=\"p\">(</span><span class=\"n\">omega</span> <span class=\"o\">*</span> <span class=\"n\">t</span><span class=\"p\">)</span><span class=\"w\">\n\n</span><span class=\"c1\">#'src' is now a PathSim block</span>\n</pre>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>func <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">callable</span></dt>\n<dd>function defining time dependent block output</dd>\n</dl>\n</div>\n",
          "source": "class Source(Block):\n    \"\"\"Source that produces an arbitrary time dependent output defined by `func` (callable).\n\n    .. math::\n\n        y(t) = \\\\mathrm{func}(t)\n\n\n    Note\n    ----\n    This block is purely algebraic and its internal function (`func`) will \n    be called multiple times per timestep, each time when `Simulation._update(t)` \n    is called in the global simulation loop.\n\n\n    Example\n    -------\n    For example a ramp:\n\n    .. code-block:: python\n\n        from pathsim.blocks import Source\n\n        src = Source(lambda t : t)\n\n    or a simple sinusoid with some frequency:\n\n    .. code-block:: python\n\n        import numpy as np\n        from pathsim.blocks import Source\n\n        #some parameter\n        omega = 100\n\n        #the function that gets evaluated\n        def f(t):\n            return np.sin(omega * t)\n\n        src = Source(f)\n\n    Because the `Source` block only has a single argument, it can be \n    used to decorate a function and make it a `PathSim` block. This might \n    be handy in some cases to keep definitions concise and localized \n    in the code:\n\n    .. code-block:: python\n\n        import numpy as np\n        from pathsim.blocks import Source\n\n        #does the same as the definition above\n\n        @Source\n        def src(t):\n            omega = 100\n            return np.sin(omega * t)\n\n        #'src' is now a PathSim block\n\n\n    Parameters\n    ---------- \n    func : callable\n        function defining time dependent block output\n    \"\"\"\n\n    input_port_labels = {}\n    output_port_labels = {\"out\":0}\n\n    def __init__(self, func=lambda t: 1):\n        super().__init__()\n\n        if not callable(func):\n            raise ValueError(f\"'{func}' is not callable\")\n\n        self.func = func\n\n\n    def __len__(self):\n        \"\"\"No algebraic passthrough\"\"\"\n        return 0\n\n\n    def update(self, t):\n        \"\"\"update system equation fixed point loop \n        by evaluating the internal function 'func'\n\n        Note\n        ----\n        No direct passthrough, so the `update` method \n        is optimized and has no convergence check\n\n        Parameters\n        ----------\n        t : float\n            evaluation time\n        \"\"\"\n        self.outputs[0] = self.func(t)",
          "bases": [
            "pathsim.blocks._block.Block"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, func=lambda t: 1):\n    super().__init__()\n\n    if not callable(func):\n        raise ValueError(f\"'{func}' is not callable\")\n\n    self.func = func",
              "signature": "(func = lambda t: 1)",
              "parameters": [
                {
                  "name": "func",
                  "type": null,
                  "default": "lambda t: 1",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "update",
              "description": "update system equation fixed point loop",
              "docstring_html": "<p>update system equation fixed point loop\nby evaluating the internal function 'func'</p>\n<div class=\"section\" id=\"note\">\n<h4>Note</h4>\n<p>No direct passthrough, so the <cite>update</cite> method\nis optimized and has no convergence check</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time</dd>\n</dl>\n</div>\n",
              "source": "def update(self, t):\n    \"\"\"update system equation fixed point loop \n    by evaluating the internal function 'func'\n\n    Note\n    ----\n    No direct passthrough, so the `update` method \n    is optimized and has no convergence check\n\n    Parameters\n    ----------\n    t : float\n        evaluation time\n    \"\"\"\n    self.outputs[0] = self.func(t)",
              "signature": "(t)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time"
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "input_port_labels",
              "description": "",
              "type": null,
              "value": "{}"
            },
            {
              "name": "output_port_labels",
              "description": "",
              "type": null,
              "value": "{'out': 0}"
            },
            {
              "name": "func",
              "description": "",
              "type": null,
              "value": "func"
            }
          ],
          "parameters": [
            {
              "name": "func",
              "type": null,
              "default": "lambda t: 1",
              "description": "function defining time dependent block output"
            }
          ]
        },
        {
          "name": "TriangleWaveSource",
          "description": "Source block that generates an analog triangle wave",
          "docstring_html": "<p>Source block that generates an analog triangle wave</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>frequency <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>frequency of the triangle wave</dd>\n<dt>amplitude <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>amplitude of the triangle wave</dd>\n<dt>phase <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>phase of the triangle wave</dd>\n</dl>\n",
          "source": "class TriangleWaveSource(Source):\n    \"\"\"Source block that generates an analog triangle wave\n\n    Parameters\n    ----------\n    frequency : float\n        frequency of the triangle wave\n    amplitude : float\n        amplitude of the triangle wave\n    phase : float\n        phase of the triangle wave\n    \"\"\"\n\n    def __init__(self, frequency=1, amplitude=1, phase=0):\n\n        #specific params\n        self.amplitude = amplitude\n        self.frequency = frequency\n        self.phase = phase\n\n        #phase induced delay\n        self._tau = self.phase/(2*np.pi*self.frequency)\n\n        super().__init__(\n            func= lambda t: self.amplitude * self._triangle_wave(t + self._tau, self.frequency)\n            )\n\n    def _triangle_wave(self, t, f):\n        \"\"\"triangle wave with amplitude '1' and frequency 'f'\n\n        Parameters\n        ----------\n        t : float\n            evaluation time\n        f : float\n            trig wave frequency\n\n        Returns\n        -------\n        out : float\n            trig wave value\n        \"\"\"\n        return 2 * abs(t*f - np.floor(t*f + 0.5)) - 1",
          "bases": [
            "pathsim.blocks.sources.Source"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, frequency=1, amplitude=1, phase=0):\n\n    #specific params\n    self.amplitude = amplitude\n    self.frequency = frequency\n    self.phase = phase\n\n    #phase induced delay\n    self._tau = self.phase/(2*np.pi*self.frequency)\n\n    super().__init__(\n        func= lambda t: self.amplitude * self._triangle_wave(t + self._tau, self.frequency)\n        )",
              "signature": "(frequency = 1, amplitude = 1, phase = 0)",
              "parameters": [
                {
                  "name": "frequency",
                  "type": null,
                  "default": "1",
                  "description": ""
                },
                {
                  "name": "amplitude",
                  "type": null,
                  "default": "1",
                  "description": ""
                },
                {
                  "name": "phase",
                  "type": null,
                  "default": "0",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "_triangle_wave",
              "description": "triangle wave with amplitude '1' and frequency 'f'",
              "docstring_html": "<p>triangle wave with amplitude '1' and frequency 'f'</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time</dd>\n<dt>f <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>trig wave frequency</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>out <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>trig wave value</dd>\n</dl>\n",
              "source": "def _triangle_wave(self, t, f):\n    \"\"\"triangle wave with amplitude '1' and frequency 'f'\n\n    Parameters\n    ----------\n    t : float\n        evaluation time\n    f : float\n        trig wave frequency\n\n    Returns\n    -------\n    out : float\n        trig wave value\n    \"\"\"\n    return 2 * abs(t*f - np.floor(t*f + 0.5)) - 1",
              "signature": "(t, f)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time"
                },
                {
                  "name": "f",
                  "type": null,
                  "default": null,
                  "description": "trig wave frequency"
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "amplitude",
              "description": "",
              "type": null,
              "value": "amplitude"
            },
            {
              "name": "frequency",
              "description": "",
              "type": null,
              "value": "frequency"
            },
            {
              "name": "phase",
              "description": "",
              "type": null,
              "value": "phase"
            },
            {
              "name": "_tau",
              "description": "",
              "type": null,
              "value": "self.phase / (2 * np.pi * self.frequency)"
            }
          ],
          "parameters": [
            {
              "name": "frequency",
              "type": null,
              "default": "1",
              "description": "frequency of the triangle wave"
            },
            {
              "name": "amplitude",
              "type": null,
              "default": "1",
              "description": "amplitude of the triangle wave"
            },
            {
              "name": "phase",
              "type": null,
              "default": "0",
              "description": "phase of the triangle wave"
            }
          ]
        },
        {
          "name": "SinusoidalSource",
          "description": "Source block that generates a sinusoid wave",
          "docstring_html": "<p>Source block that generates a sinusoid wave</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>frequency <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>frequency of the sinusoid</dd>\n<dt>amplitude <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>amplitude of the sinusoid</dd>\n<dt>phase <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>phase of the sinusoid</dd>\n</dl>\n",
          "source": "class SinusoidalSource(Source):\n    \"\"\"Source block that generates a sinusoid wave\n\n    Parameters\n    ----------\n    frequency : float\n        frequency of the sinusoid\n    amplitude : float\n        amplitude of the sinusoid\n    phase : float\n        phase of the sinusoid\n    \"\"\"\n\n    def __init__(self, frequency=1, amplitude=1, phase=0):\n\n        #block params\n        self.amplitude = amplitude\n        self.frequency = frequency\n        self.phase = phase\n\n        #angular frequency\n        self._omega = 2*np.pi*self.frequency\n\n        super().__init__(\n            func=lambda t: self.amplitude * np.sin(self._omega*t + self.phase)\n            )",
          "bases": [
            "pathsim.blocks.sources.Source"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, frequency=1, amplitude=1, phase=0):\n\n    #block params\n    self.amplitude = amplitude\n    self.frequency = frequency\n    self.phase = phase\n\n    #angular frequency\n    self._omega = 2*np.pi*self.frequency\n\n    super().__init__(\n        func=lambda t: self.amplitude * np.sin(self._omega*t + self.phase)\n        )",
              "signature": "(frequency = 1, amplitude = 1, phase = 0)",
              "parameters": [
                {
                  "name": "frequency",
                  "type": null,
                  "default": "1",
                  "description": ""
                },
                {
                  "name": "amplitude",
                  "type": null,
                  "default": "1",
                  "description": ""
                },
                {
                  "name": "phase",
                  "type": null,
                  "default": "0",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "amplitude",
              "description": "",
              "type": null,
              "value": "amplitude"
            },
            {
              "name": "frequency",
              "description": "",
              "type": null,
              "value": "frequency"
            },
            {
              "name": "phase",
              "description": "",
              "type": null,
              "value": "phase"
            },
            {
              "name": "_omega",
              "description": "",
              "type": null,
              "value": "2 * np.pi * self.frequency"
            }
          ],
          "parameters": [
            {
              "name": "frequency",
              "type": null,
              "default": "1",
              "description": "frequency of the sinusoid"
            },
            {
              "name": "amplitude",
              "type": null,
              "default": "1",
              "description": "amplitude of the sinusoid"
            },
            {
              "name": "phase",
              "type": null,
              "default": "0",
              "description": "phase of the sinusoid"
            }
          ]
        },
        {
          "name": "GaussianPulseSource",
          "description": "Source block that generates a gaussian pulse",
          "docstring_html": "<p>Source block that generates a gaussian pulse</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>amplitude <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>amplitude of the gaussian pulse</dd>\n<dt>f_max <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>maximum frequency component of the gaussian pulse (steepness)</dd>\n<dt>tau <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>time delay of the gaussian pulse</dd>\n</dl>\n",
          "source": "class GaussianPulseSource(Source):\n    \"\"\"Source block that generates a gaussian pulse\n\n    Parameters\n    ----------\n    amplitude : float\n        amplitude of the gaussian pulse\n    f_max : float\n        maximum frequency component of the gaussian pulse (steepness)\n    tau : float\n        time delay of the gaussian pulse \n    \"\"\"\n\n    def __init__(self, amplitude=1, f_max=1e3, tau=0.0):\n\n        #block outputs with port labels\n        self.outputs = Register(mapping={\"out\": 0})\n\n        #block params\n        self.amplitude = amplitude\n        self.f_max = f_max\n        self.tau = tau\n\n        super().__init__(\n            func=lambda t: self.amplitude * self._gaussian(t-self.tau, self.f_max)\n            )\n\n\n    def _gaussian(self, t, f_max):\n        \"\"\"gaussian pulse with its maximum at t=0\n\n        Parameters\n        ----------\n        t : float\n            evaluation time\n        f_max : float\n            maximum frequency component of gaussian\n\n        Returns\n        -------\n        out : float\n            gaussian value\n        \"\"\"\n        tau = 0.5 / f_max\n        return np.exp(-(t/tau)**2)",
          "bases": [
            "pathsim.blocks.sources.Source"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, amplitude=1, f_max=1e3, tau=0.0):\n\n    #block outputs with port labels\n    self.outputs = Register(mapping={\"out\": 0})\n\n    #block params\n    self.amplitude = amplitude\n    self.f_max = f_max\n    self.tau = tau\n\n    super().__init__(\n        func=lambda t: self.amplitude * self._gaussian(t-self.tau, self.f_max)\n        )",
              "signature": "(amplitude = 1, f_max = 1000.0, tau = 0.0)",
              "parameters": [
                {
                  "name": "amplitude",
                  "type": null,
                  "default": "1",
                  "description": ""
                },
                {
                  "name": "f_max",
                  "type": null,
                  "default": "1000.0",
                  "description": ""
                },
                {
                  "name": "tau",
                  "type": null,
                  "default": "0.0",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "_gaussian",
              "description": "gaussian pulse with its maximum at t=0",
              "docstring_html": "<p>gaussian pulse with its maximum at t=0</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time</dd>\n<dt>f_max <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>maximum frequency component of gaussian</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>out <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>gaussian value</dd>\n</dl>\n",
              "source": "def _gaussian(self, t, f_max):\n    \"\"\"gaussian pulse with its maximum at t=0\n\n    Parameters\n    ----------\n    t : float\n        evaluation time\n    f_max : float\n        maximum frequency component of gaussian\n\n    Returns\n    -------\n    out : float\n        gaussian value\n    \"\"\"\n    tau = 0.5 / f_max\n    return np.exp(-(t/tau)**2)",
              "signature": "(t, f_max)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time"
                },
                {
                  "name": "f_max",
                  "type": null,
                  "default": null,
                  "description": "maximum frequency component of gaussian"
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "outputs",
              "description": "",
              "type": null,
              "value": "Register(mapping={'out': 0})"
            },
            {
              "name": "amplitude",
              "description": "",
              "type": null,
              "value": "amplitude"
            },
            {
              "name": "f_max",
              "description": "",
              "type": null,
              "value": "f_max"
            },
            {
              "name": "tau",
              "description": "",
              "type": null,
              "value": "tau"
            }
          ],
          "parameters": [
            {
              "name": "amplitude",
              "type": null,
              "default": "1",
              "description": "amplitude of the gaussian pulse"
            },
            {
              "name": "f_max",
              "type": null,
              "default": "1000.0",
              "description": "maximum frequency component of the gaussian pulse (steepness)"
            },
            {
              "name": "tau",
              "type": null,
              "default": "0.0",
              "description": "time delay of the gaussian pulse"
            }
          ]
        },
        {
          "name": "SinusoidalPhaseNoiseSource",
          "description": "Sinusoidal source with cumulative and white phase noise.",
          "docstring_html": "<p>Sinusoidal source with cumulative and white phase noise.</p>\n<p>Generates a sinusoid with additive phase noise from two components:</p>\n<ul class=\"simple\">\n<li>White phase noise: sampled from a normal distribution at each sample</li>\n<li>Cumulative phase noise: integrated random walk process</li>\n</ul>\n<p>The output is given by:</p>\n<pre class=\"math\">\ny(t) = A \\sin\\left(\\omega t + \\varphi_0 + \\sigma_w n_w(t) + \\sigma_c \\int_0^t n_c(\\tau) d\\tau\\right)\n</pre>\n<p>where <tt class=\"math\">A</tt> is amplitude, <tt class=\"math\">\\omega = 2\\pi f</tt> is angular frequency,\n<tt class=\"math\">\\varphi_0</tt> is initial phase, <tt class=\"math\">\\sigma_w</tt> and <tt class=\"math\">\\sigma_c</tt> are\nthe white and cumulative noise weights, and <tt class=\"math\">n_w(t)</tt> and <tt class=\"math\">n_c(t)</tt> are\nindependent standard normal random processes sampled at the specified sampling period.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>frequency <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>frequency of the sinusoid</dd>\n<dt>amplitude <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>amplitude of the sinusoid</dd>\n<dt>phase <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>initial phase of the sinusoid (radians)</dd>\n<dt>sig_cum <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>weight for cumulative phase noise contribution</dd>\n<dt>sig_white <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>weight for white phase noise contribution</dd>\n<dt>sampling_period <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float, None</span></dt>\n<dd>time between phase noise samples. If None,\nnoise is sampled every timestep (default is 0.1)</dd>\n</dl>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>omega <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>angular frequency of the sinusoid, derived from <cite>frequency</cite></dd>\n<dt>noise_1 <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>internal noise value for white phase noise</dd>\n<dt>noise_2 <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>internal noise value for cumulative phase noise</dd>\n<dt>events <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">list[Schedule]</span></dt>\n<dd>scheduled event for periodic sampling (only if sampling_period is set)</dd>\n</dl>\n",
          "source": "class SinusoidalPhaseNoiseSource(Block):\n    \"\"\"Sinusoidal source with cumulative and white phase noise.\n\n    Generates a sinusoid with additive phase noise from two components:\n\n    - White phase noise: sampled from a normal distribution at each sample\n    - Cumulative phase noise: integrated random walk process\n\n    The output is given by:\n\n    .. math::\n\n        y(t) = A \\\\sin\\\\left(\\\\omega t + \\\\varphi_0 + \\\\sigma_w n_w(t) + \\\\sigma_c \\\\int_0^t n_c(\\\\tau) d\\\\tau\\\\right)\n\n    where :math:`A` is amplitude, :math:`\\\\omega = 2\\\\pi f` is angular frequency,\n    :math:`\\\\varphi_0` is initial phase, :math:`\\\\sigma_w` and :math:`\\\\sigma_c` are\n    the white and cumulative noise weights, and :math:`n_w(t)` and :math:`n_c(t)` are\n    independent standard normal random processes sampled at the specified sampling period.\n\n    Parameters\n    ----------\n    frequency : float\n        frequency of the sinusoid\n    amplitude : float\n        amplitude of the sinusoid\n    phase : float\n        initial phase of the sinusoid (radians)\n    sig_cum : float\n        weight for cumulative phase noise contribution\n    sig_white : float\n        weight for white phase noise contribution\n    sampling_period : float, None\n        time between phase noise samples. If None,\n        noise is sampled every timestep (default is 0.1)\n\n    Attributes\n    ----------\n    omega : float\n        angular frequency of the sinusoid, derived from `frequency`\n    noise_1 : float\n        internal noise value for white phase noise\n    noise_2 : float\n        internal noise value for cumulative phase noise\n    events : list[Schedule]\n        scheduled event for periodic sampling (only if sampling_period is set)\n    \"\"\"\n\n    input_port_labels = {}\n    output_port_labels = {\"out\":0}\n\n    def __init__(\n        self,\n        frequency=1,\n        amplitude=1,\n        phase=0,\n        sig_cum=0,\n        sig_white=0,\n        sampling_period=0.1\n        ):\n        super().__init__()\n\n        #block params\n        self.amplitude = amplitude\n        self.frequency = frequency\n        self.phase = phase\n        self.sampling_period = sampling_period\n\n        self.omega = 2 * np.pi * self.frequency\n\n        #parameters for phase noise\n        self.sig_cum = sig_cum\n        self.sig_white = sig_white\n\n        #initial noise sampling\n        self.noise_1 = np.random.normal()\n        self.noise_2 = np.random.normal()\n\n        #initial state for integration engine\n        self.initial_value = 0.0\n\n        #sampling produces discrete time behavior for noise\n        if sampling_period is None:\n            pass  # sample every timestep\n        else:\n            #internal scheduled event for noise sampling\n            def _sample_noise(t):\n                self.noise_1 = np.random.normal()\n                self.noise_2 = np.random.normal()\n\n            self.events = [\n                Schedule(\n                    t_start=0,\n                    t_period=sampling_period,\n                    func_act=_sample_noise\n                )\n            ]\n\n\n    def __len__(self):\n        return 0\n\n\n    def reset(self):\n        \"\"\"Reset block state including noise samples.\"\"\"\n        super().reset()\n\n        #reset noise samples\n        self.noise_1 = np.random.normal()\n        self.noise_2 = np.random.normal()\n\n\n    def update(self, t):\n        \"\"\"Update system equation for fixed point loop, evaluating the \n        sinusoid with phase noise.\n\n        Parameters\n        ----------\n        t : float\n            evaluation time\n        \"\"\"\n        #compute phase error from white and cumulative noise\n        phase_error = self.sig_white * self.noise_1 + self.sig_cum * self.engine.state\n\n        #set output\n        self.outputs[0] = self.amplitude * np.sin(self.omega*t + self.phase + phase_error)\n\n\n    def sample(self, t, dt):\n        \"\"\"Sample from a normal distribution after successful timestep.\n\n        Only used when sampling_period is None (continuous sampling).\n\n        Parameters\n        ----------\n        t : float\n            evaluation time\n        dt : float\n            integration timestep\n        \"\"\"\n        if self.sampling_period is None:\n            self.noise_1 = np.random.normal()\n            self.noise_2 = np.random.normal()\n\n\n    def solve(self, t, dt):\n        \"\"\"Advance solution of implicit update equation for cumulative noise integration.\n\n        Parameters\n        ----------\n        t : float\n            evaluation time\n        dt : float\n            integration timestep\n\n        Returns\n        -------\n        float\n            error estimate (always 0.0 for noise source)\n        \"\"\"\n        #advance solution of implicit update equation (no jacobian)\n        f = self.noise_2\n        self.engine.solve(f, None, dt)\n        return 0.0\n\n\n    def step(self, t, dt):\n        \"\"\"Compute update step with integration engine for cumulative noise.\n\n        Parameters\n        ----------\n        t : float\n            evaluation time\n        dt : float\n            integration timestep\n\n        Returns\n        -------\n        tuple\n            (accepted, error, scale_factor) - always (True, 0.0, None) for noise\n        \"\"\"\n        #compute update step with integration engine\n        f = self.noise_2\n        self.engine.step(f, dt)\n\n        #no error control for noise source\n        return True, 0.0, None",
          "bases": [
            "pathsim.blocks._block.Block"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(\n    self,\n    frequency=1,\n    amplitude=1,\n    phase=0,\n    sig_cum=0,\n    sig_white=0,\n    sampling_period=0.1\n    ):\n    super().__init__()\n\n    #block params\n    self.amplitude = amplitude\n    self.frequency = frequency\n    self.phase = phase\n    self.sampling_period = sampling_period\n\n    self.omega = 2 * np.pi * self.frequency\n\n    #parameters for phase noise\n    self.sig_cum = sig_cum\n    self.sig_white = sig_white\n\n    #initial noise sampling\n    self.noise_1 = np.random.normal()\n    self.noise_2 = np.random.normal()\n\n    #initial state for integration engine\n    self.initial_value = 0.0\n\n    #sampling produces discrete time behavior for noise\n    if sampling_period is None:\n        pass  # sample every timestep\n    else:\n        #internal scheduled event for noise sampling\n        def _sample_noise(t):\n            self.noise_1 = np.random.normal()\n            self.noise_2 = np.random.normal()\n\n        self.events = [\n            Schedule(\n                t_start=0,\n                t_period=sampling_period,\n                func_act=_sample_noise\n            )\n        ]",
              "signature": "(frequency = 1, amplitude = 1, phase = 0, sig_cum = 0, sig_white = 0, sampling_period = 0.1)",
              "parameters": [
                {
                  "name": "frequency",
                  "type": null,
                  "default": "1",
                  "description": ""
                },
                {
                  "name": "amplitude",
                  "type": null,
                  "default": "1",
                  "description": ""
                },
                {
                  "name": "phase",
                  "type": null,
                  "default": "0",
                  "description": ""
                },
                {
                  "name": "sig_cum",
                  "type": null,
                  "default": "0",
                  "description": ""
                },
                {
                  "name": "sig_white",
                  "type": null,
                  "default": "0",
                  "description": ""
                },
                {
                  "name": "sampling_period",
                  "type": null,
                  "default": "0.1",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "reset",
              "description": "Reset block state including noise samples.",
              "docstring_html": "<p>Reset block state including noise samples.</p>\n",
              "source": "def reset(self):\n    \"\"\"Reset block state including noise samples.\"\"\"\n    super().reset()\n\n    #reset noise samples\n    self.noise_1 = np.random.normal()\n    self.noise_2 = np.random.normal()",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "update",
              "description": "Update system equation for fixed point loop, evaluating the",
              "docstring_html": "<p>Update system equation for fixed point loop, evaluating the\nsinusoid with phase noise.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time</dd>\n</dl>\n",
              "source": "def update(self, t):\n    \"\"\"Update system equation for fixed point loop, evaluating the \n    sinusoid with phase noise.\n\n    Parameters\n    ----------\n    t : float\n        evaluation time\n    \"\"\"\n    #compute phase error from white and cumulative noise\n    phase_error = self.sig_white * self.noise_1 + self.sig_cum * self.engine.state\n\n    #set output\n    self.outputs[0] = self.amplitude * np.sin(self.omega*t + self.phase + phase_error)",
              "signature": "(t)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "sample",
              "description": "Sample from a normal distribution after successful timestep.",
              "docstring_html": "<p>Sample from a normal distribution after successful timestep.</p>\n<p>Only used when sampling_period is None (continuous sampling).</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time</dd>\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>integration timestep</dd>\n</dl>\n",
              "source": "def sample(self, t, dt):\n    \"\"\"Sample from a normal distribution after successful timestep.\n\n    Only used when sampling_period is None (continuous sampling).\n\n    Parameters\n    ----------\n    t : float\n        evaluation time\n    dt : float\n        integration timestep\n    \"\"\"\n    if self.sampling_period is None:\n        self.noise_1 = np.random.normal()\n        self.noise_2 = np.random.normal()",
              "signature": "(t, dt)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time"
                },
                {
                  "name": "dt",
                  "type": null,
                  "default": null,
                  "description": "integration timestep"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "solve",
              "description": "Advance solution of implicit update equation for cumulative noise integration.",
              "docstring_html": "<p>Advance solution of implicit update equation for cumulative noise integration.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time</dd>\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>integration timestep</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>float</dt>\n<dd>error estimate (always 0.0 for noise source)</dd>\n</dl>\n",
              "source": "def solve(self, t, dt):\n    \"\"\"Advance solution of implicit update equation for cumulative noise integration.\n\n    Parameters\n    ----------\n    t : float\n        evaluation time\n    dt : float\n        integration timestep\n\n    Returns\n    -------\n    float\n        error estimate (always 0.0 for noise source)\n    \"\"\"\n    #advance solution of implicit update equation (no jacobian)\n    f = self.noise_2\n    self.engine.solve(f, None, dt)\n    return 0.0",
              "signature": "(t, dt)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time"
                },
                {
                  "name": "dt",
                  "type": null,
                  "default": null,
                  "description": "integration timestep Returns ------- float error estimate (always 0.0 for noise source)"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "step",
              "description": "Compute update step with integration engine for cumulative noise.",
              "docstring_html": "<p>Compute update step with integration engine for cumulative noise.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time</dd>\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>integration timestep</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>tuple</dt>\n<dd>(accepted, error, scale_factor) - always (True, 0.0, None) for noise</dd>\n</dl>\n",
              "source": "def step(self, t, dt):\n    \"\"\"Compute update step with integration engine for cumulative noise.\n\n    Parameters\n    ----------\n    t : float\n        evaluation time\n    dt : float\n        integration timestep\n\n    Returns\n    -------\n    tuple\n        (accepted, error, scale_factor) - always (True, 0.0, None) for noise\n    \"\"\"\n    #compute update step with integration engine\n    f = self.noise_2\n    self.engine.step(f, dt)\n\n    #no error control for noise source\n    return True, 0.0, None",
              "signature": "(t, dt)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time"
                },
                {
                  "name": "dt",
                  "type": null,
                  "default": null,
                  "description": "integration timestep Returns ------- tuple (accepted, error, scale_factor) - always (True, 0.0, None) for noise"
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "input_port_labels",
              "description": "",
              "type": null,
              "value": "{}"
            },
            {
              "name": "output_port_labels",
              "description": "",
              "type": null,
              "value": "{'out': 0}"
            },
            {
              "name": "amplitude",
              "description": "",
              "type": null,
              "value": "amplitude"
            },
            {
              "name": "frequency",
              "description": "",
              "type": null,
              "value": "frequency"
            },
            {
              "name": "phase",
              "description": "",
              "type": null,
              "value": "phase"
            },
            {
              "name": "sampling_period",
              "description": "",
              "type": null,
              "value": "sampling_period"
            },
            {
              "name": "omega",
              "description": "",
              "type": null,
              "value": "2 * np.pi * self.frequency"
            },
            {
              "name": "sig_cum",
              "description": "",
              "type": null,
              "value": "sig_cum"
            },
            {
              "name": "sig_white",
              "description": "",
              "type": null,
              "value": "sig_white"
            },
            {
              "name": "noise_1",
              "description": "",
              "type": null,
              "value": "np.random.normal()"
            },
            {
              "name": "noise_2",
              "description": "",
              "type": null,
              "value": "np.random.normal()"
            },
            {
              "name": "initial_value",
              "description": "",
              "type": null,
              "value": "0.0"
            },
            {
              "name": "events",
              "description": "",
              "type": null,
              "value": "[Schedule(t_start=0, t_period=sampling_period, func_act=_sample_noise)]"
            }
          ],
          "parameters": [
            {
              "name": "frequency",
              "type": null,
              "default": "1",
              "description": "frequency of the sinusoid"
            },
            {
              "name": "amplitude",
              "type": null,
              "default": "1",
              "description": "amplitude of the sinusoid"
            },
            {
              "name": "phase",
              "type": null,
              "default": "0",
              "description": "initial phase of the sinusoid (radians)"
            },
            {
              "name": "sig_cum",
              "type": null,
              "default": "0",
              "description": "weight for cumulative phase noise contribution"
            },
            {
              "name": "sig_white",
              "type": null,
              "default": "0",
              "description": "weight for white phase noise contribution"
            },
            {
              "name": "sampling_period",
              "type": null,
              "default": "0.1",
              "description": "time between phase noise samples. If None, noise is sampled every timestep (default is 0.1)"
            }
          ]
        },
        {
          "name": "ChirpPhaseNoiseSource",
          "description": "Chirp source, sinusoid with frequency ramp up and ramp down, plus phase noise.",
          "docstring_html": "<p>Chirp source, sinusoid with frequency ramp up and ramp down, plus phase noise.</p>\n<p>This works by using a time dependent triangle wave for the frequency\nand integrating it with a numerical integration engine to get a\ncontinuous phase. This phase is then used to evaluate a sinusoid.</p>\n<p>Additionally the chirp source can have white and cumulative phase noise.\nMathematically it looks like this for the contributions to the phase from\nthe triangular wave:</p>\n<pre class=\"math\">\n\\varphi_t(t) = \\int_0^t \\mathrm{tri}_{f_0, B, T}(\\tau) \\, d\\tau\n</pre>\n<p>And from the white (w) and cumulative (c) noise:</p>\n<pre class=\"math\">\n\\varphi_n(t) = \\sigma_w \\, n_w(t) + \\sigma_c \\int_0^t n_c(\\tau) \\, d\\tau\n</pre>\n<p>The phase contributions are then used to evaluate a sinusoid to get the final chirp signal:</p>\n<pre class=\"math\">\ny(t) = A \\sin(\\varphi_t(t) + \\varphi_n(t) + \\varphi_0)\n</pre>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>amplitude <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>amplitude of the chirp signal</dd>\n<dt>f0 <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>start frequency of the chirp signal</dd>\n<dt>BW <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>bandwidth of the frequency ramp of the chirp signal</dd>\n<dt>T <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>period of the frequency ramp of the chirp signal</dd>\n<dt>phase <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>phase of sinusoid (initial, radians)</dd>\n<dt>sig_cum <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>weight for cumulative phase noise contribution</dd>\n<dt>sig_white <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>weight for white phase noise contribution</dd>\n<dt>sampling_period <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float, None</span></dt>\n<dd>time between phase noise samples. If None,\nnoise is sampled every timestep (default is 0.1)</dd>\n</dl>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>noise_1 <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>internal noise value for white phase noise</dd>\n<dt>noise_2 <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>internal noise value for cumulative phase noise</dd>\n<dt>events <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">list[Schedule]</span></dt>\n<dd>scheduled event for periodic sampling (only if sampling_period is set)</dd>\n</dl>\n",
          "source": "class ChirpPhaseNoiseSource(Block):\n    \"\"\"Chirp source, sinusoid with frequency ramp up and ramp down, plus phase noise.\n\n    This works by using a time dependent triangle wave for the frequency \n    and integrating it with a numerical integration engine to get a \n    continuous phase. This phase is then used to evaluate a sinusoid.\n\n    Additionally the chirp source can have white and cumulative phase noise. \n    Mathematically it looks like this for the contributions to the phase from \n    the triangular wave:\n\n    .. math::\n\n        \\\\varphi_t(t) = \\\\int_0^t \\\\mathrm{tri}_{f_0, B, T}(\\\\tau) \\\\, d\\\\tau\n\n    And from the white (w) and cumulative (c) noise:\n\n    .. math::\n\n        \\\\varphi_n(t) = \\\\sigma_w \\\\, n_w(t) + \\\\sigma_c \\\\int_0^t n_c(\\\\tau) \\\\, d\\\\tau\n\n    The phase contributions are then used to evaluate a sinusoid to get the final chirp signal:\n\n    .. math::\n\n        y(t) = A \\\\sin(\\\\varphi_t(t) + \\\\varphi_n(t) + \\\\varphi_0)\n\n    Parameters\n    ----------\n    amplitude : float\n        amplitude of the chirp signal\n    f0 : float\n        start frequency of the chirp signal\n    BW : float\n        bandwidth of the frequency ramp of the chirp signal\n    T : float\n        period of the frequency ramp of the chirp signal\n    phase : float\n        phase of sinusoid (initial, radians)\n    sig_cum : float\n        weight for cumulative phase noise contribution\n    sig_white : float\n        weight for white phase noise contribution\n    sampling_period : float, None\n        time between phase noise samples. If None,\n        noise is sampled every timestep (default is 0.1)\n\n    Attributes\n    ----------\n    noise_1 : float\n        internal noise value for white phase noise\n    noise_2 : float\n        internal noise value for cumulative phase noise\n    events : list[Schedule]\n        scheduled event for periodic sampling (only if sampling_period is set)\n    \"\"\"\n\n    input_port_labels = {}\n    output_port_labels = {\"out\":0}\n\n    def __init__(\n        self,\n        amplitude=1,\n        f0=1,\n        BW=1,\n        T=1,\n        phase=0,\n        sig_cum=0,\n        sig_white=0,\n        sampling_period=0.1\n        ):\n        super().__init__()\n\n        #parameters of chirp signal\n        self.amplitude = amplitude\n        self.phase = phase\n        self.f0 = f0\n        self.BW = BW\n        self.T = T\n\n        #parameters for phase noise\n        self.sig_cum = sig_cum\n        self.sig_white = sig_white\n        self.sampling_period = sampling_period\n\n        #initial noise sampling\n        self.noise_1 = np.random.normal()\n        self.noise_2 = np.random.normal()\n\n        #initial state for integration engine\n        self.initial_value = 0.0\n\n        #sampling produces discrete time behavior for noise\n        if sampling_period is None:\n            pass  # sample every timestep\n        else:\n            #internal scheduled event for noise sampling\n            def _sample_noise(t):\n                self.noise_1 = np.random.normal()\n                self.noise_2 = np.random.normal()\n\n            self.events = [\n                Schedule(\n                    t_start=0,\n                    t_period=sampling_period,\n                    func_act=_sample_noise\n                )\n            ]\n\n\n    def __len__(self):\n        return 0\n\n\n    def _triangle_wave(self, t, f):\n        \"\"\"Triangle wave from -1 to +1 with frequency f.\n\n        Parameters\n        ----------\n        t : float\n            evaluation time\n        f : float\n            triangle wave frequency\n\n        Returns\n        -------\n        out : float\n            triangle wave value\n        \"\"\"\n        return 2 * abs(2 * ((t * f) % 1.0) - 1) - 1\n\n\n    def reset(self):\n        \"\"\"Reset block state including noise samples.\"\"\"\n        super().reset()\n\n        #reset noise samples\n        self.noise_1 = np.random.normal()\n        self.noise_2 = np.random.normal()\n\n\n    def sample(self, t, dt):\n        \"\"\"Sample from a normal distribution after successful timestep\n        to update internal noise samples.\n\n        Only used when sampling_period is None (continuous sampling).\n\n        Parameters\n        ----------\n        t : float\n            evaluation time\n        dt : float\n            integration timestep\n        \"\"\"\n        if self.sampling_period is None:\n            self.noise_1 = np.random.normal()\n            self.noise_2 = np.random.normal()\n\n\n    def update(self, t):\n        \"\"\"Update the block output, assemble phase and evaluate the sinusoid.\n\n        Parameters\n        ----------\n        t : float\n            evaluation time\n        \"\"\"\n        _phase = 2 * np.pi * (self.engine.state + self.sig_white * self.noise_1) + self.phase\n        self.outputs[0] = self.amplitude * np.sin(_phase)\n\n\n    def solve(self, t, dt):\n        \"\"\"Advance implicit solver of implicit integration engine, evaluate \n        the triangle wave and cumulative noise RNG.\n\n        Parameters\n        ----------\n        t : float\n            evaluation time\n        dt : float\n            integration timestep\n\n        Returns\n        -------\n        float\n            error estimate (always 0.0 for chirp source)\n        \"\"\"\n        f = self.f0 + self.BW * (1 + self._triangle_wave(t, 1/self.T))/2 + self.sig_cum * self.noise_2\n        self.engine.solve(f, None, dt)\n\n        #no error for chirp source\n        return 0.0\n\n\n    def step(self, t, dt):\n        \"\"\"Compute update step with integration engine, evaluate the triangle wave \n        and cumulative noise RNG.\n\n        Parameters\n        ----------\n        t : float\n            evaluation time\n        dt : float\n            integration timestep\n\n        Returns\n        -------\n        tuple\n            (accepted, error, scale_factor) - always (True, 0.0, None) for chirp\n        \"\"\"\n        f = self.f0 + self.BW * (1 + self._triangle_wave(t, 1/self.T))/2 + self.sig_cum * self.noise_2\n        self.engine.step(f, dt)\n\n        #no error control for chirp source\n        return True, 0.0, None",
          "bases": [
            "pathsim.blocks._block.Block"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(\n    self,\n    amplitude=1,\n    f0=1,\n    BW=1,\n    T=1,\n    phase=0,\n    sig_cum=0,\n    sig_white=0,\n    sampling_period=0.1\n    ):\n    super().__init__()\n\n    #parameters of chirp signal\n    self.amplitude = amplitude\n    self.phase = phase\n    self.f0 = f0\n    self.BW = BW\n    self.T = T\n\n    #parameters for phase noise\n    self.sig_cum = sig_cum\n    self.sig_white = sig_white\n    self.sampling_period = sampling_period\n\n    #initial noise sampling\n    self.noise_1 = np.random.normal()\n    self.noise_2 = np.random.normal()\n\n    #initial state for integration engine\n    self.initial_value = 0.0\n\n    #sampling produces discrete time behavior for noise\n    if sampling_period is None:\n        pass  # sample every timestep\n    else:\n        #internal scheduled event for noise sampling\n        def _sample_noise(t):\n            self.noise_1 = np.random.normal()\n            self.noise_2 = np.random.normal()\n\n        self.events = [\n            Schedule(\n                t_start=0,\n                t_period=sampling_period,\n                func_act=_sample_noise\n            )\n        ]",
              "signature": "(amplitude = 1, f0 = 1, BW = 1, T = 1, phase = 0, sig_cum = 0, sig_white = 0, sampling_period = 0.1)",
              "parameters": [
                {
                  "name": "amplitude",
                  "type": null,
                  "default": "1",
                  "description": ""
                },
                {
                  "name": "f0",
                  "type": null,
                  "default": "1",
                  "description": ""
                },
                {
                  "name": "BW",
                  "type": null,
                  "default": "1",
                  "description": ""
                },
                {
                  "name": "T",
                  "type": null,
                  "default": "1",
                  "description": ""
                },
                {
                  "name": "phase",
                  "type": null,
                  "default": "0",
                  "description": ""
                },
                {
                  "name": "sig_cum",
                  "type": null,
                  "default": "0",
                  "description": ""
                },
                {
                  "name": "sig_white",
                  "type": null,
                  "default": "0",
                  "description": ""
                },
                {
                  "name": "sampling_period",
                  "type": null,
                  "default": "0.1",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "_triangle_wave",
              "description": "Triangle wave from -1 to +1 with frequency f.",
              "docstring_html": "<p>Triangle wave from -1 to +1 with frequency f.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time</dd>\n<dt>f <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>triangle wave frequency</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>out <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>triangle wave value</dd>\n</dl>\n",
              "source": "def _triangle_wave(self, t, f):\n    \"\"\"Triangle wave from -1 to +1 with frequency f.\n\n    Parameters\n    ----------\n    t : float\n        evaluation time\n    f : float\n        triangle wave frequency\n\n    Returns\n    -------\n    out : float\n        triangle wave value\n    \"\"\"\n    return 2 * abs(2 * ((t * f) % 1.0) - 1) - 1",
              "signature": "(t, f)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time"
                },
                {
                  "name": "f",
                  "type": null,
                  "default": null,
                  "description": "triangle wave frequency"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "reset",
              "description": "Reset block state including noise samples.",
              "docstring_html": "<p>Reset block state including noise samples.</p>\n",
              "source": "def reset(self):\n    \"\"\"Reset block state including noise samples.\"\"\"\n    super().reset()\n\n    #reset noise samples\n    self.noise_1 = np.random.normal()\n    self.noise_2 = np.random.normal()",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "sample",
              "description": "Sample from a normal distribution after successful timestep",
              "docstring_html": "<p>Sample from a normal distribution after successful timestep\nto update internal noise samples.</p>\n<p>Only used when sampling_period is None (continuous sampling).</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time</dd>\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>integration timestep</dd>\n</dl>\n",
              "source": "def sample(self, t, dt):\n    \"\"\"Sample from a normal distribution after successful timestep\n    to update internal noise samples.\n\n    Only used when sampling_period is None (continuous sampling).\n\n    Parameters\n    ----------\n    t : float\n        evaluation time\n    dt : float\n        integration timestep\n    \"\"\"\n    if self.sampling_period is None:\n        self.noise_1 = np.random.normal()\n        self.noise_2 = np.random.normal()",
              "signature": "(t, dt)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time"
                },
                {
                  "name": "dt",
                  "type": null,
                  "default": null,
                  "description": "integration timestep"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "update",
              "description": "Update the block output, assemble phase and evaluate the sinusoid.",
              "docstring_html": "<p>Update the block output, assemble phase and evaluate the sinusoid.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time</dd>\n</dl>\n",
              "source": "def update(self, t):\n    \"\"\"Update the block output, assemble phase and evaluate the sinusoid.\n\n    Parameters\n    ----------\n    t : float\n        evaluation time\n    \"\"\"\n    _phase = 2 * np.pi * (self.engine.state + self.sig_white * self.noise_1) + self.phase\n    self.outputs[0] = self.amplitude * np.sin(_phase)",
              "signature": "(t)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "solve",
              "description": "Advance implicit solver of implicit integration engine, evaluate",
              "docstring_html": "<p>Advance implicit solver of implicit integration engine, evaluate\nthe triangle wave and cumulative noise RNG.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time</dd>\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>integration timestep</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>float</dt>\n<dd>error estimate (always 0.0 for chirp source)</dd>\n</dl>\n",
              "source": "def solve(self, t, dt):\n    \"\"\"Advance implicit solver of implicit integration engine, evaluate \n    the triangle wave and cumulative noise RNG.\n\n    Parameters\n    ----------\n    t : float\n        evaluation time\n    dt : float\n        integration timestep\n\n    Returns\n    -------\n    float\n        error estimate (always 0.0 for chirp source)\n    \"\"\"\n    f = self.f0 + self.BW * (1 + self._triangle_wave(t, 1/self.T))/2 + self.sig_cum * self.noise_2\n    self.engine.solve(f, None, dt)\n\n    #no error for chirp source\n    return 0.0",
              "signature": "(t, dt)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time"
                },
                {
                  "name": "dt",
                  "type": null,
                  "default": null,
                  "description": "integration timestep Returns ------- float error estimate (always 0.0 for chirp source)"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "step",
              "description": "Compute update step with integration engine, evaluate the triangle wave",
              "docstring_html": "<p>Compute update step with integration engine, evaluate the triangle wave\nand cumulative noise RNG.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time</dd>\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>integration timestep</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>tuple</dt>\n<dd>(accepted, error, scale_factor) - always (True, 0.0, None) for chirp</dd>\n</dl>\n",
              "source": "def step(self, t, dt):\n    \"\"\"Compute update step with integration engine, evaluate the triangle wave \n    and cumulative noise RNG.\n\n    Parameters\n    ----------\n    t : float\n        evaluation time\n    dt : float\n        integration timestep\n\n    Returns\n    -------\n    tuple\n        (accepted, error, scale_factor) - always (True, 0.0, None) for chirp\n    \"\"\"\n    f = self.f0 + self.BW * (1 + self._triangle_wave(t, 1/self.T))/2 + self.sig_cum * self.noise_2\n    self.engine.step(f, dt)\n\n    #no error control for chirp source\n    return True, 0.0, None",
              "signature": "(t, dt)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time"
                },
                {
                  "name": "dt",
                  "type": null,
                  "default": null,
                  "description": "integration timestep Returns ------- tuple (accepted, error, scale_factor) - always (True, 0.0, None) for chirp"
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "input_port_labels",
              "description": "",
              "type": null,
              "value": "{}"
            },
            {
              "name": "output_port_labels",
              "description": "",
              "type": null,
              "value": "{'out': 0}"
            },
            {
              "name": "amplitude",
              "description": "",
              "type": null,
              "value": "amplitude"
            },
            {
              "name": "phase",
              "description": "",
              "type": null,
              "value": "phase"
            },
            {
              "name": "f0",
              "description": "",
              "type": null,
              "value": "f0"
            },
            {
              "name": "BW",
              "description": "",
              "type": null,
              "value": "BW"
            },
            {
              "name": "T",
              "description": "",
              "type": null,
              "value": "T"
            },
            {
              "name": "sig_cum",
              "description": "",
              "type": null,
              "value": "sig_cum"
            },
            {
              "name": "sig_white",
              "description": "",
              "type": null,
              "value": "sig_white"
            },
            {
              "name": "sampling_period",
              "description": "",
              "type": null,
              "value": "sampling_period"
            },
            {
              "name": "noise_1",
              "description": "",
              "type": null,
              "value": "np.random.normal()"
            },
            {
              "name": "noise_2",
              "description": "",
              "type": null,
              "value": "np.random.normal()"
            },
            {
              "name": "initial_value",
              "description": "",
              "type": null,
              "value": "0.0"
            },
            {
              "name": "events",
              "description": "",
              "type": null,
              "value": "[Schedule(t_start=0, t_period=sampling_period, func_act=_sample_noise)]"
            }
          ],
          "parameters": [
            {
              "name": "amplitude",
              "type": null,
              "default": "1",
              "description": "amplitude of the chirp signal"
            },
            {
              "name": "f0",
              "type": null,
              "default": "1",
              "description": "start frequency of the chirp signal"
            },
            {
              "name": "BW",
              "type": null,
              "default": "1",
              "description": "bandwidth of the frequency ramp of the chirp signal"
            },
            {
              "name": "T",
              "type": null,
              "default": "1",
              "description": "period of the frequency ramp of the chirp signal"
            },
            {
              "name": "phase",
              "type": null,
              "default": "0",
              "description": "phase of sinusoid (initial, radians)"
            },
            {
              "name": "sig_cum",
              "type": null,
              "default": "0",
              "description": "weight for cumulative phase noise contribution"
            },
            {
              "name": "sig_white",
              "type": null,
              "default": "0",
              "description": "weight for white phase noise contribution"
            },
            {
              "name": "sampling_period",
              "type": null,
              "default": "0.1",
              "description": "time between phase noise samples. If None, noise is sampled every timestep (default is 0.1)"
            }
          ]
        },
        {
          "name": "ChirpSource",
          "description": "Alias for ChirpPhaseNoiseSource.",
          "docstring_html": "<p>Alias for ChirpPhaseNoiseSource.</p>\n",
          "source": "@deprecated(version=\"1.0.0\", replacement=\"ChirpPhaseNoiseSource\")\nclass ChirpSource(ChirpPhaseNoiseSource):\n    \"\"\"Alias for ChirpPhaseNoiseSource.\"\"\"\n    pass",
          "bases": [
            "pathsim.blocks.sources.ChirpPhaseNoiseSource"
          ],
          "methods": [],
          "attributes": [],
          "parameters": []
        },
        {
          "name": "PulseSource",
          "description": "Generates a periodic pulse waveform with defined rise and fall times.",
          "docstring_html": "<p>Generates a periodic pulse waveform with defined rise and fall times.</p>\n<p>Scheduled events trigger phase changes (low, rising, high, falling),\nand the <cite>update</cite> method calculates the output value based on the\ncurrent phase, performing linear interpolation during rise and fall.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>amplitude <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float, optional</span></dt>\n<dd>Peak amplitude of the pulse. Default is 1.0.</dd>\n<dt>T <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float, optional</span></dt>\n<dd>Period of the pulse train. Must be positive. Default is 1.0.</dd>\n<dt>t_rise <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float, optional</span></dt>\n<dd>Duration of the rising edge. Default is 0.0.</dd>\n<dt>t_fall <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float, optional</span></dt>\n<dd>Duration of the falling edge. Default is 0.0.</dd>\n<dt>tau <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float, optional</span></dt>\n<dd>Initial delay before the first pulse cycle begins. Default is 0.0.</dd>\n<dt>duty <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float, optional</span></dt>\n<dd>Duty cycle, ratio of the pulse ON duration (plateau time only)\nto the total period T (must be between 0 and 1). Default is 0.5.\nThe high plateau duration is <cite>T * duty</cite>.</dd>\n</dl>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>events <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">list[Schedule]</span></dt>\n<dd>Internal scheduled events triggering phase transitions.</dd>\n<dt>_phase <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">str</span></dt>\n<dd>Current phase of the pulse ('low', 'rising', 'high', 'falling').</dd>\n<dt>_phase_start_time <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>Simulation time when the current phase began.</dd>\n</dl>\n",
          "source": "class PulseSource(Block):\n    \"\"\"Generates a periodic pulse waveform with defined rise and fall times.\n\n    Scheduled events trigger phase changes (low, rising, high, falling),\n    and the `update` method calculates the output value based on the\n    current phase, performing linear interpolation during rise and fall.\n\n    Parameters\n    ----------\n    amplitude : float, optional\n        Peak amplitude of the pulse. Default is 1.0.\n    T : float, optional\n        Period of the pulse train. Must be positive. Default is 1.0.\n    t_rise : float, optional\n        Duration of the rising edge. Default is 0.0.\n    t_fall : float, optional\n        Duration of the falling edge. Default is 0.0.\n    tau : float, optional\n        Initial delay before the first pulse cycle begins. Default is 0.0.\n    duty : float, optional\n        Duty cycle, ratio of the pulse ON duration (plateau time only)\n        to the total period T (must be between 0 and 1). Default is 0.5.\n        The high plateau duration is `T * duty`.\n\n    Attributes\n    ----------\n    events : list[Schedule]\n        Internal scheduled events triggering phase transitions.\n    _phase : str\n        Current phase of the pulse ('low', 'rising', 'high', 'falling').\n    _phase_start_time : float\n        Simulation time when the current phase began.\n    \"\"\"\n\n    input_port_labels = {}\n    output_port_labels = {\"out\":0}\n\n    def __init__(\n        self, \n        amplitude=1.0, \n        T=1.0, \n        t_rise=0.0, \n        t_fall=0.0, \n        tau=0.0, \n        duty=0.5\n        ):\n        super().__init__()\n\n        #input validation\n        if not (T > 0):\n            raise ValueError(\"Period T must be positive.\")\n        if not (0 <= t_rise):\n            raise ValueError(\"Rise time t_rise cannot be negative.\")\n        if not (0 <= t_fall):\n            raise ValueError(\"Fall time t_fall cannot be negative.\")\n        if not (0 <= duty <= 1):\n            raise ValueError(\"Duty cycle must be between 0 and 1.\")\n\n        #ensure rise + high plateau + fall fits within a period\n        t_plateau = T * duty\n        if t_rise + t_plateau + t_fall > T:\n            raise ValueError(\"Total pulse time (rise+plateau+fall) exceeds period T\")\n\n        #parameters\n        self.amplitude = amplitude\n        self.T = T\n        self.t_rise = max(TOLERANCE, t_rise)\n        self.t_fall = max(TOLERANCE, t_fall)\n        self.tau = tau\n        self.duty = duty # Duty cycle now refers to the high plateau time\n\n        #internal state\n        self._phase = 'low'\n        self._phase_start_time = self.tau \n\n        #event timings relative to start of cycle (tau)\n        t_start_rise = self.tau\n        t_start_high = t_start_rise + self.t_rise \n        t_start_fall = t_start_high + t_plateau \n        t_start_low  = t_start_fall + self.t_fall \n\n        #define event actions (update phase and start time) \n        def _set_phase_rising(t):\n            self._phase = 'rising'\n            self._phase_start_time = t\n            self.outputs[0] = 0.0    \n\n        def _set_phase_high(t):\n            self._phase = 'high'\n            self._phase_start_time = t\n            self.outputs[0] = self.amplitude\n\n        def _set_phase_falling(t):\n            self._phase = 'falling'\n            self._phase_start_time = t\n            self.outputs[0] = self.amplitude\n\n        def _set_phase_low(t):\n            self._phase = 'low'\n            self._phase_start_time = t\n            self.outputs[0] = 0.0    \n\n        #start rising\n        _E_rising = Schedule( \n            t_start=max(0.0, t_start_rise), \n            t_period=self.T, \n            func_act=_set_phase_rising\n            )\n\n        #start high plateau (end rising)\n        _E_high = Schedule(\n            t_start=max(0.0, t_start_high), \n            t_period=self.T, \n            func_act=_set_phase_high\n            )\n\n        #start falling\n        _E_falling = Schedule( \n            t_start=max(0.0, t_start_fall), \n            t_period=self.T, \n            func_act=_set_phase_falling\n            )\n\n        #start low (end falling)\n        _E_low = Schedule( \n            t_start=max(0.0, t_start_low), \n            t_period=self.T, \n            func_act=_set_phase_low\n            )\n\n        #scheduled events for state transitions\n        self.events = [_E_rising, _E_high, _E_falling, _E_low]\n\n\n    def reset(self, t: float=None):\n        \"\"\"\n        Resets the block state.\n\n        Note\n        ----\n            This block has a special implementation of reset where ``t`` can be provided\n            to reset the block's state to the specified time.\n            This is done by changing the phase of the pulse + resetting all the internal events.\n\n        Parameters\n        ----------\n            t: float, optional\n                Time to reset the block state at. If None, resets to initial state.\n\n        \"\"\"\n        if t:\n            self._phase_start_time = t\n\n            # event timings relative to start of cycle (tau)\n            new_t_start_rise = t\n            new_t_start_high = new_t_start_rise + self.t_rise\n            t_plateau = self.T * self.duty\n            new_t_start_fall = new_t_start_high + t_plateau\n            new_t_start_low = new_t_start_fall + self.t_fall\n\n            self.events[0].t_start = max(0.0, new_t_start_rise)\n            self.events[1].t_start = max(0.0, new_t_start_high)\n            self.events[2].t_start = max(0.0, new_t_start_fall)\n            self.events[3].t_start = max(0.0, new_t_start_low)\n\n            for e in self.events:\n                e.reset()\n        else:\n            super().reset()\n            self._phase = 'low'\n            self._phase_start_time = self.tau\n\n    def update(self, t):\n        \"\"\"Calculate the pulse output value based on the current phase.\n        Performs linear interpolation during 'rising' and 'falling' phases.\n\n        Parameters\n        ----------\n        t : float\n            evaluation time\n        \"\"\"\n\n        #calculate output based on phase\n        if self._phase == 'rising':\n            _val = self.amplitude * (t - self._phase_start_time) / self.t_rise\n            self.outputs[0] = np.clip(_val, 0.0, self.amplitude)\n        elif self._phase == 'high':\n            self.outputs[0] = self.amplitude\n        elif self._phase == 'falling':\n            _val = self.amplitude * (1.0 - (t - self._phase_start_time) / self.t_fall)\n            self.outputs[0] = np.clip(_val, 0.0, self.amplitude)\n        elif self._phase == 'low':\n            self.outputs[0] = 0.0\n\n\n    def __len__(self):\n        #no algebraic passthrough\n        return 0",
          "bases": [
            "pathsim.blocks._block.Block"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(\n    self, \n    amplitude=1.0, \n    T=1.0, \n    t_rise=0.0, \n    t_fall=0.0, \n    tau=0.0, \n    duty=0.5\n    ):\n    super().__init__()\n\n    #input validation\n    if not (T > 0):\n        raise ValueError(\"Period T must be positive.\")\n    if not (0 <= t_rise):\n        raise ValueError(\"Rise time t_rise cannot be negative.\")\n    if not (0 <= t_fall):\n        raise ValueError(\"Fall time t_fall cannot be negative.\")\n    if not (0 <= duty <= 1):\n        raise ValueError(\"Duty cycle must be between 0 and 1.\")\n\n    #ensure rise + high plateau + fall fits within a period\n    t_plateau = T * duty\n    if t_rise + t_plateau + t_fall > T:\n        raise ValueError(\"Total pulse time (rise+plateau+fall) exceeds period T\")\n\n    #parameters\n    self.amplitude = amplitude\n    self.T = T\n    self.t_rise = max(TOLERANCE, t_rise)\n    self.t_fall = max(TOLERANCE, t_fall)\n    self.tau = tau\n    self.duty = duty # Duty cycle now refers to the high plateau time\n\n    #internal state\n    self._phase = 'low'\n    self._phase_start_time = self.tau \n\n    #event timings relative to start of cycle (tau)\n    t_start_rise = self.tau\n    t_start_high = t_start_rise + self.t_rise \n    t_start_fall = t_start_high + t_plateau \n    t_start_low  = t_start_fall + self.t_fall \n\n    #define event actions (update phase and start time) \n    def _set_phase_rising(t):\n        self._phase = 'rising'\n        self._phase_start_time = t\n        self.outputs[0] = 0.0    \n\n    def _set_phase_high(t):\n        self._phase = 'high'\n        self._phase_start_time = t\n        self.outputs[0] = self.amplitude\n\n    def _set_phase_falling(t):\n        self._phase = 'falling'\n        self._phase_start_time = t\n        self.outputs[0] = self.amplitude\n\n    def _set_phase_low(t):\n        self._phase = 'low'\n        self._phase_start_time = t\n        self.outputs[0] = 0.0    \n\n    #start rising\n    _E_rising = Schedule( \n        t_start=max(0.0, t_start_rise), \n        t_period=self.T, \n        func_act=_set_phase_rising\n        )\n\n    #start high plateau (end rising)\n    _E_high = Schedule(\n        t_start=max(0.0, t_start_high), \n        t_period=self.T, \n        func_act=_set_phase_high\n        )\n\n    #start falling\n    _E_falling = Schedule( \n        t_start=max(0.0, t_start_fall), \n        t_period=self.T, \n        func_act=_set_phase_falling\n        )\n\n    #start low (end falling)\n    _E_low = Schedule( \n        t_start=max(0.0, t_start_low), \n        t_period=self.T, \n        func_act=_set_phase_low\n        )\n\n    #scheduled events for state transitions\n    self.events = [_E_rising, _E_high, _E_falling, _E_low]",
              "signature": "(amplitude = 1.0, T = 1.0, t_rise = 0.0, t_fall = 0.0, tau = 0.0, duty = 0.5)",
              "parameters": [
                {
                  "name": "amplitude",
                  "type": null,
                  "default": "1.0",
                  "description": ""
                },
                {
                  "name": "T",
                  "type": null,
                  "default": "1.0",
                  "description": ""
                },
                {
                  "name": "t_rise",
                  "type": null,
                  "default": "0.0",
                  "description": ""
                },
                {
                  "name": "t_fall",
                  "type": null,
                  "default": "0.0",
                  "description": ""
                },
                {
                  "name": "tau",
                  "type": null,
                  "default": "0.0",
                  "description": ""
                },
                {
                  "name": "duty",
                  "type": null,
                  "default": "0.5",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "reset",
              "description": "Resets the block state.",
              "docstring_html": "<p>Resets the block state.</p>\n<div class=\"section\" id=\"note\">\n<h4>Note</h4>\n<blockquote>\nThis block has a special implementation of reset where <tt class=\"docutils literal\">t</tt> can be provided\nto reset the block's state to the specified time.\nThis is done by changing the phase of the pulse + resetting all the internal events.</blockquote>\n<p><strong>Parameters</strong></p>\n<blockquote>\n<dl class=\"docutils\">\n<dt>t: float, optional</dt>\n<dd>Time to reset the block state at. If None, resets to initial state.</dd>\n</dl>\n</blockquote>\n</div>\n",
              "source": "def reset(self, t: float=None):\n    \"\"\"\n    Resets the block state.\n\n    Note\n    ----\n        This block has a special implementation of reset where ``t`` can be provided\n        to reset the block's state to the specified time.\n        This is done by changing the phase of the pulse + resetting all the internal events.\n\n    Parameters\n    ----------\n        t: float, optional\n            Time to reset the block state at. If None, resets to initial state.\n\n    \"\"\"\n    if t:\n        self._phase_start_time = t\n\n        # event timings relative to start of cycle (tau)\n        new_t_start_rise = t\n        new_t_start_high = new_t_start_rise + self.t_rise\n        t_plateau = self.T * self.duty\n        new_t_start_fall = new_t_start_high + t_plateau\n        new_t_start_low = new_t_start_fall + self.t_fall\n\n        self.events[0].t_start = max(0.0, new_t_start_rise)\n        self.events[1].t_start = max(0.0, new_t_start_high)\n        self.events[2].t_start = max(0.0, new_t_start_fall)\n        self.events[3].t_start = max(0.0, new_t_start_low)\n\n        for e in self.events:\n            e.reset()\n    else:\n        super().reset()\n        self._phase = 'low'\n        self._phase_start_time = self.tau",
              "signature": "(t: float = None)",
              "parameters": [
                {
                  "name": "t",
                  "type": "float",
                  "default": "None",
                  "description": "Time to reset the block state at. If None, resets to initial state."
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "update",
              "description": "Calculate the pulse output value based on the current phase.",
              "docstring_html": "<p>Calculate the pulse output value based on the current phase.\nPerforms linear interpolation during 'rising' and 'falling' phases.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time</dd>\n</dl>\n",
              "source": "def update(self, t):\n    \"\"\"Calculate the pulse output value based on the current phase.\n    Performs linear interpolation during 'rising' and 'falling' phases.\n\n    Parameters\n    ----------\n    t : float\n        evaluation time\n    \"\"\"\n\n    #calculate output based on phase\n    if self._phase == 'rising':\n        _val = self.amplitude * (t - self._phase_start_time) / self.t_rise\n        self.outputs[0] = np.clip(_val, 0.0, self.amplitude)\n    elif self._phase == 'high':\n        self.outputs[0] = self.amplitude\n    elif self._phase == 'falling':\n        _val = self.amplitude * (1.0 - (t - self._phase_start_time) / self.t_fall)\n        self.outputs[0] = np.clip(_val, 0.0, self.amplitude)\n    elif self._phase == 'low':\n        self.outputs[0] = 0.0",
              "signature": "(t)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time"
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "input_port_labels",
              "description": "",
              "type": null,
              "value": "{}"
            },
            {
              "name": "output_port_labels",
              "description": "",
              "type": null,
              "value": "{'out': 0}"
            },
            {
              "name": "amplitude",
              "description": "",
              "type": null,
              "value": "amplitude"
            },
            {
              "name": "T",
              "description": "",
              "type": null,
              "value": "T"
            },
            {
              "name": "t_rise",
              "description": "",
              "type": null,
              "value": "max(TOLERANCE, t_rise)"
            },
            {
              "name": "t_fall",
              "description": "",
              "type": null,
              "value": "max(TOLERANCE, t_fall)"
            },
            {
              "name": "tau",
              "description": "",
              "type": null,
              "value": "tau"
            },
            {
              "name": "duty",
              "description": "",
              "type": null,
              "value": "duty"
            },
            {
              "name": "_phase",
              "description": "",
              "type": null,
              "value": "'low'"
            },
            {
              "name": "_phase_start_time",
              "description": "",
              "type": null,
              "value": "self.tau"
            },
            {
              "name": "events",
              "description": "",
              "type": null,
              "value": "[_E_rising, _E_high, _E_falling, _E_low]"
            }
          ],
          "parameters": [
            {
              "name": "amplitude",
              "type": null,
              "default": "1.0",
              "description": "Peak amplitude of the pulse. Default is 1.0."
            },
            {
              "name": "T",
              "type": null,
              "default": "1.0",
              "description": "Period of the pulse train. Must be positive. Default is 1.0."
            },
            {
              "name": "t_rise",
              "type": null,
              "default": "0.0",
              "description": "Duration of the rising edge. Default is 0.0."
            },
            {
              "name": "t_fall",
              "type": null,
              "default": "0.0",
              "description": "Duration of the falling edge. Default is 0.0."
            },
            {
              "name": "tau",
              "type": null,
              "default": "0.0",
              "description": "Initial delay before the first pulse cycle begins. Default is 0.0."
            },
            {
              "name": "duty",
              "type": null,
              "default": "0.5",
              "description": "Duty cycle, ratio of the pulse ON duration (plateau time only) to the total period T (must be between 0 and 1). Default is 0.5. The high plateau duration is `T * duty`."
            }
          ]
        },
        {
          "name": "Pulse",
          "description": "Alias for PulseSource.",
          "docstring_html": "<p>Alias for PulseSource.</p>\n",
          "source": "@deprecated(version=\"1.0.0\", replacement=\"PulseSource\")\nclass Pulse(PulseSource):\n    \"\"\"Alias for PulseSource.\"\"\"\n    pass",
          "bases": [
            "pathsim.blocks.sources.PulseSource"
          ],
          "methods": [],
          "attributes": [],
          "parameters": []
        },
        {
          "name": "ClockSource",
          "description": "Discrete time clock source block.",
          "docstring_html": "<p>Discrete time clock source block.</p>\n<p>Utilizes scheduled events to periodically set\nthe block output to 0 or 1 at discrete times.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>T <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>period of the clock</dd>\n<dt>tau <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>clock delay</dd>\n</dl>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>events <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">list[Schedule]</span></dt>\n<dd>internal scheduled event list</dd>\n</dl>\n",
          "source": "class ClockSource(Block):\n    \"\"\"Discrete time clock source block.\n\n    Utilizes scheduled events to periodically set \n    the block output to 0 or 1 at discrete times.\n\n    Parameters\n    ----------\n    T : float\n        period of the clock\n    tau : float\n        clock delay\n\n    Attributes\n    ----------\n    events : list[Schedule]\n        internal scheduled event list \n    \"\"\"\n\n    input_port_labels = {}\n    output_port_labels = {\"out\":0}\n\n    def __init__(self, T=1, tau=0):\n        super().__init__()\n\n        #block params\n        self.T   = T\n        self.tau = tau\n\n        def clk_up(t):\n            self.outputs[0] = 1\n\n        def clk_down(t):\n            self.outputs[0] = 0\n\n        #internal scheduled events\n        self.events = [\n            Schedule(\n                t_start=tau,\n                t_period=T,\n                func_act=clk_up\n                ),\n            Schedule(\n                t_start=tau+T/2,\n                t_period=T,\n                func_act=clk_down\n                )\n            ]\n\n    def __len__(self):\n        #no algebraic passthrough\n        return 0",
          "bases": [
            "pathsim.blocks._block.Block"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, T=1, tau=0):\n    super().__init__()\n\n    #block params\n    self.T   = T\n    self.tau = tau\n\n    def clk_up(t):\n        self.outputs[0] = 1\n\n    def clk_down(t):\n        self.outputs[0] = 0\n\n    #internal scheduled events\n    self.events = [\n        Schedule(\n            t_start=tau,\n            t_period=T,\n            func_act=clk_up\n            ),\n        Schedule(\n            t_start=tau+T/2,\n            t_period=T,\n            func_act=clk_down\n            )\n        ]",
              "signature": "(T = 1, tau = 0)",
              "parameters": [
                {
                  "name": "T",
                  "type": null,
                  "default": "1",
                  "description": ""
                },
                {
                  "name": "tau",
                  "type": null,
                  "default": "0",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "input_port_labels",
              "description": "",
              "type": null,
              "value": "{}"
            },
            {
              "name": "output_port_labels",
              "description": "",
              "type": null,
              "value": "{'out': 0}"
            },
            {
              "name": "T",
              "description": "",
              "type": null,
              "value": "T"
            },
            {
              "name": "tau",
              "description": "",
              "type": null,
              "value": "tau"
            },
            {
              "name": "events",
              "description": "",
              "type": null,
              "value": "[Schedule(t_start=tau, t_period=T, func_act=clk_up), Schedule(t_start=(tau + T / 2), t_period=T, func_act=clk_down)]"
            }
          ],
          "parameters": [
            {
              "name": "T",
              "type": null,
              "default": "1",
              "description": "period of the clock"
            },
            {
              "name": "tau",
              "type": null,
              "default": "0",
              "description": "clock delay"
            }
          ]
        },
        {
          "name": "Clock",
          "description": "Alias for ClockSource.",
          "docstring_html": "<p>Alias for ClockSource.</p>\n",
          "source": "@deprecated(version=\"1.0.0\", replacement=\"ClockSource\")\nclass Clock(ClockSource):\n    \"\"\"Alias for ClockSource.\"\"\"\n    pass",
          "bases": [
            "pathsim.blocks.sources.ClockSource"
          ],
          "methods": [],
          "attributes": [],
          "parameters": []
        },
        {
          "name": "SquareWaveSource",
          "description": "Discrete time square wave source.",
          "docstring_html": "<p>Discrete time square wave source.</p>\n<p>Utilizes scheduled events to periodically set\nthe block output at discrete times.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>amplitude <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>amplitude of the square wave signal</dd>\n<dt>frequency <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>frequency of the square wave signal</dd>\n<dt>phase <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>phase of the square wave signal</dd>\n</dl>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>events <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">list[Schedule]</span></dt>\n<dd>internal scheduled events</dd>\n</dl>\n",
          "source": "class SquareWaveSource(Block):\n    \"\"\"Discrete time square wave source.\n\n    Utilizes scheduled events to periodically set \n    the block output at discrete times.\n\n    Parameters\n    ----------\n    amplitude : float\n        amplitude of the square wave signal\n    frequency : float\n        frequency of the square wave signal\n    phase : float\n        phase of the square wave signal\n\n    Attributes\n    ----------\n    events : list[Schedule]\n        internal scheduled events \n    \"\"\"\n\n    input_port_labels = {}\n    output_port_labels = {\"out\":0}\n\n    def __init__(self, amplitude=1, frequency=1, phase=0):\n        super().__init__()\n\n        #block params\n        self.amplitude = amplitude\n        self.frequency = frequency\n        self.phase = phase\n\n        def sqw_up(t):\n            self.outputs[0] = self.amplitude\n\n        def sqw_down(t):\n            self.outputs[0] = -self.amplitude\n\n        #internal scheduled events\n        self.events = [\n            Schedule(\n                t_start=1/frequency * phase/360,\n                t_period=1/frequency,\n                func_act=sqw_up\n                ),\n            Schedule(\n                t_start=1/frequency * (phase/360 + 0.5),\n                t_period=1/frequency,\n                func_act=sqw_down\n                )\n            ]\n\n    def __len__(self):\n        #no algebraic passthrough\n        return 0",
          "bases": [
            "pathsim.blocks._block.Block"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, amplitude=1, frequency=1, phase=0):\n    super().__init__()\n\n    #block params\n    self.amplitude = amplitude\n    self.frequency = frequency\n    self.phase = phase\n\n    def sqw_up(t):\n        self.outputs[0] = self.amplitude\n\n    def sqw_down(t):\n        self.outputs[0] = -self.amplitude\n\n    #internal scheduled events\n    self.events = [\n        Schedule(\n            t_start=1/frequency * phase/360,\n            t_period=1/frequency,\n            func_act=sqw_up\n            ),\n        Schedule(\n            t_start=1/frequency * (phase/360 + 0.5),\n            t_period=1/frequency,\n            func_act=sqw_down\n            )\n        ]",
              "signature": "(amplitude = 1, frequency = 1, phase = 0)",
              "parameters": [
                {
                  "name": "amplitude",
                  "type": null,
                  "default": "1",
                  "description": ""
                },
                {
                  "name": "frequency",
                  "type": null,
                  "default": "1",
                  "description": ""
                },
                {
                  "name": "phase",
                  "type": null,
                  "default": "0",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "input_port_labels",
              "description": "",
              "type": null,
              "value": "{}"
            },
            {
              "name": "output_port_labels",
              "description": "",
              "type": null,
              "value": "{'out': 0}"
            },
            {
              "name": "amplitude",
              "description": "",
              "type": null,
              "value": "amplitude"
            },
            {
              "name": "frequency",
              "description": "",
              "type": null,
              "value": "frequency"
            },
            {
              "name": "phase",
              "description": "",
              "type": null,
              "value": "phase"
            },
            {
              "name": "events",
              "description": "",
              "type": null,
              "value": "[Schedule(t_start=(1 / frequency * phase / 360), t_period=(1 / frequency), func_act=sqw_up), Schedule(t_start=(1 / frequency * (phase / 360 + 0.5)), t_period=(1 / frequency), func_act=sqw_down)]"
            }
          ],
          "parameters": [
            {
              "name": "amplitude",
              "type": null,
              "default": "1",
              "description": "amplitude of the square wave signal"
            },
            {
              "name": "frequency",
              "type": null,
              "default": "1",
              "description": "frequency of the square wave signal"
            },
            {
              "name": "phase",
              "type": null,
              "default": "0",
              "description": "phase of the square wave signal"
            }
          ]
        },
        {
          "name": "StepSource",
          "description": "Discrete time unit step (or multi step) source block.",
          "docstring_html": "<p>Discrete time unit step (or multi step) source block.</p>\n<p>Utilizes a scheduled event to set the block output\nto the specified output levels at the defined event times.</p>\n<p>The arguments can be vectorial and in that case, the output is set to the\namplitude that corresponds to the defined delay like a zero-order-hold stage.\nThis functionality enables adding external or time series measurement data\ninto the system.</p>\n<p><strong>Examples</strong></p>\n<p>This is how to use the source as a unit step source:</p>\n<pre class=\"code python literal-block\">\n<span class=\"kn\">from</span><span class=\"w\"> </span><span class=\"nn\">pathsim.blocks</span><span class=\"w\"> </span><span class=\"kn\">import</span> <span class=\"n\">StepSource</span><span class=\"w\">\n\n</span><span class=\"c1\">#default, starts at 0, jumps to 1</span><span class=\"w\">\n</span><span class=\"n\">stp</span> <span class=\"o\">=</span> <span class=\"n\">StepSource</span><span class=\"p\">()</span>\n</pre>\n<p>And this is how to configure it with multiple consecutive steps:</p>\n<pre class=\"code python literal-block\">\n<span class=\"kn\">from</span><span class=\"w\"> </span><span class=\"nn\">pathsim.blocks</span><span class=\"w\"> </span><span class=\"kn\">import</span> <span class=\"n\">StepSource</span><span class=\"w\">\n\n</span><span class=\"c1\">#starts at 0, jumps to 1 at 1, jumps to -1 at 2 and jumps back to 0 at 3</span><span class=\"w\">\n</span><span class=\"n\">stp</span> <span class=\"o\">=</span> <span class=\"n\">StepSource</span><span class=\"p\">(</span><span class=\"n\">amplitude</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">],</span> <span class=\"n\">tau</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">])</span>\n</pre>\n<p>Similarly implementing measured time series data via zoh:</p>\n<pre class=\"code python literal-block\">\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"nn\">numpy</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"nn\">np</span><span class=\"w\">\n</span><span class=\"kn\">from</span><span class=\"w\"> </span><span class=\"nn\">pathsim.blocks</span><span class=\"w\"> </span><span class=\"kn\">import</span> <span class=\"n\">StepSource</span><span class=\"w\">\n\n</span><span class=\"c1\">#some random time series arrays</span><span class=\"w\">\n</span><span class=\"n\">times</span><span class=\"p\">,</span> <span class=\"n\">data</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">linspace</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">100</span><span class=\"p\">,</span> <span class=\"mi\">1000</span><span class=\"p\">),</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">random</span><span class=\"o\">.</span><span class=\"n\">rand</span><span class=\"p\">(</span><span class=\"mi\">1000</span><span class=\"p\">)</span><span class=\"w\">\n\n</span><span class=\"c1\">#pass them to the block</span><span class=\"w\">\n</span><span class=\"n\">stp</span> <span class=\"o\">=</span> <span class=\"n\">StepSource</span><span class=\"p\">(</span><span class=\"n\">amplitude</span><span class=\"o\">=</span><span class=\"n\">data</span><span class=\"p\">,</span> <span class=\"n\">tau</span><span class=\"o\">=</span><span class=\"n\">times</span><span class=\"p\">)</span>\n</pre>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>amplitude <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float | list[float]</span></dt>\n<dd>amplitude of the step signal, or amplitudes / output\nlevels of the multiple steps</dd>\n<dt>tau <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float | list[float]</span></dt>\n<dd>delay of the step, or delays of the different steps</dd>\n</dl>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>Evt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">ScheduleList</span></dt>\n<dd>internal scheduled event directly accessible</dd>\n<dt>events <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">list[ScheduleList]</span></dt>\n<dd>list of interna events</dd>\n</dl>\n",
          "source": "class StepSource(Block):\n    \"\"\"Discrete time unit step (or multi step) source block.\n\n    Utilizes a scheduled event to set the block output \n    to the specified output levels at the defined event times.\n\n    The arguments can be vectorial and in that case, the output is set to the \n    amplitude that corresponds to the defined delay like a zero-order-hold stage. \n    This functionality enables adding external or time series measurement data \n    into the system.\n\n\n    Examples\n    --------\n\n    This is how to use the source as a unit step source:\n\n    .. code-block:: python\n\n        from pathsim.blocks import StepSource\n\n        #default, starts at 0, jumps to 1\n        stp = StepSource()\n\n\n    And this is how to configure it with multiple consecutive steps:\n\n    .. code-block:: python\n\n        from pathsim.blocks import StepSource\n\n        #starts at 0, jumps to 1 at 1, jumps to -1 at 2 and jumps back to 0 at 3\n        stp = StepSource(amplitude=[1, -1, 0], tau=[1, 2, 3])\n\n\n    Similarly implementing measured time series data via zoh:\n\n    .. code-block:: python\n\n        import numpy as np\n        from pathsim.blocks import StepSource\n\n        #some random time series arrays\n        times, data = np.linspace(0, 100, 1000), np.random.rand(1000)\n\n        #pass them to the block\n        stp = StepSource(amplitude=data, tau=times)\n\n\n    Parameters\n    ----------\n    amplitude : float | list[float]\n        amplitude of the step signal, or amplitudes / output \n        levels of the multiple steps\n    tau : float | list[float]\n        delay of the step, or delays of the different steps\n\n    Attributes\n    ----------\n    Evt : ScheduleList\n        internal scheduled event directly accessible\n    events : list[ScheduleList]\n        list of interna events\n    \"\"\"\n    input_port_labels = {}\n    output_port_labels = {\"out\":0}\n\n    def __init__(self, amplitude=1, tau=0.0):\n        super().__init__()\n\n        #input type validation\n        if not isinstance(amplitude, (int, float, list, np.ndarray)):\n            raise ValueError(f\"'amplitude' has to be float, or array of floarts, but is {type(amplitude)}\")\n        if not isinstance(tau, (int, float, list, np.ndarray)):\n            raise ValueError(f\"'tau' has to be float, or array of floarts, but is {type(tau)}!\") \n\n        self.amplitude = amplitude if isinstance(amplitude, (list, np.ndarray)) else [amplitude]\n        self.tau = tau if isinstance(tau, (list, np.ndarray)) else [tau]\n\n        #input shape validation\n        if len(self.amplitude) != len(self.tau):\n            raise ValueError(\"'amplitude' and 'tau' must have same dimensions!\")\n\n        #internal scheduled list event\n        def stp_set(t):\n            idx = len(self.Evt) - 1\n            self.outputs[0] = self.amplitude[idx]\n\n        self.Evt = ScheduleList(\n            times_evt=self.tau,\n            func_act=stp_set\n            )\n        self.events = [self.Evt]\n\n    def __len__(self):\n        #no algebraic passthrough\n        return 0",
          "bases": [
            "pathsim.blocks._block.Block"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, amplitude=1, tau=0.0):\n    super().__init__()\n\n    #input type validation\n    if not isinstance(amplitude, (int, float, list, np.ndarray)):\n        raise ValueError(f\"'amplitude' has to be float, or array of floarts, but is {type(amplitude)}\")\n    if not isinstance(tau, (int, float, list, np.ndarray)):\n        raise ValueError(f\"'tau' has to be float, or array of floarts, but is {type(tau)}!\") \n\n    self.amplitude = amplitude if isinstance(amplitude, (list, np.ndarray)) else [amplitude]\n    self.tau = tau if isinstance(tau, (list, np.ndarray)) else [tau]\n\n    #input shape validation\n    if len(self.amplitude) != len(self.tau):\n        raise ValueError(\"'amplitude' and 'tau' must have same dimensions!\")\n\n    #internal scheduled list event\n    def stp_set(t):\n        idx = len(self.Evt) - 1\n        self.outputs[0] = self.amplitude[idx]\n\n    self.Evt = ScheduleList(\n        times_evt=self.tau,\n        func_act=stp_set\n        )\n    self.events = [self.Evt]",
              "signature": "(amplitude = 1, tau = 0.0)",
              "parameters": [
                {
                  "name": "amplitude",
                  "type": null,
                  "default": "1",
                  "description": ""
                },
                {
                  "name": "tau",
                  "type": null,
                  "default": "0.0",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "input_port_labels",
              "description": "",
              "type": null,
              "value": "{}"
            },
            {
              "name": "output_port_labels",
              "description": "",
              "type": null,
              "value": "{'out': 0}"
            },
            {
              "name": "amplitude",
              "description": "",
              "type": null,
              "value": "amplitude if isinstance(amplitude, (list, np.ndarray)) else [amplitude]"
            },
            {
              "name": "tau",
              "description": "",
              "type": null,
              "value": "tau if isinstance(tau, (list, np.ndarray)) else [tau]"
            },
            {
              "name": "Evt",
              "description": "",
              "type": null,
              "value": "ScheduleList(times_evt=(self.tau), func_act=stp_set)"
            },
            {
              "name": "events",
              "description": "",
              "type": null,
              "value": "[self.Evt]"
            }
          ],
          "parameters": [
            {
              "name": "amplitude",
              "type": null,
              "default": "1",
              "description": "amplitude of the step signal, or amplitudes / output levels of the multiple steps"
            },
            {
              "name": "tau",
              "type": null,
              "default": "0.0",
              "description": "delay of the step, or delays of the different steps"
            }
          ]
        },
        {
          "name": "Step",
          "description": "Alias for StepSource.",
          "docstring_html": "<p>Alias for StepSource.</p>\n",
          "source": "@deprecated(version=\"1.0.0\", replacement=\"StepSource\")\nclass Step(StepSource):\n    \"\"\"Alias for StepSource.\"\"\"\n    pass",
          "bases": [
            "pathsim.blocks.sources.StepSource"
          ],
          "methods": [],
          "attributes": [],
          "parameters": []
        }
      ],
      "functions": []
    },
    "pathsim.blocks.spectrum": {
      "name": "pathsim.blocks.spectrum",
      "description": "",
      "docstring_html": "",
      "classes": [
        {
          "name": "Spectrum",
          "description": "Block for fourier spectrum analysis (spectrum analyzer).",
          "docstring_html": "<p>Block for fourier spectrum analysis (spectrum analyzer).</p>\n<p>Computes continuous time running fourier transform (RFT) of the incoming signal.</p>\n<p>A time threshold can be set by 't_wait' to start recording data only after the\nsimulation time is larger then the specified waiting time, i.e. 't - t_wait &gt; dt'.\nThis is useful for recording the steady state after all the transients have settled.</p>\n<p>An exponential forgetting factor 'alpha' can be specified for realtime spectral\nanalysis. It biases the spectral components exponentially to the most recent signal\nvalues by applying a single sided exponential window like this:</p>\n<pre class=\"math\">\n\\int_0^t u(\\tau) \\exp(\\alpha (t-\\tau))  \\exp(-j \\omega \\tau)\\ d \\tau\n</pre>\n<p>It is also known as the 'exponentially forgetting transform' (EFT) and a form of\nshort time fourier transform (STFT). It is implemented as a 1st order statespace model</p>\n<pre class=\"math\">\n\\dot{x} = - \\alpha  x +  \\exp(-j \\omega t) u\n</pre>\n<p>where 'u' is the input signal and 'x' is the state variable that represents the\ncomplex fourier coefficient to the frequency 'omega'. The ODE is integrated using the\nnumerical integration engine of the block.</p>\n<div class=\"section\" id=\"example\">\n<h4>Example</h4>\n<p>This is how to initialize it:</p>\n<pre class=\"code python literal-block\">\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"nn\">numpy</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"nn\">np</span><span class=\"w\">\n\n</span><span class=\"c1\">#linear frequencies (0Hz, DC -&gt; 1kHz)</span><span class=\"w\">\n</span><span class=\"n\">sp1</span> <span class=\"o\">=</span> <span class=\"n\">Spectrum</span><span class=\"p\">(</span><span class=\"w\">\n</span>    <span class=\"n\">freq</span><span class=\"o\">=</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">linspace</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mf\">1e3</span><span class=\"p\">,</span> <span class=\"mi\">100</span><span class=\"p\">),</span><span class=\"w\">\n</span>    <span class=\"n\">labels</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"s1\">'x1'</span><span class=\"p\">,</span> <span class=\"s1\">'x2'</span><span class=\"p\">]</span> <span class=\"c1\">#labels for two inputs</span><span class=\"w\">\n</span>    <span class=\"p\">)</span><span class=\"w\">\n\n</span><span class=\"c1\">#log frequencies (1Hz -&gt; 1kHz)</span><span class=\"w\">\n</span><span class=\"n\">sp2</span> <span class=\"o\">=</span> <span class=\"n\">Spectrum</span><span class=\"p\">(</span><span class=\"w\">\n</span>    <span class=\"n\">freq</span><span class=\"o\">=</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">logspace</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"mi\">100</span><span class=\"p\">)</span><span class=\"w\">\n</span>    <span class=\"p\">)</span><span class=\"w\">\n\n</span><span class=\"c1\">#log frequencies including DC (0Hz, DC + 1Hz -&gt; 1kHz)</span><span class=\"w\">\n</span><span class=\"n\">sp3</span> <span class=\"o\">=</span> <span class=\"n\">Spectrum</span><span class=\"p\">(</span><span class=\"w\">\n</span>    <span class=\"n\">freq</span><span class=\"o\">=</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">hstack</span><span class=\"p\">([</span><span class=\"mf\">0.0</span><span class=\"p\">,</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">logspace</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"mi\">100</span><span class=\"p\">)])</span><span class=\"w\">\n</span>    <span class=\"p\">)</span><span class=\"w\">\n\n</span><span class=\"c1\">#arbitrary frequencies</span><span class=\"w\">\n</span><span class=\"n\">sp4</span> <span class=\"o\">=</span> <span class=\"n\">Spectrum</span><span class=\"p\">(</span><span class=\"w\">\n</span>    <span class=\"n\">freq</span><span class=\"o\">=</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">array</span><span class=\"p\">([</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mf\">0.5</span><span class=\"p\">,</span> <span class=\"mi\">20</span><span class=\"p\">,</span> <span class=\"mf\">1e3</span><span class=\"p\">])</span><span class=\"w\">\n</span>    <span class=\"p\">)</span>\n</pre>\n</div>\n<div class=\"section\" id=\"note\">\n<h4>Note</h4>\n<p>This block is relatively slow! But it is valuable for long running simulations\nwith few evaluation frequencies, where just FFT'ing the time series data\nwouldnt be efficient OR if only the evaluation at weirdly spaced frequencies\nis required. Otherwise its more efficient to just do an FFT on the time\nseries recording after the simulation has finished.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>freq <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array[float]</span></dt>\n<dd>list of evaluation frequencies for RFT, can be arbitrarily spaced</dd>\n<dt>t_wait <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>wait time before starting RFT</dd>\n<dt>alpha <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>exponential forgetting factor for realtime spectrum</dd>\n<dt>labels <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">list[str]</span></dt>\n<dd>labels for the inputs</dd>\n</dl>\n</div>\n",
          "source": "class Spectrum(Block):\n    \"\"\"Block for fourier spectrum analysis (spectrum analyzer).\n\n    Computes continuous time running fourier transform (RFT) of the incoming signal.\n\n    A time threshold can be set by 't_wait' to start recording data only after the \n    simulation time is larger then the specified waiting time, i.e. 't - t_wait > dt'. \n    This is useful for recording the steady state after all the transients have settled.\n\n    An exponential forgetting factor 'alpha' can be specified for realtime spectral \n    analysis. It biases the spectral components exponentially to the most recent signal \n    values by applying a single sided exponential window like this:\n\n    .. math::\n\n        \\\\int_0^t u(\\\\tau) \\\\exp(\\\\alpha (t-\\\\tau))  \\\\exp(-j \\\\omega \\\\tau)\\\\ d \\\\tau\n\n    It is also known as the 'exponentially forgetting transform' (EFT) and a form of \n    short time fourier transform (STFT). It is implemented as a 1st order statespace model \n\n    .. math::\n\n        \\\\dot{x} = - \\\\alpha  x +  \\\\exp(-j \\\\omega t) u\n\n    where 'u' is the input signal and 'x' is the state variable that represents the \n    complex fourier coefficient to the frequency 'omega'. The ODE is integrated using the \n    numerical integration engine of the block.\n\n    Example\n    -------\n    This is how to initialize it: \n\n    .. code-block:: python\n\n        import numpy as np\n\n        #linear frequencies (0Hz, DC -> 1kHz)\n        sp1 = Spectrum(\n            freq=np.linspace(0, 1e3, 100),\n            labels=['x1', 'x2'] #labels for two inputs\n            )\n\n        #log frequencies (1Hz -> 1kHz)\n        sp2 = Spectrum(\n            freq=np.logspace(0, 3, 100)\n            )\n\n        #log frequencies including DC (0Hz, DC + 1Hz -> 1kHz)\n        sp3 = Spectrum(\n            freq=np.hstack([0.0, np.logspace(0, 3, 100)])\n            )\n\n        #arbitrary frequencies\n        sp4 = Spectrum(\n            freq=np.array([0, 0.5, 20, 1e3])\n            )\n\n    Note\n    ----\n    This block is relatively slow! But it is valuable for long running simulations \n    with few evaluation frequencies, where just FFT'ing the time series data \n    wouldnt be efficient OR if only the evaluation at weirdly spaced frequencies \n    is required. Otherwise its more efficient to just do an FFT on the time \n    series recording after the simulation has finished.\n\n\n    Parameters\n    ----------\n    freq : array[float] \n        list of evaluation frequencies for RFT, can be arbitrarily spaced\n    t_wait : float \n        wait time before starting RFT\n    alpha : float\n        exponential forgetting factor for realtime spectrum\n    labels : list[str]\n        labels for the inputs\n    \"\"\"\n\n    input_port_labels = None\n    output_port_labels = {}\n\n    def __init__(self, freq=[], t_wait=0.0, alpha=0.0, labels=[]):\n        super().__init__()\n\n        #time delay until start recording\n        self.t_wait = t_wait\n\n        #last valid timestep sample for waiting\n        self.t_sample = 0.0\n\n        #local integration time\n        self.time = 0.0\n\n        #forgetting factor\n        self.alpha = alpha\n\n        #labels for plotting and saving data\n        self.labels = labels\n\n        #frequency\n        self.freq = np.array(freq)\n        self.omega = 2.0 * np.pi * self.freq\n\n        #initial state for integration engine\n        self.initial_value = 0.0\n\n\n    def __len__(self):\n        return 0\n\n\n    def _kernel(self, x, u, t):\n        \"\"\"Helper method that defines the kernel for the internal \n        running fourier transform (RFT)\n        \"\"\"\n        if self.alpha == 0: return np.kron(u, np.exp(-1j * self.omega * t))\n        return np.kron(u, np.exp(-1j * self.omega * t)) - self.alpha * x\n\n\n    def reset(self):\n        super().reset()\n\n        #local integration time\n        self.time = 0.0\n\n\n    def read(self):\n        \"\"\"Read the recorded spectrum\n\n        Example\n        -------\n        This is how to get the recorded spectrum:\n\n        .. code-block:: python\n\n            import numpy as np\n\n            #linear frequencies (0Hz, DC -> 1kHz)\n            spc = Spectrum(\n                freq=np.linspace(0, 1e3, 100),\n                labels=['x1', 'x2'] #labels for two inputs\n                )\n\n            #... run the simulation ...\n\n            #read the complex spectra of x1 and x2\n            freq, [X1, X2] = spc.read()\n\n        Returns\n        -------\n        freq : array[float]\n            evaluation frequencies\n        spec : array[complex]\n            complex spectrum\n        \"\"\"\n\n        #just return zeros if no engine initialized\n        if self.engine is None:\n            return self.freq, [np.zeros_like(self.freq)]*len(self.inputs)\n\n        #catch case where time is still zero\n        if self.time == 0.0:\n            return self.freq, [np.zeros_like(self.freq)]*len(self.inputs)\n\n        #get state from engine\n        state = self.engine.state\n\n        #catch case where state has not been updated\n        if np.all(state == self.engine.initial_value):\n            return self.freq, [np.zeros_like(self.freq)]*len(self.inputs)\n\n        #reshape state into spectra\n        spec = np.reshape(state, (-1, len(self.freq)))\n\n        #rescale spectrum and return it\n        if self.alpha != 0.0:\n            return self.freq, spec * self.alpha / (1.0 - np.exp(-self.alpha*self.time))\n\n        #return spectrum from RFT\n        return self.freq, spec/self.time\n\n\n    @deprecated(version=\"1.0.0\", reason=\"its against pathsims philosophy\")\n    def collect(self):\n        \"\"\"Yield (category, id, data) tuples for recording blocks to simplify \n        global data collection from all recording blocks.\n        \"\"\"\n        freq, data = self.read()\n        if data is not None:\n            yield (\n                \"spectrum\", \n                id(self), \n                {\n                    \"freq\": freq,\n                    \"data\": data,\n                    \"labels\": self.labels,\n                    }\n                )\n\n\n    def solve(self, t, dt):\n        \"\"\"advance solution of implicit update equation of the solver\n\n        Parameters\n        ----------\n        t : float\n            evaluation time\n        dt : float\n            integration timestep\n\n        Returns\n        ------- \n        error : float\n            solver residual norm\n        \"\"\"\n        if self.t_sample >= self.t_wait:\n\n            #effective time for integration\n            self.time = t - self.t_wait\n\n            #advance solution of implicit update equation (no jacobian)\n            f = self._kernel(self.engine.state, self.inputs.to_array(), self.time)\n            return self.engine.solve(f, None, dt)\n\n        #no error \n        return 0.0\n\n\n    def step(self, t, dt):\n        \"\"\"compute timestep update with integration engine\n\n        Parameters\n        ----------\n        t : float\n            evaluation time\n        dt : float\n            integration timestep\n\n        Returns\n        ------- \n        success : bool\n            step was successful\n        error : float\n            local truncation error from adaptive integrators\n        scale : float\n            timestep rescale from adaptive integrators\n        \"\"\"\n        if self.t_sample >= self.t_wait:\n\n            #effective time for integration\n            self.time = t - self.t_wait\n\n            #compute update step with integration engine\n            f = self._kernel(self.engine.state, self.inputs.to_array(), self.time)\n            return self.engine.step(f, dt)\n\n        #no error estimate\n        return True, 0.0, None\n\n\n    def sample(self, t, dt):\n        \"\"\"sample time of successfull timestep for waiting period\n\n        Parameters\n        ----------\n        t : float\n            sampling time\n        dt : float\n            integration timestep\n        \"\"\"\n        self.t_sample = t\n\n\n\n    def plot(self, *args, **kwargs):\n        \"\"\"Directly create a plot of the recorded data for visualization.\n\n        The 'fig' and 'ax' objects are accessible as attributes of the 'Spectrum' instance \n        from the outside for saving, or modification, etc.\n\n        Parameters\n        ----------\n        args : tuple\n            args for ax.plot\n        kwargs : dict\n            kwargs for ax.plot\n\n        Returns\n        -------\n        fig : matplotlib.figure\n            internal figure instance\n        ax : matplotlib.axis\n            internal axis instance\n        \"\"\"\n\n        #just return 'None' if no engine initialized\n        if self.engine is None:\n            return None\n\n        #get data\n        freq, data = self.read()        \n\n        #initialize figure\n        self.fig, self.ax = plt.subplots(nrows=1, ncols=1, figsize=(8,4), tight_layout=True, dpi=120)\n\n        #custom colors\n        self.ax.set_prop_cycle(color=COLORS_ALL)\n\n        #plot magnitude in dB and add label\n        for p, d in enumerate(data):\n            lb = self.labels[p] if p < len(self.labels) else f\"port {p}\"\n            self.ax.plot(freq, abs(d), *args, **kwargs, label=lb)\n\n        #legend labels from ports\n        self.ax.legend(fancybox=False)\n\n        #other plot settings\n        self.ax.set_xlabel(\"freq [Hz]\")\n        self.ax.set_ylabel(\"magnitude\")\n        self.ax.grid()\n\n        # Legend picking functionality\n        lines = self.ax.get_lines()  # Get the lines from the plot\n        leg = self.ax.get_legend()   # Get the legend\n\n        # Map legend lines to original plot lines\n        lined = dict()  \n        for legline, origline in zip(leg.get_lines(), lines):\n            # Enable picking within 5 points tolerance\n            legline.set_picker(5)  \n            lined[legline] = origline\n\n        def on_pick(event):\n            legline = event.artist\n            origline = lined[legline]\n            visible = not origline.get_visible()\n            origline.set_visible(visible)\n            legline.set_alpha(1.0 if visible else 0.2)\n            # Redraw the figure\n            self.fig.canvas.draw()  \n\n        #enable picking\n        self.fig.canvas.mpl_connect(\"pick_event\", on_pick)\n\n        #show the plot without blocking following code\n        plt.show(block=False)\n\n        #return figure and axis for outside manipulation\n        return self.fig, self.ax\n\n\n    def save(self, path=\"spectrum.csv\"):\n        \"\"\"Save the recording of the spectrum to a csv file        \n\n        Parameters\n        ----------\n        path : str\n            path where to save the recording as a csv file\n        \"\"\"\n\n        #check path ending\n        if not path.lower().endswith(\".csv\"):\n            path += \".csv\"\n\n        #get data\n        freq, data = self.read() \n\n        #number of ports and labels\n        P, L = len(data), len(self.labels)\n\n        #construct port labels\n        port_labels = [self.labels[p] if p < L else f\"port {p}\" for p in range(P)]\n\n        #make csv header\n        header = [\"freq [Hz]\"]\n        for l in port_labels:\n            header.extend([f\"Re({l})\", f\"Im({l})\"])\n\n        #write to csv file\n        with open(path, \"w\", newline=\"\") as file:\n            wrt = csv.writer(file)\n\n            #write the header to csv file\n            wrt.writerow(header)\n\n            #write each sample to the csv file\n            for f, *dta in zip(freq, *data):\n                sample = [f]\n                for d in dta:\n                    sample.extend([np.real(d), np.imag(d)])\n                wrt.writerow(sample)\n\n\n    def update(self, t):\n        \"\"\"update system equation for fixed point loop, \n        here just setting the outputs\n\n        Note\n        ----\n        Spectrum block has no passthrough, so the 'update' method \n        is optimized for this case        \n\n        Parameters\n        ----------\n        t : float\n            evaluation time\n        \"\"\"\n        pass",
          "bases": [
            "pathsim.blocks._block.Block"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, freq=[], t_wait=0.0, alpha=0.0, labels=[]):\n    super().__init__()\n\n    #time delay until start recording\n    self.t_wait = t_wait\n\n    #last valid timestep sample for waiting\n    self.t_sample = 0.0\n\n    #local integration time\n    self.time = 0.0\n\n    #forgetting factor\n    self.alpha = alpha\n\n    #labels for plotting and saving data\n    self.labels = labels\n\n    #frequency\n    self.freq = np.array(freq)\n    self.omega = 2.0 * np.pi * self.freq\n\n    #initial state for integration engine\n    self.initial_value = 0.0",
              "signature": "(freq = [], t_wait = 0.0, alpha = 0.0, labels = [])",
              "parameters": [
                {
                  "name": "freq",
                  "type": null,
                  "default": "[]",
                  "description": ""
                },
                {
                  "name": "t_wait",
                  "type": null,
                  "default": "0.0",
                  "description": ""
                },
                {
                  "name": "alpha",
                  "type": null,
                  "default": "0.0",
                  "description": ""
                },
                {
                  "name": "labels",
                  "type": null,
                  "default": "[]",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "_kernel",
              "description": "Helper method that defines the kernel for the internal",
              "docstring_html": "<p>Helper method that defines the kernel for the internal\nrunning fourier transform (RFT)</p>\n",
              "source": "def _kernel(self, x, u, t):\n    \"\"\"Helper method that defines the kernel for the internal \n    running fourier transform (RFT)\n    \"\"\"\n    if self.alpha == 0: return np.kron(u, np.exp(-1j * self.omega * t))\n    return np.kron(u, np.exp(-1j * self.omega * t)) - self.alpha * x",
              "signature": "(x, u, t)",
              "parameters": [
                {
                  "name": "x",
                  "type": null,
                  "default": null,
                  "description": ""
                },
                {
                  "name": "u",
                  "type": null,
                  "default": null,
                  "description": ""
                },
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "reset",
              "description": "",
              "docstring_html": "",
              "source": "def reset(self):\n    super().reset()\n\n    #local integration time\n    self.time = 0.0",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "read",
              "description": "Read the recorded spectrum",
              "docstring_html": "<p>Read the recorded spectrum</p>\n<div class=\"section\" id=\"example\">\n<h4>Example</h4>\n<p>This is how to get the recorded spectrum:</p>\n<pre class=\"code python literal-block\">\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"nn\">numpy</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"nn\">np</span><span class=\"w\">\n\n</span><span class=\"c1\">#linear frequencies (0Hz, DC -&gt; 1kHz)</span><span class=\"w\">\n</span><span class=\"n\">spc</span> <span class=\"o\">=</span> <span class=\"n\">Spectrum</span><span class=\"p\">(</span><span class=\"w\">\n</span>    <span class=\"n\">freq</span><span class=\"o\">=</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">linspace</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mf\">1e3</span><span class=\"p\">,</span> <span class=\"mi\">100</span><span class=\"p\">),</span><span class=\"w\">\n</span>    <span class=\"n\">labels</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"s1\">'x1'</span><span class=\"p\">,</span> <span class=\"s1\">'x2'</span><span class=\"p\">]</span> <span class=\"c1\">#labels for two inputs</span><span class=\"w\">\n</span>    <span class=\"p\">)</span><span class=\"w\">\n\n</span><span class=\"c1\">#... run the simulation ...</span><span class=\"w\">\n\n</span><span class=\"c1\">#read the complex spectra of x1 and x2</span><span class=\"w\">\n</span><span class=\"n\">freq</span><span class=\"p\">,</span> <span class=\"p\">[</span><span class=\"n\">X1</span><span class=\"p\">,</span> <span class=\"n\">X2</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">spc</span><span class=\"o\">.</span><span class=\"n\">read</span><span class=\"p\">()</span>\n</pre>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>freq <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array[float]</span></dt>\n<dd>evaluation frequencies</dd>\n<dt>spec <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array[complex]</span></dt>\n<dd>complex spectrum</dd>\n</dl>\n</div>\n",
              "source": "def read(self):\n    \"\"\"Read the recorded spectrum\n\n    Example\n    -------\n    This is how to get the recorded spectrum:\n\n    .. code-block:: python\n\n        import numpy as np\n\n        #linear frequencies (0Hz, DC -> 1kHz)\n        spc = Spectrum(\n            freq=np.linspace(0, 1e3, 100),\n            labels=['x1', 'x2'] #labels for two inputs\n            )\n\n        #... run the simulation ...\n\n        #read the complex spectra of x1 and x2\n        freq, [X1, X2] = spc.read()\n\n    Returns\n    -------\n    freq : array[float]\n        evaluation frequencies\n    spec : array[complex]\n        complex spectrum\n    \"\"\"\n\n    #just return zeros if no engine initialized\n    if self.engine is None:\n        return self.freq, [np.zeros_like(self.freq)]*len(self.inputs)\n\n    #catch case where time is still zero\n    if self.time == 0.0:\n        return self.freq, [np.zeros_like(self.freq)]*len(self.inputs)\n\n    #get state from engine\n    state = self.engine.state\n\n    #catch case where state has not been updated\n    if np.all(state == self.engine.initial_value):\n        return self.freq, [np.zeros_like(self.freq)]*len(self.inputs)\n\n    #reshape state into spectra\n    spec = np.reshape(state, (-1, len(self.freq)))\n\n    #rescale spectrum and return it\n    if self.alpha != 0.0:\n        return self.freq, spec * self.alpha / (1.0 - np.exp(-self.alpha*self.time))\n\n    #return spectrum from RFT\n    return self.freq, spec/self.time",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "collect",
              "description": "Yield (category, id, data) tuples for recording blocks to simplify",
              "docstring_html": "<p>Yield (category, id, data) tuples for recording blocks to simplify\nglobal data collection from all recording blocks.</p>\n",
              "source": "@deprecated(version=\"1.0.0\", reason=\"its against pathsims philosophy\")\ndef collect(self):\n    \"\"\"Yield (category, id, data) tuples for recording blocks to simplify \n    global data collection from all recording blocks.\n    \"\"\"\n    freq, data = self.read()\n    if data is not None:\n        yield (\n            \"spectrum\", \n            id(self), \n            {\n                \"freq\": freq,\n                \"data\": data,\n                \"labels\": self.labels,\n                }\n            )",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "solve",
              "description": "advance solution of implicit update equation of the solver",
              "docstring_html": "<p>advance solution of implicit update equation of the solver</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time</dd>\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>integration timestep</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>error <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>solver residual norm</dd>\n</dl>\n",
              "source": "def solve(self, t, dt):\n    \"\"\"advance solution of implicit update equation of the solver\n\n    Parameters\n    ----------\n    t : float\n        evaluation time\n    dt : float\n        integration timestep\n\n    Returns\n    ------- \n    error : float\n        solver residual norm\n    \"\"\"\n    if self.t_sample >= self.t_wait:\n\n        #effective time for integration\n        self.time = t - self.t_wait\n\n        #advance solution of implicit update equation (no jacobian)\n        f = self._kernel(self.engine.state, self.inputs.to_array(), self.time)\n        return self.engine.solve(f, None, dt)\n\n    #no error \n    return 0.0",
              "signature": "(t, dt)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time"
                },
                {
                  "name": "dt",
                  "type": null,
                  "default": null,
                  "description": "integration timestep"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "step",
              "description": "compute timestep update with integration engine",
              "docstring_html": "<p>compute timestep update with integration engine</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time</dd>\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>integration timestep</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>success <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>step was successful</dd>\n<dt>error <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>local truncation error from adaptive integrators</dd>\n<dt>scale <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>timestep rescale from adaptive integrators</dd>\n</dl>\n",
              "source": "def step(self, t, dt):\n    \"\"\"compute timestep update with integration engine\n\n    Parameters\n    ----------\n    t : float\n        evaluation time\n    dt : float\n        integration timestep\n\n    Returns\n    ------- \n    success : bool\n        step was successful\n    error : float\n        local truncation error from adaptive integrators\n    scale : float\n        timestep rescale from adaptive integrators\n    \"\"\"\n    if self.t_sample >= self.t_wait:\n\n        #effective time for integration\n        self.time = t - self.t_wait\n\n        #compute update step with integration engine\n        f = self._kernel(self.engine.state, self.inputs.to_array(), self.time)\n        return self.engine.step(f, dt)\n\n    #no error estimate\n    return True, 0.0, None",
              "signature": "(t, dt)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time"
                },
                {
                  "name": "dt",
                  "type": null,
                  "default": null,
                  "description": "integration timestep"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "sample",
              "description": "sample time of successfull timestep for waiting period",
              "docstring_html": "<p>sample time of successfull timestep for waiting period</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>sampling time</dd>\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>integration timestep</dd>\n</dl>\n",
              "source": "def sample(self, t, dt):\n    \"\"\"sample time of successfull timestep for waiting period\n\n    Parameters\n    ----------\n    t : float\n        sampling time\n    dt : float\n        integration timestep\n    \"\"\"\n    self.t_sample = t",
              "signature": "(t, dt)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "sampling time"
                },
                {
                  "name": "dt",
                  "type": null,
                  "default": null,
                  "description": "integration timestep"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "plot",
              "description": "Directly create a plot of the recorded data for visualization.",
              "docstring_html": "<p>Directly create a plot of the recorded data for visualization.</p>\n<p>The 'fig' and 'ax' objects are accessible as attributes of the 'Spectrum' instance\nfrom the outside for saving, or modification, etc.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>args <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">tuple</span></dt>\n<dd>args for ax.plot</dd>\n<dt>kwargs <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">dict</span></dt>\n<dd>kwargs for ax.plot</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>fig <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">matplotlib.figure</span></dt>\n<dd>internal figure instance</dd>\n<dt>ax <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">matplotlib.axis</span></dt>\n<dd>internal axis instance</dd>\n</dl>\n",
              "source": "def plot(self, *args, **kwargs):\n    \"\"\"Directly create a plot of the recorded data for visualization.\n\n    The 'fig' and 'ax' objects are accessible as attributes of the 'Spectrum' instance \n    from the outside for saving, or modification, etc.\n\n    Parameters\n    ----------\n    args : tuple\n        args for ax.plot\n    kwargs : dict\n        kwargs for ax.plot\n\n    Returns\n    -------\n    fig : matplotlib.figure\n        internal figure instance\n    ax : matplotlib.axis\n        internal axis instance\n    \"\"\"\n\n    #just return 'None' if no engine initialized\n    if self.engine is None:\n        return None\n\n    #get data\n    freq, data = self.read()        \n\n    #initialize figure\n    self.fig, self.ax = plt.subplots(nrows=1, ncols=1, figsize=(8,4), tight_layout=True, dpi=120)\n\n    #custom colors\n    self.ax.set_prop_cycle(color=COLORS_ALL)\n\n    #plot magnitude in dB and add label\n    for p, d in enumerate(data):\n        lb = self.labels[p] if p < len(self.labels) else f\"port {p}\"\n        self.ax.plot(freq, abs(d), *args, **kwargs, label=lb)\n\n    #legend labels from ports\n    self.ax.legend(fancybox=False)\n\n    #other plot settings\n    self.ax.set_xlabel(\"freq [Hz]\")\n    self.ax.set_ylabel(\"magnitude\")\n    self.ax.grid()\n\n    # Legend picking functionality\n    lines = self.ax.get_lines()  # Get the lines from the plot\n    leg = self.ax.get_legend()   # Get the legend\n\n    # Map legend lines to original plot lines\n    lined = dict()  \n    for legline, origline in zip(leg.get_lines(), lines):\n        # Enable picking within 5 points tolerance\n        legline.set_picker(5)  \n        lined[legline] = origline\n\n    def on_pick(event):\n        legline = event.artist\n        origline = lined[legline]\n        visible = not origline.get_visible()\n        origline.set_visible(visible)\n        legline.set_alpha(1.0 if visible else 0.2)\n        # Redraw the figure\n        self.fig.canvas.draw()  \n\n    #enable picking\n    self.fig.canvas.mpl_connect(\"pick_event\", on_pick)\n\n    #show the plot without blocking following code\n    plt.show(block=False)\n\n    #return figure and axis for outside manipulation\n    return self.fig, self.ax",
              "signature": "(args = (), kwargs = {})",
              "parameters": [
                {
                  "name": "args",
                  "type": null,
                  "default": "()",
                  "description": "args for ax.plot"
                },
                {
                  "name": "kwargs",
                  "type": null,
                  "default": "{}",
                  "description": "kwargs for ax.plot"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "save",
              "description": "Save the recording of the spectrum to a csv file",
              "docstring_html": "<p>Save the recording of the spectrum to a csv file</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>path <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">str</span></dt>\n<dd>path where to save the recording as a csv file</dd>\n</dl>\n",
              "source": "def save(self, path=\"spectrum.csv\"):\n    \"\"\"Save the recording of the spectrum to a csv file        \n\n    Parameters\n    ----------\n    path : str\n        path where to save the recording as a csv file\n    \"\"\"\n\n    #check path ending\n    if not path.lower().endswith(\".csv\"):\n        path += \".csv\"\n\n    #get data\n    freq, data = self.read() \n\n    #number of ports and labels\n    P, L = len(data), len(self.labels)\n\n    #construct port labels\n    port_labels = [self.labels[p] if p < L else f\"port {p}\" for p in range(P)]\n\n    #make csv header\n    header = [\"freq [Hz]\"]\n    for l in port_labels:\n        header.extend([f\"Re({l})\", f\"Im({l})\"])\n\n    #write to csv file\n    with open(path, \"w\", newline=\"\") as file:\n        wrt = csv.writer(file)\n\n        #write the header to csv file\n        wrt.writerow(header)\n\n        #write each sample to the csv file\n        for f, *dta in zip(freq, *data):\n            sample = [f]\n            for d in dta:\n                sample.extend([np.real(d), np.imag(d)])\n            wrt.writerow(sample)",
              "signature": "(path = 'spectrum.csv')",
              "parameters": [
                {
                  "name": "path",
                  "type": null,
                  "default": "'spectrum.csv'",
                  "description": "path where to save the recording as a csv file"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "update",
              "description": "update system equation for fixed point loop,",
              "docstring_html": "<p>update system equation for fixed point loop,\nhere just setting the outputs</p>\n<div class=\"section\" id=\"note\">\n<h4>Note</h4>\n<p>Spectrum block has no passthrough, so the 'update' method\nis optimized for this case</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time</dd>\n</dl>\n</div>\n",
              "source": "def update(self, t):\n    \"\"\"update system equation for fixed point loop, \n    here just setting the outputs\n\n    Note\n    ----\n    Spectrum block has no passthrough, so the 'update' method \n    is optimized for this case        \n\n    Parameters\n    ----------\n    t : float\n        evaluation time\n    \"\"\"\n    pass",
              "signature": "(t)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time"
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "input_port_labels",
              "description": "",
              "type": null,
              "value": "None"
            },
            {
              "name": "output_port_labels",
              "description": "",
              "type": null,
              "value": "{}"
            },
            {
              "name": "t_wait",
              "description": "",
              "type": null,
              "value": "t_wait"
            },
            {
              "name": "t_sample",
              "description": "",
              "type": null,
              "value": "0.0"
            },
            {
              "name": "time",
              "description": "",
              "type": null,
              "value": "0.0"
            },
            {
              "name": "alpha",
              "description": "",
              "type": null,
              "value": "alpha"
            },
            {
              "name": "labels",
              "description": "",
              "type": null,
              "value": "labels"
            },
            {
              "name": "freq",
              "description": "",
              "type": null,
              "value": "np.array(freq)"
            },
            {
              "name": "omega",
              "description": "",
              "type": null,
              "value": "2.0 * np.pi * self.freq"
            },
            {
              "name": "initial_value",
              "description": "",
              "type": null,
              "value": "0.0"
            }
          ],
          "parameters": [
            {
              "name": "freq",
              "type": null,
              "default": "[]",
              "description": "list of evaluation frequencies for RFT, can be arbitrarily spaced"
            },
            {
              "name": "t_wait",
              "type": null,
              "default": "0.0",
              "description": "wait time before starting RFT"
            },
            {
              "name": "alpha",
              "type": null,
              "default": "0.0",
              "description": "exponential forgetting factor for realtime spectrum"
            },
            {
              "name": "labels",
              "type": null,
              "default": "[]",
              "description": "labels for the inputs"
            }
          ]
        },
        {
          "name": "RealtimeSpectrum",
          "description": "An extension of the 'Spectrum' block that also initializes a realtime plotter.",
          "docstring_html": "<p>An extension of the 'Spectrum' block that also initializes a realtime plotter.</p>\n<p>Creates an interactive plotting window while the simulation is running.\nOtherwise implements the same functionality as the regular 'Spectrum' block.</p>\n<div class=\"section\" id=\"note\">\n<h4>Note</h4>\n<p>Due to the plotting being relatively expensive, including this block slows down\nthe simulation significantly but may still be valuable for debugging and testing.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>freq <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array[float]</span></dt>\n<dd>list of evaluation frequencies for RFT, can be arbitrarily spaced</dd>\n<dt>t_wait <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>wait time before starting RFT</dd>\n<dt>alpha <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>exponential forgetting factor for realtime spectrum</dd>\n<dt>labels <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">list[str]</span></dt>\n<dd>labels for the inputs</dd>\n</dl>\n</div>\n",
          "source": "@deprecated(version=\"1.0.0\")\nclass RealtimeSpectrum(Spectrum):\n    \"\"\"An extension of the 'Spectrum' block that also initializes a realtime plotter.\n\n    Creates an interactive plotting window while the simulation is running.\n    Otherwise implements the same functionality as the regular 'Spectrum' block.\n\n    Note\n    ----\n    Due to the plotting being relatively expensive, including this block slows down\n    the simulation significantly but may still be valuable for debugging and testing.\n\n    Parameters\n    ----------\n    freq : array[float]\n        list of evaluation frequencies for RFT, can be arbitrarily spaced\n    t_wait : float\n        wait time before starting RFT\n    alpha : float\n        exponential forgetting factor for realtime spectrum\n    labels : list[str]\n        labels for the inputs\n    \"\"\"\n\n    def __init__(self, freq=[], t_wait=0.0, alpha=0.0, labels=[]):\n        super().__init__(freq, t_wait, alpha, labels)\n\n        #initialize realtime plotter\n        self.plotter = RealtimePlotter(\n            update_interval=0.1,\n            labels=labels,\n            x_label=\"freq [Hz]\",\n            y_label=\"magnitude\"\n            )\n\n\n    def step(self, t, dt):\n        \"\"\"compute timestep update with integration engine\n\n        Parameters\n        ----------\n        t : float\n            evaluation time\n        dt : float\n            integration timestep\n\n        Returns\n        ------- \n        success : bool\n            step was successful\n        error : float\n            local truncation error from adaptive integrators\n        scale : float\n            timestep rescale from adaptive integrators\n        \"\"\"\n\n        #effective time for integration\n        _t = t - self.t_wait\n        if _t > dt:\n\n            #update local integtration time\n            self.time = _t\n\n            if self.time > 2*dt:\n                #update realtime plotter\n                _, data = self.read()\n                self.plotter.update_all(self.freq, abs(data))\n\n            #compute update step with integration engine\n            f = self._kernel(self.engine.state, self.inputs.to_array(), _t)\n            return self.engine.step(f, dt)\n\n        #no error estimate\n        return True, 0.0, None",
          "bases": [
            "pathsim.blocks.spectrum.Spectrum"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, freq=[], t_wait=0.0, alpha=0.0, labels=[]):\n    super().__init__(freq, t_wait, alpha, labels)\n\n    #initialize realtime plotter\n    self.plotter = RealtimePlotter(\n        update_interval=0.1,\n        labels=labels,\n        x_label=\"freq [Hz]\",\n        y_label=\"magnitude\"\n        )",
              "signature": "(freq = [], t_wait = 0.0, alpha = 0.0, labels = [])",
              "parameters": [
                {
                  "name": "freq",
                  "type": null,
                  "default": "[]",
                  "description": ""
                },
                {
                  "name": "t_wait",
                  "type": null,
                  "default": "0.0",
                  "description": ""
                },
                {
                  "name": "alpha",
                  "type": null,
                  "default": "0.0",
                  "description": ""
                },
                {
                  "name": "labels",
                  "type": null,
                  "default": "[]",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "step",
              "description": "compute timestep update with integration engine",
              "docstring_html": "<p>compute timestep update with integration engine</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time</dd>\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>integration timestep</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>success <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>step was successful</dd>\n<dt>error <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>local truncation error from adaptive integrators</dd>\n<dt>scale <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>timestep rescale from adaptive integrators</dd>\n</dl>\n",
              "source": "def step(self, t, dt):\n    \"\"\"compute timestep update with integration engine\n\n    Parameters\n    ----------\n    t : float\n        evaluation time\n    dt : float\n        integration timestep\n\n    Returns\n    ------- \n    success : bool\n        step was successful\n    error : float\n        local truncation error from adaptive integrators\n    scale : float\n        timestep rescale from adaptive integrators\n    \"\"\"\n\n    #effective time for integration\n    _t = t - self.t_wait\n    if _t > dt:\n\n        #update local integtration time\n        self.time = _t\n\n        if self.time > 2*dt:\n            #update realtime plotter\n            _, data = self.read()\n            self.plotter.update_all(self.freq, abs(data))\n\n        #compute update step with integration engine\n        f = self._kernel(self.engine.state, self.inputs.to_array(), _t)\n        return self.engine.step(f, dt)\n\n    #no error estimate\n    return True, 0.0, None",
              "signature": "(t, dt)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time"
                },
                {
                  "name": "dt",
                  "type": null,
                  "default": null,
                  "description": "integration timestep"
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "plotter",
              "description": "",
              "type": null,
              "value": "RealtimePlotter(update_interval=0.1, labels=labels, x_label='freq [Hz]', y_label='magnitude')"
            }
          ],
          "parameters": [
            {
              "name": "freq",
              "type": null,
              "default": "[]",
              "description": "list of evaluation frequencies for RFT, can be arbitrarily spaced"
            },
            {
              "name": "t_wait",
              "type": null,
              "default": "0.0",
              "description": "wait time before starting RFT"
            },
            {
              "name": "alpha",
              "type": null,
              "default": "0.0",
              "description": "exponential forgetting factor for realtime spectrum"
            },
            {
              "name": "labels",
              "type": null,
              "default": "[]",
              "description": "labels for the inputs"
            }
          ]
        }
      ],
      "functions": []
    },
    "pathsim.blocks.switch": {
      "name": "pathsim.blocks.switch",
      "description": "",
      "docstring_html": "",
      "classes": [
        {
          "name": "Switch",
          "description": "Switch block that selects between its inputs.",
          "docstring_html": "<p>Switch block that selects between its inputs.</p>\n<div class=\"section\" id=\"example\">\n<h4>Example</h4>\n<p>The block is initialized like this:</p>\n<pre class=\"code python literal-block\">\n<span class=\"c1\">#default None -&gt; no passthrough</span><span class=\"w\">\n</span><span class=\"n\">s1</span> <span class=\"o\">=</span> <span class=\"n\">Switch</span><span class=\"p\">()</span><span class=\"w\">\n\n</span><span class=\"c1\">#selecting port 2 as passthrough</span><span class=\"w\">\n</span><span class=\"n\">s2</span> <span class=\"o\">=</span> <span class=\"n\">Switch</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">)</span><span class=\"w\">\n\n</span><span class=\"c1\">#change the state of the switch to port 3</span><span class=\"w\">\n</span><span class=\"n\">s2</span><span class=\"o\">.</span><span class=\"n\">select</span><span class=\"p\">(</span><span class=\"mi\">3</span><span class=\"p\">)</span>\n</pre>\n<p>Sets block output depending on <cite>self.state</cite> like this:</p>\n<pre class=\"code literal-block\">\nstate == None -&gt; outputs[0] = 0\n\nstate == 0 -&gt; outputs[0] = inputs[0]\n\nstate == 1 -&gt; outputs[0] = inputs[1]\n\nstate == 2 -&gt; outputs[0] = inputs[2]\n\n...\n</pre>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>state <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int, None</span></dt>\n<dd>state of the switch</dd>\n</dl>\n</div>\n",
          "source": "class Switch(Block):\n    \"\"\"Switch block that selects between its inputs.\n\n    Example\n    -------\n    The block is initialized like this:\n\n    .. code-block:: python \n\n        #default None -> no passthrough \n        s1 = Switch()\n\n        #selecting port 2 as passthrough\n        s2 = Switch(2)\n\n        #change the state of the switch to port 3\n        s2.select(3)\n\n    Sets block output depending on `self.state` like this:\n\n    .. code-block::\n\n        state == None -> outputs[0] = 0\n\n        state == 0 -> outputs[0] = inputs[0]\n\n        state == 1 -> outputs[0] = inputs[1]\n\n        state == 2 -> outputs[0] = inputs[2]\n\n        ...\n\n    Parameters\n    ----------\n    state : int, None\n        state of the switch\n\n    \"\"\"\n\n    input_port_labels = None\n    output_port_labels = {\"out\":0}\n\n    def __init__(self, state=None):\n        super().__init__()\n\n        self.state = state\n\n\n    def __len__(self):\n        \"\"\"Algebraic passthrough only possible if state is defined\"\"\"\n        return 0 if (self.state is None or not self._active) else 1\n\n\n    def select(self, state=0):\n        \"\"\"\n        This method is unique to the `Switch` block and intended \n        to be used from outside the simulation level for selecting \n        the input ports for the switch state.\n\n        This can be achieved for example with the event management \n        system and its callback/action functions.\n\n        Parameters\n        ---------\n        state : int, None\n            switch state / input port selection\n        \"\"\"\n        self.state = state\n\n\n    def update(self, t):\n        \"\"\"Update switch output depending on inputs and switch state.\n\n        Parameters\n        ----------\n        t : float\n            evaluation time\n        \"\"\"\n\n        #early exit without error control\n        if self.state is None: self.outputs[0] = 0.0\n        else: self.outputs[0] = self.inputs[self.state]",
          "bases": [
            "pathsim.blocks._block.Block"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, state=None):\n    super().__init__()\n\n    self.state = state",
              "signature": "(state = None)",
              "parameters": [
                {
                  "name": "state",
                  "type": null,
                  "default": "None",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "select",
              "description": "This method is unique to the `Switch` block and intended",
              "docstring_html": "<p>This method is unique to the <cite>Switch</cite> block and intended\nto be used from outside the simulation level for selecting\nthe input ports for the switch state.</p>\n<p>This can be achieved for example with the event management\nsystem and its callback/action functions.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>state <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int, None</span></dt>\n<dd>switch state / input port selection</dd>\n</dl>\n",
              "source": "def select(self, state=0):\n    \"\"\"\n    This method is unique to the `Switch` block and intended \n    to be used from outside the simulation level for selecting \n    the input ports for the switch state.\n\n    This can be achieved for example with the event management \n    system and its callback/action functions.\n\n    Parameters\n    ---------\n    state : int, None\n        switch state / input port selection\n    \"\"\"\n    self.state = state",
              "signature": "(state = 0)",
              "parameters": [
                {
                  "name": "state",
                  "type": null,
                  "default": "0",
                  "description": "switch state / input port selection"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "update",
              "description": "Update switch output depending on inputs and switch state.",
              "docstring_html": "<p>Update switch output depending on inputs and switch state.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time</dd>\n</dl>\n",
              "source": "def update(self, t):\n    \"\"\"Update switch output depending on inputs and switch state.\n\n    Parameters\n    ----------\n    t : float\n        evaluation time\n    \"\"\"\n\n    #early exit without error control\n    if self.state is None: self.outputs[0] = 0.0\n    else: self.outputs[0] = self.inputs[self.state]",
              "signature": "(t)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time"
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "input_port_labels",
              "description": "",
              "type": null,
              "value": "None"
            },
            {
              "name": "output_port_labels",
              "description": "",
              "type": null,
              "value": "{'out': 0}"
            },
            {
              "name": "state",
              "description": "",
              "type": null,
              "value": "state"
            }
          ],
          "parameters": [
            {
              "name": "state",
              "type": null,
              "default": "None",
              "description": "state of the switch"
            }
          ]
        }
      ],
      "functions": []
    },
    "pathsim.blocks.table": {
      "name": "pathsim.blocks.table",
      "description": "",
      "docstring_html": "",
      "classes": [
        {
          "name": "LUT",
          "description": "N-dimensional lookup table with linear interpolation functionality.",
          "docstring_html": "<p>N-dimensional lookup table with linear interpolation functionality.</p>\n<p>This class implements a multi-dimensional lookup table that uses scipy's\nLinearNDInterpolator <a class=\"footnote-reference\" href=\"#scipy\" id=\"footnote-reference-1\">[1]</a> for piecewise linear interpolation in N-dimensional\nspace. The interpolation is based on Delaunay triangulation of the input points,\nproviding smooth linear interpolation between data points. For points outside\nthe convex hull of the input data, the interpolator returns NaN values.</p>\n<p>The LUT acts as a Function block.</p>\n<p><strong>References</strong></p>\n<table class=\"docutils footnote\" frame=\"void\" id=\"scipy\" rules=\"none\">\n<colgroup><col class=\"label\" /><col /></colgroup>\n<tbody valign=\"top\">\n<tr><td class=\"label\"><a class=\"fn-backref\" href=\"#footnote-reference-1\">[1]</a></td><td><a class=\"reference external\" href=\"https://docs.scipy.org/doc/scipy-1.16.1/reference/generated/scipy.interpolate.LinearNDInterpolator.html\">https://docs.scipy.org/doc/scipy-1.16.1/reference/generated/scipy.interpolate.LinearNDInterpolator.html</a></td></tr>\n</tbody>\n</table>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>points <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array_like of shape (n, ndim)</span></dt>\n<dd>2-D array of data point coordinates where n is the number of points\nand ndim is the dimensionality of the space. Each row represents a\nsingle data point in ndim-dimensional space.</dd>\n<dt>values <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array_like of shape (n,) or (n, m)</span></dt>\n<dd>N-D array of data values at the corresponding points. If 1-D, represents\nscalar values at each point. If 2-D, each column represents a different\noutput dimension (m output values per input point).</dd>\n</dl>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>points <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">ndarray</span></dt>\n<dd>Stored array of input point coordinates.</dd>\n<dt>values <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">ndarray</span></dt>\n<dd>Stored array of output values at each point.</dd>\n<dt>inter <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">scipy.interpolate.LinearNDInterpolator</span></dt>\n<dd>The scipy linear interpolator object used for interpolation.</dd>\n</dl>\n",
          "source": "class LUT(Function):\n    \"\"\"N-dimensional lookup table with linear interpolation functionality.\n\n    This class implements a multi-dimensional lookup table that uses scipy's\n    LinearNDInterpolator [#scipy]_ for piecewise linear interpolation in N-dimensional \n    space. The interpolation is based on Delaunay triangulation of the input points, \n    providing smooth linear interpolation between data points. For points outside \n    the convex hull of the input data, the interpolator returns NaN values.\n\n    The LUT acts as a Function block.\n\n\n    References\n    ----------\n    .. [#scipy] https://docs.scipy.org/doc/scipy-1.16.1/reference/generated/scipy.interpolate.LinearNDInterpolator.html\n\n\n    Parameters\n    ----------\n    points : array_like of shape (n, ndim)\n        2-D array of data point coordinates where n is the number of points\n        and ndim is the dimensionality of the space. Each row represents a\n        single data point in ndim-dimensional space.\n    values : array_like of shape (n,) or (n, m)\n        N-D array of data values at the corresponding points. If 1-D, represents\n        scalar values at each point. If 2-D, each column represents a different\n        output dimension (m output values per input point).\n\n\n    Attributes\n    ----------\n    points : ndarray\n        Stored array of input point coordinates.\n    values : ndarray  \n        Stored array of output values at each point.\n    inter : scipy.interpolate.LinearNDInterpolator\n        The scipy linear interpolator object used for interpolation.\n    \"\"\"\n\n    def __init__(self, points=None, values=None):\n        self.points = np.asarray(points) if points is not None else np.ones(2) \n        self.values = np.asarray(values) if values is not None else np.ones(2)\n\n        self.inter = LinearNDInterpolator(self.points, self.values)\n\n        super().__init__(func=lambda *x :self.inter(x))",
          "bases": [
            "pathsim.blocks.Function"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, points=None, values=None):\n    self.points = np.asarray(points) if points is not None else np.ones(2) \n    self.values = np.asarray(values) if values is not None else np.ones(2)\n\n    self.inter = LinearNDInterpolator(self.points, self.values)\n\n    super().__init__(func=lambda *x :self.inter(x))",
              "signature": "(points = None, values = None)",
              "parameters": [
                {
                  "name": "points",
                  "type": null,
                  "default": "None",
                  "description": ""
                },
                {
                  "name": "values",
                  "type": null,
                  "default": "None",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "points",
              "description": "",
              "type": null,
              "value": "np.asarray(points) if points is not None else np.ones(2)"
            },
            {
              "name": "values",
              "description": "",
              "type": null,
              "value": "np.asarray(values) if values is not None else np.ones(2)"
            },
            {
              "name": "inter",
              "description": "",
              "type": null,
              "value": "LinearNDInterpolator(self.points, self.values)"
            }
          ],
          "parameters": [
            {
              "name": "points",
              "type": null,
              "default": "None",
              "description": "2-D array of data point coordinates where n is the number of points and ndim is the dimensionality of the space. Each row represents a single data point in ndim-dimensional space."
            },
            {
              "name": "values",
              "type": null,
              "default": "None",
              "description": "N-D array of data values at the corresponding points. If 1-D, represents scalar values at each point. If 2-D, each column represents a different output dimension (m output values per input point)."
            }
          ]
        },
        {
          "name": "LUT1D",
          "description": "One-dimensional lookup table with linear interpolation functionality.",
          "docstring_html": "<p>One-dimensional lookup table with linear interpolation functionality.</p>\n<p>This class implements a 1-dimensional lookup table that uses scipy's interp1d <a class=\"footnote-reference\" href=\"#scipy\" id=\"footnote-reference-1\">[1]</a>\nfor piecewise linear interpolation along a single axis. The interpolation\nprovides linear interpolation between adjacent data points and supports\nextrapolation beyond the input data range using the 'extrapolate' fill mode.</p>\n<p>The LUT1D acts as a Function block.</p>\n<p><strong>References</strong></p>\n<table class=\"docutils footnote\" frame=\"void\" id=\"scipy\" rules=\"none\">\n<colgroup><col class=\"label\" /><col /></colgroup>\n<tbody valign=\"top\">\n<tr><td class=\"label\"><a class=\"fn-backref\" href=\"#footnote-reference-1\">[1]</a></td><td><a class=\"reference external\" href=\"https://docs.scipy.org/doc/scipy-1.16.1/reference/generated/scipy.interpolate.interp1d.html\">https://docs.scipy.org/doc/scipy-1.16.1/reference/generated/scipy.interpolate.interp1d.html</a></td></tr>\n</tbody>\n</table>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>points <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array_like of shape (n,)</span></dt>\n<dd>1-D array of monotonically increasing data point coordinates where n\nis the number of points. These represent the independent variable values\nat which the dependent values are known.</dd>\n<dt>values <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array_like of shape (n,) or (n, m)</span></dt>\n<dd>1-D or 2-D array of data values at the corresponding points. If 1-D,\nrepresents scalar values at each point. If 2-D with shape (n, m),\neach column represents a different output dimension, allowing the\nlookup table to return m-dimensional vectors.</dd>\n<dt>fill_value <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float or str, optional</span></dt>\n<dd>The value to use for points outside the interpolation range. If &quot;extrapolate&quot;,\nthe interpolator will use linear extrapolation. Default is &quot;extrapolate&quot;.\nSee <a class=\"reference external\" href=\"https://docs.scipy.org/doc/scipy-1.16.1/reference/generated/scipy.interpolate.interp1d.html\">https://docs.scipy.org/doc/scipy-1.16.1/reference/generated/scipy.interpolate.interp1d.html</a> for more details</dd>\n</dl>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>points <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">ndarray</span></dt>\n<dd>Flattened array of input point coordinates, stored as 1-D array.</dd>\n<dt>values <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">ndarray</span></dt>\n<dd>Stored array of output values at each point, preserving original shape.</dd>\n<dt>inter <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">scipy.interpolate.interp1d</span></dt>\n<dd>The scipy 1D interpolator object used for linear interpolation with\nextrapolation enabled beyond the data range.</dd>\n</dl>\n",
          "source": "class LUT1D(Function):\n    \"\"\"One-dimensional lookup table with linear interpolation functionality.\n\n    This class implements a 1-dimensional lookup table that uses scipy's interp1d [#scipy]_\n    for piecewise linear interpolation along a single axis. The interpolation\n    provides linear interpolation between adjacent data points and supports\n    extrapolation beyond the input data range using the 'extrapolate' fill mode.\n\n    The LUT1D acts as a Function block.\n\n\n    References\n    ----------\n    .. [#scipy] https://docs.scipy.org/doc/scipy-1.16.1/reference/generated/scipy.interpolate.interp1d.html\n\n\n    Parameters\n    ----------\n    points : array_like of shape (n,)\n        1-D array of monotonically increasing data point coordinates where n \n        is the number of points. These represent the independent variable values\n        at which the dependent values are known.\n    values : array_like of shape (n,) or (n, m)\n        1-D or 2-D array of data values at the corresponding points. If 1-D,\n        represents scalar values at each point. If 2-D with shape (n, m), \n        each column represents a different output dimension, allowing the\n        lookup table to return m-dimensional vectors.\n    fill_value : float or str, optional\n        The value to use for points outside the interpolation range. If \"extrapolate\",\n        the interpolator will use linear extrapolation. Default is \"extrapolate\".\n        See https://docs.scipy.org/doc/scipy-1.16.1/reference/generated/scipy.interpolate.interp1d.html for more details\n\n\n    Attributes\n    ----------\n    points : ndarray\n        Flattened array of input point coordinates, stored as 1-D array.\n    values : ndarray\n        Stored array of output values at each point, preserving original shape.\n    inter : scipy.interpolate.interp1d\n        The scipy 1D interpolator object used for linear interpolation with\n        extrapolation enabled beyond the data range.\n    \"\"\"\n\n    def __init__(self, points=None, values=None, fill_value=\"extrapolate\"):\n        self.points = np.asarray(points).flatten() if points is not None else np.ones(2) \n        self.values = np.asarray(values) if values is not None else np.ones(2)\n\n        # Handle both 1D and 2D values\n        if self.values.ndim == 1:\n            # Single output dimension\n            self.inter = interp1d(self.points, self.values, fill_value=fill_value)\n            def func(*x):\n                return self.inter(x[0])\n        else:\n            # Multiple output dimensions - interpolate each column separately\n            self.inter = interp1d(self.points, self.values, axis=0, fill_value=fill_value)\n            def func(*x):\n                return self.inter(x[0])\n\n        super().__init__(func=func)",
          "bases": [
            "pathsim.blocks.Function"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, points=None, values=None, fill_value=\"extrapolate\"):\n    self.points = np.asarray(points).flatten() if points is not None else np.ones(2) \n    self.values = np.asarray(values) if values is not None else np.ones(2)\n\n    # Handle both 1D and 2D values\n    if self.values.ndim == 1:\n        # Single output dimension\n        self.inter = interp1d(self.points, self.values, fill_value=fill_value)\n        def func(*x):\n            return self.inter(x[0])\n    else:\n        # Multiple output dimensions - interpolate each column separately\n        self.inter = interp1d(self.points, self.values, axis=0, fill_value=fill_value)\n        def func(*x):\n            return self.inter(x[0])\n\n    super().__init__(func=func)",
              "signature": "(points = None, values = None, fill_value = 'extrapolate')",
              "parameters": [
                {
                  "name": "points",
                  "type": null,
                  "default": "None",
                  "description": ""
                },
                {
                  "name": "values",
                  "type": null,
                  "default": "None",
                  "description": ""
                },
                {
                  "name": "fill_value",
                  "type": null,
                  "default": "'extrapolate'",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "points",
              "description": "",
              "type": null,
              "value": "np.asarray(points).flatten() if points is not None else np.ones(2)"
            },
            {
              "name": "values",
              "description": "",
              "type": null,
              "value": "np.asarray(values) if values is not None else np.ones(2)"
            },
            {
              "name": "inter",
              "description": "",
              "type": null,
              "value": "interp1d(self.points, self.values, fill_value=fill_value)"
            }
          ],
          "parameters": [
            {
              "name": "points",
              "type": null,
              "default": "None",
              "description": "1-D array of monotonically increasing data point coordinates where n is the number of points. These represent the independent variable values at which the dependent values are known."
            },
            {
              "name": "values",
              "type": null,
              "default": "None",
              "description": "1-D or 2-D array of data values at the corresponding points. If 1-D, represents scalar values at each point. If 2-D with shape (n, m), each column represents a different output dimension, allowing the lookup table to return m-dimensional vectors."
            },
            {
              "name": "fill_value",
              "type": null,
              "default": "'extrapolate'",
              "description": "The value to use for points outside the interpolation range. If \"extrapolate\", the interpolator will use linear extrapolation. Default is \"extrapolate\". See https://docs.scipy.org/doc/scipy-1.16.1/reference/generated/scipy.interpolate.interp1d.html for more details"
            }
          ]
        }
      ],
      "functions": []
    },
    "pathsim.blocks.wrapper": {
      "name": "pathsim.blocks.wrapper",
      "description": "",
      "docstring_html": "",
      "classes": [
        {
          "name": "Wrapper",
          "description": "Wrapper block for discrete implementation and external code integration.",
          "docstring_html": "<p>Wrapper block for discrete implementation and external code integration.</p>\n<p>The <cite>Wrapper</cite> class is designed to call the internal <cite>func</cite> at fixed intervals\nusing an internal <cite>Schedule</cite> event. This makes it particularly useful for wrapping\nexternal code or implementing discrete-time systems.</p>\n<p>Essentially this block does the same as <cite>Function</cite> with the difference that its\nnot evaluated continuously but periodically at discrete times.</p>\n<div class=\"section\" id=\"example\">\n<h4>Example</h4>\n<p>There are two ways to setup the <cite>Wrapper</cite>, first and standard way is to define\na function to be wrapped and pass it to the block initializer:</p>\n<pre class=\"code python literal-block\">\n<span class=\"kn\">from</span><span class=\"w\"> </span><span class=\"nn\">pathsim.blocks</span><span class=\"w\"> </span><span class=\"kn\">import</span> <span class=\"n\">Wrapper</span><span class=\"w\">\n\n</span><span class=\"c1\">#function to be wrapped</span><span class=\"w\">\n</span><span class=\"k\">def</span><span class=\"w\"> </span><span class=\"nf\">func</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">,</span> <span class=\"n\">b</span><span class=\"p\">,</span> <span class=\"n\">c</span><span class=\"p\">):</span><span class=\"w\">\n</span>    <span class=\"k\">return</span> <span class=\"n\">a</span> <span class=\"o\">*</span> <span class=\"p\">(</span><span class=\"n\">b</span> <span class=\"o\">+</span> <span class=\"n\">c</span><span class=\"p\">)</span><span class=\"w\">\n\n</span><span class=\"n\">wrp</span> <span class=\"o\">=</span> <span class=\"n\">Wrapper</span><span class=\"p\">(</span><span class=\"n\">func</span><span class=\"p\">,</span> <span class=\"n\">T</span><span class=\"o\">=</span><span class=\"mf\">0.1</span><span class=\"p\">)</span>\n</pre>\n<p>Another option is to use the <cite>dec</cite> classmethod, which might be more convenient\nin some situations:</p>\n<pre class=\"code python literal-block\">\n<span class=\"kn\">from</span><span class=\"w\"> </span><span class=\"nn\">pathsim.blocks</span><span class=\"w\"> </span><span class=\"kn\">import</span> <span class=\"n\">Wrapper</span><span class=\"w\">\n\n</span><span class=\"nd\">&#64;Wrapper</span><span class=\"o\">.</span><span class=\"n\">dec</span><span class=\"p\">(</span><span class=\"n\">T</span><span class=\"o\">=</span><span class=\"mf\">0.1</span><span class=\"p\">)</span><span class=\"w\">\n</span><span class=\"k\">def</span><span class=\"w\"> </span><span class=\"nf\">wrp</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">,</span> <span class=\"n\">b</span><span class=\"p\">,</span> <span class=\"n\">c</span><span class=\"p\">):</span><span class=\"w\">\n</span>    <span class=\"k\">return</span> <span class=\"n\">a</span> <span class=\"o\">*</span> <span class=\"p\">(</span><span class=\"n\">b</span> <span class=\"o\">+</span> <span class=\"n\">c</span><span class=\"p\">)</span>\n</pre>\n<p>This way the internal function of the block <cite>wrp</cite> will be evaluated with a period\nof <cite>T=0.1</cite> and its outputs updated accordingly.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>func <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">callable</span></dt>\n<dd>function that defines algebraic block IO behaviour</dd>\n<dt>T <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>sampling period for the wrapped function</dd>\n<dt>tau <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>delay time for the start time of the event</dd>\n</dl>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>Evt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">Schedule</span></dt>\n<dd>internal event. Used for periodic sampling the wrapped method</dd>\n</dl>\n</div>\n",
          "source": "class Wrapper(Block):\n    \"\"\"Wrapper block for discrete implementation and external code integration.\n\n    The `Wrapper` class is designed to call the internal `func` at fixed intervals \n    using an internal `Schedule` event. This makes it particularly useful for wrapping \n    external code or implementing discrete-time systems.\n\n    Essentially this block does the same as `Function` with the difference that its \n    not evaluated continuously but periodically at discrete times.\n\n\n    Example\n    -------\n    There are two ways to setup the `Wrapper`, first and standard way is to define \n    a function to be wrapped and pass it to the block initializer:\n\n    .. code-block:: python\n\n        from pathsim.blocks import Wrapper\n\n        #function to be wrapped\n        def func(a, b, c):\n            return a * (b + c)\n\n        wrp = Wrapper(func, T=0.1)\n\n\n    Another option is to use the `dec` classmethod, which might be more convenient \n    in some situations:\n\n    .. code-block:: python\n\n        from pathsim.blocks import Wrapper\n\n        @Wrapper.dec(T=0.1)\n        def wrp(a, b, c):\n            return a * (b + c)\n\n\n    This way the internal function of the block `wrp` will be evaluated with a period \n    of `T=0.1` and its outputs updated accordingly.\n\n\n    Parameters\n    ----------\n    func : callable\n        function that defines algebraic block IO behaviour\n    T : float\n        sampling period for the wrapped function\n    tau : float\n        delay time for the start time of the event\n\n    Attributes\n    ----------\n    Evt : Schedule\n        internal event. Used for periodic sampling the wrapped method\n    \"\"\"\n\n    def __init__(self, func=None, T=1, tau=0):\n        super().__init__()\n        self._T   = T\n        self._tau = tau\n\n        #assign func to wrap (direct initialization)\n        if callable(func):\n            self.func = func\n\n        def _sample(t):\n\n            #read current inputs\n            u = self.inputs.to_array()\n\n            #compute operator output\n            y = self.func(*u)\n\n            #update block outputs\n            self.outputs.update_from_array(y)\n\n        #internal scheduled events\n        self.Evt = Schedule(\n                t_start=tau,\n                t_period=T,\n                func_act=_sample\n                )\n        self.events = [self.Evt]\n\n\n    def update(self, t):\n        \"\"\"Update system equation for fixed point loop.\n\n        Note\n        ----\n        No direct passthrough, the `Wrapper` block doesnt \n        implement the `update` method. The behavior is \n        defined by the `func` arg.\n\n        Parameters\n        ----------\n        t : float\n            evaluation time\n        \"\"\"\n        pass\n\n\n    @property\n    def tau(self):\n        \"\"\"Getter for tau\n\n        Returns\n        -------\n        tau : float\n              delay time for the Schedule event\n        \"\"\"\n        return self._tau\n\n\n    @tau.setter\n    def tau(self, value):\n        \"\"\"Setter for tau\n\n        Parameters\n        ----------\n        value : float\n                delay time\n        \"\"\"\n        if value < 0:\n            raise ValueError(\"tau must be non-negative\")\n        self._tau = value\n        self.Evt.t_start = value\n\n\n    @property\n    def T(self):\n        \"\"\"Get the sampling period of the block\n\n        Returns\n        -------\n        T: float\n            sampling period for the Schedule event\n        \"\"\"\n        return self._T\n\n\n    @T.setter\n    def T(self, value):\n        \"\"\"Set the sampling period of the block\n        Parameters\n        ----------\n        value : float\n                sampling period\n        \"\"\"\n        if value <= 0:\n            raise ValueError(\"T must be positive\")\n        self._T = value\n        self.Evt.t_period = value\n\n\n    @classmethod\n    def dec(cls, T=1, tau=0):\n        \"\"\"decorator for direct instance construction from func\n\n        Example\n        -------\n        Decorate a function definition to directly make it \n        a `Wrapper` block instance:\n\n        .. code-block:: python\n\n        from pathsim.blocks import Wrapper\n\n        @Wrapper.dec(T=0.1)\n        def wrp(a, b, c):\n            return a * (b + c)\n\n\n        Parameters\n        ----------\n        tau : float\n            delay time for the start time of the wrapper sampling\n        T : float\n            sampling period for calling the `wrapped` function\n        \"\"\"\n        def decorator(func):\n            return cls(func, T, tau)\n        return decorator",
          "bases": [
            "pathsim.blocks._block.Block"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, func=None, T=1, tau=0):\n    super().__init__()\n    self._T   = T\n    self._tau = tau\n\n    #assign func to wrap (direct initialization)\n    if callable(func):\n        self.func = func\n\n    def _sample(t):\n\n        #read current inputs\n        u = self.inputs.to_array()\n\n        #compute operator output\n        y = self.func(*u)\n\n        #update block outputs\n        self.outputs.update_from_array(y)\n\n    #internal scheduled events\n    self.Evt = Schedule(\n            t_start=tau,\n            t_period=T,\n            func_act=_sample\n            )\n    self.events = [self.Evt]",
              "signature": "(func = None, T = 1, tau = 0)",
              "parameters": [
                {
                  "name": "func",
                  "type": null,
                  "default": "None",
                  "description": ""
                },
                {
                  "name": "T",
                  "type": null,
                  "default": "1",
                  "description": ""
                },
                {
                  "name": "tau",
                  "type": null,
                  "default": "0",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "update",
              "description": "Update system equation for fixed point loop.",
              "docstring_html": "<p>Update system equation for fixed point loop.</p>\n<div class=\"section\" id=\"note\">\n<h4>Note</h4>\n<p>No direct passthrough, the <cite>Wrapper</cite> block doesnt\nimplement the <cite>update</cite> method. The behavior is\ndefined by the <cite>func</cite> arg.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time</dd>\n</dl>\n</div>\n",
              "source": "def update(self, t):\n    \"\"\"Update system equation for fixed point loop.\n\n    Note\n    ----\n    No direct passthrough, the `Wrapper` block doesnt \n    implement the `update` method. The behavior is \n    defined by the `func` arg.\n\n    Parameters\n    ----------\n    t : float\n        evaluation time\n    \"\"\"\n    pass",
              "signature": "(t)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "dec",
              "description": "decorator for direct instance construction from func",
              "docstring_html": "<p>decorator for direct instance construction from func</p>\n<div class=\"section\" id=\"example\">\n<h4>Example</h4>\n<p>Decorate a function definition to directly make it\na <cite>Wrapper</cite> block instance:</p>\n<p>from pathsim.blocks import Wrapper</p>\n<p>&#64;Wrapper.dec(T=0.1)\ndef wrp(a, b, c):</p>\n<blockquote>\nreturn a * (b + c)</blockquote>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>tau <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>delay time for the start time of the wrapper sampling</dd>\n<dt>T <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>sampling period for calling the <cite>wrapped</cite> function</dd>\n</dl>\n</div>\n",
              "source": "@classmethod\ndef dec(cls, T=1, tau=0):\n    \"\"\"decorator for direct instance construction from func\n\n    Example\n    -------\n    Decorate a function definition to directly make it \n    a `Wrapper` block instance:\n\n    .. code-block:: python\n\n    from pathsim.blocks import Wrapper\n\n    @Wrapper.dec(T=0.1)\n    def wrp(a, b, c):\n        return a * (b + c)\n\n\n    Parameters\n    ----------\n    tau : float\n        delay time for the start time of the wrapper sampling\n    T : float\n        sampling period for calling the `wrapped` function\n    \"\"\"\n    def decorator(func):\n        return cls(func, T, tau)\n    return decorator",
              "signature": "(cls, T = 1, tau = 0)",
              "parameters": [
                {
                  "name": "cls",
                  "type": null,
                  "default": null,
                  "description": ""
                },
                {
                  "name": "T",
                  "type": null,
                  "default": "1",
                  "description": "sampling period for calling the `wrapped` function"
                },
                {
                  "name": "tau",
                  "type": null,
                  "default": "0",
                  "description": "delay time for the start time of the wrapper sampling"
                }
              ],
              "returns": null,
              "method_type": "classmethod"
            }
          ],
          "attributes": [
            {
              "name": "_T",
              "description": "",
              "type": null,
              "value": "T"
            },
            {
              "name": "_tau",
              "description": "",
              "type": null,
              "value": "tau"
            },
            {
              "name": "func",
              "description": "",
              "type": null,
              "value": "func"
            },
            {
              "name": "Evt",
              "description": "",
              "type": null,
              "value": "Schedule(t_start=tau, t_period=T, func_act=_sample)"
            },
            {
              "name": "events",
              "description": "",
              "type": null,
              "value": "[self.Evt]"
            },
            {
              "name": "tau",
              "description": "Getter for tau",
              "type": null,
              "value": null
            },
            {
              "name": "T",
              "description": "Get the sampling period of the block",
              "type": null,
              "value": null
            }
          ],
          "parameters": [
            {
              "name": "func",
              "type": null,
              "default": "None",
              "description": "function that defines algebraic block IO behaviour"
            },
            {
              "name": "T",
              "type": null,
              "default": "1",
              "description": "sampling period for the wrapped function"
            },
            {
              "name": "tau",
              "type": null,
              "default": "0",
              "description": "delay time for the start time of the event Attributes ----------"
            }
          ]
        }
      ],
      "functions": []
    },
    "pathsim.solvers._rungekutta": {
      "name": "pathsim.solvers._rungekutta",
      "description": "",
      "docstring_html": "",
      "classes": [
        {
          "name": "ExplicitRungeKutta",
          "description": "Base class for explicit Runge-Kutta integrators which implements",
          "docstring_html": "<p>Base class for explicit Runge-Kutta integrators which implements\nthe timestepping at intermediate stages and the error control if\nthe coefficients for the local truncation error estimate are defined.</p>\n<div class=\"section\" id=\"note\">\n<h4>Note</h4>\n<p>This class is not intended to be used directly!!!</p>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>n <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>order of stepping integration scheme</dd>\n<dt>m <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>order of embedded integration scheme for error control</dd>\n<dt>s <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>numer of RK stages</dd>\n<dt>history <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">deque[numeric]</span></dt>\n<dd>internal history of past results</dd>\n<dt>beta <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>safety factor for error control</dd>\n<dt>Ks <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">dict</span></dt>\n<dd>slopes at RK stages</dd>\n<dt>BT <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">dict[int: None, list[float]], None</span></dt>\n<dd>butcher table</dd>\n<dt>TR <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">list[float]</span></dt>\n<dd>coefficients for truncation error estimate</dd>\n</dl>\n</div>\n",
          "source": "class ExplicitRungeKutta(ExplicitSolver):\n    \"\"\"Base class for explicit Runge-Kutta integrators which implements \n    the timestepping at intermediate stages and the error control if \n    the coefficients for the local truncation error estimate are defined.        \n\n    Note\n    ----\n    This class is not intended to be used directly!!!\n\n    Attributes\n    ----------\n    n : int \n        order of stepping integration scheme\n    m : int\n        order of embedded integration scheme for error control\n    s : int\n        numer of RK stages\n    history : deque[numeric]\n        internal history of past results\n    beta : float\n        safety factor for error control\n    Ks : dict\n        slopes at RK stages\n    BT : dict[int: None, list[float]], None\n        butcher table\n    TR : list[float]\n        coefficients for truncation error estimate\n    \"\"\"\n\n    def __init__(self, *solver_args, **solver_kwargs):\n        super().__init__(*solver_args, **solver_kwargs)\n\n        #order of the integration scheme and embedded method (if available)\n        self.n = 0\n        self.m = 0\n\n        #number of stages in RK scheme\n        self.s = 0\n\n        #safety factor for error controller (if available)\n        self.beta = SOL_BETA\n\n        #slope coefficients for stages\n        self.Ks = {}\n\n        #extended butcher tableau\n        self.BT = None\n\n        #coefficients for local truncation error estimate\n        self.TR = None\n\n\n    def error_controller(self, dt):\n        \"\"\"Compute scaling factor for adaptive timestep based on \n        absolute and relative local truncation error estimate, \n        also checks if the error tolerance is achieved and returns \n        a success metric.\n\n        Parameters\n        ----------\n        dt : float \n            integration timestep\n\n        Returns\n        -------\n        success : bool\n            timestep was successful\n        err : float\n            truncation error estimate\n        scale : float\n            timestep rescale from error controller\n        \"\"\"\n\n        #local truncation error slope (this is faster then 'sum' comprehension)\n        slope = 0.0\n        for i, b in enumerate(self.TR):\n            slope = slope + self.Ks[i] * b\n\n        #compute scaling factors (avoid division by zero)\n        scale = self.tolerance_lte_abs + self.tolerance_lte_rel * np.abs(self.x)\n\n        #compute scaled truncation error (element-wise)\n        scaled_error = np.abs(dt * slope) / scale\n\n        #compute the error norm and clip it\n        error_norm = np.clip(float(np.max(scaled_error)), TOLERANCE, None)\n\n        #determine if the error is acceptable\n        success = error_norm <= 1.0\n\n        #compute timestep scale factor using accuracy order of truncation error\n        timestep_rescale = self.beta / error_norm ** (1/(min(self.m, self.n) + 1)) \n\n        #clip the rescale factor to a reasonable range\n        timestep_rescale = np.clip(timestep_rescale, SOL_SCALE_MIN, SOL_SCALE_MAX)\n\n        return success, error_norm, timestep_rescale\n\n\n    def step(self, f, dt):\n        \"\"\"Performs the (explicit) timestep at the intermediate RK stages \n        for (t+dt) based on the state and input at (t)\n\n        Parameters\n        ----------\n        f : numeric, array[numeric]\n            evaluation of function\n        dt : float \n            integration timestep\n\n        Returns\n        -------\n        success : bool\n            timestep was successful\n        err : float\n            truncation error estimate\n        scale : float\n            timestep rescale from error controller        \n        \"\"\"\n\n        #buffer intermediate slope\n        self.Ks[self.stage] = f\n\n        #get current state from history\n        x_0 = self.history[0]\n\n        #compute slope at stage, faster then 'sum' comprehension\n        slope = 0.0\n        for i, b in enumerate(self.BT[self.stage]):\n            slope = slope + self.Ks[i] * b\n        self.x = x_0 + dt * slope\n\n        #no error estimate or not last stage -> early exit\n        if self.TR is None or not self.is_last_stage():\n            return True, 0.0, None\n\n        #compute truncation error estimate\n        return self.error_controller(dt)",
          "bases": [
            "pathsim.solvers._solver.ExplicitSolver"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, *solver_args, **solver_kwargs):\n    super().__init__(*solver_args, **solver_kwargs)\n\n    #order of the integration scheme and embedded method (if available)\n    self.n = 0\n    self.m = 0\n\n    #number of stages in RK scheme\n    self.s = 0\n\n    #safety factor for error controller (if available)\n    self.beta = SOL_BETA\n\n    #slope coefficients for stages\n    self.Ks = {}\n\n    #extended butcher tableau\n    self.BT = None\n\n    #coefficients for local truncation error estimate\n    self.TR = None",
              "signature": "(solver_args = (), solver_kwargs = {})",
              "parameters": [
                {
                  "name": "solver_args",
                  "type": null,
                  "default": "()",
                  "description": ""
                },
                {
                  "name": "solver_kwargs",
                  "type": null,
                  "default": "{}",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "error_controller",
              "description": "Compute scaling factor for adaptive timestep based on",
              "docstring_html": "<p>Compute scaling factor for adaptive timestep based on\nabsolute and relative local truncation error estimate,\nalso checks if the error tolerance is achieved and returns\na success metric.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>integration timestep</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>success <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>timestep was successful</dd>\n<dt>err <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>truncation error estimate</dd>\n<dt>scale <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>timestep rescale from error controller</dd>\n</dl>\n",
              "source": "def error_controller(self, dt):\n    \"\"\"Compute scaling factor for adaptive timestep based on \n    absolute and relative local truncation error estimate, \n    also checks if the error tolerance is achieved and returns \n    a success metric.\n\n    Parameters\n    ----------\n    dt : float \n        integration timestep\n\n    Returns\n    -------\n    success : bool\n        timestep was successful\n    err : float\n        truncation error estimate\n    scale : float\n        timestep rescale from error controller\n    \"\"\"\n\n    #local truncation error slope (this is faster then 'sum' comprehension)\n    slope = 0.0\n    for i, b in enumerate(self.TR):\n        slope = slope + self.Ks[i] * b\n\n    #compute scaling factors (avoid division by zero)\n    scale = self.tolerance_lte_abs + self.tolerance_lte_rel * np.abs(self.x)\n\n    #compute scaled truncation error (element-wise)\n    scaled_error = np.abs(dt * slope) / scale\n\n    #compute the error norm and clip it\n    error_norm = np.clip(float(np.max(scaled_error)), TOLERANCE, None)\n\n    #determine if the error is acceptable\n    success = error_norm <= 1.0\n\n    #compute timestep scale factor using accuracy order of truncation error\n    timestep_rescale = self.beta / error_norm ** (1/(min(self.m, self.n) + 1)) \n\n    #clip the rescale factor to a reasonable range\n    timestep_rescale = np.clip(timestep_rescale, SOL_SCALE_MIN, SOL_SCALE_MAX)\n\n    return success, error_norm, timestep_rescale",
              "signature": "(dt)",
              "parameters": [
                {
                  "name": "dt",
                  "type": null,
                  "default": null,
                  "description": "integration timestep"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "step",
              "description": "Performs the (explicit) timestep at the intermediate RK stages",
              "docstring_html": "<p>Performs the (explicit) timestep at the intermediate RK stages\nfor (t+dt) based on the state and input at (t)</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>f <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">numeric, array[numeric]</span></dt>\n<dd>evaluation of function</dd>\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>integration timestep</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>success <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>timestep was successful</dd>\n<dt>err <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>truncation error estimate</dd>\n<dt>scale <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>timestep rescale from error controller</dd>\n</dl>\n",
              "source": "def step(self, f, dt):\n    \"\"\"Performs the (explicit) timestep at the intermediate RK stages \n    for (t+dt) based on the state and input at (t)\n\n    Parameters\n    ----------\n    f : numeric, array[numeric]\n        evaluation of function\n    dt : float \n        integration timestep\n\n    Returns\n    -------\n    success : bool\n        timestep was successful\n    err : float\n        truncation error estimate\n    scale : float\n        timestep rescale from error controller        \n    \"\"\"\n\n    #buffer intermediate slope\n    self.Ks[self.stage] = f\n\n    #get current state from history\n    x_0 = self.history[0]\n\n    #compute slope at stage, faster then 'sum' comprehension\n    slope = 0.0\n    for i, b in enumerate(self.BT[self.stage]):\n        slope = slope + self.Ks[i] * b\n    self.x = x_0 + dt * slope\n\n    #no error estimate or not last stage -> early exit\n    if self.TR is None or not self.is_last_stage():\n        return True, 0.0, None\n\n    #compute truncation error estimate\n    return self.error_controller(dt)",
              "signature": "(f, dt)",
              "parameters": [
                {
                  "name": "f",
                  "type": null,
                  "default": null,
                  "description": "evaluation of function"
                },
                {
                  "name": "dt",
                  "type": null,
                  "default": null,
                  "description": "integration timestep"
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "n",
              "description": "",
              "type": null,
              "value": "0"
            },
            {
              "name": "m",
              "description": "",
              "type": null,
              "value": "0"
            },
            {
              "name": "s",
              "description": "",
              "type": null,
              "value": "0"
            },
            {
              "name": "beta",
              "description": "",
              "type": null,
              "value": "SOL_BETA"
            },
            {
              "name": "Ks",
              "description": "",
              "type": null,
              "value": "{}"
            },
            {
              "name": "BT",
              "description": "",
              "type": null,
              "value": "None"
            },
            {
              "name": "TR",
              "description": "",
              "type": null,
              "value": "None"
            }
          ],
          "parameters": [
            {
              "name": "solver_args",
              "type": null,
              "default": "()",
              "description": ""
            },
            {
              "name": "solver_kwargs",
              "type": null,
              "default": "{}",
              "description": ""
            }
          ]
        },
        {
          "name": "DiagonallyImplicitRungeKutta",
          "description": "Base class for diagonally implicit Runge-Kutta (DIRK) integrators",
          "docstring_html": "<p>Base class for diagonally implicit Runge-Kutta (DIRK) integrators\nwhich implements the timestepping at intermediate stages, involving\nthe numerical solution of the implicit update equation and the\nerror control if the coefficients for the local truncation error\nestimate are defined.</p>\n<p>Extensions and checks to also handle explicit first stages (ESDIRK)\nand additional final evaluation coefficients (not stiffly accurate)</p>\n<div class=\"section\" id=\"note\">\n<h4>Note</h4>\n<p>This class is not intended to be used directly!!!</p>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>n <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>order of stepping integration scheme</dd>\n<dt>m <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>order of embedded integration scheme for error control</dd>\n<dt>s <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>numer of RK stages</dd>\n<dt>beta <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>safety factor for error control</dd>\n<dt>Ks <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">dict</span></dt>\n<dd>slopes at RK stages</dd>\n<dt>BT <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">dict[int: None, list[float]], None</span></dt>\n<dd>butcher table</dd>\n<dt>A <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">list[float], None</span></dt>\n<dd>coefficients for final solution evaluation</dd>\n<dt>TR <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">list[float]</span></dt>\n<dd>coefficients for truncation error estimate</dd>\n</dl>\n</div>\n",
          "source": "class DiagonallyImplicitRungeKutta(ImplicitSolver):\n    \"\"\"Base class for diagonally implicit Runge-Kutta (DIRK) integrators \n    which implements the timestepping at intermediate stages, involving\n    the numerical solution of the implicit update equation and the \n    error control if the coefficients for the local truncation error \n    estimate are defined.\n\n    Extensions and checks to also handle explicit first stages (ESDIRK) \n    and additional final evaluation coefficients (not stiffly accurate)\n\n    Note\n    ----\n    This class is not intended to be used directly!!!\n\n    Attributes\n    ----------\n    n : int \n        order of stepping integration scheme\n    m : int\n        order of embedded integration scheme for error control\n    s : int\n        numer of RK stages\n    beta : float\n        safety factor for error control\n    Ks : dict\n        slopes at RK stages\n    BT : dict[int: None, list[float]], None\n        butcher table\n    A : list[float], None\n        coefficients for final solution evaluation\n    TR : list[float]\n        coefficients for truncation error estimate\n\n    \"\"\"\n\n    def __init__(self, *solver_args, **solver_kwargs):\n        super().__init__(*solver_args, **solver_kwargs)\n\n        #order of the integration scheme and embedded method (if available)\n        self.n = 0\n        self.m = 0\n\n        #number of stages in RK scheme\n        self.s = 0\n\n        #safety factor for error controller (if available)\n        self.beta = SOL_BETA\n\n        #slope coefficients for stages\n        self.Ks = {}\n\n        #extended butcher tableau\n        self.BT = None\n\n        #final evaluation (if not stiffly accurate)\n        self.A = None\n\n        #coefficients for local truncation error estimate\n        self.TR = None\n\n\n    def error_controller(self, dt):\n        \"\"\"Compute scaling factor for adaptive timestep based on \n        absolute and relative local truncation error estimate, \n        also checks if the error tolerance is achieved and returns \n        a success metric.\n\n        Parameters\n        ----------\n        dt : float \n            integration timestep\n\n        Returns\n        -------\n        success : bool\n            timestep was successful\n        err : float\n            truncation error estimate\n        scale : float\n            timestep rescale from error controller\n        \"\"\"\n\n        #local truncation error slope (this is faster then 'sum' comprehension)\n        slope = 0.0\n        for i, b in enumerate(self.TR):\n            slope = slope + self.Ks[i] * b\n\n        #compute scaling factors (avoid division by zero)\n        scale = self.tolerance_lte_abs + self.tolerance_lte_rel * np.abs(self.x)\n\n        #compute scaled truncation error (element-wise)\n        scaled_error = np.abs(dt * slope) / scale\n\n        #compute the error norm and clip it#compute the error norm and clip it\n        error_norm = np.clip(float(np.max(scaled_error)), TOLERANCE, None)\n\n        #determine if the error is acceptable\n        success = error_norm <= 1.0\n\n        #compute timestep scale factor using accuracy order of truncation error\n        timestep_rescale = self.beta / error_norm ** (1/(min(self.m, self.n) + 1)) \n\n        #clip the rescale factor to a reasonable range\n        timestep_rescale = np.clip(timestep_rescale, SOL_SCALE_MIN, SOL_SCALE_MAX)\n\n        return success, error_norm, timestep_rescale\n\n\n    def solve(self, f, J, dt):\n        \"\"\"Solves the implicit update equation using the optimizer of the engine.\n\n        Parameters\n        ----------\n        f : array_like\n            evaluation of function\n        J : array_like\n            evaluation of jacobian of function\n        dt : float \n            integration timestep\n\n        Returns\n        -------\n        err : float\n            residual error of the fixed point update equation\n        \"\"\"\n\n        #first stage is explicit -> ESDIRK -> early exit\n        if self.is_first_stage() and self.BT[0] is None:\n            return 0.0\n\n        #update timestep weighted slope \n        self.Ks[self.stage] = f\n\n        #get past state from history\n        x_0 = self.history[0]\n\n        #compute slope (this is faster then 'sum' comprehension)\n        slope = 0.0\n        for i, a in enumerate(self.BT[self.stage]):\n            slope = slope + self.Ks[i] * a\n\n        #use the jacobian\n        if J is not None:\n\n            #most recent butcher coefficient\n            b = self.BT[self.stage][self.stage]\n\n            #optimizer step with block local jacobian\n            self.x, err = self.opt.step(self.x, x_0 + dt * slope, dt * b * J)\n\n        else:\n            #optimizer step (pure)\n            self.x, err = self.opt.step(self.x, x_0 + dt * slope, None)\n\n        #return the fixed-point residual\n        return err\n\n\n    def step(self, f, dt):\n        \"\"\"performs the (explicit) timestep at the intermediate RK stages \n        for (t+dt) based on the state and input at (t)\n\n        Parameters\n        ----------\n        f : array_like\n            evaluation of function\n        dt : float \n            integration timestep\n\n        Returns\n        -------\n        success : bool\n            timestep was successful\n        err : float\n            truncation error estimate\n        scale : float\n            timestep rescale from error controller\n        \"\"\"\n\n        #first stage is explicit -> ESDIRK\n        if self.is_first_stage() and self.BT[0] is None:\n            self.Ks[self.stage] = f\n\n        #last stage, stiffly accurate and error control\n        if self.is_last_stage():\n\n            #compute final output if not stiffly accurate\n            if self.A is not None:\n\n                #get past state from history\n                x_0 = self.history[0]\n\n                #compute slope (this is faster then 'sum' comprehension)\n                slope = 0.0\n                for i, a in enumerate(self.A):\n                    slope = slope + self.Ks[i] * a\n                self.x = x_0 + dt * slope    \n\n            #no error estimate -> early exit\n            if self.TR is None:\n                return True, 0.0, None\n\n            #compute truncation error estimate\n            return self.error_controller(dt)\n\n        #no error estimate otherwise\n        return True, 0.0, None",
          "bases": [
            "pathsim.solvers._solver.ImplicitSolver"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, *solver_args, **solver_kwargs):\n    super().__init__(*solver_args, **solver_kwargs)\n\n    #order of the integration scheme and embedded method (if available)\n    self.n = 0\n    self.m = 0\n\n    #number of stages in RK scheme\n    self.s = 0\n\n    #safety factor for error controller (if available)\n    self.beta = SOL_BETA\n\n    #slope coefficients for stages\n    self.Ks = {}\n\n    #extended butcher tableau\n    self.BT = None\n\n    #final evaluation (if not stiffly accurate)\n    self.A = None\n\n    #coefficients for local truncation error estimate\n    self.TR = None",
              "signature": "(solver_args = (), solver_kwargs = {})",
              "parameters": [
                {
                  "name": "solver_args",
                  "type": null,
                  "default": "()",
                  "description": ""
                },
                {
                  "name": "solver_kwargs",
                  "type": null,
                  "default": "{}",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "error_controller",
              "description": "Compute scaling factor for adaptive timestep based on",
              "docstring_html": "<p>Compute scaling factor for adaptive timestep based on\nabsolute and relative local truncation error estimate,\nalso checks if the error tolerance is achieved and returns\na success metric.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>integration timestep</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>success <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>timestep was successful</dd>\n<dt>err <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>truncation error estimate</dd>\n<dt>scale <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>timestep rescale from error controller</dd>\n</dl>\n",
              "source": "def error_controller(self, dt):\n    \"\"\"Compute scaling factor for adaptive timestep based on \n    absolute and relative local truncation error estimate, \n    also checks if the error tolerance is achieved and returns \n    a success metric.\n\n    Parameters\n    ----------\n    dt : float \n        integration timestep\n\n    Returns\n    -------\n    success : bool\n        timestep was successful\n    err : float\n        truncation error estimate\n    scale : float\n        timestep rescale from error controller\n    \"\"\"\n\n    #local truncation error slope (this is faster then 'sum' comprehension)\n    slope = 0.0\n    for i, b in enumerate(self.TR):\n        slope = slope + self.Ks[i] * b\n\n    #compute scaling factors (avoid division by zero)\n    scale = self.tolerance_lte_abs + self.tolerance_lte_rel * np.abs(self.x)\n\n    #compute scaled truncation error (element-wise)\n    scaled_error = np.abs(dt * slope) / scale\n\n    #compute the error norm and clip it#compute the error norm and clip it\n    error_norm = np.clip(float(np.max(scaled_error)), TOLERANCE, None)\n\n    #determine if the error is acceptable\n    success = error_norm <= 1.0\n\n    #compute timestep scale factor using accuracy order of truncation error\n    timestep_rescale = self.beta / error_norm ** (1/(min(self.m, self.n) + 1)) \n\n    #clip the rescale factor to a reasonable range\n    timestep_rescale = np.clip(timestep_rescale, SOL_SCALE_MIN, SOL_SCALE_MAX)\n\n    return success, error_norm, timestep_rescale",
              "signature": "(dt)",
              "parameters": [
                {
                  "name": "dt",
                  "type": null,
                  "default": null,
                  "description": "integration timestep"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "solve",
              "description": "Solves the implicit update equation using the optimizer of the engine.",
              "docstring_html": "<p>Solves the implicit update equation using the optimizer of the engine.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>f <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array_like</span></dt>\n<dd>evaluation of function</dd>\n<dt>J <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array_like</span></dt>\n<dd>evaluation of jacobian of function</dd>\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>integration timestep</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>err <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>residual error of the fixed point update equation</dd>\n</dl>\n",
              "source": "def solve(self, f, J, dt):\n    \"\"\"Solves the implicit update equation using the optimizer of the engine.\n\n    Parameters\n    ----------\n    f : array_like\n        evaluation of function\n    J : array_like\n        evaluation of jacobian of function\n    dt : float \n        integration timestep\n\n    Returns\n    -------\n    err : float\n        residual error of the fixed point update equation\n    \"\"\"\n\n    #first stage is explicit -> ESDIRK -> early exit\n    if self.is_first_stage() and self.BT[0] is None:\n        return 0.0\n\n    #update timestep weighted slope \n    self.Ks[self.stage] = f\n\n    #get past state from history\n    x_0 = self.history[0]\n\n    #compute slope (this is faster then 'sum' comprehension)\n    slope = 0.0\n    for i, a in enumerate(self.BT[self.stage]):\n        slope = slope + self.Ks[i] * a\n\n    #use the jacobian\n    if J is not None:\n\n        #most recent butcher coefficient\n        b = self.BT[self.stage][self.stage]\n\n        #optimizer step with block local jacobian\n        self.x, err = self.opt.step(self.x, x_0 + dt * slope, dt * b * J)\n\n    else:\n        #optimizer step (pure)\n        self.x, err = self.opt.step(self.x, x_0 + dt * slope, None)\n\n    #return the fixed-point residual\n    return err",
              "signature": "(f, J, dt)",
              "parameters": [
                {
                  "name": "f",
                  "type": null,
                  "default": null,
                  "description": "evaluation of function"
                },
                {
                  "name": "J",
                  "type": null,
                  "default": null,
                  "description": "evaluation of jacobian of function"
                },
                {
                  "name": "dt",
                  "type": null,
                  "default": null,
                  "description": "integration timestep"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "step",
              "description": "performs the (explicit) timestep at the intermediate RK stages",
              "docstring_html": "<p>performs the (explicit) timestep at the intermediate RK stages\nfor (t+dt) based on the state and input at (t)</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>f <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array_like</span></dt>\n<dd>evaluation of function</dd>\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>integration timestep</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>success <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>timestep was successful</dd>\n<dt>err <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>truncation error estimate</dd>\n<dt>scale <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>timestep rescale from error controller</dd>\n</dl>\n",
              "source": "def step(self, f, dt):\n    \"\"\"performs the (explicit) timestep at the intermediate RK stages \n    for (t+dt) based on the state and input at (t)\n\n    Parameters\n    ----------\n    f : array_like\n        evaluation of function\n    dt : float \n        integration timestep\n\n    Returns\n    -------\n    success : bool\n        timestep was successful\n    err : float\n        truncation error estimate\n    scale : float\n        timestep rescale from error controller\n    \"\"\"\n\n    #first stage is explicit -> ESDIRK\n    if self.is_first_stage() and self.BT[0] is None:\n        self.Ks[self.stage] = f\n\n    #last stage, stiffly accurate and error control\n    if self.is_last_stage():\n\n        #compute final output if not stiffly accurate\n        if self.A is not None:\n\n            #get past state from history\n            x_0 = self.history[0]\n\n            #compute slope (this is faster then 'sum' comprehension)\n            slope = 0.0\n            for i, a in enumerate(self.A):\n                slope = slope + self.Ks[i] * a\n            self.x = x_0 + dt * slope    \n\n        #no error estimate -> early exit\n        if self.TR is None:\n            return True, 0.0, None\n\n        #compute truncation error estimate\n        return self.error_controller(dt)\n\n    #no error estimate otherwise\n    return True, 0.0, None",
              "signature": "(f, dt)",
              "parameters": [
                {
                  "name": "f",
                  "type": null,
                  "default": null,
                  "description": "evaluation of function"
                },
                {
                  "name": "dt",
                  "type": null,
                  "default": null,
                  "description": "integration timestep"
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "n",
              "description": "",
              "type": null,
              "value": "0"
            },
            {
              "name": "m",
              "description": "",
              "type": null,
              "value": "0"
            },
            {
              "name": "s",
              "description": "",
              "type": null,
              "value": "0"
            },
            {
              "name": "beta",
              "description": "",
              "type": null,
              "value": "SOL_BETA"
            },
            {
              "name": "Ks",
              "description": "",
              "type": null,
              "value": "{}"
            },
            {
              "name": "BT",
              "description": "",
              "type": null,
              "value": "None"
            },
            {
              "name": "A",
              "description": "",
              "type": null,
              "value": "None"
            },
            {
              "name": "TR",
              "description": "",
              "type": null,
              "value": "None"
            }
          ],
          "parameters": [
            {
              "name": "solver_args",
              "type": null,
              "default": "()",
              "description": ""
            },
            {
              "name": "solver_kwargs",
              "type": null,
              "default": "{}",
              "description": ""
            }
          ]
        }
      ],
      "functions": []
    },
    "pathsim.solvers._solver": {
      "name": "pathsim.solvers._solver",
      "description": "",
      "docstring_html": "",
      "classes": [
        {
          "name": "Solver",
          "description": "Base skeleton class for solver definition. Defines the basic solver methods and",
          "docstring_html": "<p>Base skeleton class for solver definition. Defines the basic solver methods and\nthe metadata.</p>\n<p>Specific solvers need to implement (some of) the base class methods defined here.\nThis depends on the type of solver (implicit/explicit, multistage, adaptive).</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>initial_value <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float, array</span></dt>\n<dd>initial condition / integration constant</dd>\n<dt>tolerance_lte_abs <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>absolute tolerance for local truncation error (for solvers with error estimate)</dd>\n<dt>tolerance_lte_rel <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>relative tolerance for local truncation error (for solvers with error estimate)</dd>\n<dt>parent <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">None | Solver</span></dt>\n<dd>parent solver instance that manages the intermediate stages, stage counter, etc.</dd>\n</dl>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>x <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">numeric, array[numeric]</span></dt>\n<dd>internal 'working' state</dd>\n<dt>history <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">deque[numeric]</span></dt>\n<dd>internal history of past results</dd>\n<dt>n <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>order of integration scheme</dd>\n<dt>s <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>number of internal intermediate stages</dd>\n<dt>_stage <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>counter for current intermediate stage</dd>\n<dt>eval_stages <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">list[float]</span></dt>\n<dd>rations for evaluation times of intermediate stages</dd>\n</dl>\n",
          "source": "class Solver:\n    \"\"\"Base skeleton class for solver definition. Defines the basic solver methods and \n    the metadata.\n\n    Specific solvers need to implement (some of) the base class methods defined here. \n    This depends on the type of solver (implicit/explicit, multistage, adaptive).\n\n    Parameters\n    ----------\n    initial_value : float, array\n        initial condition / integration constant\n    tolerance_lte_abs : float\n        absolute tolerance for local truncation error (for solvers with error estimate)\n    tolerance_lte_rel : float\n        relative tolerance for local truncation error (for solvers with error estimate)\n    parent : None | Solver\n        parent solver instance that manages the intermediate stages, stage counter, etc.\n\n    Attributes\n    ----------\n    x : numeric, array[numeric]\n        internal 'working' state\n    history : deque[numeric]\n        internal history of past results\n    n : int\n        order of integration scheme\n    s : int\n        number of internal intermediate stages\n    _stage : int\n        counter for current intermediate stage\n    eval_stages : list[float]\n        rations for evaluation times of intermediate stages\n    \"\"\"\n\n    def __init__(\n        self, \n        initial_value=0,\n        parent=None, \n        tolerance_lte_abs=SOL_TOLERANCE_LTE_ABS, \n        tolerance_lte_rel=SOL_TOLERANCE_LTE_REL\n        ):\n\n        #set state and initial condition (ensure array format for consistency)\n        self.initial_value = initial_value\n        self.x = np.atleast_1d(initial_value).copy()\n\n        #track if initial value was scalar for output formatting\n        self._scalar_initial = np.isscalar(initial_value)\n\n        #tolerances for local truncation error (for adaptive solvers)\n        self.tolerance_lte_abs = tolerance_lte_abs\n        self.tolerance_lte_rel = tolerance_lte_rel  \n\n        #parent solver instance\n        self.parent = parent\n\n        #flag to identify adaptive/fixed timestep solvers\n        self.is_adaptive = False\n\n        #history of past solutions, default only one\n        self.history = deque([], maxlen=1)\n\n        #order of the integration scheme\n        self.n = 1\n\n        #number of stages\n        self.s = 1\n\n        #current evaluation stage for multistage solvers\n        self._stage = 0\n\n        #intermediate evaluation times as ratios between [t, t+dt]\n        self.eval_stages = [0.0]\n\n\n    def __str__(self):\n        return self.__class__.__name__\n\n\n    def __len__(self):\n        \"\"\"size of the internal state, i.e. the order\n\n        Returns\n        -------\n        size : int\n            size of the current internal state\n        \"\"\"\n        return len(np.atleast_1d(self.x))\n\n\n    def __bool__(self):\n        return True\n\n\n    @property\n    def stage(self):\n        \"\"\"stage property management to interface with parent solver\n\n        Returns\n        -------\n        stage : int\n            current intermediate evaluation stage of solver\n        \"\"\"\n        if self.parent is None:\n            return self._stage\n        return self.parent.stage\n\n\n    @stage.setter\n    def stage(self, val):\n        \"\"\"stage property management to interface with parent solver,\n        setter method for property\n\n        Parameters\n        ----------\n        val : int\n            set intermediate evaluation stage of solver\n        \"\"\"\n        self._stage = val\n\n\n    def is_first_stage(self):\n        return self.stage == 0\n\n\n    def is_last_stage(self):\n        return self.stage == self.s - 1\n\n\n    def stages(self, t, dt):\n        \"\"\"Generator that yields the intermediate evaluation \n        time during the timestep 't + ratio * dt' and also updates \n        the current stage number for internal use.\n\n        Parameters\n        ----------\n        t : float \n            evaluation time\n        dt : float\n            integration timestep\n        \"\"\"\n        for self.stage, ratio in enumerate(self.eval_stages):\n            yield t + ratio * dt\n\n\n    def get(self):\n        \"\"\"Returns current internal state of the solver.\n\n        Returns\n        -------\n        x : numeric, array[numeric]\n            current internal state of the solver\n        \"\"\"\n        return self.x\n\n\n    def set(self, x):\n        \"\"\"Sets the internal state of the integration engine.\n\n        This method is required for event based simulations,\n        and to handle discontinuities in state variables.\n\n        Parameters\n        ----------\n        x : numeric, array[numeric]\n            new internal state of the solver\n\n        \"\"\"\n        #overwrite internal state with value\n        self.x = x\n\n\n    @property\n    def state(self):\n        \"\"\"Property for cleaner access to internal state.\n\n        Returns\n        -------\n        x : numeric, array[numeric]\n            current internal state of the solver\n        \"\"\"\n        return self.x\n\n\n    @state.setter\n    def state(self, value):\n        \"\"\"Property setter for internal state.\n\n        Parameters\n        ----------\n        value : numeric, array[numeric]\n            new internal state of the solver\n        \"\"\"\n        self.x = np.atleast_1d(value)\n\n\n    def reset(self):\n        \"\"\"\"Resets integration engine to initial value\"\"\"\n\n        #overwrite state with initial value (ensure array format)\n        self.x = np.atleast_1d(self.initial_value).copy()\n        self.history.clear()\n\n\n    def buffer(self, dt):\n        \"\"\"Saves the current state to an internal state buffer which \n        is especially relevant for multistage and implicit solvers.\n\n        Multistep solver implement rolling buffers for the states \n        and timesteps.\n\n        Resets the stage counter.\n\n        Parameters\n        ----------\n        dt : float\n            integration timestep\n\n        \"\"\"\n\n        #buffer internal state to history\n        self.history.appendleft(self.x)\n\n\n    @classmethod\n    def cast(cls, other, parent, **solver_kwargs):\n        \"\"\"Cast the integration engine to the new type and initialize \n        with previous solver arguments so it can continue from where \n        the 'old' solver stopped.\n\n        Parameters\n        ----------\n        other : Solver\n            solver instance to cast to new solver type\n        parent : None | Solver\n            solver instance to use as parent\n        solver_kwargs : dict\n            additional args for the new solver\n\n        Returns\n        -------\n        engine : Solver\n            new solver instance cast from `other`      \n        \"\"\"\n\n        if not isinstance(other, Solver):\n            raise ValueError(\"'other' must be instance of 'Solver' or child\")\n\n        #assemble additional solver kwargs (default)\n        _solver_kwargs = {\n            \"tolerance_lte_rel\": other.tolerance_lte_rel,\n            \"tolerance_lte_abs\": other.tolerance_lte_abs\n        }\n\n        #update from casting\n        _solver_kwargs.update(solver_kwargs)\n\n        #create new solver instance\n        engine = cls(\n            initial_value=other.initial_value, \n            parent=parent,\n            **_solver_kwargs\n            )\n\n        #set internal state of new engine from other\n        engine.set(other.get())\n\n        return engine\n\n\n    @classmethod\n    def create(cls, initial_value, parent=None, from_engine=None, **solver_kwargs):\n        \"\"\"Create a new solver instance, optionally inheriting state from existing engine.\n\n        This provides a unified interface for solver creation that handles both\n        new instantiation and solver switching (previously done via cast).\n\n        Parameters\n        ----------\n        initial_value : float, array\n            initial condition / integration constant\n        parent : None | Solver\n            parent solver instance for stage synchronization\n        from_engine : None | Solver\n            existing solver to inherit state and settings from\n        solver_kwargs : dict\n            additional args for the solver (tolerances, etc.)\n\n        Returns\n        -------\n        engine : Solver\n            new solver instance\n        \"\"\"\n        if from_engine is not None:\n            #inherit tolerances from existing engine if not specified\n            if \"tolerance_lte_rel\" not in solver_kwargs:\n                solver_kwargs[\"tolerance_lte_rel\"] = from_engine.tolerance_lte_rel\n            if \"tolerance_lte_abs\" not in solver_kwargs:\n                solver_kwargs[\"tolerance_lte_abs\"] = from_engine.tolerance_lte_abs\n\n            #create new solver\n            engine = cls(initial_value, parent, **solver_kwargs)\n\n            #preserve state from old engine\n            engine.state = from_engine.state\n\n            return engine\n\n        #simple creation without existing engine\n        return cls(initial_value, parent, **solver_kwargs)\n\n\n    # methods for adaptive timestep solvers --------------------------------------------\n\n    def error_controller(self):\n        \"\"\"Returns the estimated local truncation error (abs and rel) and scaling factor\n        for the timestep, only relevant for adaptive timestepping methods.\n\n        Returns\n        -------\n        success : bool\n            True if the timestep was successful\n        error : float\n            estimated error of the internal error controller\n        scale : float | None\n            estimated timestep rescale factor for error control, None if no rescale needed\n        \"\"\"\n        return True, 0.0, None\n\n\n    def revert(self):\n        \"\"\"Revert integration engine to previous timestep. \n\n        This is only relevant for adaptive methods where the simulation \n        timestep 'dt' is rescaled and the engine step is recomputed with \n        the smaller timestep.\n        \"\"\"\n\n        #reset internal state to previous state from history\n        self.x = self.history.popleft() \n\n\n    # methods for timestepping ---------------------------------------------------------\n\n    def step(self, f, dt):\n        \"\"\"Performs the explicit timestep for (t+dt) based\n        on the state and input at (t).\n\n        Returns the local truncation error estimate and the\n        rescale factor for the timestep if the solver is adaptive.\n\n        Parameters\n        ----------\n        f : numeric, array[numeric]\n            evaluation of rhs function\n        dt : float\n            integration timestep\n\n        Returns\n        -------\n        success : bool\n            True if the timestep was successful\n        error : float\n            estimated error of the internal error controller\n        scale : float | None\n            estimated timestep rescale factor for error control, None if no rescale needed\n        \"\"\"\n        return True, 0.0, None\n\n\n    # methods for interpolation --------------------------------------------------------\n\n    def interpolate(self, r, dt):\n        \"\"\"Interpolate solution after successful timestep as a ratio \n        in the interval [t, t+dt].\n\n        This is especially relevant for Runge-Kutta solvers that \n        have a higher order interpolant. Otherwise this is just \n        linear interpolation using the buffered state.\n\n        Parameters\n        ----------\n        r : float\n            ration for interpolation within timestep\n        dt : float\n            integration timestep\n\n        Returns\n        -------\n        x : numeric, array[numeric]\n            interpolated state\n        \"\"\"\n        _r = np.clip(r, 0.0, 1.0)\n        return _r * self.x + (1.0 - _r) * self.x_0",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(\n    self, \n    initial_value=0,\n    parent=None, \n    tolerance_lte_abs=SOL_TOLERANCE_LTE_ABS, \n    tolerance_lte_rel=SOL_TOLERANCE_LTE_REL\n    ):\n\n    #set state and initial condition (ensure array format for consistency)\n    self.initial_value = initial_value\n    self.x = np.atleast_1d(initial_value).copy()\n\n    #track if initial value was scalar for output formatting\n    self._scalar_initial = np.isscalar(initial_value)\n\n    #tolerances for local truncation error (for adaptive solvers)\n    self.tolerance_lte_abs = tolerance_lte_abs\n    self.tolerance_lte_rel = tolerance_lte_rel  \n\n    #parent solver instance\n    self.parent = parent\n\n    #flag to identify adaptive/fixed timestep solvers\n    self.is_adaptive = False\n\n    #history of past solutions, default only one\n    self.history = deque([], maxlen=1)\n\n    #order of the integration scheme\n    self.n = 1\n\n    #number of stages\n    self.s = 1\n\n    #current evaluation stage for multistage solvers\n    self._stage = 0\n\n    #intermediate evaluation times as ratios between [t, t+dt]\n    self.eval_stages = [0.0]",
              "signature": "(initial_value = 0, parent = None, tolerance_lte_abs = SOL_TOLERANCE_LTE_ABS, tolerance_lte_rel = SOL_TOLERANCE_LTE_REL)",
              "parameters": [
                {
                  "name": "initial_value",
                  "type": null,
                  "default": "0",
                  "description": ""
                },
                {
                  "name": "parent",
                  "type": null,
                  "default": "None",
                  "description": ""
                },
                {
                  "name": "tolerance_lte_abs",
                  "type": null,
                  "default": "SOL_TOLERANCE_LTE_ABS",
                  "description": ""
                },
                {
                  "name": "tolerance_lte_rel",
                  "type": null,
                  "default": "SOL_TOLERANCE_LTE_REL",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "is_first_stage",
              "description": "",
              "docstring_html": "",
              "source": "def is_first_stage(self):\n    return self.stage == 0",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "is_last_stage",
              "description": "",
              "docstring_html": "",
              "source": "def is_last_stage(self):\n    return self.stage == self.s - 1",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "stages",
              "description": "Generator that yields the intermediate evaluation",
              "docstring_html": "<p>Generator that yields the intermediate evaluation\ntime during the timestep 't + ratio * dt' and also updates\nthe current stage number for internal use.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time</dd>\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>integration timestep</dd>\n</dl>\n",
              "source": "def stages(self, t, dt):\n    \"\"\"Generator that yields the intermediate evaluation \n    time during the timestep 't + ratio * dt' and also updates \n    the current stage number for internal use.\n\n    Parameters\n    ----------\n    t : float \n        evaluation time\n    dt : float\n        integration timestep\n    \"\"\"\n    for self.stage, ratio in enumerate(self.eval_stages):\n        yield t + ratio * dt",
              "signature": "(t, dt)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time"
                },
                {
                  "name": "dt",
                  "type": null,
                  "default": null,
                  "description": "integration timestep"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "get",
              "description": "Returns current internal state of the solver.",
              "docstring_html": "<p>Returns current internal state of the solver.</p>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>x <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">numeric, array[numeric]</span></dt>\n<dd>current internal state of the solver</dd>\n</dl>\n",
              "source": "def get(self):\n    \"\"\"Returns current internal state of the solver.\n\n    Returns\n    -------\n    x : numeric, array[numeric]\n        current internal state of the solver\n    \"\"\"\n    return self.x",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "set",
              "description": "Sets the internal state of the integration engine.",
              "docstring_html": "<p>Sets the internal state of the integration engine.</p>\n<p>This method is required for event based simulations,\nand to handle discontinuities in state variables.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>x <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">numeric, array[numeric]</span></dt>\n<dd>new internal state of the solver</dd>\n</dl>\n",
              "source": "def set(self, x):\n    \"\"\"Sets the internal state of the integration engine.\n\n    This method is required for event based simulations,\n    and to handle discontinuities in state variables.\n\n    Parameters\n    ----------\n    x : numeric, array[numeric]\n        new internal state of the solver\n\n    \"\"\"\n    #overwrite internal state with value\n    self.x = x",
              "signature": "(x)",
              "parameters": [
                {
                  "name": "x",
                  "type": null,
                  "default": null,
                  "description": "new internal state of the solver"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "reset",
              "description": "\"Resets integration engine to initial value",
              "docstring_html": "<p>&quot;Resets integration engine to initial value</p>\n",
              "source": "def reset(self):\n    \"\"\"\"Resets integration engine to initial value\"\"\"\n\n    #overwrite state with initial value (ensure array format)\n    self.x = np.atleast_1d(self.initial_value).copy()\n    self.history.clear()",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "buffer",
              "description": "Saves the current state to an internal state buffer which",
              "docstring_html": "<p>Saves the current state to an internal state buffer which\nis especially relevant for multistage and implicit solvers.</p>\n<p>Multistep solver implement rolling buffers for the states\nand timesteps.</p>\n<p>Resets the stage counter.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>integration timestep</dd>\n</dl>\n",
              "source": "def buffer(self, dt):\n    \"\"\"Saves the current state to an internal state buffer which \n    is especially relevant for multistage and implicit solvers.\n\n    Multistep solver implement rolling buffers for the states \n    and timesteps.\n\n    Resets the stage counter.\n\n    Parameters\n    ----------\n    dt : float\n        integration timestep\n\n    \"\"\"\n\n    #buffer internal state to history\n    self.history.appendleft(self.x)",
              "signature": "(dt)",
              "parameters": [
                {
                  "name": "dt",
                  "type": null,
                  "default": null,
                  "description": "integration timestep"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "cast",
              "description": "Cast the integration engine to the new type and initialize",
              "docstring_html": "<p>Cast the integration engine to the new type and initialize\nwith previous solver arguments so it can continue from where\nthe 'old' solver stopped.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>other <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">Solver</span></dt>\n<dd>solver instance to cast to new solver type</dd>\n<dt>parent <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">None | Solver</span></dt>\n<dd>solver instance to use as parent</dd>\n<dt>solver_kwargs <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">dict</span></dt>\n<dd>additional args for the new solver</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>engine <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">Solver</span></dt>\n<dd>new solver instance cast from <cite>other</cite></dd>\n</dl>\n",
              "source": "@classmethod\ndef cast(cls, other, parent, **solver_kwargs):\n    \"\"\"Cast the integration engine to the new type and initialize \n    with previous solver arguments so it can continue from where \n    the 'old' solver stopped.\n\n    Parameters\n    ----------\n    other : Solver\n        solver instance to cast to new solver type\n    parent : None | Solver\n        solver instance to use as parent\n    solver_kwargs : dict\n        additional args for the new solver\n\n    Returns\n    -------\n    engine : Solver\n        new solver instance cast from `other`      \n    \"\"\"\n\n    if not isinstance(other, Solver):\n        raise ValueError(\"'other' must be instance of 'Solver' or child\")\n\n    #assemble additional solver kwargs (default)\n    _solver_kwargs = {\n        \"tolerance_lte_rel\": other.tolerance_lte_rel,\n        \"tolerance_lte_abs\": other.tolerance_lte_abs\n    }\n\n    #update from casting\n    _solver_kwargs.update(solver_kwargs)\n\n    #create new solver instance\n    engine = cls(\n        initial_value=other.initial_value, \n        parent=parent,\n        **_solver_kwargs\n        )\n\n    #set internal state of new engine from other\n    engine.set(other.get())\n\n    return engine",
              "signature": "(cls, other, parent, solver_kwargs = {})",
              "parameters": [
                {
                  "name": "cls",
                  "type": null,
                  "default": null,
                  "description": ""
                },
                {
                  "name": "other",
                  "type": null,
                  "default": null,
                  "description": "solver instance to cast to new solver type"
                },
                {
                  "name": "parent",
                  "type": null,
                  "default": null,
                  "description": "solver instance to use as parent"
                },
                {
                  "name": "solver_kwargs",
                  "type": null,
                  "default": "{}",
                  "description": "additional args for the new solver"
                }
              ],
              "returns": null,
              "method_type": "classmethod"
            },
            {
              "name": "create",
              "description": "Create a new solver instance, optionally inheriting state from existing engine.",
              "docstring_html": "<p>Create a new solver instance, optionally inheriting state from existing engine.</p>\n<p>This provides a unified interface for solver creation that handles both\nnew instantiation and solver switching (previously done via cast).</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>initial_value <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float, array</span></dt>\n<dd>initial condition / integration constant</dd>\n<dt>parent <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">None | Solver</span></dt>\n<dd>parent solver instance for stage synchronization</dd>\n<dt>from_engine <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">None | Solver</span></dt>\n<dd>existing solver to inherit state and settings from</dd>\n<dt>solver_kwargs <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">dict</span></dt>\n<dd>additional args for the solver (tolerances, etc.)</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>engine <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">Solver</span></dt>\n<dd>new solver instance</dd>\n</dl>\n",
              "source": "@classmethod\ndef create(cls, initial_value, parent=None, from_engine=None, **solver_kwargs):\n    \"\"\"Create a new solver instance, optionally inheriting state from existing engine.\n\n    This provides a unified interface for solver creation that handles both\n    new instantiation and solver switching (previously done via cast).\n\n    Parameters\n    ----------\n    initial_value : float, array\n        initial condition / integration constant\n    parent : None | Solver\n        parent solver instance for stage synchronization\n    from_engine : None | Solver\n        existing solver to inherit state and settings from\n    solver_kwargs : dict\n        additional args for the solver (tolerances, etc.)\n\n    Returns\n    -------\n    engine : Solver\n        new solver instance\n    \"\"\"\n    if from_engine is not None:\n        #inherit tolerances from existing engine if not specified\n        if \"tolerance_lte_rel\" not in solver_kwargs:\n            solver_kwargs[\"tolerance_lte_rel\"] = from_engine.tolerance_lte_rel\n        if \"tolerance_lte_abs\" not in solver_kwargs:\n            solver_kwargs[\"tolerance_lte_abs\"] = from_engine.tolerance_lte_abs\n\n        #create new solver\n        engine = cls(initial_value, parent, **solver_kwargs)\n\n        #preserve state from old engine\n        engine.state = from_engine.state\n\n        return engine\n\n    #simple creation without existing engine\n    return cls(initial_value, parent, **solver_kwargs)",
              "signature": "(cls, initial_value, parent = None, from_engine = None, solver_kwargs = {})",
              "parameters": [
                {
                  "name": "cls",
                  "type": null,
                  "default": null,
                  "description": ""
                },
                {
                  "name": "initial_value",
                  "type": null,
                  "default": null,
                  "description": "initial condition / integration constant"
                },
                {
                  "name": "parent",
                  "type": null,
                  "default": "None",
                  "description": "parent solver instance for stage synchronization"
                },
                {
                  "name": "from_engine",
                  "type": null,
                  "default": "None",
                  "description": "existing solver to inherit state and settings from"
                },
                {
                  "name": "solver_kwargs",
                  "type": null,
                  "default": "{}",
                  "description": "additional args for the solver (tolerances, etc.)"
                }
              ],
              "returns": null,
              "method_type": "classmethod"
            },
            {
              "name": "error_controller",
              "description": "Returns the estimated local truncation error (abs and rel) and scaling factor",
              "docstring_html": "<p>Returns the estimated local truncation error (abs and rel) and scaling factor\nfor the timestep, only relevant for adaptive timestepping methods.</p>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>success <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>True if the timestep was successful</dd>\n<dt>error <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>estimated error of the internal error controller</dd>\n<dt>scale <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float | None</span></dt>\n<dd>estimated timestep rescale factor for error control, None if no rescale needed</dd>\n</dl>\n",
              "source": "def error_controller(self):\n    \"\"\"Returns the estimated local truncation error (abs and rel) and scaling factor\n    for the timestep, only relevant for adaptive timestepping methods.\n\n    Returns\n    -------\n    success : bool\n        True if the timestep was successful\n    error : float\n        estimated error of the internal error controller\n    scale : float | None\n        estimated timestep rescale factor for error control, None if no rescale needed\n    \"\"\"\n    return True, 0.0, None",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "revert",
              "description": "Revert integration engine to previous timestep.",
              "docstring_html": "<p>Revert integration engine to previous timestep.</p>\n<p>This is only relevant for adaptive methods where the simulation\ntimestep 'dt' is rescaled and the engine step is recomputed with\nthe smaller timestep.</p>\n",
              "source": "def revert(self):\n    \"\"\"Revert integration engine to previous timestep. \n\n    This is only relevant for adaptive methods where the simulation \n    timestep 'dt' is rescaled and the engine step is recomputed with \n    the smaller timestep.\n    \"\"\"\n\n    #reset internal state to previous state from history\n    self.x = self.history.popleft()",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "step",
              "description": "Performs the explicit timestep for (t+dt) based",
              "docstring_html": "<p>Performs the explicit timestep for (t+dt) based\non the state and input at (t).</p>\n<p>Returns the local truncation error estimate and the\nrescale factor for the timestep if the solver is adaptive.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>f <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">numeric, array[numeric]</span></dt>\n<dd>evaluation of rhs function</dd>\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>integration timestep</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>success <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>True if the timestep was successful</dd>\n<dt>error <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>estimated error of the internal error controller</dd>\n<dt>scale <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float | None</span></dt>\n<dd>estimated timestep rescale factor for error control, None if no rescale needed</dd>\n</dl>\n",
              "source": "def step(self, f, dt):\n    \"\"\"Performs the explicit timestep for (t+dt) based\n    on the state and input at (t).\n\n    Returns the local truncation error estimate and the\n    rescale factor for the timestep if the solver is adaptive.\n\n    Parameters\n    ----------\n    f : numeric, array[numeric]\n        evaluation of rhs function\n    dt : float\n        integration timestep\n\n    Returns\n    -------\n    success : bool\n        True if the timestep was successful\n    error : float\n        estimated error of the internal error controller\n    scale : float | None\n        estimated timestep rescale factor for error control, None if no rescale needed\n    \"\"\"\n    return True, 0.0, None",
              "signature": "(f, dt)",
              "parameters": [
                {
                  "name": "f",
                  "type": null,
                  "default": null,
                  "description": "evaluation of rhs function"
                },
                {
                  "name": "dt",
                  "type": null,
                  "default": null,
                  "description": "integration timestep"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "interpolate",
              "description": "Interpolate solution after successful timestep as a ratio",
              "docstring_html": "<p>Interpolate solution after successful timestep as a ratio\nin the interval [t, t+dt].</p>\n<p>This is especially relevant for Runge-Kutta solvers that\nhave a higher order interpolant. Otherwise this is just\nlinear interpolation using the buffered state.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>r <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>ration for interpolation within timestep</dd>\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>integration timestep</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>x <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">numeric, array[numeric]</span></dt>\n<dd>interpolated state</dd>\n</dl>\n",
              "source": "def interpolate(self, r, dt):\n    \"\"\"Interpolate solution after successful timestep as a ratio \n    in the interval [t, t+dt].\n\n    This is especially relevant for Runge-Kutta solvers that \n    have a higher order interpolant. Otherwise this is just \n    linear interpolation using the buffered state.\n\n    Parameters\n    ----------\n    r : float\n        ration for interpolation within timestep\n    dt : float\n        integration timestep\n\n    Returns\n    -------\n    x : numeric, array[numeric]\n        interpolated state\n    \"\"\"\n    _r = np.clip(r, 0.0, 1.0)\n    return _r * self.x + (1.0 - _r) * self.x_0",
              "signature": "(r, dt)",
              "parameters": [
                {
                  "name": "r",
                  "type": null,
                  "default": null,
                  "description": "ration for interpolation within timestep"
                },
                {
                  "name": "dt",
                  "type": null,
                  "default": null,
                  "description": "integration timestep"
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "initial_value",
              "description": "",
              "type": null,
              "value": "initial_value"
            },
            {
              "name": "x",
              "description": "",
              "type": null,
              "value": "np.atleast_1d(initial_value).copy()"
            },
            {
              "name": "_scalar_initial",
              "description": "",
              "type": null,
              "value": "np.isscalar(initial_value)"
            },
            {
              "name": "tolerance_lte_abs",
              "description": "",
              "type": null,
              "value": "tolerance_lte_abs"
            },
            {
              "name": "tolerance_lte_rel",
              "description": "",
              "type": null,
              "value": "tolerance_lte_rel"
            },
            {
              "name": "parent",
              "description": "",
              "type": null,
              "value": "parent"
            },
            {
              "name": "is_adaptive",
              "description": "",
              "type": null,
              "value": "False"
            },
            {
              "name": "history",
              "description": "",
              "type": null,
              "value": "deque([], maxlen=1)"
            },
            {
              "name": "n",
              "description": "",
              "type": null,
              "value": "1"
            },
            {
              "name": "s",
              "description": "",
              "type": null,
              "value": "1"
            },
            {
              "name": "_stage",
              "description": "",
              "type": null,
              "value": "0"
            },
            {
              "name": "eval_stages",
              "description": "",
              "type": null,
              "value": "[0.0]"
            },
            {
              "name": "stage",
              "description": "stage property management to interface with parent solver",
              "type": null,
              "value": null
            },
            {
              "name": "state",
              "description": "Property for cleaner access to internal state.",
              "type": null,
              "value": null
            }
          ],
          "parameters": [
            {
              "name": "initial_value",
              "type": null,
              "default": "0",
              "description": "initial condition / integration constant"
            },
            {
              "name": "parent",
              "type": null,
              "default": "None",
              "description": "parent solver instance that manages the intermediate stages, stage counter, etc."
            },
            {
              "name": "tolerance_lte_abs",
              "type": null,
              "default": "SOL_TOLERANCE_LTE_ABS",
              "description": "absolute tolerance for local truncation error (for solvers with error estimate)"
            },
            {
              "name": "tolerance_lte_rel",
              "type": null,
              "default": "SOL_TOLERANCE_LTE_REL",
              "description": "relative tolerance for local truncation error (for solvers with error estimate)"
            }
          ]
        },
        {
          "name": "ExplicitSolver",
          "description": "Base class for explicit solver definition.",
          "docstring_html": "<p>Base class for explicit solver definition.</p>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>x_0 <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">numeric, array[numeric]</span></dt>\n<dd>internal 'working' initial value</dd>\n<dt>x <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">numeric, array[numeric]</span></dt>\n<dd>internal 'working' state</dd>\n<dt>n <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>order of integration scheme</dd>\n<dt>s <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>number of internal intermediate stages</dd>\n<dt>stage <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>counter for current intermediate stage</dd>\n<dt>eval_stages <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">list[float]</span></dt>\n<dd>rations for evaluation times of intermediate stages</dd>\n</dl>\n",
          "source": "class ExplicitSolver(Solver):\n    \"\"\"Base class for explicit solver definition.\n\n    Attributes\n    ----------\n    x_0 : numeric, array[numeric]\n        internal 'working' initial value\n    x : numeric, array[numeric]\n        internal 'working' state\n    n : int\n        order of integration scheme\n    s : int\n        number of internal intermediate stages\n    stage : int\n        counter for current intermediate stage\n    eval_stages : list[float]\n        rations for evaluation times of intermediate stages\n\n    \"\"\"\n\n    def __init__(self, *solver_args, **solver_kwargs):\n        super().__init__(*solver_args, **solver_kwargs)\n\n        #flag to identify implicit/explicit solvers\n        self.is_explicit = True\n        self.is_implicit = False\n\n        #intermediate evaluation times for multistage solvers as ratios between [t, t+dt]\n        self.eval_stages = [0.0]\n\n\n    # method for direct integration ----------------------------------------------------\n\n    def integrate_singlestep(self, func, time=0.0, dt=SIM_TIMESTEP):\n        \"\"\"Directly integrate the function for a single timestep 'dt' with \n        explicit solvers. This method is primarily intended for testing purposes.\n\n        Parameters\n        ----------  \n        func : callable\n            function to integrate f(x, t)\n        time : float\n            starting time for timestep\n        dt : float\n            integration timestep\n\n        Returns \n        -------\n        success : bool\n            True if the timestep was successful\n        error_norm : float\n            estimated error of the internal error controller\n        scale : float\n            estimated timestep rescale factor for error control\n        \"\"\"\n\n        #buffer current state\n        self.buffer(dt)\n\n        #iterate solver stages (explicit updates)\n        for t in self.stages(time, dt):\n            f = func(self.x, t)\n            success, error_norm, scale = self.step(f, dt)\n\n        return success, error_norm, scale\n\n\n    def integrate(\n        self, \n        func,\n        time_start=0.0, \n        time_end=1.0, \n        dt=SIM_TIMESTEP, \n        dt_min=SIM_TIMESTEP_MIN, \n        dt_max=SIM_TIMESTEP_MAX, \n        adaptive=True\n        ):\n        \"\"\"Directly integrate the function 'func' from 'time_start' \n        to 'time_end' with timestep 'dt' for explicit solvers. \n\n        This method is primarily intended for testing purposes or \n        for use as a standalone numerical integrator.\n\n        Example\n        -------\n\n        This is how to directly use the solver to integrate an ODE:\n\n        .. code-block:: python\n\n            #1st order linear ODE\n            def f(x, u, t):\n                return -x\n\n            #initial condition\n            x0 = 1\n\n            #initialize ODE solver\n            sol = Solver(x0)\n\n            #integrate from 0 to 5 with timestep 0.1\n            t, x = sol.integrate(f, time_end=5, dt=0.1)\n\n\n        Parameters\n        ----------\n        func : callable\n            function to integrate f(x, t)\n        time_start : float\n            starting time for integration\n        time_end : float\n            end time for integration\n        dt : float\n            timestep or initial timestep for adaptive solvers\n        dt_min : float\n            lower bound for timestep, default '0.0'\n        dt_max : float\n            upper bound for timestep, default 'None'\n        adaptive : bool\n            use adaptive timestepping if available\n\n        Returns\n        -------\n        outout_times : array[float]\n            time points of the solution\n        output_states : array[numeric], array[array[numeric]]\n            state values at solution time points\n        \"\"\"\n\n        #output lists with initial state\n        output_states = [self.x]\n        output_times = [time_start]\n\n        #integration starting time\n        time = time_start\n\n        #step until duration is reached\n        while time < time_end + dt:\n\n            #perform single timestep\n            success, _, scale = self.integrate_singlestep(func, time, dt)\n\n            #check if timestep was successful\n            if adaptive and not success:\n                self.revert()\n            else:\n                time += dt\n                output_states.append(self.x)\n                output_times.append(time)\n\n            #rescale and apply bounds to timestep\n            if adaptive and scale is not None:\n                if scale*dt < dt_min:\n                    raise RuntimeError(\"Error control requires timestep smaller 'dt_min'!\")\n                dt = np.clip(scale*dt, dt_min, dt_max)\n\n        #return the evaluation times and the states\n        #squeeze output if initial value was scalar\n        output_states_arr = np.array(output_states)\n        if self._scalar_initial:\n            output_states_arr = output_states_arr.squeeze()\n\n        return np.array(output_times), output_states_arr",
          "bases": [
            "pathsim.solvers._solver.Solver"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, *solver_args, **solver_kwargs):\n    super().__init__(*solver_args, **solver_kwargs)\n\n    #flag to identify implicit/explicit solvers\n    self.is_explicit = True\n    self.is_implicit = False\n\n    #intermediate evaluation times for multistage solvers as ratios between [t, t+dt]\n    self.eval_stages = [0.0]",
              "signature": "(solver_args = (), solver_kwargs = {})",
              "parameters": [
                {
                  "name": "solver_args",
                  "type": null,
                  "default": "()",
                  "description": ""
                },
                {
                  "name": "solver_kwargs",
                  "type": null,
                  "default": "{}",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "integrate_singlestep",
              "description": "Directly integrate the function for a single timestep 'dt' with",
              "docstring_html": "<p>Directly integrate the function for a single timestep 'dt' with\nexplicit solvers. This method is primarily intended for testing purposes.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>func <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">callable</span></dt>\n<dd>function to integrate f(x, t)</dd>\n<dt>time <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>starting time for timestep</dd>\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>integration timestep</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>success <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>True if the timestep was successful</dd>\n<dt>error_norm <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>estimated error of the internal error controller</dd>\n<dt>scale <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>estimated timestep rescale factor for error control</dd>\n</dl>\n",
              "source": "def integrate_singlestep(self, func, time=0.0, dt=SIM_TIMESTEP):\n    \"\"\"Directly integrate the function for a single timestep 'dt' with \n    explicit solvers. This method is primarily intended for testing purposes.\n\n    Parameters\n    ----------  \n    func : callable\n        function to integrate f(x, t)\n    time : float\n        starting time for timestep\n    dt : float\n        integration timestep\n\n    Returns \n    -------\n    success : bool\n        True if the timestep was successful\n    error_norm : float\n        estimated error of the internal error controller\n    scale : float\n        estimated timestep rescale factor for error control\n    \"\"\"\n\n    #buffer current state\n    self.buffer(dt)\n\n    #iterate solver stages (explicit updates)\n    for t in self.stages(time, dt):\n        f = func(self.x, t)\n        success, error_norm, scale = self.step(f, dt)\n\n    return success, error_norm, scale",
              "signature": "(func, time = 0.0, dt = SIM_TIMESTEP)",
              "parameters": [
                {
                  "name": "func",
                  "type": null,
                  "default": null,
                  "description": "function to integrate f(x, t)"
                },
                {
                  "name": "time",
                  "type": null,
                  "default": "0.0",
                  "description": "starting time for timestep"
                },
                {
                  "name": "dt",
                  "type": null,
                  "default": "SIM_TIMESTEP",
                  "description": "integration timestep"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "integrate",
              "description": "Directly integrate the function 'func' from 'time_start'",
              "docstring_html": "<p>Directly integrate the function 'func' from 'time_start'\nto 'time_end' with timestep 'dt' for explicit solvers.</p>\n<p>This method is primarily intended for testing purposes or\nfor use as a standalone numerical integrator.</p>\n<div class=\"section\" id=\"example\">\n<h4>Example</h4>\n<p>This is how to directly use the solver to integrate an ODE:</p>\n<pre class=\"code python literal-block\">\n<span class=\"c1\">#1st order linear ODE</span><span class=\"w\">\n</span><span class=\"k\">def</span><span class=\"w\"> </span><span class=\"nf\">f</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">u</span><span class=\"p\">,</span> <span class=\"n\">t</span><span class=\"p\">):</span><span class=\"w\">\n</span>    <span class=\"k\">return</span> <span class=\"o\">-</span><span class=\"n\">x</span><span class=\"w\">\n\n</span><span class=\"c1\">#initial condition</span><span class=\"w\">\n</span><span class=\"n\">x0</span> <span class=\"o\">=</span> <span class=\"mi\">1</span><span class=\"w\">\n\n</span><span class=\"c1\">#initialize ODE solver</span><span class=\"w\">\n</span><span class=\"n\">sol</span> <span class=\"o\">=</span> <span class=\"n\">Solver</span><span class=\"p\">(</span><span class=\"n\">x0</span><span class=\"p\">)</span><span class=\"w\">\n\n</span><span class=\"c1\">#integrate from 0 to 5 with timestep 0.1</span><span class=\"w\">\n</span><span class=\"n\">t</span><span class=\"p\">,</span> <span class=\"n\">x</span> <span class=\"o\">=</span> <span class=\"n\">sol</span><span class=\"o\">.</span><span class=\"n\">integrate</span><span class=\"p\">(</span><span class=\"n\">f</span><span class=\"p\">,</span> <span class=\"n\">time_end</span><span class=\"o\">=</span><span class=\"mi\">5</span><span class=\"p\">,</span> <span class=\"n\">dt</span><span class=\"o\">=</span><span class=\"mf\">0.1</span><span class=\"p\">)</span>\n</pre>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>func <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">callable</span></dt>\n<dd>function to integrate f(x, t)</dd>\n<dt>time_start <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>starting time for integration</dd>\n<dt>time_end <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>end time for integration</dd>\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>timestep or initial timestep for adaptive solvers</dd>\n<dt>dt_min <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>lower bound for timestep, default '0.0'</dd>\n<dt>dt_max <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>upper bound for timestep, default 'None'</dd>\n<dt>adaptive <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>use adaptive timestepping if available</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>outout_times <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array[float]</span></dt>\n<dd>time points of the solution</dd>\n<dt>output_states <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array[numeric], array[array[numeric]]</span></dt>\n<dd>state values at solution time points</dd>\n</dl>\n</div>\n",
              "source": "def integrate(\n    self, \n    func,\n    time_start=0.0, \n    time_end=1.0, \n    dt=SIM_TIMESTEP, \n    dt_min=SIM_TIMESTEP_MIN, \n    dt_max=SIM_TIMESTEP_MAX, \n    adaptive=True\n    ):\n    \"\"\"Directly integrate the function 'func' from 'time_start' \n    to 'time_end' with timestep 'dt' for explicit solvers. \n\n    This method is primarily intended for testing purposes or \n    for use as a standalone numerical integrator.\n\n    Example\n    -------\n\n    This is how to directly use the solver to integrate an ODE:\n\n    .. code-block:: python\n\n        #1st order linear ODE\n        def f(x, u, t):\n            return -x\n\n        #initial condition\n        x0 = 1\n\n        #initialize ODE solver\n        sol = Solver(x0)\n\n        #integrate from 0 to 5 with timestep 0.1\n        t, x = sol.integrate(f, time_end=5, dt=0.1)\n\n\n    Parameters\n    ----------\n    func : callable\n        function to integrate f(x, t)\n    time_start : float\n        starting time for integration\n    time_end : float\n        end time for integration\n    dt : float\n        timestep or initial timestep for adaptive solvers\n    dt_min : float\n        lower bound for timestep, default '0.0'\n    dt_max : float\n        upper bound for timestep, default 'None'\n    adaptive : bool\n        use adaptive timestepping if available\n\n    Returns\n    -------\n    outout_times : array[float]\n        time points of the solution\n    output_states : array[numeric], array[array[numeric]]\n        state values at solution time points\n    \"\"\"\n\n    #output lists with initial state\n    output_states = [self.x]\n    output_times = [time_start]\n\n    #integration starting time\n    time = time_start\n\n    #step until duration is reached\n    while time < time_end + dt:\n\n        #perform single timestep\n        success, _, scale = self.integrate_singlestep(func, time, dt)\n\n        #check if timestep was successful\n        if adaptive and not success:\n            self.revert()\n        else:\n            time += dt\n            output_states.append(self.x)\n            output_times.append(time)\n\n        #rescale and apply bounds to timestep\n        if adaptive and scale is not None:\n            if scale*dt < dt_min:\n                raise RuntimeError(\"Error control requires timestep smaller 'dt_min'!\")\n            dt = np.clip(scale*dt, dt_min, dt_max)\n\n    #return the evaluation times and the states\n    #squeeze output if initial value was scalar\n    output_states_arr = np.array(output_states)\n    if self._scalar_initial:\n        output_states_arr = output_states_arr.squeeze()\n\n    return np.array(output_times), output_states_arr",
              "signature": "(func, time_start = 0.0, time_end = 1.0, dt = SIM_TIMESTEP, dt_min = SIM_TIMESTEP_MIN, dt_max = SIM_TIMESTEP_MAX, adaptive = True)",
              "parameters": [
                {
                  "name": "func",
                  "type": null,
                  "default": null,
                  "description": "function to integrate f(x, t)"
                },
                {
                  "name": "time_start",
                  "type": null,
                  "default": "0.0",
                  "description": "starting time for integration"
                },
                {
                  "name": "time_end",
                  "type": null,
                  "default": "1.0",
                  "description": "end time for integration"
                },
                {
                  "name": "dt",
                  "type": null,
                  "default": "SIM_TIMESTEP",
                  "description": "timestep or initial timestep for adaptive solvers"
                },
                {
                  "name": "dt_min",
                  "type": null,
                  "default": "SIM_TIMESTEP_MIN",
                  "description": "lower bound for timestep, default '0.0'"
                },
                {
                  "name": "dt_max",
                  "type": null,
                  "default": "SIM_TIMESTEP_MAX",
                  "description": "upper bound for timestep, default 'None'"
                },
                {
                  "name": "adaptive",
                  "type": null,
                  "default": "True",
                  "description": "use adaptive timestepping if available"
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "is_explicit",
              "description": "",
              "type": null,
              "value": "True"
            },
            {
              "name": "is_implicit",
              "description": "",
              "type": null,
              "value": "False"
            },
            {
              "name": "eval_stages",
              "description": "",
              "type": null,
              "value": "[0.0]"
            }
          ],
          "parameters": [
            {
              "name": "solver_args",
              "type": null,
              "default": "()",
              "description": ""
            },
            {
              "name": "solver_kwargs",
              "type": null,
              "default": "{}",
              "description": ""
            }
          ]
        },
        {
          "name": "ImplicitSolver",
          "description": "Base class for implicit solver definition.",
          "docstring_html": "<p>Base class for implicit solver definition.</p>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>x_0 <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">numeric, array[numeric]</span></dt>\n<dd>internal 'working' initial value</dd>\n<dt>x <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">numeric, array[numeric]</span></dt>\n<dd>internal 'working' state</dd>\n<dt>n <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>order of integration scheme</dd>\n<dt>s <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>number of internal intermediate stages</dd>\n<dt>stage <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>counter for current intermediate stage</dd>\n<dt>eval_stages <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">list[float]</span></dt>\n<dd>rations for evaluation times of intermediate stages</dd>\n<dt>opt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">NewtonAnderson, Anderson, etc.</span></dt>\n<dd>optimizer instance to solve the implicit update equation</dd>\n</dl>\n",
          "source": "class ImplicitSolver(Solver):\n    \"\"\"\n    Base class for implicit solver definition.\n\n    Attributes\n    ----------\n    x_0 : numeric, array[numeric]\n        internal 'working' initial value\n    x : numeric, array[numeric]\n        internal 'working' state\n    n : int\n        order of integration scheme\n    s : int\n        number of internal intermediate stages\n    stage : int\n        counter for current intermediate stage\n    eval_stages : list[float]\n        rations for evaluation times of intermediate stages\n    opt : NewtonAnderson, Anderson, etc.\n        optimizer instance to solve the implicit update equation\n\n    \"\"\"\n\n    def __init__(self, *solver_args, **solver_kwargs):\n        super().__init__(*solver_args, **solver_kwargs)\n\n        #flag to identify implicit/explicit solvers\n        self.is_explicit = False\n        self.is_implicit = True\n\n        #intermediate evaluation times for multistage solvers as ratios between [t, t+dt]\n        self.eval_stages = [1.0]\n\n        #initialize optimizer for solving implicit update equation (default args)\n        self.opt = NewtonAnderson()\n\n\n    def buffer(self, dt):\n        \"\"\"Saves the current state to an internal state buffer which \n        is especially relevant for multistage and implicit solvers.\n\n        Resets the stage counter and the optimizer of implicit methods.\n\n        Parameters\n        ----------\n        dt : float\n            integration timestep\n        \"\"\"\n\n        #buffer internal state to history\n        self.history.appendleft(self.x)\n\n        #reset stage counter\n        self.stage = 0\n\n        #reset optimizer\n        self.opt.reset()\n\n\n    # methods for timestepping ---------------------------------------------------------\n\n    def solve(self, j, J, dt):\n        \"\"\"Advances the solution of the implicit update equation of the solver \n        with the optimizer of the engine and tracks the evolution of the \n        solution by providing the residual norm of the fixed-point solution.\n\n        Parameters\n        ----------\n        f : numeric, array[numeric]\n            evaluation of rhs function\n        J : array[numeric]\n            evaluation of jacobian of rhs function \n        dt : float \n            integration timestep\n\n        Returns\n        -------\n        err : float\n            residual error of the fixed point update equation\n        \"\"\"\n        return 0.0\n\n\n    # method for direct integration ----------------------------------------------------\n\n    def integrate_singlestep(\n        self, \n        func,\n        jac,\n        time=0.0, \n        dt=SIM_TIMESTEP, \n        tolerance_fpi=SOL_TOLERANCE_FPI, \n        max_iterations=SOL_ITERATIONS_MAX\n        ):\n        \"\"\"\n        Directly integrate the function 'func' for a single timestep 'dt' with \n        implicit solvers. This method is primarily intended for testing purposes.\n\n        Parameters\n        ----------  \n        func : callable\n            function to integrate f(x, t)\n        jac : callable\n            jacobian of f w.r.t. x\n        time_start : float\n            starting time for timestep\n        dt : float\n            integration timestep\n        tolerance_fpi : float\n            convergence criterion for implicit update equation\n        max_iterations : int\n            maximum numer of iterations for optimizer to solve \n            implicit update equation\n\n        Returns \n        -------\n        success : bool\n            True if the timestep was successful\n        error_norm : float\n            estimated error of the internal error controller \n            or solver when not converged\n        scale : float\n            estimated timestep rescale factor for error control\n        \"\"\"\n\n        #buffer current state\n        self.buffer(dt)\n\n        #iterate solver stages (implicit updates)\n        for t in self.stages(time, dt):\n\n            #iteratively solve implicit update equation\n            for _ in range(max_iterations):\n                f, J = func(self.x, t), jac(self.x, t)\n                error_sol = self.solve(f, J, dt)\n                if error_sol < tolerance_fpi: \n                    break\n\n            #catch convergence error -> early exit, half timestep\n            if error_sol > tolerance_fpi:\n                return False, error_sol, 0.5\n\n            #perform explicit component of timestep\n            f = func(self.x, t)\n            success, error_norm, scale = self.step(f, dt)\n\n        return success, error_norm, scale \n\n\n    def integrate(\n        self, \n        func, \n        jac,\n        time_start=0.0, \n        time_end=1.0, \n        dt=SIM_TIMESTEP, \n        dt_min=SIM_TIMESTEP_MIN, \n        dt_max=SIM_TIMESTEP_MAX, \n        adaptive=True,\n        tolerance_fpi=SOL_TOLERANCE_FPI, \n        max_iterations=SOL_ITERATIONS_MAX\n        ):\n        \"\"\"Directly integrate the function 'func' from 'time_start' \n        to 'time_end' with timestep 'dt' for implicit solvers. \n\n        This method is primarily intended for testing purposes or \n        for use as a standalone numerical integrator.\n\n        Example\n        -------\n\n        This is how to directly use the solver to integrate an ODE:\n\n        .. code-block:: python\n\n            #1st order linear ODE\n            def f(x, t):\n                return -x\n\n            #initial condition\n            x0 = 1\n\n            #initialize ODE solver\n            sol = Solver(x0)\n\n            #integrate from 0 to 5 with timestep 0.1\n            t, x = sol.integrate(f, time_end=5, dt=0.1)\n\n        Parameters\n        ----------\n        func : callable\n            function to integrate f(x, t)\n        jac : callable\n            jacobian of f w.r.t. x\n        time_start : float\n            starting time for integration\n        time_end : float\n            end time for integration\n        dt : float\n            timestep or initial timestep for adaptive solvers\n        dt_min : float\n            lower bound for timestep, default '0.0'\n        dt_max : float\n            upper bound for timestep, default 'None'\n        adaptive : bool\n            use adaptive timestepping if available\n        tolerance_fpi : float\n            convergence criterion for implicit update equation\n        max_iterations : int\n            maximum numer of iterations for optimizer to solve \n            implicit update equation\n\n        Returns\n        -------\n        outout_times : array[float]\n            time points of the solution\n        output_states : array[numeric], array[array[numeric]]\n            state values at solution time points    \n        \"\"\"\n\n        #output lists with initial state\n        output_states = [self.x.copy()]\n        output_times = [time_start]\n\n        #integration starting time\n        time = time_start\n\n        #step until duration is reached\n        while time < time_end + dt:\n\n            #integrate for single timestep\n            success, _, scale = self.integrate_singlestep(\n                func,\n                jac,\n                time,\n                dt,\n                tolerance_fpi,\n                max_iterations\n                )\n\n\n            #check if timestep was successful and adaptive\n            if adaptive and not success:\n                self.revert()\n            else:\n                time += dt\n                output_states.append(self.x.copy())\n                output_times.append(time)\n\n            #rescale and apply bounds to timestep\n            if adaptive and scale is not None:\n                if scale*dt < dt_min:\n                    raise RuntimeError(\"Error control requires timestep smaller 'dt_min'!\")\n                dt = np.clip(scale*dt, dt_min, dt_max)\n\n        #return the evaluation times and the states\n        #squeeze output if initial value was scalar\n        output_states_arr = np.array(output_states)\n        if self._scalar_initial:\n            output_states_arr = output_states_arr.squeeze()\n\n        return np.array(output_times), output_states_arr",
          "bases": [
            "pathsim.solvers._solver.Solver"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, *solver_args, **solver_kwargs):\n    super().__init__(*solver_args, **solver_kwargs)\n\n    #flag to identify implicit/explicit solvers\n    self.is_explicit = False\n    self.is_implicit = True\n\n    #intermediate evaluation times for multistage solvers as ratios between [t, t+dt]\n    self.eval_stages = [1.0]\n\n    #initialize optimizer for solving implicit update equation (default args)\n    self.opt = NewtonAnderson()",
              "signature": "(solver_args = (), solver_kwargs = {})",
              "parameters": [
                {
                  "name": "solver_args",
                  "type": null,
                  "default": "()",
                  "description": ""
                },
                {
                  "name": "solver_kwargs",
                  "type": null,
                  "default": "{}",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "buffer",
              "description": "Saves the current state to an internal state buffer which",
              "docstring_html": "<p>Saves the current state to an internal state buffer which\nis especially relevant for multistage and implicit solvers.</p>\n<p>Resets the stage counter and the optimizer of implicit methods.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>integration timestep</dd>\n</dl>\n",
              "source": "def buffer(self, dt):\n    \"\"\"Saves the current state to an internal state buffer which \n    is especially relevant for multistage and implicit solvers.\n\n    Resets the stage counter and the optimizer of implicit methods.\n\n    Parameters\n    ----------\n    dt : float\n        integration timestep\n    \"\"\"\n\n    #buffer internal state to history\n    self.history.appendleft(self.x)\n\n    #reset stage counter\n    self.stage = 0\n\n    #reset optimizer\n    self.opt.reset()",
              "signature": "(dt)",
              "parameters": [
                {
                  "name": "dt",
                  "type": null,
                  "default": null,
                  "description": "integration timestep"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "solve",
              "description": "Advances the solution of the implicit update equation of the solver",
              "docstring_html": "<p>Advances the solution of the implicit update equation of the solver\nwith the optimizer of the engine and tracks the evolution of the\nsolution by providing the residual norm of the fixed-point solution.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>f <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">numeric, array[numeric]</span></dt>\n<dd>evaluation of rhs function</dd>\n<dt>J <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array[numeric]</span></dt>\n<dd>evaluation of jacobian of rhs function</dd>\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>integration timestep</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>err <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>residual error of the fixed point update equation</dd>\n</dl>\n",
              "source": "def solve(self, j, J, dt):\n    \"\"\"Advances the solution of the implicit update equation of the solver \n    with the optimizer of the engine and tracks the evolution of the \n    solution by providing the residual norm of the fixed-point solution.\n\n    Parameters\n    ----------\n    f : numeric, array[numeric]\n        evaluation of rhs function\n    J : array[numeric]\n        evaluation of jacobian of rhs function \n    dt : float \n        integration timestep\n\n    Returns\n    -------\n    err : float\n        residual error of the fixed point update equation\n    \"\"\"\n    return 0.0",
              "signature": "(j, J, dt)",
              "parameters": [
                {
                  "name": "j",
                  "type": null,
                  "default": null,
                  "description": ""
                },
                {
                  "name": "J",
                  "type": null,
                  "default": null,
                  "description": "evaluation of jacobian of rhs function"
                },
                {
                  "name": "dt",
                  "type": null,
                  "default": null,
                  "description": "integration timestep"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "integrate_singlestep",
              "description": "Directly integrate the function 'func' for a single timestep 'dt' with",
              "docstring_html": "<p>Directly integrate the function 'func' for a single timestep 'dt' with\nimplicit solvers. This method is primarily intended for testing purposes.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>func <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">callable</span></dt>\n<dd>function to integrate f(x, t)</dd>\n<dt>jac <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">callable</span></dt>\n<dd>jacobian of f w.r.t. x</dd>\n<dt>time_start <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>starting time for timestep</dd>\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>integration timestep</dd>\n<dt>tolerance_fpi <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>convergence criterion for implicit update equation</dd>\n<dt>max_iterations <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>maximum numer of iterations for optimizer to solve\nimplicit update equation</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>success <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>True if the timestep was successful</dd>\n<dt>error_norm <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>estimated error of the internal error controller\nor solver when not converged</dd>\n<dt>scale <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>estimated timestep rescale factor for error control</dd>\n</dl>\n",
              "source": "def integrate_singlestep(\n    self, \n    func,\n    jac,\n    time=0.0, \n    dt=SIM_TIMESTEP, \n    tolerance_fpi=SOL_TOLERANCE_FPI, \n    max_iterations=SOL_ITERATIONS_MAX\n    ):\n    \"\"\"\n    Directly integrate the function 'func' for a single timestep 'dt' with \n    implicit solvers. This method is primarily intended for testing purposes.\n\n    Parameters\n    ----------  \n    func : callable\n        function to integrate f(x, t)\n    jac : callable\n        jacobian of f w.r.t. x\n    time_start : float\n        starting time for timestep\n    dt : float\n        integration timestep\n    tolerance_fpi : float\n        convergence criterion for implicit update equation\n    max_iterations : int\n        maximum numer of iterations for optimizer to solve \n        implicit update equation\n\n    Returns \n    -------\n    success : bool\n        True if the timestep was successful\n    error_norm : float\n        estimated error of the internal error controller \n        or solver when not converged\n    scale : float\n        estimated timestep rescale factor for error control\n    \"\"\"\n\n    #buffer current state\n    self.buffer(dt)\n\n    #iterate solver stages (implicit updates)\n    for t in self.stages(time, dt):\n\n        #iteratively solve implicit update equation\n        for _ in range(max_iterations):\n            f, J = func(self.x, t), jac(self.x, t)\n            error_sol = self.solve(f, J, dt)\n            if error_sol < tolerance_fpi: \n                break\n\n        #catch convergence error -> early exit, half timestep\n        if error_sol > tolerance_fpi:\n            return False, error_sol, 0.5\n\n        #perform explicit component of timestep\n        f = func(self.x, t)\n        success, error_norm, scale = self.step(f, dt)\n\n    return success, error_norm, scale",
              "signature": "(func, jac, time = 0.0, dt = SIM_TIMESTEP, tolerance_fpi = SOL_TOLERANCE_FPI, max_iterations = SOL_ITERATIONS_MAX)",
              "parameters": [
                {
                  "name": "func",
                  "type": null,
                  "default": null,
                  "description": "function to integrate f(x, t)"
                },
                {
                  "name": "jac",
                  "type": null,
                  "default": null,
                  "description": "jacobian of f w.r.t. x"
                },
                {
                  "name": "time",
                  "type": null,
                  "default": "0.0",
                  "description": ""
                },
                {
                  "name": "dt",
                  "type": null,
                  "default": "SIM_TIMESTEP",
                  "description": "integration timestep"
                },
                {
                  "name": "tolerance_fpi",
                  "type": null,
                  "default": "SOL_TOLERANCE_FPI",
                  "description": "convergence criterion for implicit update equation"
                },
                {
                  "name": "max_iterations",
                  "type": null,
                  "default": "SOL_ITERATIONS_MAX",
                  "description": "maximum numer of iterations for optimizer to solve implicit update equation"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "integrate",
              "description": "Directly integrate the function 'func' from 'time_start'",
              "docstring_html": "<p>Directly integrate the function 'func' from 'time_start'\nto 'time_end' with timestep 'dt' for implicit solvers.</p>\n<p>This method is primarily intended for testing purposes or\nfor use as a standalone numerical integrator.</p>\n<div class=\"section\" id=\"example\">\n<h4>Example</h4>\n<p>This is how to directly use the solver to integrate an ODE:</p>\n<pre class=\"code python literal-block\">\n<span class=\"c1\">#1st order linear ODE</span><span class=\"w\">\n</span><span class=\"k\">def</span><span class=\"w\"> </span><span class=\"nf\">f</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">t</span><span class=\"p\">):</span><span class=\"w\">\n</span>    <span class=\"k\">return</span> <span class=\"o\">-</span><span class=\"n\">x</span><span class=\"w\">\n\n</span><span class=\"c1\">#initial condition</span><span class=\"w\">\n</span><span class=\"n\">x0</span> <span class=\"o\">=</span> <span class=\"mi\">1</span><span class=\"w\">\n\n</span><span class=\"c1\">#initialize ODE solver</span><span class=\"w\">\n</span><span class=\"n\">sol</span> <span class=\"o\">=</span> <span class=\"n\">Solver</span><span class=\"p\">(</span><span class=\"n\">x0</span><span class=\"p\">)</span><span class=\"w\">\n\n</span><span class=\"c1\">#integrate from 0 to 5 with timestep 0.1</span><span class=\"w\">\n</span><span class=\"n\">t</span><span class=\"p\">,</span> <span class=\"n\">x</span> <span class=\"o\">=</span> <span class=\"n\">sol</span><span class=\"o\">.</span><span class=\"n\">integrate</span><span class=\"p\">(</span><span class=\"n\">f</span><span class=\"p\">,</span> <span class=\"n\">time_end</span><span class=\"o\">=</span><span class=\"mi\">5</span><span class=\"p\">,</span> <span class=\"n\">dt</span><span class=\"o\">=</span><span class=\"mf\">0.1</span><span class=\"p\">)</span>\n</pre>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>func <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">callable</span></dt>\n<dd>function to integrate f(x, t)</dd>\n<dt>jac <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">callable</span></dt>\n<dd>jacobian of f w.r.t. x</dd>\n<dt>time_start <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>starting time for integration</dd>\n<dt>time_end <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>end time for integration</dd>\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>timestep or initial timestep for adaptive solvers</dd>\n<dt>dt_min <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>lower bound for timestep, default '0.0'</dd>\n<dt>dt_max <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>upper bound for timestep, default 'None'</dd>\n<dt>adaptive <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>use adaptive timestepping if available</dd>\n<dt>tolerance_fpi <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>convergence criterion for implicit update equation</dd>\n<dt>max_iterations <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>maximum numer of iterations for optimizer to solve\nimplicit update equation</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>outout_times <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array[float]</span></dt>\n<dd>time points of the solution</dd>\n<dt>output_states <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array[numeric], array[array[numeric]]</span></dt>\n<dd>state values at solution time points</dd>\n</dl>\n</div>\n",
              "source": "def integrate(\n    self, \n    func, \n    jac,\n    time_start=0.0, \n    time_end=1.0, \n    dt=SIM_TIMESTEP, \n    dt_min=SIM_TIMESTEP_MIN, \n    dt_max=SIM_TIMESTEP_MAX, \n    adaptive=True,\n    tolerance_fpi=SOL_TOLERANCE_FPI, \n    max_iterations=SOL_ITERATIONS_MAX\n    ):\n    \"\"\"Directly integrate the function 'func' from 'time_start' \n    to 'time_end' with timestep 'dt' for implicit solvers. \n\n    This method is primarily intended for testing purposes or \n    for use as a standalone numerical integrator.\n\n    Example\n    -------\n\n    This is how to directly use the solver to integrate an ODE:\n\n    .. code-block:: python\n\n        #1st order linear ODE\n        def f(x, t):\n            return -x\n\n        #initial condition\n        x0 = 1\n\n        #initialize ODE solver\n        sol = Solver(x0)\n\n        #integrate from 0 to 5 with timestep 0.1\n        t, x = sol.integrate(f, time_end=5, dt=0.1)\n\n    Parameters\n    ----------\n    func : callable\n        function to integrate f(x, t)\n    jac : callable\n        jacobian of f w.r.t. x\n    time_start : float\n        starting time for integration\n    time_end : float\n        end time for integration\n    dt : float\n        timestep or initial timestep for adaptive solvers\n    dt_min : float\n        lower bound for timestep, default '0.0'\n    dt_max : float\n        upper bound for timestep, default 'None'\n    adaptive : bool\n        use adaptive timestepping if available\n    tolerance_fpi : float\n        convergence criterion for implicit update equation\n    max_iterations : int\n        maximum numer of iterations for optimizer to solve \n        implicit update equation\n\n    Returns\n    -------\n    outout_times : array[float]\n        time points of the solution\n    output_states : array[numeric], array[array[numeric]]\n        state values at solution time points    \n    \"\"\"\n\n    #output lists with initial state\n    output_states = [self.x.copy()]\n    output_times = [time_start]\n\n    #integration starting time\n    time = time_start\n\n    #step until duration is reached\n    while time < time_end + dt:\n\n        #integrate for single timestep\n        success, _, scale = self.integrate_singlestep(\n            func,\n            jac,\n            time,\n            dt,\n            tolerance_fpi,\n            max_iterations\n            )\n\n\n        #check if timestep was successful and adaptive\n        if adaptive and not success:\n            self.revert()\n        else:\n            time += dt\n            output_states.append(self.x.copy())\n            output_times.append(time)\n\n        #rescale and apply bounds to timestep\n        if adaptive and scale is not None:\n            if scale*dt < dt_min:\n                raise RuntimeError(\"Error control requires timestep smaller 'dt_min'!\")\n            dt = np.clip(scale*dt, dt_min, dt_max)\n\n    #return the evaluation times and the states\n    #squeeze output if initial value was scalar\n    output_states_arr = np.array(output_states)\n    if self._scalar_initial:\n        output_states_arr = output_states_arr.squeeze()\n\n    return np.array(output_times), output_states_arr",
              "signature": "(func, jac, time_start = 0.0, time_end = 1.0, dt = SIM_TIMESTEP, dt_min = SIM_TIMESTEP_MIN, dt_max = SIM_TIMESTEP_MAX, adaptive = True, tolerance_fpi = SOL_TOLERANCE_FPI, max_iterations = SOL_ITERATIONS_MAX)",
              "parameters": [
                {
                  "name": "func",
                  "type": null,
                  "default": null,
                  "description": "function to integrate f(x, t)"
                },
                {
                  "name": "jac",
                  "type": null,
                  "default": null,
                  "description": "jacobian of f w.r.t. x"
                },
                {
                  "name": "time_start",
                  "type": null,
                  "default": "0.0",
                  "description": "starting time for integration"
                },
                {
                  "name": "time_end",
                  "type": null,
                  "default": "1.0",
                  "description": "end time for integration"
                },
                {
                  "name": "dt",
                  "type": null,
                  "default": "SIM_TIMESTEP",
                  "description": "timestep or initial timestep for adaptive solvers"
                },
                {
                  "name": "dt_min",
                  "type": null,
                  "default": "SIM_TIMESTEP_MIN",
                  "description": "lower bound for timestep, default '0.0'"
                },
                {
                  "name": "dt_max",
                  "type": null,
                  "default": "SIM_TIMESTEP_MAX",
                  "description": "upper bound for timestep, default 'None'"
                },
                {
                  "name": "adaptive",
                  "type": null,
                  "default": "True",
                  "description": "use adaptive timestepping if available"
                },
                {
                  "name": "tolerance_fpi",
                  "type": null,
                  "default": "SOL_TOLERANCE_FPI",
                  "description": "convergence criterion for implicit update equation"
                },
                {
                  "name": "max_iterations",
                  "type": null,
                  "default": "SOL_ITERATIONS_MAX",
                  "description": "maximum numer of iterations for optimizer to solve implicit update equation"
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "is_explicit",
              "description": "",
              "type": null,
              "value": "False"
            },
            {
              "name": "is_implicit",
              "description": "",
              "type": null,
              "value": "True"
            },
            {
              "name": "eval_stages",
              "description": "",
              "type": null,
              "value": "[1.0]"
            },
            {
              "name": "opt",
              "description": "",
              "type": null,
              "value": "NewtonAnderson()"
            }
          ],
          "parameters": [
            {
              "name": "solver_args",
              "type": null,
              "default": "()",
              "description": ""
            },
            {
              "name": "solver_kwargs",
              "type": null,
              "default": "{}",
              "description": ""
            }
          ]
        }
      ],
      "functions": []
    },
    "pathsim.solvers.bdf": {
      "name": "pathsim.solvers.bdf",
      "description": "",
      "docstring_html": "",
      "classes": [
        {
          "name": "BDF",
          "description": "Base class for the backward differentiation formula (BDF) integrators.",
          "docstring_html": "<p>Base class for the backward differentiation formula (BDF) integrators.</p>\n<p><strong>Notes</strong></p>\n<p>This solver class is not intended to be used directly</p>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>x <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">numeric, array[numeric]</span></dt>\n<dd>internal 'working' state</dd>\n<dt>n <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>order of integration scheme</dd>\n<dt>s <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>number of internal intermediate stages</dd>\n<dt>stage <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>counter for current intermediate stage</dd>\n<dt>eval_stages <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">list[float]</span></dt>\n<dd>rations for evaluation times of intermediate stages</dd>\n<dt>opt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">NewtonAnderson, Anderson, etc.</span></dt>\n<dd>optimizer instance to solve the implicit update equation</dd>\n<dt>K <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">dict[int: list[float]]</span></dt>\n<dd>bdf coefficients for the state buffer for each order</dd>\n<dt>F <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">dict[int: float]</span></dt>\n<dd>bdf coefficients for the function 'func' for each order</dd>\n<dt>history <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">deque[numeric]</span></dt>\n<dd>internal history of past results</dd>\n<dt>startup <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">Solver</span></dt>\n<dd>internal solver instance for startup (building history)\nof multistep methods (using 'DIRK3' for 'BDF' methods)</dd>\n</dl>\n",
          "source": "class BDF(ImplicitSolver):\n    \"\"\"Base class for the backward differentiation formula (BDF) integrators.\n\n    Notes\n    ----- \n    This solver class is not intended to be used directly\n\n    Attributes\n    ----------\n    x : numeric, array[numeric]\n        internal 'working' state\n    n : int\n        order of integration scheme\n    s : int\n        number of internal intermediate stages\n    stage : int\n        counter for current intermediate stage\n    eval_stages : list[float]\n        rations for evaluation times of intermediate stages\n    opt : NewtonAnderson, Anderson, etc.\n        optimizer instance to solve the implicit update equation\n    K : dict[int: list[float]]\n        bdf coefficients for the state buffer for each order\n    F : dict[int: float]\n        bdf coefficients for the function 'func' for each order\n    history : deque[numeric]\n        internal history of past results\n    startup : Solver\n        internal solver instance for startup (building history) \n        of multistep methods (using 'DIRK3' for 'BDF' methods)\n    \"\"\"\n\n    def __init__(self, *solver_args, **solver_kwargs):\n        super().__init__(*solver_args, **solver_kwargs)\n\n        #integration order\n        self.n = None\n\n        #bdf coefficients for orders 1 to 6\n        self.K = {\n            1:[1.0], \n            2:[4/3, -1/3], \n            3:[18/11, -9/11, 2/11], \n            4:[48/25, -36/25, 16/25, -3/25],\n            5:[300/137, -300/137, 200/137, -75/137, 12/137],\n            6:[360/147, -450/147, 400/147, -225/147, 72/147, -10/147]\n            }\n        self.F = {1:1.0, 2:2/3, 3:6/11, 4:12/25, 5:60/137, 6:60/147}\n\n        #initialize startup solver from 'self' and flag\n        self._needs_startup = True\n        self.startup = DIRK3.cast(self, self.parent)\n\n\n    @classmethod\n    def cast(cls, other, parent, **solver_kwargs):\n        \"\"\"cast to this solver needs special handling of startup method\n\n        Parameters\n        ----------\n        other : Solver\n            solver instance to cast new instance of this class from\n        parent : None | Solver\n            solver instance to use as parent\n        solver_kwargs : dict\n            other args for the solver\n\n        Returns\n        -------\n        engine : BDF\n            instance of `BDF` solver with params and state from `other`\n        \"\"\"\n        engine = super().cast(other, parent, **solver_kwargs)\n        engine.startup = DIRK3.cast(engine, parent)\n\n        return engine\n\n\n    @classmethod\n    def create(cls, initial_value, parent=None, from_engine=None, **solver_kwargs):\n        \"\"\"Create a new BDF solver, properly initializing the startup solver.\n\n        Parameters\n        ----------\n        initial_value : float, array\n            initial condition / integration constant\n        parent : None | Solver\n            parent solver instance for stage synchronization\n        from_engine : None | Solver\n            existing solver to inherit state and settings from\n        solver_kwargs : dict\n            additional args for the solver\n\n        Returns\n        -------\n        engine : BDF\n            new BDF solver instance\n        \"\"\"\n        if from_engine is not None:\n            #inherit tolerances from existing engine if not specified\n            if \"tolerance_lte_rel\" not in solver_kwargs:\n                solver_kwargs[\"tolerance_lte_rel\"] = from_engine.tolerance_lte_rel\n            if \"tolerance_lte_abs\" not in solver_kwargs:\n                solver_kwargs[\"tolerance_lte_abs\"] = from_engine.tolerance_lte_abs\n\n            #create new solver (this initializes startup in __init__)\n            engine = cls(initial_value, parent, **solver_kwargs)\n\n            #preserve state from old engine\n            engine.state = from_engine.state\n\n            #re-initialize startup solver from the new engine\n            engine.startup = DIRK3.create(initial_value, parent, **solver_kwargs)\n            engine.startup.state = from_engine.state\n\n            return engine\n\n        #simple creation without existing engine\n        return cls(initial_value, parent, **solver_kwargs)\n\n\n    def stages(self, t, dt):\n        \"\"\"Generator that yields the intermediate evaluation \n        time during the timestep 't + ratio * dt'.\n\n        Parameters\n        ----------\n        t : float \n            evaluation time\n        dt : float\n            integration timestep\n        \"\"\"\n\n        #not enough history for full order -> stages of startup method\n        if self._needs_startup:\n            for self.stage, _t in enumerate(self.startup.stages(t, dt)):\n                yield _t\n        else:\n            for _t in super().stages(t, dt):\n                yield _t\n\n\n    def reset(self):\n        \"\"\"\"Resets integration engine to initial state.\"\"\"\n\n        #clear history (BDF solution buffer)\n        self.history.clear()\n\n        #overwrite state with initial value (ensure array format)\n        self.x = np.atleast_1d(self.initial_value).copy()\n\n        #reset startup solver\n        self.startup.reset()\n\n\n    def buffer(self, dt):\n        \"\"\"buffer the state for the multistep method\n\n        Parameters\n        ----------\n        dt : float\n            integration timestep\n        \"\"\"\n\n        #reset optimizer\n        self.opt.reset()\n\n        #add current solution to history\n        self.history.appendleft(self.x)\n\n        #flag for startup method, not enough history\n        self._needs_startup = len(self.history) < self.n\n\n        #buffer with startup method\n        if self._needs_startup:\n            self.startup.buffer(dt)\n\n\n    def solve(self, f, J, dt):\n        \"\"\"Solves the implicit update equation using the optimizer of the engine.\n\n        Parameters\n        ----------\n        f : array_like\n            evaluation of function\n        J : array_like\n            evaluation of jacobian of function\n        dt : float \n            integration timestep\n\n        Returns\n        -------\n        err : float\n            residual error of the fixed point update equation\n        \"\"\"\n\n        #not enough history for full order -> solve with startup method\n        if self._needs_startup:\n            err = self.startup.solve(f, J, dt)\n            self.x = self.startup.get()\n            return err\n\n        #fixed-point function update\n        g = self.F[self.n] * dt * f\n        for b, k in zip(self.history, self.K[self.n]):\n            g = g + b * k\n\n        #use the jacobian\n        if J is not None:\n\n            #optimizer step with block local jacobian\n            self.x, err = self.opt.step(self.x, g, self.F[self.n] * dt * J)\n\n        else:\n            #optimizer step (pure)\n            self.x, err = self.opt.step(self.x, g, None)\n\n        #return the fixed-point residual\n        return err\n\n\n    def step(self, f, dt):\n        \"\"\"Performs the explicit timestep for (t+dt) based \n        on the state and input at (t).\n\n        Note\n        ----\n        This is only required for the startup solver.\n\n        Parameters\n        ----------\n        f : numeric, array[numeric]\n            evaluation of rhs function\n        dt : float \n            integration timestep\n\n        Returns \n        -------\n        success : bool\n            True if the timestep was successful\n        error : float\n            estimated error of the internal error controller\n        scale : float\n            estimated timestep rescale factor for error control\n        \"\"\"\n\n        #not enough histors -> step the startup solver\n        if self._needs_startup:\n            self.startup.step(f, dt)\n            self.x = self.startup.get()\n\n        return True, 0.0, None",
          "bases": [
            "pathsim.solvers._solver.ImplicitSolver"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, *solver_args, **solver_kwargs):\n    super().__init__(*solver_args, **solver_kwargs)\n\n    #integration order\n    self.n = None\n\n    #bdf coefficients for orders 1 to 6\n    self.K = {\n        1:[1.0], \n        2:[4/3, -1/3], \n        3:[18/11, -9/11, 2/11], \n        4:[48/25, -36/25, 16/25, -3/25],\n        5:[300/137, -300/137, 200/137, -75/137, 12/137],\n        6:[360/147, -450/147, 400/147, -225/147, 72/147, -10/147]\n        }\n    self.F = {1:1.0, 2:2/3, 3:6/11, 4:12/25, 5:60/137, 6:60/147}\n\n    #initialize startup solver from 'self' and flag\n    self._needs_startup = True\n    self.startup = DIRK3.cast(self, self.parent)",
              "signature": "(solver_args = (), solver_kwargs = {})",
              "parameters": [
                {
                  "name": "solver_args",
                  "type": null,
                  "default": "()",
                  "description": ""
                },
                {
                  "name": "solver_kwargs",
                  "type": null,
                  "default": "{}",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "cast",
              "description": "cast to this solver needs special handling of startup method",
              "docstring_html": "<p>cast to this solver needs special handling of startup method</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>other <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">Solver</span></dt>\n<dd>solver instance to cast new instance of this class from</dd>\n<dt>parent <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">None | Solver</span></dt>\n<dd>solver instance to use as parent</dd>\n<dt>solver_kwargs <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">dict</span></dt>\n<dd>other args for the solver</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>engine <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">BDF</span></dt>\n<dd>instance of <cite>BDF</cite> solver with params and state from <cite>other</cite></dd>\n</dl>\n",
              "source": "@classmethod\ndef cast(cls, other, parent, **solver_kwargs):\n    \"\"\"cast to this solver needs special handling of startup method\n\n    Parameters\n    ----------\n    other : Solver\n        solver instance to cast new instance of this class from\n    parent : None | Solver\n        solver instance to use as parent\n    solver_kwargs : dict\n        other args for the solver\n\n    Returns\n    -------\n    engine : BDF\n        instance of `BDF` solver with params and state from `other`\n    \"\"\"\n    engine = super().cast(other, parent, **solver_kwargs)\n    engine.startup = DIRK3.cast(engine, parent)\n\n    return engine",
              "signature": "(cls, other, parent, solver_kwargs = {})",
              "parameters": [
                {
                  "name": "cls",
                  "type": null,
                  "default": null,
                  "description": ""
                },
                {
                  "name": "other",
                  "type": null,
                  "default": null,
                  "description": "solver instance to cast new instance of this class from"
                },
                {
                  "name": "parent",
                  "type": null,
                  "default": null,
                  "description": "solver instance to use as parent"
                },
                {
                  "name": "solver_kwargs",
                  "type": null,
                  "default": "{}",
                  "description": "other args for the solver"
                }
              ],
              "returns": null,
              "method_type": "classmethod"
            },
            {
              "name": "create",
              "description": "Create a new BDF solver, properly initializing the startup solver.",
              "docstring_html": "<p>Create a new BDF solver, properly initializing the startup solver.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>initial_value <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float, array</span></dt>\n<dd>initial condition / integration constant</dd>\n<dt>parent <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">None | Solver</span></dt>\n<dd>parent solver instance for stage synchronization</dd>\n<dt>from_engine <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">None | Solver</span></dt>\n<dd>existing solver to inherit state and settings from</dd>\n<dt>solver_kwargs <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">dict</span></dt>\n<dd>additional args for the solver</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>engine <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">BDF</span></dt>\n<dd>new BDF solver instance</dd>\n</dl>\n",
              "source": "@classmethod\ndef create(cls, initial_value, parent=None, from_engine=None, **solver_kwargs):\n    \"\"\"Create a new BDF solver, properly initializing the startup solver.\n\n    Parameters\n    ----------\n    initial_value : float, array\n        initial condition / integration constant\n    parent : None | Solver\n        parent solver instance for stage synchronization\n    from_engine : None | Solver\n        existing solver to inherit state and settings from\n    solver_kwargs : dict\n        additional args for the solver\n\n    Returns\n    -------\n    engine : BDF\n        new BDF solver instance\n    \"\"\"\n    if from_engine is not None:\n        #inherit tolerances from existing engine if not specified\n        if \"tolerance_lte_rel\" not in solver_kwargs:\n            solver_kwargs[\"tolerance_lte_rel\"] = from_engine.tolerance_lte_rel\n        if \"tolerance_lte_abs\" not in solver_kwargs:\n            solver_kwargs[\"tolerance_lte_abs\"] = from_engine.tolerance_lte_abs\n\n        #create new solver (this initializes startup in __init__)\n        engine = cls(initial_value, parent, **solver_kwargs)\n\n        #preserve state from old engine\n        engine.state = from_engine.state\n\n        #re-initialize startup solver from the new engine\n        engine.startup = DIRK3.create(initial_value, parent, **solver_kwargs)\n        engine.startup.state = from_engine.state\n\n        return engine\n\n    #simple creation without existing engine\n    return cls(initial_value, parent, **solver_kwargs)",
              "signature": "(cls, initial_value, parent = None, from_engine = None, solver_kwargs = {})",
              "parameters": [
                {
                  "name": "cls",
                  "type": null,
                  "default": null,
                  "description": ""
                },
                {
                  "name": "initial_value",
                  "type": null,
                  "default": null,
                  "description": "initial condition / integration constant"
                },
                {
                  "name": "parent",
                  "type": null,
                  "default": "None",
                  "description": "parent solver instance for stage synchronization"
                },
                {
                  "name": "from_engine",
                  "type": null,
                  "default": "None",
                  "description": "existing solver to inherit state and settings from"
                },
                {
                  "name": "solver_kwargs",
                  "type": null,
                  "default": "{}",
                  "description": "additional args for the solver"
                }
              ],
              "returns": null,
              "method_type": "classmethod"
            },
            {
              "name": "stages",
              "description": "Generator that yields the intermediate evaluation",
              "docstring_html": "<p>Generator that yields the intermediate evaluation\ntime during the timestep 't + ratio * dt'.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time</dd>\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>integration timestep</dd>\n</dl>\n",
              "source": "def stages(self, t, dt):\n    \"\"\"Generator that yields the intermediate evaluation \n    time during the timestep 't + ratio * dt'.\n\n    Parameters\n    ----------\n    t : float \n        evaluation time\n    dt : float\n        integration timestep\n    \"\"\"\n\n    #not enough history for full order -> stages of startup method\n    if self._needs_startup:\n        for self.stage, _t in enumerate(self.startup.stages(t, dt)):\n            yield _t\n    else:\n        for _t in super().stages(t, dt):\n            yield _t",
              "signature": "(t, dt)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time"
                },
                {
                  "name": "dt",
                  "type": null,
                  "default": null,
                  "description": "integration timestep"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "reset",
              "description": "\"Resets integration engine to initial state.",
              "docstring_html": "<p>&quot;Resets integration engine to initial state.</p>\n",
              "source": "def reset(self):\n    \"\"\"\"Resets integration engine to initial state.\"\"\"\n\n    #clear history (BDF solution buffer)\n    self.history.clear()\n\n    #overwrite state with initial value (ensure array format)\n    self.x = np.atleast_1d(self.initial_value).copy()\n\n    #reset startup solver\n    self.startup.reset()",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "buffer",
              "description": "buffer the state for the multistep method",
              "docstring_html": "<p>buffer the state for the multistep method</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>integration timestep</dd>\n</dl>\n",
              "source": "def buffer(self, dt):\n    \"\"\"buffer the state for the multistep method\n\n    Parameters\n    ----------\n    dt : float\n        integration timestep\n    \"\"\"\n\n    #reset optimizer\n    self.opt.reset()\n\n    #add current solution to history\n    self.history.appendleft(self.x)\n\n    #flag for startup method, not enough history\n    self._needs_startup = len(self.history) < self.n\n\n    #buffer with startup method\n    if self._needs_startup:\n        self.startup.buffer(dt)",
              "signature": "(dt)",
              "parameters": [
                {
                  "name": "dt",
                  "type": null,
                  "default": null,
                  "description": "integration timestep"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "solve",
              "description": "Solves the implicit update equation using the optimizer of the engine.",
              "docstring_html": "<p>Solves the implicit update equation using the optimizer of the engine.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>f <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array_like</span></dt>\n<dd>evaluation of function</dd>\n<dt>J <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array_like</span></dt>\n<dd>evaluation of jacobian of function</dd>\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>integration timestep</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>err <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>residual error of the fixed point update equation</dd>\n</dl>\n",
              "source": "def solve(self, f, J, dt):\n    \"\"\"Solves the implicit update equation using the optimizer of the engine.\n\n    Parameters\n    ----------\n    f : array_like\n        evaluation of function\n    J : array_like\n        evaluation of jacobian of function\n    dt : float \n        integration timestep\n\n    Returns\n    -------\n    err : float\n        residual error of the fixed point update equation\n    \"\"\"\n\n    #not enough history for full order -> solve with startup method\n    if self._needs_startup:\n        err = self.startup.solve(f, J, dt)\n        self.x = self.startup.get()\n        return err\n\n    #fixed-point function update\n    g = self.F[self.n] * dt * f\n    for b, k in zip(self.history, self.K[self.n]):\n        g = g + b * k\n\n    #use the jacobian\n    if J is not None:\n\n        #optimizer step with block local jacobian\n        self.x, err = self.opt.step(self.x, g, self.F[self.n] * dt * J)\n\n    else:\n        #optimizer step (pure)\n        self.x, err = self.opt.step(self.x, g, None)\n\n    #return the fixed-point residual\n    return err",
              "signature": "(f, J, dt)",
              "parameters": [
                {
                  "name": "f",
                  "type": null,
                  "default": null,
                  "description": "evaluation of function"
                },
                {
                  "name": "J",
                  "type": null,
                  "default": null,
                  "description": "evaluation of jacobian of function"
                },
                {
                  "name": "dt",
                  "type": null,
                  "default": null,
                  "description": "integration timestep"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "step",
              "description": "Performs the explicit timestep for (t+dt) based",
              "docstring_html": "<p>Performs the explicit timestep for (t+dt) based\non the state and input at (t).</p>\n<div class=\"section\" id=\"note\">\n<h4>Note</h4>\n<p>This is only required for the startup solver.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>f <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">numeric, array[numeric]</span></dt>\n<dd>evaluation of rhs function</dd>\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>integration timestep</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>success <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>True if the timestep was successful</dd>\n<dt>error <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>estimated error of the internal error controller</dd>\n<dt>scale <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>estimated timestep rescale factor for error control</dd>\n</dl>\n</div>\n",
              "source": "def step(self, f, dt):\n    \"\"\"Performs the explicit timestep for (t+dt) based \n    on the state and input at (t).\n\n    Note\n    ----\n    This is only required for the startup solver.\n\n    Parameters\n    ----------\n    f : numeric, array[numeric]\n        evaluation of rhs function\n    dt : float \n        integration timestep\n\n    Returns \n    -------\n    success : bool\n        True if the timestep was successful\n    error : float\n        estimated error of the internal error controller\n    scale : float\n        estimated timestep rescale factor for error control\n    \"\"\"\n\n    #not enough histors -> step the startup solver\n    if self._needs_startup:\n        self.startup.step(f, dt)\n        self.x = self.startup.get()\n\n    return True, 0.0, None",
              "signature": "(f, dt)",
              "parameters": [
                {
                  "name": "f",
                  "type": null,
                  "default": null,
                  "description": "evaluation of rhs function"
                },
                {
                  "name": "dt",
                  "type": null,
                  "default": null,
                  "description": "integration timestep"
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "n",
              "description": "",
              "type": null,
              "value": "None"
            },
            {
              "name": "K",
              "description": "",
              "type": null,
              "value": "{1: [1.0], 2: [4 / 3, -1 / 3], 3: [18 / 11, -9 / 11, 2 / 11], 4: [48 / 25, -36 / 25, 16 / 25, -3 / 25], 5: [300 / 137, -300 / 137, 200 / 137, -75 / 137, 12 / 137], 6: [360 / 147, -450 / 147, 400 / 147, -225 / 147, 72 / 147, -10 / 147]}"
            },
            {
              "name": "F",
              "description": "",
              "type": null,
              "value": "{1: 1.0, 2: 2 / 3, 3: 6 / 11, 4: 12 / 25, 5: 60 / 137, 6: 60 / 147}"
            },
            {
              "name": "_needs_startup",
              "description": "",
              "type": null,
              "value": "True"
            },
            {
              "name": "startup",
              "description": "",
              "type": null,
              "value": "DIRK3.cast(self, self.parent)"
            }
          ],
          "parameters": [
            {
              "name": "solver_args",
              "type": null,
              "default": "()",
              "description": ""
            },
            {
              "name": "solver_kwargs",
              "type": null,
              "default": "{}",
              "description": ""
            }
          ]
        },
        {
          "name": "BDF2",
          "description": "Fixed-step 2nd order BDF method. A-stable.",
          "docstring_html": "<p>Fixed-step 2nd order BDF method. A-stable.</p>\n<pre class=\"math\">\nx_{n+1} = \\tfrac{4}{3}\\,x_n - \\tfrac{1}{3}\\,x_{n-1}\n          + \\tfrac{2}{3}\\,h\\,f(x_{n+1}, t_{n+1})\n</pre>\n<p>Uses <tt class=\"docutils literal\">DIRK3</tt> as startup solver for the first step.</p>\n<div class=\"section\" id=\"characteristics\">\n<h4>Characteristics</h4>\n<ul class=\"simple\">\n<li>Order: 2</li>\n<li>Implicit linear multistep, fixed timestep</li>\n<li>A-stable</li>\n</ul>\n</div>\n<div class=\"section\" id=\"note\">\n<h4>Note</h4>\n<p>The workhorse fixed-step stiff solver. A-stability means no eigenvalue\nin the left half-plane causes instability, regardless of the timestep.\nWell suited for block diagrams with a fixed simulation clock and\nmoderately-to-very stiff dynamics. For adaptive stepping, use <tt class=\"docutils literal\">GEAR21</tt>\nor <tt class=\"docutils literal\">ESDIRK43</tt>.</p>\n<p><strong>References</strong></p>\n<table class=\"docutils footnote\" frame=\"void\" id=\"footnote-1\" rules=\"none\">\n<colgroup><col class=\"label\" /><col /></colgroup>\n<tbody valign=\"top\">\n<tr><td class=\"label\">[1]</td><td>Gear, C. W. (1971). &quot;Numerical Initial Value Problems in Ordinary\nDifferential Equations&quot;. Prentice-Hall.</td></tr>\n</tbody>\n</table>\n<table class=\"docutils footnote\" frame=\"void\" id=\"footnote-2\" rules=\"none\">\n<colgroup><col class=\"label\" /><col /></colgroup>\n<tbody valign=\"top\">\n<tr><td class=\"label\">[2]</td><td>Hairer, E., &amp; Wanner, G. (1996). &quot;Solving Ordinary Differential\nEquations II: Stiff and Differential-Algebraic Problems&quot;. Springer\nSeries in Computational Mathematics, Vol. 14.\n:doi:`10.1007/978-3-642-05221-7`</td></tr>\n</tbody>\n</table>\n</div>\n",
          "source": "class BDF2(BDF):\n    \"\"\"Fixed-step 2nd order BDF method. A-stable.\n\n    .. math::\n\n        x_{n+1} = \\\\tfrac{4}{3}\\\\,x_n - \\\\tfrac{1}{3}\\\\,x_{n-1}\n                  + \\\\tfrac{2}{3}\\\\,h\\\\,f(x_{n+1}, t_{n+1})\n\n    Uses ``DIRK3`` as startup solver for the first step.\n\n    Characteristics\n    ---------------\n    * Order: 2\n    * Implicit linear multistep, fixed timestep\n    * A-stable\n\n    Note\n    ----\n    The workhorse fixed-step stiff solver. A-stability means no eigenvalue\n    in the left half-plane causes instability, regardless of the timestep.\n    Well suited for block diagrams with a fixed simulation clock and\n    moderately-to-very stiff dynamics. For adaptive stepping, use ``GEAR21``\n    or ``ESDIRK43``.\n\n    References\n    ----------\n    .. [1] Gear, C. W. (1971). \"Numerical Initial Value Problems in Ordinary\n           Differential Equations\". Prentice-Hall.\n    .. [2] Hairer, E., & Wanner, G. (1996). \"Solving Ordinary Differential\n           Equations II: Stiff and Differential-Algebraic Problems\". Springer\n           Series in Computational Mathematics, Vol. 14.\n           :doi:`10.1007/978-3-642-05221-7`\n\n    \"\"\"\n\n    def __init__(self, *solver_args, **solver_kwargs):\n        super().__init__(*solver_args, **solver_kwargs)\n\n        #integration order (local)\n        self.n = 2\n\n        #longer history for BDF\n        self.history = deque([], maxlen=2)",
          "bases": [
            "pathsim.solvers.bdf.BDF"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, *solver_args, **solver_kwargs):\n    super().__init__(*solver_args, **solver_kwargs)\n\n    #integration order (local)\n    self.n = 2\n\n    #longer history for BDF\n    self.history = deque([], maxlen=2)",
              "signature": "(solver_args = (), solver_kwargs = {})",
              "parameters": [
                {
                  "name": "solver_args",
                  "type": null,
                  "default": "()",
                  "description": ""
                },
                {
                  "name": "solver_kwargs",
                  "type": null,
                  "default": "{}",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "n",
              "description": "",
              "type": null,
              "value": "2"
            },
            {
              "name": "history",
              "description": "",
              "type": null,
              "value": "deque([], maxlen=2)"
            }
          ],
          "parameters": [
            {
              "name": "solver_args",
              "type": null,
              "default": "()",
              "description": ""
            },
            {
              "name": "solver_kwargs",
              "type": null,
              "default": "{}",
              "description": ""
            }
          ]
        },
        {
          "name": "BDF3",
          "description": "Fixed-step 3rd order BDF method. :math:`A(\\alpha)`-stable with",
          "docstring_html": "<p>Fixed-step 3rd order BDF method. <tt class=\"math\">A(\\alpha)</tt>-stable with\n<tt class=\"math\">\\alpha \\approx 86°</tt>.</p>\n<p>Uses <tt class=\"docutils literal\">DIRK3</tt> as startup solver for the first two steps.</p>\n<div class=\"section\" id=\"characteristics\">\n<h4>Characteristics</h4>\n<ul class=\"simple\">\n<li>Order: 3</li>\n<li>Implicit linear multistep, fixed timestep</li>\n<li><tt class=\"math\">A(\\alpha)</tt>-stable, <tt class=\"math\">\\alpha \\approx 86°</tt></li>\n</ul>\n</div>\n<div class=\"section\" id=\"note\">\n<h4>Note</h4>\n<p>Higher accuracy than <tt class=\"docutils literal\">BDF2</tt> with only a slight reduction in the\nstability wedge. The <tt class=\"math\">86°</tt> sector covers nearly the entire left\nhalf-plane, so most stiff block diagrams remain well-handled. For\nadaptive stepping, use <tt class=\"docutils literal\">GEAR32</tt>.</p>\n<p><strong>References</strong></p>\n<table class=\"docutils footnote\" frame=\"void\" id=\"footnote-1\" rules=\"none\">\n<colgroup><col class=\"label\" /><col /></colgroup>\n<tbody valign=\"top\">\n<tr><td class=\"label\">[1]</td><td>Gear, C. W. (1971). &quot;Numerical Initial Value Problems in Ordinary\nDifferential Equations&quot;. Prentice-Hall.</td></tr>\n</tbody>\n</table>\n<table class=\"docutils footnote\" frame=\"void\" id=\"footnote-2\" rules=\"none\">\n<colgroup><col class=\"label\" /><col /></colgroup>\n<tbody valign=\"top\">\n<tr><td class=\"label\">[2]</td><td>Hairer, E., &amp; Wanner, G. (1996). &quot;Solving Ordinary Differential\nEquations II: Stiff and Differential-Algebraic Problems&quot;. Springer\nSeries in Computational Mathematics, Vol. 14.\n:doi:`10.1007/978-3-642-05221-7`</td></tr>\n</tbody>\n</table>\n</div>\n",
          "source": "class BDF3(BDF):\n    \"\"\"Fixed-step 3rd order BDF method. :math:`A(\\\\alpha)`-stable with\n    :math:`\\\\alpha \\\\approx 86°`.\n\n    Uses ``DIRK3`` as startup solver for the first two steps.\n\n    Characteristics\n    ---------------\n    * Order: 3\n    * Implicit linear multistep, fixed timestep\n    * :math:`A(\\\\alpha)`-stable, :math:`\\\\alpha \\\\approx 86°`\n\n    Note\n    ----\n    Higher accuracy than ``BDF2`` with only a slight reduction in the\n    stability wedge. The :math:`86°` sector covers nearly the entire left\n    half-plane, so most stiff block diagrams remain well-handled. For\n    adaptive stepping, use ``GEAR32``.\n\n    References\n    ----------\n    .. [1] Gear, C. W. (1971). \"Numerical Initial Value Problems in Ordinary\n           Differential Equations\". Prentice-Hall.\n    .. [2] Hairer, E., & Wanner, G. (1996). \"Solving Ordinary Differential\n           Equations II: Stiff and Differential-Algebraic Problems\". Springer\n           Series in Computational Mathematics, Vol. 14.\n           :doi:`10.1007/978-3-642-05221-7`\n\n    \"\"\"\n\n    def __init__(self, *solver_args, **solver_kwargs):\n        super().__init__(*solver_args, **solver_kwargs)\n\n        #integration order (local)\n        self.n = 3\n\n        #longer history for BDF\n        self.history = deque([], maxlen=3)",
          "bases": [
            "pathsim.solvers.bdf.BDF"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, *solver_args, **solver_kwargs):\n    super().__init__(*solver_args, **solver_kwargs)\n\n    #integration order (local)\n    self.n = 3\n\n    #longer history for BDF\n    self.history = deque([], maxlen=3)",
              "signature": "(solver_args = (), solver_kwargs = {})",
              "parameters": [
                {
                  "name": "solver_args",
                  "type": null,
                  "default": "()",
                  "description": ""
                },
                {
                  "name": "solver_kwargs",
                  "type": null,
                  "default": "{}",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "n",
              "description": "",
              "type": null,
              "value": "3"
            },
            {
              "name": "history",
              "description": "",
              "type": null,
              "value": "deque([], maxlen=3)"
            }
          ],
          "parameters": [
            {
              "name": "solver_args",
              "type": null,
              "default": "()",
              "description": ""
            },
            {
              "name": "solver_kwargs",
              "type": null,
              "default": "{}",
              "description": ""
            }
          ]
        },
        {
          "name": "BDF4",
          "description": "Fixed-step 4th order BDF method. :math:`A(\\alpha)`-stable with",
          "docstring_html": "<p>Fixed-step 4th order BDF method. <tt class=\"math\">A(\\alpha)</tt>-stable with\n<tt class=\"math\">\\alpha \\approx 73°</tt>.</p>\n<p>Uses <tt class=\"docutils literal\">DIRK3</tt> as startup solver for the first three steps.</p>\n<div class=\"section\" id=\"characteristics\">\n<h4>Characteristics</h4>\n<ul class=\"simple\">\n<li>Order: 4</li>\n<li>Implicit linear multistep, fixed timestep</li>\n<li><tt class=\"math\">A(\\alpha)</tt>-stable, <tt class=\"math\">\\alpha \\approx 73°</tt></li>\n</ul>\n</div>\n<div class=\"section\" id=\"note\">\n<h4>Note</h4>\n<p>The narrower stability wedge compared to <tt class=\"docutils literal\">BDF2</tt>/<tt class=\"docutils literal\">BDF3</tt> means\neigenvalues close to the imaginary axis may be poorly damped. Safe for\nblock diagrams whose stiff modes are strongly dissipative (well inside\nthe left half-plane). For problems with near-imaginary eigenvalues (e.g.\nlightly damped oscillators), prefer lower-order BDF or an ESDIRK solver.</p>\n<p><strong>References</strong></p>\n<table class=\"docutils footnote\" frame=\"void\" id=\"footnote-1\" rules=\"none\">\n<colgroup><col class=\"label\" /><col /></colgroup>\n<tbody valign=\"top\">\n<tr><td class=\"label\">[1]</td><td>Gear, C. W. (1971). &quot;Numerical Initial Value Problems in Ordinary\nDifferential Equations&quot;. Prentice-Hall.</td></tr>\n</tbody>\n</table>\n<table class=\"docutils footnote\" frame=\"void\" id=\"footnote-2\" rules=\"none\">\n<colgroup><col class=\"label\" /><col /></colgroup>\n<tbody valign=\"top\">\n<tr><td class=\"label\">[2]</td><td>Hairer, E., &amp; Wanner, G. (1996). &quot;Solving Ordinary Differential\nEquations II: Stiff and Differential-Algebraic Problems&quot;. Springer\nSeries in Computational Mathematics, Vol. 14.\n:doi:`10.1007/978-3-642-05221-7`</td></tr>\n</tbody>\n</table>\n</div>\n",
          "source": "class BDF4(BDF):\n    \"\"\"Fixed-step 4th order BDF method. :math:`A(\\\\alpha)`-stable with\n    :math:`\\\\alpha \\\\approx 73°`.\n\n    Uses ``DIRK3`` as startup solver for the first three steps.\n\n    Characteristics\n    ---------------\n    * Order: 4\n    * Implicit linear multistep, fixed timestep\n    * :math:`A(\\\\alpha)`-stable, :math:`\\\\alpha \\\\approx 73°`\n\n    Note\n    ----\n    The narrower stability wedge compared to ``BDF2``/``BDF3`` means\n    eigenvalues close to the imaginary axis may be poorly damped. Safe for\n    block diagrams whose stiff modes are strongly dissipative (well inside\n    the left half-plane). For problems with near-imaginary eigenvalues (e.g.\n    lightly damped oscillators), prefer lower-order BDF or an ESDIRK solver.\n\n    References\n    ----------\n    .. [1] Gear, C. W. (1971). \"Numerical Initial Value Problems in Ordinary\n           Differential Equations\". Prentice-Hall.\n    .. [2] Hairer, E., & Wanner, G. (1996). \"Solving Ordinary Differential\n           Equations II: Stiff and Differential-Algebraic Problems\". Springer\n           Series in Computational Mathematics, Vol. 14.\n           :doi:`10.1007/978-3-642-05221-7`\n\n    \"\"\"\n\n    def __init__(self, *solver_args, **solver_kwargs):\n        super().__init__(*solver_args, **solver_kwargs)\n\n        #integration order (local)\n        self.n = 4\n\n        #longer history for BDF\n        self.history = deque([], maxlen=4)",
          "bases": [
            "pathsim.solvers.bdf.BDF"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, *solver_args, **solver_kwargs):\n    super().__init__(*solver_args, **solver_kwargs)\n\n    #integration order (local)\n    self.n = 4\n\n    #longer history for BDF\n    self.history = deque([], maxlen=4)",
              "signature": "(solver_args = (), solver_kwargs = {})",
              "parameters": [
                {
                  "name": "solver_args",
                  "type": null,
                  "default": "()",
                  "description": ""
                },
                {
                  "name": "solver_kwargs",
                  "type": null,
                  "default": "{}",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "n",
              "description": "",
              "type": null,
              "value": "4"
            },
            {
              "name": "history",
              "description": "",
              "type": null,
              "value": "deque([], maxlen=4)"
            }
          ],
          "parameters": [
            {
              "name": "solver_args",
              "type": null,
              "default": "()",
              "description": ""
            },
            {
              "name": "solver_kwargs",
              "type": null,
              "default": "{}",
              "description": ""
            }
          ]
        },
        {
          "name": "BDF5",
          "description": "Fixed-step 5th order BDF method. :math:`A(\\alpha)`-stable with",
          "docstring_html": "<p>Fixed-step 5th order BDF method. <tt class=\"math\">A(\\alpha)</tt>-stable with\n<tt class=\"math\">\\alpha \\approx 51°</tt>.</p>\n<p>Uses <tt class=\"docutils literal\">DIRK3</tt> as startup solver for the first four steps.</p>\n<div class=\"section\" id=\"characteristics\">\n<h4>Characteristics</h4>\n<ul class=\"simple\">\n<li>Order: 5</li>\n<li>Implicit linear multistep, fixed timestep</li>\n<li><tt class=\"math\">A(\\alpha)</tt>-stable, <tt class=\"math\">\\alpha \\approx 51°</tt></li>\n</ul>\n</div>\n<div class=\"section\" id=\"note\">\n<h4>Note</h4>\n<p>The stability wedge is noticeably smaller than <tt class=\"docutils literal\">BDF3</tt> or <tt class=\"docutils literal\">BDF4</tt>.\nOnly appropriate when the stiff eigenvalues of the block diagram are\nconcentrated well inside the left half-plane and high accuracy per step\nis essential. For most stiff systems, <tt class=\"docutils literal\">BDF2</tt> or <tt class=\"docutils literal\">BDF3</tt> with a\nsmaller timestep is more robust.</p>\n<p><strong>References</strong></p>\n<table class=\"docutils footnote\" frame=\"void\" id=\"footnote-1\" rules=\"none\">\n<colgroup><col class=\"label\" /><col /></colgroup>\n<tbody valign=\"top\">\n<tr><td class=\"label\">[1]</td><td>Gear, C. W. (1971). &quot;Numerical Initial Value Problems in Ordinary\nDifferential Equations&quot;. Prentice-Hall.</td></tr>\n</tbody>\n</table>\n<table class=\"docutils footnote\" frame=\"void\" id=\"footnote-2\" rules=\"none\">\n<colgroup><col class=\"label\" /><col /></colgroup>\n<tbody valign=\"top\">\n<tr><td class=\"label\">[2]</td><td>Hairer, E., &amp; Wanner, G. (1996). &quot;Solving Ordinary Differential\nEquations II: Stiff and Differential-Algebraic Problems&quot;. Springer\nSeries in Computational Mathematics, Vol. 14.\n:doi:`10.1007/978-3-642-05221-7`</td></tr>\n</tbody>\n</table>\n</div>\n",
          "source": "class BDF5(BDF):\n    \"\"\"Fixed-step 5th order BDF method. :math:`A(\\\\alpha)`-stable with\n    :math:`\\\\alpha \\\\approx 51°`.\n\n    Uses ``DIRK3`` as startup solver for the first four steps.\n\n    Characteristics\n    ---------------\n    * Order: 5\n    * Implicit linear multistep, fixed timestep\n    * :math:`A(\\\\alpha)`-stable, :math:`\\\\alpha \\\\approx 51°`\n\n    Note\n    ----\n    The stability wedge is noticeably smaller than ``BDF3`` or ``BDF4``.\n    Only appropriate when the stiff eigenvalues of the block diagram are\n    concentrated well inside the left half-plane and high accuracy per step\n    is essential. For most stiff systems, ``BDF2`` or ``BDF3`` with a\n    smaller timestep is more robust.\n\n    References\n    ----------\n    .. [1] Gear, C. W. (1971). \"Numerical Initial Value Problems in Ordinary\n           Differential Equations\". Prentice-Hall.\n    .. [2] Hairer, E., & Wanner, G. (1996). \"Solving Ordinary Differential\n           Equations II: Stiff and Differential-Algebraic Problems\". Springer\n           Series in Computational Mathematics, Vol. 14.\n           :doi:`10.1007/978-3-642-05221-7`\n\n    \"\"\"\n\n    def __init__(self, *solver_args, **solver_kwargs):\n        super().__init__(*solver_args, **solver_kwargs)\n\n        #integration order (local)\n        self.n = 5\n\n        #longer history for BDF\n        self.history = deque([], maxlen=5)",
          "bases": [
            "pathsim.solvers.bdf.BDF"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, *solver_args, **solver_kwargs):\n    super().__init__(*solver_args, **solver_kwargs)\n\n    #integration order (local)\n    self.n = 5\n\n    #longer history for BDF\n    self.history = deque([], maxlen=5)",
              "signature": "(solver_args = (), solver_kwargs = {})",
              "parameters": [
                {
                  "name": "solver_args",
                  "type": null,
                  "default": "()",
                  "description": ""
                },
                {
                  "name": "solver_kwargs",
                  "type": null,
                  "default": "{}",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "n",
              "description": "",
              "type": null,
              "value": "5"
            },
            {
              "name": "history",
              "description": "",
              "type": null,
              "value": "deque([], maxlen=5)"
            }
          ],
          "parameters": [
            {
              "name": "solver_args",
              "type": null,
              "default": "()",
              "description": ""
            },
            {
              "name": "solver_kwargs",
              "type": null,
              "default": "{}",
              "description": ""
            }
          ]
        },
        {
          "name": "BDF6",
          "description": "Fixed-step 6th order BDF method. **Not** A-stable",
          "docstring_html": "<p>Fixed-step 6th order BDF method. <strong>Not</strong> A-stable\n(<tt class=\"math\">\\alpha \\approx 18°</tt>).</p>\n<p>Uses <tt class=\"docutils literal\">DIRK3</tt> as startup solver for the first five steps.</p>\n<div class=\"section\" id=\"characteristics\">\n<h4>Characteristics</h4>\n<ul class=\"simple\">\n<li>Order: 6</li>\n<li>Implicit linear multistep, fixed timestep</li>\n<li><tt class=\"math\">A(\\alpha)</tt>-stable, <tt class=\"math\">\\alpha \\approx 18°</tt> (not A-stable)</li>\n</ul>\n</div>\n<div class=\"section\" id=\"note\">\n<h4>Note</h4>\n<p>The very narrow stability wedge means that most stiff problems will be\nunstable at practical timestep sizes. Provided mainly for completeness.\nFor 6th order accuracy on non-stiff systems, the explicit <tt class=\"docutils literal\">RKV65</tt> is\ncheaper. For stiff systems, <tt class=\"docutils literal\">BDF2</tt>--<tt class=\"docutils literal\">BDF4</tt> with a smaller timestep\nor an ESDIRK solver are far more robust.</p>\n<p><strong>References</strong></p>\n<table class=\"docutils footnote\" frame=\"void\" id=\"footnote-1\" rules=\"none\">\n<colgroup><col class=\"label\" /><col /></colgroup>\n<tbody valign=\"top\">\n<tr><td class=\"label\">[1]</td><td>Gear, C. W. (1971). &quot;Numerical Initial Value Problems in Ordinary\nDifferential Equations&quot;. Prentice-Hall.</td></tr>\n</tbody>\n</table>\n<table class=\"docutils footnote\" frame=\"void\" id=\"footnote-2\" rules=\"none\">\n<colgroup><col class=\"label\" /><col /></colgroup>\n<tbody valign=\"top\">\n<tr><td class=\"label\">[2]</td><td>Hairer, E., &amp; Wanner, G. (1996). &quot;Solving Ordinary Differential\nEquations II: Stiff and Differential-Algebraic Problems&quot;. Springer\nSeries in Computational Mathematics, Vol. 14.\n:doi:`10.1007/978-3-642-05221-7`</td></tr>\n</tbody>\n</table>\n</div>\n",
          "source": "class BDF6(BDF):\n    \"\"\"Fixed-step 6th order BDF method. **Not** A-stable\n    (:math:`\\\\alpha \\\\approx 18°`).\n\n    Uses ``DIRK3`` as startup solver for the first five steps.\n\n    Characteristics\n    ---------------\n    * Order: 6\n    * Implicit linear multistep, fixed timestep\n    * :math:`A(\\\\alpha)`-stable, :math:`\\\\alpha \\\\approx 18°` (not A-stable)\n\n    Note\n    ----\n    The very narrow stability wedge means that most stiff problems will be\n    unstable at practical timestep sizes. Provided mainly for completeness.\n    For 6th order accuracy on non-stiff systems, the explicit ``RKV65`` is\n    cheaper. For stiff systems, ``BDF2``--``BDF4`` with a smaller timestep\n    or an ESDIRK solver are far more robust.\n\n    References\n    ----------\n    .. [1] Gear, C. W. (1971). \"Numerical Initial Value Problems in Ordinary\n           Differential Equations\". Prentice-Hall.\n    .. [2] Hairer, E., & Wanner, G. (1996). \"Solving Ordinary Differential\n           Equations II: Stiff and Differential-Algebraic Problems\". Springer\n           Series in Computational Mathematics, Vol. 14.\n           :doi:`10.1007/978-3-642-05221-7`\n\n    \"\"\"\n\n    def __init__(self, *solver_args, **solver_kwargs):\n        super().__init__(*solver_args, **solver_kwargs)\n\n        #integration order (local)\n        self.n = 6\n\n        #longer history for BDF\n        self.history = deque([], maxlen=6)",
          "bases": [
            "pathsim.solvers.bdf.BDF"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, *solver_args, **solver_kwargs):\n    super().__init__(*solver_args, **solver_kwargs)\n\n    #integration order (local)\n    self.n = 6\n\n    #longer history for BDF\n    self.history = deque([], maxlen=6)",
              "signature": "(solver_args = (), solver_kwargs = {})",
              "parameters": [
                {
                  "name": "solver_args",
                  "type": null,
                  "default": "()",
                  "description": ""
                },
                {
                  "name": "solver_kwargs",
                  "type": null,
                  "default": "{}",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "n",
              "description": "",
              "type": null,
              "value": "6"
            },
            {
              "name": "history",
              "description": "",
              "type": null,
              "value": "deque([], maxlen=6)"
            }
          ],
          "parameters": [
            {
              "name": "solver_args",
              "type": null,
              "default": "()",
              "description": ""
            },
            {
              "name": "solver_kwargs",
              "type": null,
              "default": "{}",
              "description": ""
            }
          ]
        }
      ],
      "functions": []
    },
    "pathsim.solvers.dirk2": {
      "name": "pathsim.solvers.dirk2",
      "description": "",
      "docstring_html": "",
      "classes": [
        {
          "name": "DIRK2",
          "description": "Two-stage, 2nd order DIRK method. L-stable, SSP-optimal, symplectic.",
          "docstring_html": "<p>Two-stage, 2nd order DIRK method. L-stable, SSP-optimal, symplectic.</p>\n<div class=\"section\" id=\"characteristics\">\n<h4>Characteristics</h4>\n<ul class=\"simple\">\n<li>Order: 2</li>\n<li>Stages: 2 (implicit)</li>\n<li>Fixed timestep</li>\n<li>L-stable, SSP-optimal, symplectic</li>\n</ul>\n</div>\n<div class=\"section\" id=\"note\">\n<h4>Note</h4>\n<p>The simplest multi-stage implicit Runge-Kutta method. L-stability\nfully damps parasitic high-frequency modes, and the symplectic property\npreserves Hamiltonian structure when the dynamics are conservative. Two\nimplicit stages per step is relatively cheap. For higher accuracy on\nstiff systems, use <tt class=\"docutils literal\">DIRK3</tt> or the adaptive <tt class=\"docutils literal\">ESDIRK43</tt>.</p>\n<p><strong>References</strong></p>\n<table class=\"docutils footnote\" frame=\"void\" id=\"footnote-1\" rules=\"none\">\n<colgroup><col class=\"label\" /><col /></colgroup>\n<tbody valign=\"top\">\n<tr><td class=\"label\">[1]</td><td>Ferracina, L., &amp; Spijker, M. N. (2008). &quot;Strong stability of\nsingly-diagonally-implicit Runge-Kutta methods&quot;. Applied Numerical\nMathematics, 58(11), 1675-1686.\n:doi:`10.1016/j.apnum.2007.10.004`</td></tr>\n</tbody>\n</table>\n<table class=\"docutils footnote\" frame=\"void\" id=\"footnote-2\" rules=\"none\">\n<colgroup><col class=\"label\" /><col /></colgroup>\n<tbody valign=\"top\">\n<tr><td class=\"label\">[2]</td><td>Hairer, E., &amp; Wanner, G. (1996). &quot;Solving Ordinary Differential\nEquations II: Stiff and Differential-Algebraic Problems&quot;. Springer\nSeries in Computational Mathematics, Vol. 14.\n:doi:`10.1007/978-3-642-05221-7`</td></tr>\n</tbody>\n</table>\n</div>\n",
          "source": "class DIRK2(DiagonallyImplicitRungeKutta):\n    \"\"\"Two-stage, 2nd order DIRK method. L-stable, SSP-optimal, symplectic.\n\n    Characteristics\n    ---------------\n    * Order: 2\n    * Stages: 2 (implicit)\n    * Fixed timestep\n    * L-stable, SSP-optimal, symplectic\n\n    Note\n    ----\n    The simplest multi-stage implicit Runge-Kutta method. L-stability\n    fully damps parasitic high-frequency modes, and the symplectic property\n    preserves Hamiltonian structure when the dynamics are conservative. Two\n    implicit stages per step is relatively cheap. For higher accuracy on\n    stiff systems, use ``DIRK3`` or the adaptive ``ESDIRK43``.\n\n    References\n    ----------\n    .. [1] Ferracina, L., & Spijker, M. N. (2008). \"Strong stability of\n           singly-diagonally-implicit Runge-Kutta methods\". Applied Numerical\n           Mathematics, 58(11), 1675-1686.\n           :doi:`10.1016/j.apnum.2007.10.004`\n    .. [2] Hairer, E., & Wanner, G. (1996). \"Solving Ordinary Differential\n           Equations II: Stiff and Differential-Algebraic Problems\". Springer\n           Series in Computational Mathematics, Vol. 14.\n           :doi:`10.1007/978-3-642-05221-7`\n\n    \"\"\"\n\n    def __init__(self, *solver_args, **solver_kwargs):\n        super().__init__(*solver_args, **solver_kwargs)\n\n        #number of stages in RK scheme\n        self.s = 2\n\n        #order of scheme\n        self.n = 2\n\n        #intermediate evaluation times\n        self.eval_stages = [1/4, 3/4]\n\n        #butcher table\n        self.BT = {\n            0: [1/4],\n            1: [1/2, 1/4]\n            }\n\n        #final evaluation\n        self.A = [1/2, 1/2]",
          "bases": [
            "pathsim.solvers._rungekutta.DiagonallyImplicitRungeKutta"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, *solver_args, **solver_kwargs):\n    super().__init__(*solver_args, **solver_kwargs)\n\n    #number of stages in RK scheme\n    self.s = 2\n\n    #order of scheme\n    self.n = 2\n\n    #intermediate evaluation times\n    self.eval_stages = [1/4, 3/4]\n\n    #butcher table\n    self.BT = {\n        0: [1/4],\n        1: [1/2, 1/4]\n        }\n\n    #final evaluation\n    self.A = [1/2, 1/2]",
              "signature": "(solver_args = (), solver_kwargs = {})",
              "parameters": [
                {
                  "name": "solver_args",
                  "type": null,
                  "default": "()",
                  "description": ""
                },
                {
                  "name": "solver_kwargs",
                  "type": null,
                  "default": "{}",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "s",
              "description": "",
              "type": null,
              "value": "2"
            },
            {
              "name": "n",
              "description": "",
              "type": null,
              "value": "2"
            },
            {
              "name": "eval_stages",
              "description": "",
              "type": null,
              "value": "[1 / 4, 3 / 4]"
            },
            {
              "name": "BT",
              "description": "",
              "type": null,
              "value": "{0: [1 / 4], 1: [1 / 2, 1 / 4]}"
            },
            {
              "name": "A",
              "description": "",
              "type": null,
              "value": "[1 / 2, 1 / 2]"
            }
          ],
          "parameters": [
            {
              "name": "solver_args",
              "type": null,
              "default": "()",
              "description": ""
            },
            {
              "name": "solver_kwargs",
              "type": null,
              "default": "{}",
              "description": ""
            }
          ]
        }
      ],
      "functions": []
    },
    "pathsim.solvers.dirk3": {
      "name": "pathsim.solvers.dirk3",
      "description": "",
      "docstring_html": "",
      "classes": [
        {
          "name": "DIRK3",
          "description": "Four-stage, 3rd order L-stable DIRK method. Stiffly accurate.",
          "docstring_html": "<p>Four-stage, 3rd order L-stable DIRK method. Stiffly accurate.</p>\n<p>L-stability (<tt class=\"math\">|R(\\infty)| = 0</tt>) fully damps parasitic\nhigh-frequency modes. The stiffly accurate property ensures the last\nstage equals the step output, which is beneficial for\ndifferential-algebraic systems.</p>\n<div class=\"section\" id=\"characteristics\">\n<h4>Characteristics</h4>\n<ul class=\"simple\">\n<li>Order: 3</li>\n<li>Stages: 4 (implicit)</li>\n<li>Fixed timestep</li>\n<li>L-stable, stiffly accurate</li>\n</ul>\n</div>\n<div class=\"section\" id=\"note\">\n<h4>Note</h4>\n<p>A robust fixed-step solver for stiff block diagrams. L-stability makes\nit well-suited for systems with widely separated time scales, such as a\nfast electrical subsystem driving a slow thermal or mechanical model.\nAlso used internally as the startup method for <tt class=\"docutils literal\">BDF</tt> solvers. For\nadaptive stepping on stiff problems, prefer <tt class=\"docutils literal\">ESDIRK43</tt>.</p>\n<p><strong>References</strong></p>\n<table class=\"docutils footnote\" frame=\"void\" id=\"footnote-1\" rules=\"none\">\n<colgroup><col class=\"label\" /><col /></colgroup>\n<tbody valign=\"top\">\n<tr><td class=\"label\">[1]</td><td>Alexander, R. (1977). &quot;Diagonally implicit Runge-Kutta methods\nfor stiff O.D.E.'s&quot;. SIAM Journal on Numerical Analysis, 14(6),\n1006-1021. :doi:`10.1137/0714068`</td></tr>\n</tbody>\n</table>\n<table class=\"docutils footnote\" frame=\"void\" id=\"footnote-2\" rules=\"none\">\n<colgroup><col class=\"label\" /><col /></colgroup>\n<tbody valign=\"top\">\n<tr><td class=\"label\">[2]</td><td>Hairer, E., &amp; Wanner, G. (1996). &quot;Solving Ordinary Differential\nEquations II: Stiff and Differential-Algebraic Problems&quot;. Springer\nSeries in Computational Mathematics, Vol. 14.\n:doi:`10.1007/978-3-642-05221-7`</td></tr>\n</tbody>\n</table>\n</div>\n",
          "source": "class DIRK3(DiagonallyImplicitRungeKutta):\n    \"\"\"Four-stage, 3rd order L-stable DIRK method. Stiffly accurate.\n\n    L-stability (:math:`|R(\\\\infty)| = 0`) fully damps parasitic\n    high-frequency modes. The stiffly accurate property ensures the last\n    stage equals the step output, which is beneficial for\n    differential-algebraic systems.\n\n    Characteristics\n    ---------------\n    * Order: 3\n    * Stages: 4 (implicit)\n    * Fixed timestep\n    * L-stable, stiffly accurate\n\n    Note\n    ----\n    A robust fixed-step solver for stiff block diagrams. L-stability makes\n    it well-suited for systems with widely separated time scales, such as a\n    fast electrical subsystem driving a slow thermal or mechanical model.\n    Also used internally as the startup method for ``BDF`` solvers. For\n    adaptive stepping on stiff problems, prefer ``ESDIRK43``.\n\n    References\n    ----------\n    .. [1] Alexander, R. (1977). \"Diagonally implicit Runge-Kutta methods\n           for stiff O.D.E.'s\". SIAM Journal on Numerical Analysis, 14(6),\n           1006-1021. :doi:`10.1137/0714068`\n    .. [2] Hairer, E., & Wanner, G. (1996). \"Solving Ordinary Differential\n           Equations II: Stiff and Differential-Algebraic Problems\". Springer\n           Series in Computational Mathematics, Vol. 14.\n           :doi:`10.1007/978-3-642-05221-7`\n\n    \"\"\"\n\n    def __init__(self, *solver_args, **solver_kwargs):\n        super().__init__(*solver_args, **solver_kwargs)\n\n        #number of stages in RK scheme\n        self.s = 4\n\n        #order of scheme\n        self.n = 3\n\n        #intermediate evaluation times\n        self.eval_stages = [1/2, 2/3, 1/2, 1.0]\n\n        #butcher table\n        self.BT = {\n            0: [1/2],\n            1: [1/6, 1/2], \n            2: [-1/2, 1/2, 1/2], \n            3: [3/2, -3/2, 1/2, 1/2]\n            }",
          "bases": [
            "pathsim.solvers._rungekutta.DiagonallyImplicitRungeKutta"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, *solver_args, **solver_kwargs):\n    super().__init__(*solver_args, **solver_kwargs)\n\n    #number of stages in RK scheme\n    self.s = 4\n\n    #order of scheme\n    self.n = 3\n\n    #intermediate evaluation times\n    self.eval_stages = [1/2, 2/3, 1/2, 1.0]\n\n    #butcher table\n    self.BT = {\n        0: [1/2],\n        1: [1/6, 1/2], \n        2: [-1/2, 1/2, 1/2], \n        3: [3/2, -3/2, 1/2, 1/2]\n        }",
              "signature": "(solver_args = (), solver_kwargs = {})",
              "parameters": [
                {
                  "name": "solver_args",
                  "type": null,
                  "default": "()",
                  "description": ""
                },
                {
                  "name": "solver_kwargs",
                  "type": null,
                  "default": "{}",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "s",
              "description": "",
              "type": null,
              "value": "4"
            },
            {
              "name": "n",
              "description": "",
              "type": null,
              "value": "3"
            },
            {
              "name": "eval_stages",
              "description": "",
              "type": null,
              "value": "[1 / 2, 2 / 3, 1 / 2, 1.0]"
            },
            {
              "name": "BT",
              "description": "",
              "type": null,
              "value": "{0: [1 / 2], 1: [1 / 6, 1 / 2], 2: [-1 / 2, 1 / 2, 1 / 2], 3: [3 / 2, -3 / 2, 1 / 2, 1 / 2]}"
            }
          ],
          "parameters": [
            {
              "name": "solver_args",
              "type": null,
              "default": "()",
              "description": ""
            },
            {
              "name": "solver_kwargs",
              "type": null,
              "default": "{}",
              "description": ""
            }
          ]
        }
      ],
      "functions": []
    },
    "pathsim.solvers.esdirk32": {
      "name": "pathsim.solvers.esdirk32",
      "description": "",
      "docstring_html": "",
      "classes": [
        {
          "name": "ESDIRK32",
          "description": "Four-stage, 3rd order ESDIRK method with embedded 2nd order error",
          "docstring_html": "<p>Four-stage, 3rd order ESDIRK method with embedded 2nd order error\nestimate. L-stable and stiffly accurate.</p>\n<div class=\"section\" id=\"characteristics\">\n<h4>Characteristics</h4>\n<ul class=\"simple\">\n<li>Order: 3 (propagating) / 2 (embedded)</li>\n<li>Stages: 4 (1 explicit, 3 implicit)</li>\n<li>Adaptive timestep</li>\n<li>L-stable, stiffly accurate</li>\n<li>Stage order 2 (<tt class=\"math\">\\gamma = 1/2</tt>)</li>\n</ul>\n</div>\n<div class=\"section\" id=\"note\">\n<h4>Note</h4>\n<p>The cheapest adaptive implicit Runge-Kutta solver in this library,\nyet remarkably robust.  L-stability and stiff accuracy guarantee that\nhigh-frequency parasitic modes are fully damped regardless of\ntimestep, and the optimal stage order of 2 (from <tt class=\"math\">\\gamma = 1/2</tt>)\nminimises order reduction on stiff problems.  Three implicit stages\nper step keeps the cost well below <tt class=\"docutils literal\">ESDIRK43</tt> while still providing\nadaptive step-size control.  For even lower per-step cost the\n<tt class=\"docutils literal\">GEAR</tt> multistep solvers require only one implicit solve per step.\nAlso used internally as the startup method for <tt class=\"docutils literal\">GEAR</tt> solvers.</p>\n<p><strong>References</strong></p>\n<table class=\"docutils footnote\" frame=\"void\" id=\"footnote-1\" rules=\"none\">\n<colgroup><col class=\"label\" /><col /></colgroup>\n<tbody valign=\"top\">\n<tr><td class=\"label\">[1]</td><td>Kennedy, C. A., &amp; Carpenter, M. H. (2019). &quot;Diagonally implicit\nRunge-Kutta methods for stiff ODEs&quot;. Applied Numerical\nMathematics, 146, 221-244.\n:doi:`10.1016/j.apnum.2019.07.008`</td></tr>\n</tbody>\n</table>\n<table class=\"docutils footnote\" frame=\"void\" id=\"footnote-2\" rules=\"none\">\n<colgroup><col class=\"label\" /><col /></colgroup>\n<tbody valign=\"top\">\n<tr><td class=\"label\">[2]</td><td>Hairer, E., &amp; Wanner, G. (1996). &quot;Solving Ordinary Differential\nEquations II: Stiff and Differential-Algebraic Problems&quot;. Springer\nSeries in Computational Mathematics, Vol. 14.\n:doi:`10.1007/978-3-642-05221-7`</td></tr>\n</tbody>\n</table>\n</div>\n",
          "source": "class ESDIRK32(DiagonallyImplicitRungeKutta):\n    \"\"\"Four-stage, 3rd order ESDIRK method with embedded 2nd order error\n    estimate. L-stable and stiffly accurate.\n\n    Characteristics\n    ---------------\n    * Order: 3 (propagating) / 2 (embedded)\n    * Stages: 4 (1 explicit, 3 implicit)\n    * Adaptive timestep\n    * L-stable, stiffly accurate\n    * Stage order 2 (:math:`\\\\gamma = 1/2`)\n\n    Note\n    ----\n    The cheapest adaptive implicit Runge-Kutta solver in this library,\n    yet remarkably robust.  L-stability and stiff accuracy guarantee that\n    high-frequency parasitic modes are fully damped regardless of\n    timestep, and the optimal stage order of 2 (from :math:`\\\\gamma = 1/2`)\n    minimises order reduction on stiff problems.  Three implicit stages\n    per step keeps the cost well below ``ESDIRK43`` while still providing\n    adaptive step-size control.  For even lower per-step cost the\n    ``GEAR`` multistep solvers require only one implicit solve per step.\n    Also used internally as the startup method for ``GEAR`` solvers.\n\n    References\n    ----------\n    .. [1] Kennedy, C. A., & Carpenter, M. H. (2019). \"Diagonally implicit\n           Runge-Kutta methods for stiff ODEs\". Applied Numerical\n           Mathematics, 146, 221-244.\n           :doi:`10.1016/j.apnum.2019.07.008`\n    .. [2] Hairer, E., & Wanner, G. (1996). \"Solving Ordinary Differential\n           Equations II: Stiff and Differential-Algebraic Problems\". Springer\n           Series in Computational Mathematics, Vol. 14.\n           :doi:`10.1007/978-3-642-05221-7`\n\n    \"\"\"\n\n    def __init__(self, *solver_args, **solver_kwargs):\n        super().__init__(*solver_args, **solver_kwargs)\n\n        #number of stages in RK scheme\n        self.s = 4\n\n        #order of scheme and embedded method\n        self.n = 3\n        self.m = 2\n\n        #flag adaptive timestep solver\n        self.is_adaptive = True\n\n        #intermediate evaluation times\n        self.eval_stages = [0.0, 1.0, 3/2, 1.0]\n\n        #butcher table\n        self.BT = {\n            0: None,      #explicit first stage\n            1: [1/2, 1/2],\n            2: [5/8, 3/8, 1/2],\n            3: [7/18, 1/3, -2/9, 1/2]\n            }\n\n        #coefficients for truncation error estimate\n        self.TR = [-1/9, -1/6, -2/9, 1/2]",
          "bases": [
            "pathsim.solvers._rungekutta.DiagonallyImplicitRungeKutta"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, *solver_args, **solver_kwargs):\n    super().__init__(*solver_args, **solver_kwargs)\n\n    #number of stages in RK scheme\n    self.s = 4\n\n    #order of scheme and embedded method\n    self.n = 3\n    self.m = 2\n\n    #flag adaptive timestep solver\n    self.is_adaptive = True\n\n    #intermediate evaluation times\n    self.eval_stages = [0.0, 1.0, 3/2, 1.0]\n\n    #butcher table\n    self.BT = {\n        0: None,      #explicit first stage\n        1: [1/2, 1/2],\n        2: [5/8, 3/8, 1/2],\n        3: [7/18, 1/3, -2/9, 1/2]\n        }\n\n    #coefficients for truncation error estimate\n    self.TR = [-1/9, -1/6, -2/9, 1/2]",
              "signature": "(solver_args = (), solver_kwargs = {})",
              "parameters": [
                {
                  "name": "solver_args",
                  "type": null,
                  "default": "()",
                  "description": ""
                },
                {
                  "name": "solver_kwargs",
                  "type": null,
                  "default": "{}",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "s",
              "description": "",
              "type": null,
              "value": "4"
            },
            {
              "name": "n",
              "description": "",
              "type": null,
              "value": "3"
            },
            {
              "name": "m",
              "description": "",
              "type": null,
              "value": "2"
            },
            {
              "name": "is_adaptive",
              "description": "",
              "type": null,
              "value": "True"
            },
            {
              "name": "eval_stages",
              "description": "",
              "type": null,
              "value": "[0.0, 1.0, 3 / 2, 1.0]"
            },
            {
              "name": "BT",
              "description": "",
              "type": null,
              "value": "{0: None, 1: [1 / 2, 1 / 2], 2: [5 / 8, 3 / 8, 1 / 2], 3: [7 / 18, 1 / 3, -2 / 9, 1 / 2]}"
            },
            {
              "name": "TR",
              "description": "",
              "type": null,
              "value": "[-1 / 9, -1 / 6, -2 / 9, 1 / 2]"
            }
          ],
          "parameters": [
            {
              "name": "solver_args",
              "type": null,
              "default": "()",
              "description": ""
            },
            {
              "name": "solver_kwargs",
              "type": null,
              "default": "{}",
              "description": ""
            }
          ]
        }
      ],
      "functions": []
    },
    "pathsim.solvers.esdirk4": {
      "name": "pathsim.solvers.esdirk4",
      "description": "",
      "docstring_html": "",
      "classes": [
        {
          "name": "ESDIRK4",
          "description": "Six-stage, 4th order ESDIRK method. L-stable and stiffly accurate.",
          "docstring_html": "<p>Six-stage, 4th order ESDIRK method. L-stable and stiffly accurate.</p>\n<p>No embedded error estimator; fixed timestep only.</p>\n<div class=\"section\" id=\"characteristics\">\n<h4>Characteristics</h4>\n<ul class=\"simple\">\n<li>Order: 4</li>\n<li>Stages: 6 (1 explicit, 5 implicit)</li>\n<li>Fixed timestep</li>\n<li>L-stable, stiffly accurate</li>\n<li>Stage order 2</li>\n</ul>\n</div>\n<div class=\"section\" id=\"note\">\n<h4>Note</h4>\n<p>Provides 4th order accuracy on stiff block diagrams when the timestep is\npredetermined (e.g. real-time or hardware-in-the-loop contexts). The\nexplicit first stage reuses the last function evaluation from the\nprevious step, saving one implicit solve per step compared to a fully\nimplicit DIRK. L-stability and stiff accuracy ensure full damping of\nparasitic high-frequency modes. For adaptive stepping, use <tt class=\"docutils literal\">ESDIRK43</tt>\nwhich adds an embedded error estimator at the same stage count.</p>\n<p><strong>References</strong></p>\n<table class=\"docutils footnote\" frame=\"void\" id=\"footnote-1\" rules=\"none\">\n<colgroup><col class=\"label\" /><col /></colgroup>\n<tbody valign=\"top\">\n<tr><td class=\"label\">[1]</td><td>Kennedy, C. A., &amp; Carpenter, M. H. (2016). &quot;Diagonally implicit\nRunge-Kutta methods for ordinary differential equations. A\nreview&quot;. NASA/TM-2016-219173.</td></tr>\n</tbody>\n</table>\n<table class=\"docutils footnote\" frame=\"void\" id=\"footnote-2\" rules=\"none\">\n<colgroup><col class=\"label\" /><col /></colgroup>\n<tbody valign=\"top\">\n<tr><td class=\"label\">[2]</td><td>Hairer, E., &amp; Wanner, G. (1996). &quot;Solving Ordinary Differential\nEquations II: Stiff and Differential-Algebraic Problems&quot;. Springer\nSeries in Computational Mathematics, Vol. 14.\n:doi:`10.1007/978-3-642-05221-7`</td></tr>\n</tbody>\n</table>\n</div>\n",
          "source": "class ESDIRK4(DiagonallyImplicitRungeKutta):\n    \"\"\"Six-stage, 4th order ESDIRK method. L-stable and stiffly accurate.\n\n    No embedded error estimator; fixed timestep only.\n\n    Characteristics\n    ---------------\n    * Order: 4\n    * Stages: 6 (1 explicit, 5 implicit)\n    * Fixed timestep\n    * L-stable, stiffly accurate\n    * Stage order 2\n\n    Note\n    ----\n    Provides 4th order accuracy on stiff block diagrams when the timestep is\n    predetermined (e.g. real-time or hardware-in-the-loop contexts). The\n    explicit first stage reuses the last function evaluation from the\n    previous step, saving one implicit solve per step compared to a fully\n    implicit DIRK. L-stability and stiff accuracy ensure full damping of\n    parasitic high-frequency modes. For adaptive stepping, use ``ESDIRK43``\n    which adds an embedded error estimator at the same stage count.\n\n    References\n    ----------\n    .. [1] Kennedy, C. A., & Carpenter, M. H. (2016). \"Diagonally implicit\n           Runge-Kutta methods for ordinary differential equations. A\n           review\". NASA/TM-2016-219173.\n    .. [2] Hairer, E., & Wanner, G. (1996). \"Solving Ordinary Differential\n           Equations II: Stiff and Differential-Algebraic Problems\". Springer\n           Series in Computational Mathematics, Vol. 14.\n           :doi:`10.1007/978-3-642-05221-7`\n\n    \"\"\"\n\n    def __init__(self, *solver_args, **solver_kwargs):\n        super().__init__(*solver_args, **solver_kwargs)\n\n        #number of stages in RK scheme\n        self.s = 6\n\n        #order of scheme\n        self.n = 4\n\n        #intermediate evaluation times\n        self.eval_stages = [\n            0.0, 1/2, 1/6, 37/40, 1/2, 1.0\n            ]\n\n        #butcher table\n        self.BT = {\n            0: None, #explicit first stage\n            1: [1/4, 1/4],\n            2: [-1/36, -1/18, 1/4],\n            3: [-21283/32000, -5143/64000, 90909/64000, 1/4],\n            4: [46010759/749250000, -737693/40500000, 10931269/45500000, -1140071/34090875, 1/4],\n            5: [89/444, 89/804756, -27/364, -20000/171717, 843750/1140071, 1/4]\n            }",
          "bases": [
            "pathsim.solvers._rungekutta.DiagonallyImplicitRungeKutta"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, *solver_args, **solver_kwargs):\n    super().__init__(*solver_args, **solver_kwargs)\n\n    #number of stages in RK scheme\n    self.s = 6\n\n    #order of scheme\n    self.n = 4\n\n    #intermediate evaluation times\n    self.eval_stages = [\n        0.0, 1/2, 1/6, 37/40, 1/2, 1.0\n        ]\n\n    #butcher table\n    self.BT = {\n        0: None, #explicit first stage\n        1: [1/4, 1/4],\n        2: [-1/36, -1/18, 1/4],\n        3: [-21283/32000, -5143/64000, 90909/64000, 1/4],\n        4: [46010759/749250000, -737693/40500000, 10931269/45500000, -1140071/34090875, 1/4],\n        5: [89/444, 89/804756, -27/364, -20000/171717, 843750/1140071, 1/4]\n        }",
              "signature": "(solver_args = (), solver_kwargs = {})",
              "parameters": [
                {
                  "name": "solver_args",
                  "type": null,
                  "default": "()",
                  "description": ""
                },
                {
                  "name": "solver_kwargs",
                  "type": null,
                  "default": "{}",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "s",
              "description": "",
              "type": null,
              "value": "6"
            },
            {
              "name": "n",
              "description": "",
              "type": null,
              "value": "4"
            },
            {
              "name": "eval_stages",
              "description": "",
              "type": null,
              "value": "[0.0, 1 / 2, 1 / 6, 37 / 40, 1 / 2, 1.0]"
            },
            {
              "name": "BT",
              "description": "",
              "type": null,
              "value": "{0: None, 1: [1 / 4, 1 / 4], 2: [-1 / 36, -1 / 18, 1 / 4], 3: [-21283 / 32000, -5143 / 64000, 90909 / 64000, 1 / 4], 4: [46010759 / 749250000, -737693 / 40500000, 10931269 / 45500000, -1140071 / 34090875, 1 / 4], 5: [89 / 444, 89 / 804756, -27 / 364, -20000 / 171717, 843750 / 1140071, 1 / 4]}"
            }
          ],
          "parameters": [
            {
              "name": "solver_args",
              "type": null,
              "default": "()",
              "description": ""
            },
            {
              "name": "solver_kwargs",
              "type": null,
              "default": "{}",
              "description": ""
            }
          ]
        }
      ],
      "functions": []
    },
    "pathsim.solvers.esdirk43": {
      "name": "pathsim.solvers.esdirk43",
      "description": "",
      "docstring_html": "",
      "classes": [
        {
          "name": "ESDIRK43",
          "description": "Six-stage, 4th order ESDIRK method with embedded 3rd order error",
          "docstring_html": "<p>Six-stage, 4th order ESDIRK method with embedded 3rd order error\nestimate. L-stable and stiffly accurate.</p>\n<div class=\"section\" id=\"characteristics\">\n<h4>Characteristics</h4>\n<ul class=\"simple\">\n<li>Order: 4 (propagating) / 3 (embedded)</li>\n<li>Stages: 6 (1 explicit, 5 implicit)</li>\n<li>Adaptive timestep</li>\n<li>L-stable, stiffly accurate</li>\n<li>Stage order 2</li>\n</ul>\n</div>\n<div class=\"section\" id=\"note\">\n<h4>Note</h4>\n<p>Recommended default for stiff block diagrams. L-stability damps\nhigh-frequency parasitic modes that arise from stiff subsystems (e.g.\nPID controllers with large derivative gain, fast electrical or chemical\ndynamics). The adaptive step-size control concentrates computational\neffort where the solution changes rapidly. For non-stiff systems,\n<tt class=\"docutils literal\">RKDP54</tt> avoids the implicit solve cost and is more efficient. For\ntighter tolerances on stiff problems, <tt class=\"docutils literal\">ESDIRK54</tt> provides 5th order\naccuracy.</p>\n<p><strong>References</strong></p>\n<table class=\"docutils footnote\" frame=\"void\" id=\"footnote-1\" rules=\"none\">\n<colgroup><col class=\"label\" /><col /></colgroup>\n<tbody valign=\"top\">\n<tr><td class=\"label\">[1]</td><td>Kennedy, C. A., &amp; Carpenter, M. H. (2019). &quot;Diagonally implicit\nRunge-Kutta methods for stiff ODEs&quot;. Applied Numerical\nMathematics, 146, 221-244.\n:doi:`10.1016/j.apnum.2019.07.008`</td></tr>\n</tbody>\n</table>\n<table class=\"docutils footnote\" frame=\"void\" id=\"footnote-2\" rules=\"none\">\n<colgroup><col class=\"label\" /><col /></colgroup>\n<tbody valign=\"top\">\n<tr><td class=\"label\">[2]</td><td>Hairer, E., &amp; Wanner, G. (1996). &quot;Solving Ordinary Differential\nEquations II: Stiff and Differential-Algebraic Problems&quot;. Springer\nSeries in Computational Mathematics, Vol. 14.\n:doi:`10.1007/978-3-642-05221-7`</td></tr>\n</tbody>\n</table>\n</div>\n",
          "source": "class ESDIRK43(DiagonallyImplicitRungeKutta):\n    \"\"\"Six-stage, 4th order ESDIRK method with embedded 3rd order error\n    estimate. L-stable and stiffly accurate.\n\n    Characteristics\n    ---------------\n    * Order: 4 (propagating) / 3 (embedded)\n    * Stages: 6 (1 explicit, 5 implicit)\n    * Adaptive timestep\n    * L-stable, stiffly accurate\n    * Stage order 2\n\n    Note\n    ----\n    Recommended default for stiff block diagrams. L-stability damps\n    high-frequency parasitic modes that arise from stiff subsystems (e.g.\n    PID controllers with large derivative gain, fast electrical or chemical\n    dynamics). The adaptive step-size control concentrates computational\n    effort where the solution changes rapidly. For non-stiff systems,\n    ``RKDP54`` avoids the implicit solve cost and is more efficient. For\n    tighter tolerances on stiff problems, ``ESDIRK54`` provides 5th order\n    accuracy.\n\n    References\n    ----------\n    .. [1] Kennedy, C. A., & Carpenter, M. H. (2019). \"Diagonally implicit\n           Runge-Kutta methods for stiff ODEs\". Applied Numerical\n           Mathematics, 146, 221-244.\n           :doi:`10.1016/j.apnum.2019.07.008`\n    .. [2] Hairer, E., & Wanner, G. (1996). \"Solving Ordinary Differential\n           Equations II: Stiff and Differential-Algebraic Problems\". Springer\n           Series in Computational Mathematics, Vol. 14.\n           :doi:`10.1007/978-3-642-05221-7`\n\n    \"\"\"\n\n    def __init__(self, *solver_args, **solver_kwargs):\n        super().__init__(*solver_args, **solver_kwargs)\n\n        #number of stages in RK scheme\n        self.s = 6\n\n        #order of scheme and embedded method\n        self.n = 4\n        self.m = 3\n\n        #flag adaptive timestep solver\n        self.is_adaptive = True\n\n        #intermediate evaluation times\n        self.eval_stages = [0.0, 1/2, (2-np.sqrt(2))/4, 2012122486997/3467029789466, 1.0, 1.0]\n\n        #butcher table\n        self.BT = {\n            0: None, # explicit first stage\n            1: [1/4, 1/4],\n            2: [-1356991263433/26208533697614, -1356991263433/26208533697614, 1/4],\n            3: [-1778551891173/14697912885533, -1778551891173/14697912885533, \n                7325038566068/12797657924939, 1/4],\n            4: [-24076725932807/39344244018142, -24076725932807/39344244018142, \n                9344023789330/6876721947151, 11302510524611/18374767399840, 1/4],\n            5: [657241292721/9909463049845, 657241292721/9909463049845, \n                1290772910128/5804808736437, 1103522341516/2197678446715, -3/28, 1/4]\n            }\n\n        #coefficients for truncation error estimate\n        _A1 = [\n            657241292721/9909463049845, 657241292721/9909463049845, \n            1290772910128/5804808736437, 1103522341516/2197678446715, -3/28, 1/4\n            ]\n        _A2 = [\n            -71925161075/3900939759889, -71925161075/3900939759889, \n            2973346383745/8160025745289, 3972464885073/7694851252693, \n            -263368882881/4213126269514, 3295468053953/15064441987965\n            ]\n        self.TR = [a1 - a2 for a1, a2 in zip(_A1, _A2)]",
          "bases": [
            "pathsim.solvers._rungekutta.DiagonallyImplicitRungeKutta"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, *solver_args, **solver_kwargs):\n    super().__init__(*solver_args, **solver_kwargs)\n\n    #number of stages in RK scheme\n    self.s = 6\n\n    #order of scheme and embedded method\n    self.n = 4\n    self.m = 3\n\n    #flag adaptive timestep solver\n    self.is_adaptive = True\n\n    #intermediate evaluation times\n    self.eval_stages = [0.0, 1/2, (2-np.sqrt(2))/4, 2012122486997/3467029789466, 1.0, 1.0]\n\n    #butcher table\n    self.BT = {\n        0: None, # explicit first stage\n        1: [1/4, 1/4],\n        2: [-1356991263433/26208533697614, -1356991263433/26208533697614, 1/4],\n        3: [-1778551891173/14697912885533, -1778551891173/14697912885533, \n            7325038566068/12797657924939, 1/4],\n        4: [-24076725932807/39344244018142, -24076725932807/39344244018142, \n            9344023789330/6876721947151, 11302510524611/18374767399840, 1/4],\n        5: [657241292721/9909463049845, 657241292721/9909463049845, \n            1290772910128/5804808736437, 1103522341516/2197678446715, -3/28, 1/4]\n        }\n\n    #coefficients for truncation error estimate\n    _A1 = [\n        657241292721/9909463049845, 657241292721/9909463049845, \n        1290772910128/5804808736437, 1103522341516/2197678446715, -3/28, 1/4\n        ]\n    _A2 = [\n        -71925161075/3900939759889, -71925161075/3900939759889, \n        2973346383745/8160025745289, 3972464885073/7694851252693, \n        -263368882881/4213126269514, 3295468053953/15064441987965\n        ]\n    self.TR = [a1 - a2 for a1, a2 in zip(_A1, _A2)]",
              "signature": "(solver_args = (), solver_kwargs = {})",
              "parameters": [
                {
                  "name": "solver_args",
                  "type": null,
                  "default": "()",
                  "description": ""
                },
                {
                  "name": "solver_kwargs",
                  "type": null,
                  "default": "{}",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "s",
              "description": "",
              "type": null,
              "value": "6"
            },
            {
              "name": "n",
              "description": "",
              "type": null,
              "value": "4"
            },
            {
              "name": "m",
              "description": "",
              "type": null,
              "value": "3"
            },
            {
              "name": "is_adaptive",
              "description": "",
              "type": null,
              "value": "True"
            },
            {
              "name": "eval_stages",
              "description": "",
              "type": null,
              "value": "[0.0, 1 / 2, (2 - np.sqrt(2)) / 4, 2012122486997 / 3467029789466, 1.0, 1.0]"
            },
            {
              "name": "BT",
              "description": "",
              "type": null,
              "value": "{0: None, 1: [1 / 4, 1 / 4], 2: [-1356991263433 / 26208533697614, -1356991263433 / 26208533697614, 1 / 4], 3: [-1778551891173 / 14697912885533, -1778551891173 / 14697912885533, 7325038566068 / 12797657924939, 1 / 4], 4: [-24076725932807 / 39344244018142, -24076725932807 / 39344244018142, 9344023789330 / 6876721947151, 11302510524611 / 18374767399840, 1 / 4], 5: [657241292721 / 9909463049845, 657241292721 / 9909463049845, 1290772910128 / 5804808736437, 1103522341516 / 2197678446715, -3 / 28, 1 / 4]}"
            },
            {
              "name": "TR",
              "description": "",
              "type": null,
              "value": "[(a1 - a2) for a1, a2 in (zip(_A1, _A2))]"
            }
          ],
          "parameters": [
            {
              "name": "solver_args",
              "type": null,
              "default": "()",
              "description": ""
            },
            {
              "name": "solver_kwargs",
              "type": null,
              "default": "{}",
              "description": ""
            }
          ]
        }
      ],
      "functions": []
    },
    "pathsim.solvers.esdirk54": {
      "name": "pathsim.solvers.esdirk54",
      "description": "",
      "docstring_html": "",
      "classes": [
        {
          "name": "ESDIRK54",
          "description": "Seven-stage, 5th order ESDIRK method with embedded 4th order error",
          "docstring_html": "<p>Seven-stage, 5th order ESDIRK method with embedded 4th order error\nestimate. L-stable and stiffly accurate (ESDIRK5(4)7L[2]SA2).</p>\n<div class=\"section\" id=\"characteristics\">\n<h4>Characteristics</h4>\n<ul class=\"simple\">\n<li>Order: 5 (propagating) / 4 (embedded)</li>\n<li>Stages: 7 (1 explicit, 6 implicit)</li>\n<li>Adaptive timestep</li>\n<li>L-stable, stiffly accurate</li>\n<li>Stage order 2</li>\n</ul>\n</div>\n<div class=\"section\" id=\"note\">\n<h4>Note</h4>\n<p>The highest-accuracy L-stable single-step solver in this library before\nthe much more expensive <tt class=\"docutils literal\">ESDIRK85</tt>. Use when tight tolerances are\nneeded on a stiff block diagram (e.g. multi-rate systems combining fast\nelectrical and slow thermal dynamics). At moderate tolerances,\n<tt class=\"docutils literal\">ESDIRK43</tt> achieves similar results with fewer implicit solves per\nstep.</p>\n<p><strong>References</strong></p>\n<table class=\"docutils footnote\" frame=\"void\" id=\"footnote-1\" rules=\"none\">\n<colgroup><col class=\"label\" /><col /></colgroup>\n<tbody valign=\"top\">\n<tr><td class=\"label\">[1]</td><td>Kennedy, C. A., &amp; Carpenter, M. H. (2019). &quot;Diagonally implicit\nRunge-Kutta methods for stiff ODEs&quot;. Applied Numerical\nMathematics, 146, 221-244.\n:doi:`10.1016/j.apnum.2019.07.008`</td></tr>\n</tbody>\n</table>\n<table class=\"docutils footnote\" frame=\"void\" id=\"footnote-2\" rules=\"none\">\n<colgroup><col class=\"label\" /><col /></colgroup>\n<tbody valign=\"top\">\n<tr><td class=\"label\">[2]</td><td>Hairer, E., &amp; Wanner, G. (1996). &quot;Solving Ordinary Differential\nEquations II: Stiff and Differential-Algebraic Problems&quot;. Springer\nSeries in Computational Mathematics, Vol. 14.\n:doi:`10.1007/978-3-642-05221-7`</td></tr>\n</tbody>\n</table>\n</div>\n",
          "source": "class ESDIRK54(DiagonallyImplicitRungeKutta):\n    \"\"\"Seven-stage, 5th order ESDIRK method with embedded 4th order error\n    estimate. L-stable and stiffly accurate (ESDIRK5(4)7L[2]SA2).\n\n    Characteristics\n    ---------------\n    * Order: 5 (propagating) / 4 (embedded)\n    * Stages: 7 (1 explicit, 6 implicit)\n    * Adaptive timestep\n    * L-stable, stiffly accurate\n    * Stage order 2\n\n    Note\n    ----\n    The highest-accuracy L-stable single-step solver in this library before\n    the much more expensive ``ESDIRK85``. Use when tight tolerances are\n    needed on a stiff block diagram (e.g. multi-rate systems combining fast\n    electrical and slow thermal dynamics). At moderate tolerances,\n    ``ESDIRK43`` achieves similar results with fewer implicit solves per\n    step.\n\n    References\n    ----------\n    .. [1] Kennedy, C. A., & Carpenter, M. H. (2019). \"Diagonally implicit\n           Runge-Kutta methods for stiff ODEs\". Applied Numerical\n           Mathematics, 146, 221-244.\n           :doi:`10.1016/j.apnum.2019.07.008`\n    .. [2] Hairer, E., & Wanner, G. (1996). \"Solving Ordinary Differential\n           Equations II: Stiff and Differential-Algebraic Problems\". Springer\n           Series in Computational Mathematics, Vol. 14.\n           :doi:`10.1007/978-3-642-05221-7`\n\n    \"\"\"\n\n    def __init__(self, *solver_args, **solver_kwargs):\n        super().__init__(*solver_args, **solver_kwargs)\n\n        #number of stages in RK scheme\n        self.s = 7\n\n        #order of scheme and embedded method\n        self.n = 5\n        self.m = 4\n\n        #flag adaptive timestep solver\n        self.is_adaptive = True\n\n        #intermediate evaluation times\n        self.eval_stages = [\n            0.0, 46/125, 7121331996143/11335814405378, 49/353, \n            3706679970760/5295570149437, 347/382, 1.0\n            ]\n\n        #butcher table\n        self.BT = {\n            0: None, #explicit first stage\n            1: [23/125, 23/125], \n            2: [791020047304/3561426431547, 791020047304/3561426431547, 23/125], \n            3: [-158159076358/11257294102345, -158159076358/11257294102345, \n                -85517644447/5003708988389, 23/125], \n            4: [-1653327111580/4048416487981, -1653327111580/4048416487981, \n                1514767744496/9099671765375, 14283835447591/12247432691556, 23/125],\n            5: [-4540011970825/8418487046959, -4540011970825/8418487046959, \n                -1790937573418/7393406387169, 10819093665085/7266595846747, \n                4109463131231/7386972500302, 23/125],\n            6: [-188593204321/4778616380481, -188593204321/4778616380481, \n                2809310203510/10304234040467, 1021729336898/2364210264653, \n                870612361811/2470410392208, -1307970675534/8059683598661, 23/125]\n                }\n\n        #coefficients for truncation error estimate\n        _A1 = [\n            -188593204321/4778616380481, -188593204321/4778616380481, \n            2809310203510/10304234040467, 1021729336898/2364210264653, \n            870612361811/2470410392208, -1307970675534/8059683598661, 23/125\n            ]\n        _A2 = [\n            -582099335757/7214068459310, -582099335757/7214068459310, \n            615023338567/3362626566945, 3192122436311/6174152374399, \n            6156034052041/14430468657929, -1011318518279/9693750372484, \n            1914490192573/13754262428401\n            ]\n        self.TR = [_a1 - _a2 for _a1, _a2 in zip(_A1, _A2)]",
          "bases": [
            "pathsim.solvers._rungekutta.DiagonallyImplicitRungeKutta"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, *solver_args, **solver_kwargs):\n    super().__init__(*solver_args, **solver_kwargs)\n\n    #number of stages in RK scheme\n    self.s = 7\n\n    #order of scheme and embedded method\n    self.n = 5\n    self.m = 4\n\n    #flag adaptive timestep solver\n    self.is_adaptive = True\n\n    #intermediate evaluation times\n    self.eval_stages = [\n        0.0, 46/125, 7121331996143/11335814405378, 49/353, \n        3706679970760/5295570149437, 347/382, 1.0\n        ]\n\n    #butcher table\n    self.BT = {\n        0: None, #explicit first stage\n        1: [23/125, 23/125], \n        2: [791020047304/3561426431547, 791020047304/3561426431547, 23/125], \n        3: [-158159076358/11257294102345, -158159076358/11257294102345, \n            -85517644447/5003708988389, 23/125], \n        4: [-1653327111580/4048416487981, -1653327111580/4048416487981, \n            1514767744496/9099671765375, 14283835447591/12247432691556, 23/125],\n        5: [-4540011970825/8418487046959, -4540011970825/8418487046959, \n            -1790937573418/7393406387169, 10819093665085/7266595846747, \n            4109463131231/7386972500302, 23/125],\n        6: [-188593204321/4778616380481, -188593204321/4778616380481, \n            2809310203510/10304234040467, 1021729336898/2364210264653, \n            870612361811/2470410392208, -1307970675534/8059683598661, 23/125]\n            }\n\n    #coefficients for truncation error estimate\n    _A1 = [\n        -188593204321/4778616380481, -188593204321/4778616380481, \n        2809310203510/10304234040467, 1021729336898/2364210264653, \n        870612361811/2470410392208, -1307970675534/8059683598661, 23/125\n        ]\n    _A2 = [\n        -582099335757/7214068459310, -582099335757/7214068459310, \n        615023338567/3362626566945, 3192122436311/6174152374399, \n        6156034052041/14430468657929, -1011318518279/9693750372484, \n        1914490192573/13754262428401\n        ]\n    self.TR = [_a1 - _a2 for _a1, _a2 in zip(_A1, _A2)]",
              "signature": "(solver_args = (), solver_kwargs = {})",
              "parameters": [
                {
                  "name": "solver_args",
                  "type": null,
                  "default": "()",
                  "description": ""
                },
                {
                  "name": "solver_kwargs",
                  "type": null,
                  "default": "{}",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "s",
              "description": "",
              "type": null,
              "value": "7"
            },
            {
              "name": "n",
              "description": "",
              "type": null,
              "value": "5"
            },
            {
              "name": "m",
              "description": "",
              "type": null,
              "value": "4"
            },
            {
              "name": "is_adaptive",
              "description": "",
              "type": null,
              "value": "True"
            },
            {
              "name": "eval_stages",
              "description": "",
              "type": null,
              "value": "[0.0, 46 / 125, 7121331996143 / 11335814405378, 49 / 353, 3706679970760 / 5295570149437, 347 / 382, 1.0]"
            },
            {
              "name": "BT",
              "description": "",
              "type": null,
              "value": "{0: None, 1: [23 / 125, 23 / 125], 2: [791020047304 / 3561426431547, 791020047304 / 3561426431547, 23 / 125], 3: [-158159076358 / 11257294102345, -158159076358 / 11257294102345, -85517644447 / 5003708988389, 23 / 125], 4: [-1653327111580 / 4048416487981, -1653327111580 / 4048416487981, 1514767744496 / 9099671765375, 14283835447591 / 12247432691556, 23 / 125], 5: [-4540011970825 / 8418487046959, -4540011970825 / 8418487046959, -1790937573418 / 7393406387169, 10819093665085 / 7266595846747, 4109463131231 / 7386972500302, 23 / 125], 6: [-188593204321 / 4778616380481, -188593204321 / 4778616380481, 2809310203510 / 10304234040467, 1021729336898 / 2364210264653, 870612361811 / 2470410392208, -1307970675534 / 8059683598661, 23 / 125]}"
            },
            {
              "name": "TR",
              "description": "",
              "type": null,
              "value": "[(_a1 - _a2) for _a1, _a2 in (zip(_A1, _A2))]"
            }
          ],
          "parameters": [
            {
              "name": "solver_args",
              "type": null,
              "default": "()",
              "description": ""
            },
            {
              "name": "solver_kwargs",
              "type": null,
              "default": "{}",
              "description": ""
            }
          ]
        }
      ],
      "functions": []
    },
    "pathsim.solvers.esdirk85": {
      "name": "pathsim.solvers.esdirk85",
      "description": "",
      "docstring_html": "",
      "classes": [
        {
          "name": "ESDIRK85",
          "description": "Sixteen-stage, 8th order ESDIRK method with embedded 5th order error",
          "docstring_html": "<p>Sixteen-stage, 8th order ESDIRK method with embedded 5th order error\nestimate. L-stable and stiffly accurate (ESDIRK(16,8)[2]SAL-[(16,5)]).</p>\n<div class=\"section\" id=\"characteristics\">\n<h4>Characteristics</h4>\n<ul class=\"simple\">\n<li>Order: 8 (propagating) / 5 (embedded)</li>\n<li>Stages: 16 (1 explicit, 15 implicit)</li>\n<li>Adaptive timestep</li>\n<li>L-stable, stiffly accurate</li>\n<li>Stage order 2</li>\n</ul>\n</div>\n<div class=\"section\" id=\"note\">\n<h4>Note</h4>\n<p>Fifteen implicit solves per step make this very expensive. It is only\njustified when the right-hand side evaluation is itself costly (large\nstate dimension, expensive <tt class=\"docutils literal\">ODE</tt> blocks) and very tight tolerances are\nrequired so that the 8th order convergence compensates through much\nlarger steps. For generating stiff reference solutions to validate other\nsolvers. In almost all practical block-diagram simulations, <tt class=\"docutils literal\">ESDIRK54</tt>\nis the better choice.</p>\n<p><strong>References</strong></p>\n<table class=\"docutils footnote\" frame=\"void\" id=\"footnote-1\" rules=\"none\">\n<colgroup><col class=\"label\" /><col /></colgroup>\n<tbody valign=\"top\">\n<tr><td class=\"label\">[1]</td><td>Alamri, Y., &amp; Ketcheson, D. I. (2024). &quot;Very high-order A-stable\nstiffly accurate diagonally implicit Runge-Kutta methods with\nerror estimators&quot;. Journal of Scientific Computing, 100,\nArticle 84. :doi:`10.1007/s10915-024-02627-w`</td></tr>\n</tbody>\n</table>\n<table class=\"docutils footnote\" frame=\"void\" id=\"footnote-2\" rules=\"none\">\n<colgroup><col class=\"label\" /><col /></colgroup>\n<tbody valign=\"top\">\n<tr><td class=\"label\">[2]</td><td>Kennedy, C. A., &amp; Carpenter, M. H. (2019). &quot;Diagonally implicit\nRunge-Kutta methods for stiff ODEs&quot;. Applied Numerical\nMathematics, 146, 221-244.\n:doi:`10.1016/j.apnum.2019.07.008`</td></tr>\n</tbody>\n</table>\n</div>\n",
          "source": "class ESDIRK85(DiagonallyImplicitRungeKutta):\n    \"\"\"Sixteen-stage, 8th order ESDIRK method with embedded 5th order error\n    estimate. L-stable and stiffly accurate (ESDIRK(16,8)[2]SAL-[(16,5)]).\n\n    Characteristics\n    ---------------\n    * Order: 8 (propagating) / 5 (embedded)\n    * Stages: 16 (1 explicit, 15 implicit)\n    * Adaptive timestep\n    * L-stable, stiffly accurate\n    * Stage order 2\n\n    Note\n    ----\n    Fifteen implicit solves per step make this very expensive. It is only\n    justified when the right-hand side evaluation is itself costly (large\n    state dimension, expensive ``ODE`` blocks) and very tight tolerances are\n    required so that the 8th order convergence compensates through much\n    larger steps. For generating stiff reference solutions to validate other\n    solvers. In almost all practical block-diagram simulations, ``ESDIRK54``\n    is the better choice.\n\n    References\n    ----------\n    .. [1] Alamri, Y., & Ketcheson, D. I. (2024). \"Very high-order A-stable\n           stiffly accurate diagonally implicit Runge-Kutta methods with\n           error estimators\". Journal of Scientific Computing, 100,\n           Article 84. :doi:`10.1007/s10915-024-02627-w`\n    .. [2] Kennedy, C. A., & Carpenter, M. H. (2019). \"Diagonally implicit\n           Runge-Kutta methods for stiff ODEs\". Applied Numerical\n           Mathematics, 146, 221-244.\n           :doi:`10.1016/j.apnum.2019.07.008`\n\n    \"\"\"\n\n    def __init__(self, *solver_args, **solver_kwargs):\n        super().__init__(*solver_args, **solver_kwargs)\n\n        #number of stages in RK scheme\n        self.s = 16\n\n        #order of scheme and embedded method\n        self.n = 8\n        self.m = 5\n\n        #flag adaptive timestep solver\n        self.is_adaptive = True\n\n        #intermediate evaluation times as ratios\n        self.eval_stages = [\n            0.0              , 0.234637638717043, 0.558545926594724,\n            0.562667638694992, 0.697898381329126, 0.956146958839776,\n            0.812903043340468, 0.148256733818785, 0.944650387704291,\n            0.428471803715736, 0.984131639774509, 0.320412672954752,\n            0.974077670791771, 0.852850433853921, 0.823320301074444,\n            1.0\n            ]\n\n        #butcher table\n        self.BT = {\n            0:None, #explicit first stage\n            1:[0.117318819358521, 0.117318819358521],\n            2:[0.0557014605974616, 0.385525646638742, 0.117318819358521],\n            3:[0.063493276428895, 0.373556126263681, 0.0082994166438953,\n              0.117318819358521],\n            4:[0.0961351856230088, 0.335558324517178, 0.207077765910132,\n              -0.0581917140797146, 0.117318819358521],\n            5:[0.0497669214238319, 0.384288616546039, 0.0821728117583936,\n              0.120337007107103, 0.202262782645888, 0.117318819358521],\n            6:[0.00626710666809847, 0.496491452640725, -0.111303249827358,\n              0.170478821683603, 0.166517073971103, -0.0328669811542241,\n              0.117318819358521],\n            7:[0.0463439767281591, 0.00306724391019652, -0.00816305222386205,\n              -0.0353302599538294, 0.0139313601702569, -0.00992014507967429,\n              0.0210087909090165, 0.117318819358521],\n            8:[0.111574049232048, 0.467639166482209, 0.237773114804619,\n              0.0798895699267508, 0.109580615914593, 0.0307353103825936,\n              -0.0404391509541147, -0.16942110744293, 0.117318819358521],\n            9:[-0.0107072484863877, -0.231376703354252, 0.017541113036611,\n              0.144871527682418, -0.041855459769806, 0.0841832168332261,\n              -0.0850020937282192, 0.486170343825899, -0.0526717116822739,\n              0.117318819358521],\n            10:[-0.0142238262314935, 0.14752923682514, 0.238235830732566,\n               0.037950291904103, 0.252075123381518, 0.0474266904224567,\n               -0.00363139069342027, 0.274081442388563, -0.0599166970745255,\n               -0.0527138812389185, 0.117318819358521],\n            11:[-0.11837020183211, -0.635712481821264, 0.239738832602538,\n               0.330058936651707, -0.325784087988237, -0.0506514314589253,\n               -0.281914404487009, 0.852596345144291, 0.651444614298805,\n               -0.103476387303591, -0.354835880209975, 0.117318819358521],\n            12:[-0.00458164025442349, 0.296219694015248, 0.322146049419995,\n               0.15917778285238, 0.284864871688843, 0.185509526463076,\n               -0.0784621067883274, 0.166312223692047, -0.284152486083397,\n               -0.357125104338944, 0.078437074055306, 0.0884129667114481,\n               0.117318819358521],\n            13:[-0.0545561913848106, 0.675785423442753, 0.423066443201941,\n               -0.000165300126841193, 0.104252994793763, -0.105763019303021,\n               -0.15988308809318, 0.0515050001032011, 0.56013979290924,\n               -0.45781539708603, -0.255870699752664, 0.026960254296416,\n               -0.0721245985053681, 0.117318819358521],\n            14:[0.0649253995775223, -0.0216056457922249, -0.073738139377975,\n               0.0931033310077225, -0.0194339577299149, -0.0879623837313009,\n               0.057125517179467, 0.205120850488097, 0.132576503537441,\n               0.489416890627328, -0.1106765720501, -0.081038793996096,\n               0.0606031613503788, -0.00241467937442272, 0.117318819358521],\n            15:[0.0459979286336779, 0.0780075394482806, 0.015021874148058,\n               0.195180277284195, -0.00246643310153235, 0.0473977117068314,\n               -0.0682773558610363, 0.19568019123878, -0.0876765449323747,\n               0.177874852409192, -0.337519251582222, -0.0123255553640736,\n               0.311573291192553, 0.0458604327754991, 0.278352222645651,\n               0.117318819358521]\n               }\n\n        #coefficients for truncation error estimate (8th and 5th order solution)\n        _A1 = [\n            0.0459979286336779, 0.0780075394482806, 0.015021874148058,\n            0.195180277284195, -0.00246643310153235, 0.0473977117068314,\n            -0.0682773558610363, 0.19568019123878, -0.0876765449323747,\n            0.177874852409192, -0.337519251582222, -0.0123255553640736,\n            0.311573291192553, 0.0458604327754991, 0.278352222645651,\n            0.117318819358521\n            ]\n        _A2 = [\n            0.0603373529853206, 0.175453809423998, 0.0537707777611352,\n            0.195309248607308, 0.0135893741970232, -0.0221160259296707,\n            -0.00726526156430691, 0.102961059369124, 0.000900215457460583,\n            0.0547959465692338, -0.334995726863153, 0.0464409662093384,\n            0.301388101652194, 0.00524851570622031, 0.229538601845236,\n            0.124643044573514\n            ]\n        self.TR = [_a1 - _a2 for _a1, _a2 in zip(_A1, _A2)]",
          "bases": [
            "pathsim.solvers._rungekutta.DiagonallyImplicitRungeKutta"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, *solver_args, **solver_kwargs):\n    super().__init__(*solver_args, **solver_kwargs)\n\n    #number of stages in RK scheme\n    self.s = 16\n\n    #order of scheme and embedded method\n    self.n = 8\n    self.m = 5\n\n    #flag adaptive timestep solver\n    self.is_adaptive = True\n\n    #intermediate evaluation times as ratios\n    self.eval_stages = [\n        0.0              , 0.234637638717043, 0.558545926594724,\n        0.562667638694992, 0.697898381329126, 0.956146958839776,\n        0.812903043340468, 0.148256733818785, 0.944650387704291,\n        0.428471803715736, 0.984131639774509, 0.320412672954752,\n        0.974077670791771, 0.852850433853921, 0.823320301074444,\n        1.0\n        ]\n\n    #butcher table\n    self.BT = {\n        0:None, #explicit first stage\n        1:[0.117318819358521, 0.117318819358521],\n        2:[0.0557014605974616, 0.385525646638742, 0.117318819358521],\n        3:[0.063493276428895, 0.373556126263681, 0.0082994166438953,\n          0.117318819358521],\n        4:[0.0961351856230088, 0.335558324517178, 0.207077765910132,\n          -0.0581917140797146, 0.117318819358521],\n        5:[0.0497669214238319, 0.384288616546039, 0.0821728117583936,\n          0.120337007107103, 0.202262782645888, 0.117318819358521],\n        6:[0.00626710666809847, 0.496491452640725, -0.111303249827358,\n          0.170478821683603, 0.166517073971103, -0.0328669811542241,\n          0.117318819358521],\n        7:[0.0463439767281591, 0.00306724391019652, -0.00816305222386205,\n          -0.0353302599538294, 0.0139313601702569, -0.00992014507967429,\n          0.0210087909090165, 0.117318819358521],\n        8:[0.111574049232048, 0.467639166482209, 0.237773114804619,\n          0.0798895699267508, 0.109580615914593, 0.0307353103825936,\n          -0.0404391509541147, -0.16942110744293, 0.117318819358521],\n        9:[-0.0107072484863877, -0.231376703354252, 0.017541113036611,\n          0.144871527682418, -0.041855459769806, 0.0841832168332261,\n          -0.0850020937282192, 0.486170343825899, -0.0526717116822739,\n          0.117318819358521],\n        10:[-0.0142238262314935, 0.14752923682514, 0.238235830732566,\n           0.037950291904103, 0.252075123381518, 0.0474266904224567,\n           -0.00363139069342027, 0.274081442388563, -0.0599166970745255,\n           -0.0527138812389185, 0.117318819358521],\n        11:[-0.11837020183211, -0.635712481821264, 0.239738832602538,\n           0.330058936651707, -0.325784087988237, -0.0506514314589253,\n           -0.281914404487009, 0.852596345144291, 0.651444614298805,\n           -0.103476387303591, -0.354835880209975, 0.117318819358521],\n        12:[-0.00458164025442349, 0.296219694015248, 0.322146049419995,\n           0.15917778285238, 0.284864871688843, 0.185509526463076,\n           -0.0784621067883274, 0.166312223692047, -0.284152486083397,\n           -0.357125104338944, 0.078437074055306, 0.0884129667114481,\n           0.117318819358521],\n        13:[-0.0545561913848106, 0.675785423442753, 0.423066443201941,\n           -0.000165300126841193, 0.104252994793763, -0.105763019303021,\n           -0.15988308809318, 0.0515050001032011, 0.56013979290924,\n           -0.45781539708603, -0.255870699752664, 0.026960254296416,\n           -0.0721245985053681, 0.117318819358521],\n        14:[0.0649253995775223, -0.0216056457922249, -0.073738139377975,\n           0.0931033310077225, -0.0194339577299149, -0.0879623837313009,\n           0.057125517179467, 0.205120850488097, 0.132576503537441,\n           0.489416890627328, -0.1106765720501, -0.081038793996096,\n           0.0606031613503788, -0.00241467937442272, 0.117318819358521],\n        15:[0.0459979286336779, 0.0780075394482806, 0.015021874148058,\n           0.195180277284195, -0.00246643310153235, 0.0473977117068314,\n           -0.0682773558610363, 0.19568019123878, -0.0876765449323747,\n           0.177874852409192, -0.337519251582222, -0.0123255553640736,\n           0.311573291192553, 0.0458604327754991, 0.278352222645651,\n           0.117318819358521]\n           }\n\n    #coefficients for truncation error estimate (8th and 5th order solution)\n    _A1 = [\n        0.0459979286336779, 0.0780075394482806, 0.015021874148058,\n        0.195180277284195, -0.00246643310153235, 0.0473977117068314,\n        -0.0682773558610363, 0.19568019123878, -0.0876765449323747,\n        0.177874852409192, -0.337519251582222, -0.0123255553640736,\n        0.311573291192553, 0.0458604327754991, 0.278352222645651,\n        0.117318819358521\n        ]\n    _A2 = [\n        0.0603373529853206, 0.175453809423998, 0.0537707777611352,\n        0.195309248607308, 0.0135893741970232, -0.0221160259296707,\n        -0.00726526156430691, 0.102961059369124, 0.000900215457460583,\n        0.0547959465692338, -0.334995726863153, 0.0464409662093384,\n        0.301388101652194, 0.00524851570622031, 0.229538601845236,\n        0.124643044573514\n        ]\n    self.TR = [_a1 - _a2 for _a1, _a2 in zip(_A1, _A2)]",
              "signature": "(solver_args = (), solver_kwargs = {})",
              "parameters": [
                {
                  "name": "solver_args",
                  "type": null,
                  "default": "()",
                  "description": ""
                },
                {
                  "name": "solver_kwargs",
                  "type": null,
                  "default": "{}",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "s",
              "description": "",
              "type": null,
              "value": "16"
            },
            {
              "name": "n",
              "description": "",
              "type": null,
              "value": "8"
            },
            {
              "name": "m",
              "description": "",
              "type": null,
              "value": "5"
            },
            {
              "name": "is_adaptive",
              "description": "",
              "type": null,
              "value": "True"
            },
            {
              "name": "eval_stages",
              "description": "",
              "type": null,
              "value": "[0.0, 0.234637638717043, 0.558545926594724, 0.562667638694992, 0.697898381329126, 0.956146958839776, 0.812903043340468, 0.148256733818785, 0.944650387704291, 0.428471803715736, 0.984131639774509, 0.320412672954752, 0.974077670791771, 0.852850433853921, 0.823320301074444, 1.0]"
            },
            {
              "name": "BT",
              "description": "",
              "type": null,
              "value": "{0: None, 1: [0.117318819358521, 0.117318819358521], 2: [0.0557014605974616, 0.385525646638742, 0.117318819358521], 3: [0.063493276428895, 0.373556126263681, 0.0082994166438953, 0.117318819358521], 4: [0.0961351856230088, 0.335558324517178, 0.207077765910132, -0.0581917140797146, 0.117318819358521], 5: [0.0497669214238319, 0.384288616546039, 0.0821728117583936, 0.120337007107103, 0.202262782645888, 0.117318819358521], 6: [0.00626710666809847, 0.496491452640725, -0.111303249827358, 0.170478821683603, 0.166517073971103, -0.0328669811542241, 0.117318819358521], 7: [0.0463439767281591, 0.00306724391019652, -0.00816305222386205, -0.0353302599538294, 0.0139313601702569, -0.00992014507967429, 0.0210087909090165, 0.117318819358521], 8: [0.111574049232048, 0.467639166482209, 0.237773114804619, 0.0798895699267508, 0.109580615914593, 0.0307353103825936, -0.0404391509541147, -0.16942110744293, 0.117318819358521], 9: [-0.0107072484863877, -0.231376703354252, 0.017541113036611, 0.144871527682418, -0.041855459769806, 0.0841832168332261, -0.0850020937282192, 0.486170343825899, -0.0526717116822739, 0.117318819358521], 10: [-0.0142238262314935, 0.14752923682514, 0.238235830732566, 0.037950291904103, 0.252075123381518, 0.0474266904224567, -0.00363139069342027, 0.274081442388563, -0.0599166970745255, -0.0527138812389185, 0.117318819358521], 11: [-0.11837020183211, -0.635712481821264, 0.239738832602538, 0.330058936651707, -0.325784087988237, -0.0506514314589253, -0.281914404487009, 0.852596345144291, 0.651444614298805, -0.103476387303591, -0.354835880209975, 0.117318819358521], 12: [-0.00458164025442349, 0.296219694015248, 0.322146049419995, 0.15917778285238, 0.284864871688843, 0.185509526463076, -0.0784621067883274, 0.166312223692047, -0.284152486083397, -0.357125104338944, 0.078437074055306, 0.0884129667114481, 0.117318819358521], 13: [-0.0545561913848106, 0.675785423442753, 0.423066443201941, -0.000165300126841193, 0.104252994793763, -0.105763019303021, -0.15988308809318, 0.0515050001032011, 0.56013979290924, -0.45781539708603, -0.255870699752664, 0.026960254296416, -0.0721245985053681, 0.117318819358521], 14: [0.0649253995775223, -0.0216056457922249, -0.073738139377975, 0.0931033310077225, -0.0194339577299149, -0.0879623837313009, 0.057125517179467, 0.205120850488097, 0.132576503537441, 0.489416890627328, -0.1106765720501, -0.081038793996096, 0.0606031613503788, -0.00241467937442272, 0.117318819358521], 15: [0.0459979286336779, 0.0780075394482806, 0.015021874148058, 0.195180277284195, -0.00246643310153235, 0.0473977117068314, -0.0682773558610363, 0.19568019123878, -0.0876765449323747, 0.177874852409192, -0.337519251582222, -0.0123255553640736, 0.311573291192553, 0.0458604327754991, 0.278352222645651, 0.117318819358521]}"
            },
            {
              "name": "TR",
              "description": "",
              "type": null,
              "value": "[(_a1 - _a2) for _a1, _a2 in (zip(_A1, _A2))]"
            }
          ],
          "parameters": [
            {
              "name": "solver_args",
              "type": null,
              "default": "()",
              "description": ""
            },
            {
              "name": "solver_kwargs",
              "type": null,
              "default": "{}",
              "description": ""
            }
          ]
        }
      ],
      "functions": []
    },
    "pathsim.solvers.euler": {
      "name": "pathsim.solvers.euler",
      "description": "",
      "docstring_html": "",
      "classes": [
        {
          "name": "EUF",
          "description": "Explicit forward Euler method. First-order, single-stage.",
          "docstring_html": "<p>Explicit forward Euler method. First-order, single-stage.</p>\n<pre class=\"math\">\nx_{n+1} = x_n + h \\, f(x_n, t_n)\n</pre>\n<div class=\"section\" id=\"characteristics\">\n<h4>Characteristics</h4>\n<ul class=\"simple\">\n<li>Order: 1</li>\n<li>Stages: 1</li>\n<li>Explicit, fixed timestep</li>\n<li>Not A-stable</li>\n</ul>\n</div>\n<div class=\"section\" id=\"note\">\n<h4>Note</h4>\n<p>The cheapest solver per step but also the least accurate. Its small stability\nregion requires very small timesteps for moderately dynamic block diagrams,\nwhich usually makes higher-order methods more efficient overall. Prefer\n<tt class=\"docutils literal\">RK4</tt> for fixed-step or <tt class=\"docutils literal\">RKDP54</tt> for adaptive integration of non-stiff\nsystems. Only practical when computational cost per step must be absolute\nminimum and accuracy is secondary.</p>\n<p><strong>References</strong></p>\n<table class=\"docutils footnote\" frame=\"void\" id=\"footnote-1\" rules=\"none\">\n<colgroup><col class=\"label\" /><col /></colgroup>\n<tbody valign=\"top\">\n<tr><td class=\"label\">[1]</td><td>Hairer, E., Nørsett, S. P., &amp; Wanner, G. (1993). &quot;Solving Ordinary\nDifferential Equations I: Nonstiff Problems&quot;. Springer Series in\nComputational Mathematics, Vol. 8.\n:doi:`10.1007/978-3-540-78862-1`</td></tr>\n</tbody>\n</table>\n<table class=\"docutils footnote\" frame=\"void\" id=\"footnote-2\" rules=\"none\">\n<colgroup><col class=\"label\" /><col /></colgroup>\n<tbody valign=\"top\">\n<tr><td class=\"label\">[2]</td><td>Butcher, J. C. (2016). &quot;Numerical Methods for Ordinary Differential\nEquations&quot;. John Wiley &amp; Sons, 3rd Edition.\n:doi:`10.1002/9781119121534`</td></tr>\n</tbody>\n</table>\n</div>\n",
          "source": "class EUF(ExplicitSolver):\n    \"\"\"Explicit forward Euler method. First-order, single-stage.\n\n    .. math::\n\n        x_{n+1} = x_n + h \\\\, f(x_n, t_n)\n\n    Characteristics\n    ---------------\n    * Order: 1\n    * Stages: 1\n    * Explicit, fixed timestep\n    * Not A-stable\n\n    Note\n    ----\n    The cheapest solver per step but also the least accurate. Its small stability\n    region requires very small timesteps for moderately dynamic block diagrams,\n    which usually makes higher-order methods more efficient overall. Prefer\n    ``RK4`` for fixed-step or ``RKDP54`` for adaptive integration of non-stiff\n    systems. Only practical when computational cost per step must be absolute\n    minimum and accuracy is secondary.\n\n    References\n    ----------\n    .. [1] Hairer, E., Nørsett, S. P., & Wanner, G. (1993). \"Solving Ordinary\n           Differential Equations I: Nonstiff Problems\". Springer Series in\n           Computational Mathematics, Vol. 8.\n           :doi:`10.1007/978-3-540-78862-1`\n    .. [2] Butcher, J. C. (2016). \"Numerical Methods for Ordinary Differential\n           Equations\". John Wiley & Sons, 3rd Edition.\n           :doi:`10.1002/9781119121534`\n\n    \"\"\"\n\n    def step(self, f, dt):\n        \"\"\"performs the explicit forward timestep for (t+dt) \n        based on the state and input at (t)\n\n        Parameters\n        ----------\n        f : array_like\n            evaluation of function\n        dt : float \n            integration timestep\n\n        Returns\n        -------\n        success : bool\n            timestep was successful\n        err : float\n            truncation error estimate\n        scale : float\n            timestep rescale from error controller\n        \"\"\"\n\n        #get current state from history\n        x_0 = self.history[0]\n\n        #update state with euler step\n        self.x = x_0 + dt * f\n\n        #no error estimate available\n        return True, 0.0, None",
          "bases": [
            "pathsim.solvers._solver.ExplicitSolver"
          ],
          "methods": [
            {
              "name": "step",
              "description": "performs the explicit forward timestep for (t+dt)",
              "docstring_html": "<p>performs the explicit forward timestep for (t+dt)\nbased on the state and input at (t)</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>f <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array_like</span></dt>\n<dd>evaluation of function</dd>\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>integration timestep</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>success <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>timestep was successful</dd>\n<dt>err <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>truncation error estimate</dd>\n<dt>scale <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>timestep rescale from error controller</dd>\n</dl>\n",
              "source": "def step(self, f, dt):\n    \"\"\"performs the explicit forward timestep for (t+dt) \n    based on the state and input at (t)\n\n    Parameters\n    ----------\n    f : array_like\n        evaluation of function\n    dt : float \n        integration timestep\n\n    Returns\n    -------\n    success : bool\n        timestep was successful\n    err : float\n        truncation error estimate\n    scale : float\n        timestep rescale from error controller\n    \"\"\"\n\n    #get current state from history\n    x_0 = self.history[0]\n\n    #update state with euler step\n    self.x = x_0 + dt * f\n\n    #no error estimate available\n    return True, 0.0, None",
              "signature": "(f, dt)",
              "parameters": [
                {
                  "name": "f",
                  "type": null,
                  "default": null,
                  "description": "evaluation of function"
                },
                {
                  "name": "dt",
                  "type": null,
                  "default": null,
                  "description": "integration timestep"
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [],
          "parameters": []
        },
        {
          "name": "EUB",
          "description": "Implicit backward Euler method. First-order, A-stable and L-stable.",
          "docstring_html": "<p>Implicit backward Euler method. First-order, A-stable and L-stable.</p>\n<pre class=\"math\">\nx_{n+1} = x_n + h \\, f(x_{n+1}, t_{n+1})\n</pre>\n<p>The implicit equation is solved iteratively by the internal optimizer.</p>\n<div class=\"section\" id=\"characteristics\">\n<h4>Characteristics</h4>\n<ul class=\"simple\">\n<li>Order: 1</li>\n<li>Stages: 1 (implicit)</li>\n<li>Fixed timestep</li>\n<li>A-stable, L-stable</li>\n</ul>\n</div>\n<div class=\"section\" id=\"note\">\n<h4>Note</h4>\n<p>Maximum stability at the cost of accuracy. L-stability fully damps\nparasitic high-frequency modes, making this a safe fallback for very stiff\nblock diagrams (e.g. high-gain PID loops or fast electrical dynamics coupled\nto slow mechanical plant). Because each step requires solving a nonlinear\nequation, the cost per step is higher than explicit methods. For better\naccuracy on stiff systems, use <tt class=\"docutils literal\">BDF2</tt> (fixed-step) or <tt class=\"docutils literal\">ESDIRK43</tt>\n(adaptive).</p>\n<p><strong>References</strong></p>\n<table class=\"docutils footnote\" frame=\"void\" id=\"footnote-1\" rules=\"none\">\n<colgroup><col class=\"label\" /><col /></colgroup>\n<tbody valign=\"top\">\n<tr><td class=\"label\">[1]</td><td>Curtiss, C. F., &amp; Hirschfelder, J. O. (1952). &quot;Integration of stiff\nequations&quot;. Proceedings of the National Academy of Sciences, 38(3),\n235-243. :doi:`10.1073/pnas.38.3.235`</td></tr>\n</tbody>\n</table>\n<table class=\"docutils footnote\" frame=\"void\" id=\"footnote-2\" rules=\"none\">\n<colgroup><col class=\"label\" /><col /></colgroup>\n<tbody valign=\"top\">\n<tr><td class=\"label\">[2]</td><td>Hairer, E., &amp; Wanner, G. (1996). &quot;Solving Ordinary Differential\nEquations II: Stiff and Differential-Algebraic Problems&quot;. Springer\nSeries in Computational Mathematics, Vol. 14.\n:doi:`10.1007/978-3-642-05221-7`</td></tr>\n</tbody>\n</table>\n</div>\n",
          "source": "class EUB(ImplicitSolver):\n    \"\"\"Implicit backward Euler method. First-order, A-stable and L-stable.\n\n    .. math::\n\n        x_{n+1} = x_n + h \\\\, f(x_{n+1}, t_{n+1})\n\n    The implicit equation is solved iteratively by the internal optimizer.\n\n    Characteristics\n    ---------------\n    * Order: 1\n    * Stages: 1 (implicit)\n    * Fixed timestep\n    * A-stable, L-stable\n\n    Note\n    ----\n    Maximum stability at the cost of accuracy. L-stability fully damps\n    parasitic high-frequency modes, making this a safe fallback for very stiff\n    block diagrams (e.g. high-gain PID loops or fast electrical dynamics coupled\n    to slow mechanical plant). Because each step requires solving a nonlinear\n    equation, the cost per step is higher than explicit methods. For better\n    accuracy on stiff systems, use ``BDF2`` (fixed-step) or ``ESDIRK43``\n    (adaptive).\n\n    References\n    ----------\n    .. [1] Curtiss, C. F., & Hirschfelder, J. O. (1952). \"Integration of stiff\n           equations\". Proceedings of the National Academy of Sciences, 38(3),\n           235-243. :doi:`10.1073/pnas.38.3.235`\n    .. [2] Hairer, E., & Wanner, G. (1996). \"Solving Ordinary Differential\n           Equations II: Stiff and Differential-Algebraic Problems\". Springer\n           Series in Computational Mathematics, Vol. 14.\n           :doi:`10.1007/978-3-642-05221-7`\n\n    \"\"\"\n\n    def solve(self, f, J, dt):\n        \"\"\"Solves the implicit update equation \n        using the internal optimizer.\n\n        Parameters\n        ----------\n        f : array_like\n            evaluation of function\n        J : array_like\n            evaluation of jacobian of function\n        dt : float \n            integration timestep\n\n        Returns\n        -------\n        err : float\n            residual error of the fixed point update equation\n        \"\"\"\n\n        #get current state from history\n        x_0 = self.history[0]\n\n        #update the fixed point equation\n        g = x_0 + dt * f\n\n        #use the numerical jacobian\n        if J is not None:\n\n            #optimizer step with block local jacobian\n            self.x, err = self.opt.step(self.x, g, dt * J)\n\n        else:\n            #optimizer step (pure)\n            self.x, err = self.opt.step(self.x, g, None)\n\n        #return the fixed-point residual\n        return err",
          "bases": [
            "pathsim.solvers._solver.ImplicitSolver"
          ],
          "methods": [
            {
              "name": "solve",
              "description": "Solves the implicit update equation",
              "docstring_html": "<p>Solves the implicit update equation\nusing the internal optimizer.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>f <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array_like</span></dt>\n<dd>evaluation of function</dd>\n<dt>J <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array_like</span></dt>\n<dd>evaluation of jacobian of function</dd>\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>integration timestep</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>err <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>residual error of the fixed point update equation</dd>\n</dl>\n",
              "source": "def solve(self, f, J, dt):\n    \"\"\"Solves the implicit update equation \n    using the internal optimizer.\n\n    Parameters\n    ----------\n    f : array_like\n        evaluation of function\n    J : array_like\n        evaluation of jacobian of function\n    dt : float \n        integration timestep\n\n    Returns\n    -------\n    err : float\n        residual error of the fixed point update equation\n    \"\"\"\n\n    #get current state from history\n    x_0 = self.history[0]\n\n    #update the fixed point equation\n    g = x_0 + dt * f\n\n    #use the numerical jacobian\n    if J is not None:\n\n        #optimizer step with block local jacobian\n        self.x, err = self.opt.step(self.x, g, dt * J)\n\n    else:\n        #optimizer step (pure)\n        self.x, err = self.opt.step(self.x, g, None)\n\n    #return the fixed-point residual\n    return err",
              "signature": "(f, J, dt)",
              "parameters": [
                {
                  "name": "f",
                  "type": null,
                  "default": null,
                  "description": "evaluation of function"
                },
                {
                  "name": "J",
                  "type": null,
                  "default": null,
                  "description": "evaluation of jacobian of function"
                },
                {
                  "name": "dt",
                  "type": null,
                  "default": null,
                  "description": "integration timestep"
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [],
          "parameters": []
        }
      ],
      "functions": []
    },
    "pathsim.solvers.gear": {
      "name": "pathsim.solvers.gear",
      "description": "",
      "docstring_html": "",
      "classes": [
        {
          "name": "GEAR",
          "description": "Base class for GEAR-type integrators that defines the universal methods.",
          "docstring_html": "<p>Base class for GEAR-type integrators that defines the universal methods.</p>\n<p>Numerical integration method based on BDFs (linear multistep methods).\nUses n-th order BDF for timestepping and (n-1)-th order BDF coefficients\nto estimate a lower ordersolutuin for error control.</p>\n<p>The adaptive timestep BDF coefficients are dynamically computed at the\nbeginning of each timestep from the buffered previous timsteps.</p>\n<p><strong>Notes</strong></p>\n<p>Not to be used directly!</p>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>x <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">numeric, array[numeric]</span></dt>\n<dd>internal 'working' state</dd>\n<dt>n <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>order of integration scheme</dd>\n<dt>s <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>number of internal intermediate stages</dd>\n<dt>stage <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>counter for current intermediate stage</dd>\n<dt>eval_stages <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">list[float]</span></dt>\n<dd>rations for evaluation times of intermediate stages</dd>\n<dt>opt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">NewtonAnderson, Anderson, etc.</span></dt>\n<dd>optimizer instance to solve the implicit update equation</dd>\n<dt>K <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">dict[int: list[float]]</span></dt>\n<dd>bdf coefficients for the state buffer for each order</dd>\n<dt>F <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">dict[int: float]</span></dt>\n<dd>bdf coefficients for the function 'func' for each order</dd>\n<dt>history <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">deque[numeric]</span></dt>\n<dd>internal history of past results</dd>\n<dt>history_dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">deque[numeric]</span></dt>\n<dd>internal history of past timesteps</dd>\n<dt>startup <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">Solver</span></dt>\n<dd>internal solver instance for startup (building history)\nof multistep methods (using 'ESDIRK32' for 'GEAR' methods)</dd>\n</dl>\n",
          "source": "class GEAR(ImplicitSolver):\n    \"\"\"Base class for GEAR-type integrators that defines the universal methods.\n\n    Numerical integration method based on BDFs (linear multistep methods). \n    Uses n-th order BDF for timestepping and (n-1)-th order BDF coefficients \n    to estimate a lower ordersolutuin for error control. \n\n    The adaptive timestep BDF coefficients are dynamically computed at the \n    beginning of each timestep from the buffered previous timsteps.\n\n    Notes\n    -----\n    Not to be used directly!\n\n    Attributes\n    ----------\n    x : numeric, array[numeric]\n        internal 'working' state\n    n : int\n        order of integration scheme\n    s : int\n        number of internal intermediate stages\n    stage : int\n        counter for current intermediate stage\n    eval_stages : list[float]\n        rations for evaluation times of intermediate stages\n    opt : NewtonAnderson, Anderson, etc.\n        optimizer instance to solve the implicit update equation\n    K : dict[int: list[float]]\n        bdf coefficients for the state buffer for each order\n    F : dict[int: float]\n        bdf coefficients for the function 'func' for each order\n    history : deque[numeric]\n        internal history of past results\n    history_dt : deque[numeric]\n        internal history of past timesteps\n    startup : Solver\n        internal solver instance for startup (building history) \n        of multistep methods (using 'ESDIRK32' for 'GEAR' methods)\n    \"\"\"\n\n    def __init__(self, *solver_args, **solver_kwargs):\n        super().__init__(*solver_args, **solver_kwargs)\n\n        #integration order and order of secondary method\n        self.n = None\n        self.m = None\n\n        #safety factor for error controller (if available)\n        self.beta = SOL_BETA\n\n        #gear timestep buffer\n        self.history_dt = deque([], maxlen=1)\n\n        #flag adaptive timestep solver\n        self.is_adaptive = True\n\n        #initialize startup solver from 'self'\n        self._needs_startup = True\n        self.startup = ESDIRK32.cast(self, self.parent)\n\n\n    @classmethod\n    def cast(cls, other, parent, **solver_kwargs):\n        \"\"\"cast to this solver needs special handling of startup method\n\n        Parameters\n        ----------\n        other : Solver\n            solver instance to cast new instance of this class from\n        parent : None | Solver\n            solver instance to use as parent\n        solver_kwargs : dict\n            other args for the solver\n\n        Returns\n        -------\n        engine : GEAR\n            instance of `GEAR` solver with params and state from `other`\n        \"\"\"\n        engine = super().cast(other, parent, **solver_kwargs)\n        engine.startup = ESDIRK32.cast(engine, parent)\n\n        return engine\n\n\n    @classmethod\n    def create(cls, initial_value, parent=None, from_engine=None, **solver_kwargs):\n        \"\"\"Create a new GEAR solver, properly initializing the startup solver.\n\n        Parameters\n        ----------\n        initial_value : float, array\n            initial condition / integration constant\n        parent : None | Solver\n            parent solver instance for stage synchronization\n        from_engine : None | Solver\n            existing solver to inherit state and settings from\n        solver_kwargs : dict\n            additional args for the solver\n\n        Returns\n        -------\n        engine : GEAR\n            new GEAR solver instance\n        \"\"\"\n        if from_engine is not None:\n            #inherit tolerances from existing engine if not specified\n            if \"tolerance_lte_rel\" not in solver_kwargs:\n                solver_kwargs[\"tolerance_lte_rel\"] = from_engine.tolerance_lte_rel\n            if \"tolerance_lte_abs\" not in solver_kwargs:\n                solver_kwargs[\"tolerance_lte_abs\"] = from_engine.tolerance_lte_abs\n\n            #create new solver (this initializes startup in __init__)\n            engine = cls(initial_value, parent, **solver_kwargs)\n\n            #preserve state from old engine\n            engine.state = from_engine.state\n\n            #re-initialize startup solver from the new engine\n            engine.startup = ESDIRK32.create(initial_value, parent, **solver_kwargs)\n            engine.startup.state = from_engine.state\n\n            return engine\n\n        #simple creation without existing engine\n        return cls(initial_value, parent, **solver_kwargs)\n\n\n    def stages(self, t, dt):\n        \"\"\"Generator that yields the intermediate evaluation \n        time during the timestep 't + ratio * dt'.\n\n        Parameters\n        ----------\n        t : float \n            evaluation time\n        dt : float\n            integration timestep\n        \"\"\"\n\n        #not enough history for full order -> stages of startup method\n        if self._needs_startup:\n            for self.stage, _t in enumerate(self.startup.stages(t, dt)):\n                yield _t\n        else:\n            for _t in super().stages(t, dt):\n                yield _t\n\n\n    def reset(self):\n        \"\"\"\"Resets integration engine to initial state.\"\"\"\n\n        #clear buffers\n        self.history.clear()\n        self.history_dt.clear()\n\n        #overwrite state with initial value (ensure array format)\n        self.x = np.atleast_1d(self.initial_value).copy()\n\n        #reset startup solver\n        self.startup.reset()\n\n\n    def buffer(self, dt):\n        \"\"\"Buffer the state and timestep. Dynamically precompute \n        the variable timestep BDF coefficients on the fly for the \n        current timestep.\n\n        Parameters\n        ----------\n        dt : float\n            integration timestep\n        \"\"\"\n\n        #reset optimizer\n        self.opt.reset()\n\n        #add to histories (solution and timestep)            \n        self.history.appendleft(self.x)\n        self.history_dt.appendleft(dt)\n\n        #flag for startup method\n        self._needs_startup = len(self.history) < self.n\n\n        #buffer with startup method\n        if self._needs_startup:\n            self.startup.buffer(dt)\n\n        #precompute coefficients here, where buffers are available\n        self.F, self.K = {}, {}\n        for n, _ in enumerate(self.history_dt, 1):\n            self.F[n], self.K[n] = compute_bdf_coefficients(n, np.array(self.history_dt))\n\n\n    # methods for adaptive timestep solvers --------------------------------------------\n\n    def revert(self):\n        \"\"\"Revert integration engine to previous timestep, this is only \n        relevant for adaptive methods where the simulation timestep 'dt' \n        is rescaled and the engine step is recomputed with the smaller \n        timestep.\n        \"\"\"\n\n        #reset internal state to previous state from history\n        self.x = self.history.popleft() \n\n        #also remove latest timestep from timestep history\n        _ = self.history_dt.popleft()\n\n        #revert startup method\n        if self._needs_startup:\n            self.startup.revert()\n\n\n    def error_controller(self, tr):\n        \"\"\"Compute scaling factor for adaptive timestep based on absolute and \n        relative tolerances for local truncation error. \n\n        Checks if the error tolerance is achieved and returns a success metric.\n\n        Parameters\n        ----------\n        tr : array[float]\n            truncation error estimate \n\n        Returns \n        -------\n        success : bool\n            True if the timestep was successful\n        error : float\n            estimated error of the internal error controller\n        scale : float\n            estimated timestep rescale factor for error control\n        \"\"\"\n\n        #compute scaling factors (avoid division by zero)\n        scale = self.tolerance_lte_abs + self.tolerance_lte_rel * np.abs(self.x)\n\n        #compute scaled truncation error (element-wise)\n        scaled_error = np.abs(tr) / scale\n\n        #compute the error norm and clip it\n        error_norm = np.clip(float(np.max(scaled_error)), TOLERANCE, None)\n\n        #determine if the error is acceptable\n        success = error_norm <= 1.0\n\n        #compute timestep scale factor using accuracy order of truncation error\n        timestep_rescale = self.beta / error_norm ** (1/self.n)\n\n        #clip the rescale factor to a reasonable range\n        timestep_rescale = np.clip(timestep_rescale, SOL_SCALE_MIN, SOL_SCALE_MAX)\n\n        return success, error_norm, timestep_rescale\n\n\n    # methods for timestepping ---------------------------------------------------------\n\n    def solve(self, f, J, dt):\n        \"\"\"Solves the implicit update equation using the optimizer of the engine.\n\n        Parameters\n        ----------\n        f : array_like\n            evaluation of function\n        J : array_like\n            evaluation of jacobian of function\n        dt : float \n            integration timestep\n\n        Returns\n        -------\n        err : float\n            residual error of the fixed point update equation\n\n        \"\"\"\n\n        #not enough history for full order -> solve with startup method\n        if self._needs_startup:\n            err = self.startup.solve(f, J, dt)\n            self.x = self.startup.get()\n            return err\n\n        #fixed-point function update (faster then sum comprehension)\n        g = self.F[self.n] * dt * f\n        for b, k in zip(self.history, self.K[self.n]):\n            g = g + b * k\n\n        #use the jacobian\n        if J is not None:\n\n            #optimizer step with block local jacobian\n            self.x, err = self.opt.step(self.x, g, self.F[self.n] * dt * J)\n\n        else:\n            #optimizer step (pure)\n            self.x, err = self.opt.step(self.x, g, None)\n\n        #return the fixed-point residual\n        return err\n\n\n    def step(self, f, dt):\n        \"\"\"Finalizes the timestep by resetting the solver for the implicit \n        update equation and computing the lower order estimate of the \n        solution for error control.\n\n        Parameters\n        ----------\n        f : array_like\n            evaluation of function\n        dt : float \n            integration timestep\n\n        Returns \n        -------\n        success : bool\n            True if the timestep was successful\n        error : float\n            estimated error of the internal error controller\n        scale : float\n            estimated timestep rescale factor for error control\n        \"\"\"\n\n        #not enough history for full order -> step with startup method\n        if self._needs_startup:\n            suc, err, scl = self.startup.step(f, dt)\n            self.x = self.startup.get()\n            return suc, err, scl\n\n        #estimate truncation error from lower order solution\n        tr = self.x - self.F[self.m] * dt * f\n        for b, k in zip(self.history, self.K[self.m]):\n            tr = tr - b * k\n\n        #error control\n        return self.error_controller(tr)",
          "bases": [
            "pathsim.solvers._solver.ImplicitSolver"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, *solver_args, **solver_kwargs):\n    super().__init__(*solver_args, **solver_kwargs)\n\n    #integration order and order of secondary method\n    self.n = None\n    self.m = None\n\n    #safety factor for error controller (if available)\n    self.beta = SOL_BETA\n\n    #gear timestep buffer\n    self.history_dt = deque([], maxlen=1)\n\n    #flag adaptive timestep solver\n    self.is_adaptive = True\n\n    #initialize startup solver from 'self'\n    self._needs_startup = True\n    self.startup = ESDIRK32.cast(self, self.parent)",
              "signature": "(solver_args = (), solver_kwargs = {})",
              "parameters": [
                {
                  "name": "solver_args",
                  "type": null,
                  "default": "()",
                  "description": ""
                },
                {
                  "name": "solver_kwargs",
                  "type": null,
                  "default": "{}",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "cast",
              "description": "cast to this solver needs special handling of startup method",
              "docstring_html": "<p>cast to this solver needs special handling of startup method</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>other <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">Solver</span></dt>\n<dd>solver instance to cast new instance of this class from</dd>\n<dt>parent <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">None | Solver</span></dt>\n<dd>solver instance to use as parent</dd>\n<dt>solver_kwargs <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">dict</span></dt>\n<dd>other args for the solver</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>engine <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">GEAR</span></dt>\n<dd>instance of <cite>GEAR</cite> solver with params and state from <cite>other</cite></dd>\n</dl>\n",
              "source": "@classmethod\ndef cast(cls, other, parent, **solver_kwargs):\n    \"\"\"cast to this solver needs special handling of startup method\n\n    Parameters\n    ----------\n    other : Solver\n        solver instance to cast new instance of this class from\n    parent : None | Solver\n        solver instance to use as parent\n    solver_kwargs : dict\n        other args for the solver\n\n    Returns\n    -------\n    engine : GEAR\n        instance of `GEAR` solver with params and state from `other`\n    \"\"\"\n    engine = super().cast(other, parent, **solver_kwargs)\n    engine.startup = ESDIRK32.cast(engine, parent)\n\n    return engine",
              "signature": "(cls, other, parent, solver_kwargs = {})",
              "parameters": [
                {
                  "name": "cls",
                  "type": null,
                  "default": null,
                  "description": ""
                },
                {
                  "name": "other",
                  "type": null,
                  "default": null,
                  "description": "solver instance to cast new instance of this class from"
                },
                {
                  "name": "parent",
                  "type": null,
                  "default": null,
                  "description": "solver instance to use as parent"
                },
                {
                  "name": "solver_kwargs",
                  "type": null,
                  "default": "{}",
                  "description": "other args for the solver"
                }
              ],
              "returns": null,
              "method_type": "classmethod"
            },
            {
              "name": "create",
              "description": "Create a new GEAR solver, properly initializing the startup solver.",
              "docstring_html": "<p>Create a new GEAR solver, properly initializing the startup solver.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>initial_value <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float, array</span></dt>\n<dd>initial condition / integration constant</dd>\n<dt>parent <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">None | Solver</span></dt>\n<dd>parent solver instance for stage synchronization</dd>\n<dt>from_engine <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">None | Solver</span></dt>\n<dd>existing solver to inherit state and settings from</dd>\n<dt>solver_kwargs <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">dict</span></dt>\n<dd>additional args for the solver</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>engine <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">GEAR</span></dt>\n<dd>new GEAR solver instance</dd>\n</dl>\n",
              "source": "@classmethod\ndef create(cls, initial_value, parent=None, from_engine=None, **solver_kwargs):\n    \"\"\"Create a new GEAR solver, properly initializing the startup solver.\n\n    Parameters\n    ----------\n    initial_value : float, array\n        initial condition / integration constant\n    parent : None | Solver\n        parent solver instance for stage synchronization\n    from_engine : None | Solver\n        existing solver to inherit state and settings from\n    solver_kwargs : dict\n        additional args for the solver\n\n    Returns\n    -------\n    engine : GEAR\n        new GEAR solver instance\n    \"\"\"\n    if from_engine is not None:\n        #inherit tolerances from existing engine if not specified\n        if \"tolerance_lte_rel\" not in solver_kwargs:\n            solver_kwargs[\"tolerance_lte_rel\"] = from_engine.tolerance_lte_rel\n        if \"tolerance_lte_abs\" not in solver_kwargs:\n            solver_kwargs[\"tolerance_lte_abs\"] = from_engine.tolerance_lte_abs\n\n        #create new solver (this initializes startup in __init__)\n        engine = cls(initial_value, parent, **solver_kwargs)\n\n        #preserve state from old engine\n        engine.state = from_engine.state\n\n        #re-initialize startup solver from the new engine\n        engine.startup = ESDIRK32.create(initial_value, parent, **solver_kwargs)\n        engine.startup.state = from_engine.state\n\n        return engine\n\n    #simple creation without existing engine\n    return cls(initial_value, parent, **solver_kwargs)",
              "signature": "(cls, initial_value, parent = None, from_engine = None, solver_kwargs = {})",
              "parameters": [
                {
                  "name": "cls",
                  "type": null,
                  "default": null,
                  "description": ""
                },
                {
                  "name": "initial_value",
                  "type": null,
                  "default": null,
                  "description": "initial condition / integration constant"
                },
                {
                  "name": "parent",
                  "type": null,
                  "default": "None",
                  "description": "parent solver instance for stage synchronization"
                },
                {
                  "name": "from_engine",
                  "type": null,
                  "default": "None",
                  "description": "existing solver to inherit state and settings from"
                },
                {
                  "name": "solver_kwargs",
                  "type": null,
                  "default": "{}",
                  "description": "additional args for the solver"
                }
              ],
              "returns": null,
              "method_type": "classmethod"
            },
            {
              "name": "stages",
              "description": "Generator that yields the intermediate evaluation",
              "docstring_html": "<p>Generator that yields the intermediate evaluation\ntime during the timestep 't + ratio * dt'.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time</dd>\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>integration timestep</dd>\n</dl>\n",
              "source": "def stages(self, t, dt):\n    \"\"\"Generator that yields the intermediate evaluation \n    time during the timestep 't + ratio * dt'.\n\n    Parameters\n    ----------\n    t : float \n        evaluation time\n    dt : float\n        integration timestep\n    \"\"\"\n\n    #not enough history for full order -> stages of startup method\n    if self._needs_startup:\n        for self.stage, _t in enumerate(self.startup.stages(t, dt)):\n            yield _t\n    else:\n        for _t in super().stages(t, dt):\n            yield _t",
              "signature": "(t, dt)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time"
                },
                {
                  "name": "dt",
                  "type": null,
                  "default": null,
                  "description": "integration timestep"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "reset",
              "description": "\"Resets integration engine to initial state.",
              "docstring_html": "<p>&quot;Resets integration engine to initial state.</p>\n",
              "source": "def reset(self):\n    \"\"\"\"Resets integration engine to initial state.\"\"\"\n\n    #clear buffers\n    self.history.clear()\n    self.history_dt.clear()\n\n    #overwrite state with initial value (ensure array format)\n    self.x = np.atleast_1d(self.initial_value).copy()\n\n    #reset startup solver\n    self.startup.reset()",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "buffer",
              "description": "Buffer the state and timestep. Dynamically precompute",
              "docstring_html": "<p>Buffer the state and timestep. Dynamically precompute\nthe variable timestep BDF coefficients on the fly for the\ncurrent timestep.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>integration timestep</dd>\n</dl>\n",
              "source": "def buffer(self, dt):\n    \"\"\"Buffer the state and timestep. Dynamically precompute \n    the variable timestep BDF coefficients on the fly for the \n    current timestep.\n\n    Parameters\n    ----------\n    dt : float\n        integration timestep\n    \"\"\"\n\n    #reset optimizer\n    self.opt.reset()\n\n    #add to histories (solution and timestep)            \n    self.history.appendleft(self.x)\n    self.history_dt.appendleft(dt)\n\n    #flag for startup method\n    self._needs_startup = len(self.history) < self.n\n\n    #buffer with startup method\n    if self._needs_startup:\n        self.startup.buffer(dt)\n\n    #precompute coefficients here, where buffers are available\n    self.F, self.K = {}, {}\n    for n, _ in enumerate(self.history_dt, 1):\n        self.F[n], self.K[n] = compute_bdf_coefficients(n, np.array(self.history_dt))",
              "signature": "(dt)",
              "parameters": [
                {
                  "name": "dt",
                  "type": null,
                  "default": null,
                  "description": "integration timestep"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "revert",
              "description": "Revert integration engine to previous timestep, this is only",
              "docstring_html": "<p>Revert integration engine to previous timestep, this is only\nrelevant for adaptive methods where the simulation timestep 'dt'\nis rescaled and the engine step is recomputed with the smaller\ntimestep.</p>\n",
              "source": "def revert(self):\n    \"\"\"Revert integration engine to previous timestep, this is only \n    relevant for adaptive methods where the simulation timestep 'dt' \n    is rescaled and the engine step is recomputed with the smaller \n    timestep.\n    \"\"\"\n\n    #reset internal state to previous state from history\n    self.x = self.history.popleft() \n\n    #also remove latest timestep from timestep history\n    _ = self.history_dt.popleft()\n\n    #revert startup method\n    if self._needs_startup:\n        self.startup.revert()",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "error_controller",
              "description": "Compute scaling factor for adaptive timestep based on absolute and",
              "docstring_html": "<p>Compute scaling factor for adaptive timestep based on absolute and\nrelative tolerances for local truncation error.</p>\n<p>Checks if the error tolerance is achieved and returns a success metric.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>tr <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array[float]</span></dt>\n<dd>truncation error estimate</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>success <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>True if the timestep was successful</dd>\n<dt>error <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>estimated error of the internal error controller</dd>\n<dt>scale <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>estimated timestep rescale factor for error control</dd>\n</dl>\n",
              "source": "def error_controller(self, tr):\n    \"\"\"Compute scaling factor for adaptive timestep based on absolute and \n    relative tolerances for local truncation error. \n\n    Checks if the error tolerance is achieved and returns a success metric.\n\n    Parameters\n    ----------\n    tr : array[float]\n        truncation error estimate \n\n    Returns \n    -------\n    success : bool\n        True if the timestep was successful\n    error : float\n        estimated error of the internal error controller\n    scale : float\n        estimated timestep rescale factor for error control\n    \"\"\"\n\n    #compute scaling factors (avoid division by zero)\n    scale = self.tolerance_lte_abs + self.tolerance_lte_rel * np.abs(self.x)\n\n    #compute scaled truncation error (element-wise)\n    scaled_error = np.abs(tr) / scale\n\n    #compute the error norm and clip it\n    error_norm = np.clip(float(np.max(scaled_error)), TOLERANCE, None)\n\n    #determine if the error is acceptable\n    success = error_norm <= 1.0\n\n    #compute timestep scale factor using accuracy order of truncation error\n    timestep_rescale = self.beta / error_norm ** (1/self.n)\n\n    #clip the rescale factor to a reasonable range\n    timestep_rescale = np.clip(timestep_rescale, SOL_SCALE_MIN, SOL_SCALE_MAX)\n\n    return success, error_norm, timestep_rescale",
              "signature": "(tr)",
              "parameters": [
                {
                  "name": "tr",
                  "type": null,
                  "default": null,
                  "description": "truncation error estimate"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "solve",
              "description": "Solves the implicit update equation using the optimizer of the engine.",
              "docstring_html": "<p>Solves the implicit update equation using the optimizer of the engine.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>f <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array_like</span></dt>\n<dd>evaluation of function</dd>\n<dt>J <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array_like</span></dt>\n<dd>evaluation of jacobian of function</dd>\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>integration timestep</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>err <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>residual error of the fixed point update equation</dd>\n</dl>\n",
              "source": "def solve(self, f, J, dt):\n    \"\"\"Solves the implicit update equation using the optimizer of the engine.\n\n    Parameters\n    ----------\n    f : array_like\n        evaluation of function\n    J : array_like\n        evaluation of jacobian of function\n    dt : float \n        integration timestep\n\n    Returns\n    -------\n    err : float\n        residual error of the fixed point update equation\n\n    \"\"\"\n\n    #not enough history for full order -> solve with startup method\n    if self._needs_startup:\n        err = self.startup.solve(f, J, dt)\n        self.x = self.startup.get()\n        return err\n\n    #fixed-point function update (faster then sum comprehension)\n    g = self.F[self.n] * dt * f\n    for b, k in zip(self.history, self.K[self.n]):\n        g = g + b * k\n\n    #use the jacobian\n    if J is not None:\n\n        #optimizer step with block local jacobian\n        self.x, err = self.opt.step(self.x, g, self.F[self.n] * dt * J)\n\n    else:\n        #optimizer step (pure)\n        self.x, err = self.opt.step(self.x, g, None)\n\n    #return the fixed-point residual\n    return err",
              "signature": "(f, J, dt)",
              "parameters": [
                {
                  "name": "f",
                  "type": null,
                  "default": null,
                  "description": "evaluation of function"
                },
                {
                  "name": "J",
                  "type": null,
                  "default": null,
                  "description": "evaluation of jacobian of function"
                },
                {
                  "name": "dt",
                  "type": null,
                  "default": null,
                  "description": "integration timestep"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "step",
              "description": "Finalizes the timestep by resetting the solver for the implicit",
              "docstring_html": "<p>Finalizes the timestep by resetting the solver for the implicit\nupdate equation and computing the lower order estimate of the\nsolution for error control.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>f <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array_like</span></dt>\n<dd>evaluation of function</dd>\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>integration timestep</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>success <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>True if the timestep was successful</dd>\n<dt>error <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>estimated error of the internal error controller</dd>\n<dt>scale <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>estimated timestep rescale factor for error control</dd>\n</dl>\n",
              "source": "def step(self, f, dt):\n    \"\"\"Finalizes the timestep by resetting the solver for the implicit \n    update equation and computing the lower order estimate of the \n    solution for error control.\n\n    Parameters\n    ----------\n    f : array_like\n        evaluation of function\n    dt : float \n        integration timestep\n\n    Returns \n    -------\n    success : bool\n        True if the timestep was successful\n    error : float\n        estimated error of the internal error controller\n    scale : float\n        estimated timestep rescale factor for error control\n    \"\"\"\n\n    #not enough history for full order -> step with startup method\n    if self._needs_startup:\n        suc, err, scl = self.startup.step(f, dt)\n        self.x = self.startup.get()\n        return suc, err, scl\n\n    #estimate truncation error from lower order solution\n    tr = self.x - self.F[self.m] * dt * f\n    for b, k in zip(self.history, self.K[self.m]):\n        tr = tr - b * k\n\n    #error control\n    return self.error_controller(tr)",
              "signature": "(f, dt)",
              "parameters": [
                {
                  "name": "f",
                  "type": null,
                  "default": null,
                  "description": "evaluation of function"
                },
                {
                  "name": "dt",
                  "type": null,
                  "default": null,
                  "description": "integration timestep"
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "n",
              "description": "",
              "type": null,
              "value": "None"
            },
            {
              "name": "m",
              "description": "",
              "type": null,
              "value": "None"
            },
            {
              "name": "beta",
              "description": "",
              "type": null,
              "value": "SOL_BETA"
            },
            {
              "name": "history_dt",
              "description": "",
              "type": null,
              "value": "deque([], maxlen=1)"
            },
            {
              "name": "is_adaptive",
              "description": "",
              "type": null,
              "value": "True"
            },
            {
              "name": "_needs_startup",
              "description": "",
              "type": null,
              "value": "True"
            },
            {
              "name": "startup",
              "description": "",
              "type": null,
              "value": "ESDIRK32.cast(self, self.parent)"
            }
          ],
          "parameters": [
            {
              "name": "solver_args",
              "type": null,
              "default": "()",
              "description": ""
            },
            {
              "name": "solver_kwargs",
              "type": null,
              "default": "{}",
              "description": ""
            }
          ]
        },
        {
          "name": "GEAR21",
          "description": "Variable-step 2nd order BDF with 1st order error estimate. A-stable.",
          "docstring_html": "<p>Variable-step 2nd order BDF with 1st order error estimate. A-stable.</p>\n<p>BDF coefficients are recomputed each step to account for variable\ntimesteps. Uses <tt class=\"docutils literal\">ESDIRK32</tt> as startup solver.</p>\n<div class=\"section\" id=\"characteristics\">\n<h4>Characteristics</h4>\n<ul class=\"simple\">\n<li>Order: 2 (stepping) / 1 (error estimate)</li>\n<li>Implicit variable-step multistep</li>\n<li>Adaptive timestep</li>\n<li>A-stable</li>\n</ul>\n</div>\n<div class=\"section\" id=\"note\">\n<h4>Note</h4>\n<p>The simplest adaptive multistep stiff solver. A-stability makes it safe\nfor any stiff block diagram. The multistep approach reuses past solution\nvalues, so per-step cost is lower than single-step implicit methods\n(ESDIRK), but a startup phase is needed to fill the history buffer. For\nhigher accuracy, use <tt class=\"docutils literal\">GEAR32</tt> or <tt class=\"docutils literal\">ESDIRK43</tt>.</p>\n<p><strong>References</strong></p>\n<table class=\"docutils footnote\" frame=\"void\" id=\"footnote-1\" rules=\"none\">\n<colgroup><col class=\"label\" /><col /></colgroup>\n<tbody valign=\"top\">\n<tr><td class=\"label\">[1]</td><td>Gear, C. W. (1971). &quot;Numerical Initial Value Problems in Ordinary\nDifferential Equations&quot;. Prentice-Hall.</td></tr>\n</tbody>\n</table>\n<table class=\"docutils footnote\" frame=\"void\" id=\"footnote-2\" rules=\"none\">\n<colgroup><col class=\"label\" /><col /></colgroup>\n<tbody valign=\"top\">\n<tr><td class=\"label\">[2]</td><td>Hairer, E., &amp; Wanner, G. (1996). &quot;Solving Ordinary Differential\nEquations II: Stiff and Differential-Algebraic Problems&quot;. Springer\nSeries in Computational Mathematics, Vol. 14.\n:doi:`10.1007/978-3-642-05221-7`</td></tr>\n</tbody>\n</table>\n</div>\n",
          "source": "class GEAR21(GEAR):\n    \"\"\"Variable-step 2nd order BDF with 1st order error estimate. A-stable.\n\n    BDF coefficients are recomputed each step to account for variable\n    timesteps. Uses ``ESDIRK32`` as startup solver.\n\n    Characteristics\n    ---------------\n    * Order: 2 (stepping) / 1 (error estimate)\n    * Implicit variable-step multistep\n    * Adaptive timestep\n    * A-stable\n\n    Note\n    ----\n    The simplest adaptive multistep stiff solver. A-stability makes it safe\n    for any stiff block diagram. The multistep approach reuses past solution\n    values, so per-step cost is lower than single-step implicit methods\n    (ESDIRK), but a startup phase is needed to fill the history buffer. For\n    higher accuracy, use ``GEAR32`` or ``ESDIRK43``.\n\n    References\n    ----------\n    .. [1] Gear, C. W. (1971). \"Numerical Initial Value Problems in Ordinary\n           Differential Equations\". Prentice-Hall.\n    .. [2] Hairer, E., & Wanner, G. (1996). \"Solving Ordinary Differential\n           Equations II: Stiff and Differential-Algebraic Problems\". Springer\n           Series in Computational Mathematics, Vol. 14.\n           :doi:`10.1007/978-3-642-05221-7`\n\n    \"\"\"\n\n    def __init__(self, *solver_args, **solver_kwargs):\n        super().__init__(*solver_args, **solver_kwargs)\n\n        #integration order and order of secondary method\n        self.n = 2\n        self.m = 1\n\n        #gear buffers, here 2\n        self.history = deque([], maxlen=2)\n        self.history_dt = deque([], maxlen=2)",
          "bases": [
            "pathsim.solvers.gear.GEAR"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, *solver_args, **solver_kwargs):\n    super().__init__(*solver_args, **solver_kwargs)\n\n    #integration order and order of secondary method\n    self.n = 2\n    self.m = 1\n\n    #gear buffers, here 2\n    self.history = deque([], maxlen=2)\n    self.history_dt = deque([], maxlen=2)",
              "signature": "(solver_args = (), solver_kwargs = {})",
              "parameters": [
                {
                  "name": "solver_args",
                  "type": null,
                  "default": "()",
                  "description": ""
                },
                {
                  "name": "solver_kwargs",
                  "type": null,
                  "default": "{}",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "n",
              "description": "",
              "type": null,
              "value": "2"
            },
            {
              "name": "m",
              "description": "",
              "type": null,
              "value": "1"
            },
            {
              "name": "history",
              "description": "",
              "type": null,
              "value": "deque([], maxlen=2)"
            },
            {
              "name": "history_dt",
              "description": "",
              "type": null,
              "value": "deque([], maxlen=2)"
            }
          ],
          "parameters": [
            {
              "name": "solver_args",
              "type": null,
              "default": "()",
              "description": ""
            },
            {
              "name": "solver_kwargs",
              "type": null,
              "default": "{}",
              "description": ""
            }
          ]
        },
        {
          "name": "GEAR32",
          "description": "Variable-step 3rd order BDF with 2nd order error estimate.",
          "docstring_html": "<p>Variable-step 3rd order BDF with 2nd order error estimate.\n<tt class=\"math\">A(\\alpha)</tt>-stable.</p>\n<p>Uses <tt class=\"docutils literal\">ESDIRK32</tt> as startup solver.</p>\n<div class=\"section\" id=\"characteristics\">\n<h4>Characteristics</h4>\n<ul class=\"simple\">\n<li>Order: 3 (stepping) / 2 (error estimate)</li>\n<li>Implicit variable-step multistep</li>\n<li>Adaptive timestep</li>\n<li><tt class=\"math\">A(\\alpha)</tt>-stable (BDF3 stability wedge)</li>\n</ul>\n</div>\n<div class=\"section\" id=\"note\">\n<h4>Note</h4>\n<p>Good balance of accuracy and stability for stiff block diagrams. The\nstability wedge is nearly as wide as <tt class=\"docutils literal\">GEAR21</tt> (<tt class=\"math\">\\approx 86°</tt>)\nwhile providing an extra order of accuracy. For most stiff systems this\nis a practical default when a multistep solver is preferred over ESDIRK.</p>\n<p><strong>References</strong></p>\n<table class=\"docutils footnote\" frame=\"void\" id=\"footnote-1\" rules=\"none\">\n<colgroup><col class=\"label\" /><col /></colgroup>\n<tbody valign=\"top\">\n<tr><td class=\"label\">[1]</td><td>Gear, C. W. (1971). &quot;Numerical Initial Value Problems in Ordinary\nDifferential Equations&quot;. Prentice-Hall.</td></tr>\n</tbody>\n</table>\n<table class=\"docutils footnote\" frame=\"void\" id=\"footnote-2\" rules=\"none\">\n<colgroup><col class=\"label\" /><col /></colgroup>\n<tbody valign=\"top\">\n<tr><td class=\"label\">[2]</td><td>Hairer, E., &amp; Wanner, G. (1996). &quot;Solving Ordinary Differential\nEquations II: Stiff and Differential-Algebraic Problems&quot;. Springer\nSeries in Computational Mathematics, Vol. 14.\n:doi:`10.1007/978-3-642-05221-7`</td></tr>\n</tbody>\n</table>\n</div>\n",
          "source": "class GEAR32(GEAR):\n    \"\"\"Variable-step 3rd order BDF with 2nd order error estimate.\n    :math:`A(\\\\alpha)`-stable.\n\n    Uses ``ESDIRK32`` as startup solver.\n\n    Characteristics\n    ---------------\n    * Order: 3 (stepping) / 2 (error estimate)\n    * Implicit variable-step multistep\n    * Adaptive timestep\n    * :math:`A(\\\\alpha)`-stable (BDF3 stability wedge)\n\n    Note\n    ----\n    Good balance of accuracy and stability for stiff block diagrams. The\n    stability wedge is nearly as wide as ``GEAR21`` (:math:`\\\\approx 86°`)\n    while providing an extra order of accuracy. For most stiff systems this\n    is a practical default when a multistep solver is preferred over ESDIRK.\n\n    References\n    ----------\n    .. [1] Gear, C. W. (1971). \"Numerical Initial Value Problems in Ordinary\n           Differential Equations\". Prentice-Hall.\n    .. [2] Hairer, E., & Wanner, G. (1996). \"Solving Ordinary Differential\n           Equations II: Stiff and Differential-Algebraic Problems\". Springer\n           Series in Computational Mathematics, Vol. 14.\n           :doi:`10.1007/978-3-642-05221-7`\n\n    \"\"\"\n\n    def __init__(self, *solver_args, **solver_kwargs):\n        super().__init__(*solver_args, **solver_kwargs)\n\n        #integration order and order of secondary method\n        self.n = 3\n        self.m = 2\n\n        #gear buffers, here 3\n        self.history = deque([], maxlen=3)\n        self.history_dt = deque([], maxlen=3)",
          "bases": [
            "pathsim.solvers.gear.GEAR"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, *solver_args, **solver_kwargs):\n    super().__init__(*solver_args, **solver_kwargs)\n\n    #integration order and order of secondary method\n    self.n = 3\n    self.m = 2\n\n    #gear buffers, here 3\n    self.history = deque([], maxlen=3)\n    self.history_dt = deque([], maxlen=3)",
              "signature": "(solver_args = (), solver_kwargs = {})",
              "parameters": [
                {
                  "name": "solver_args",
                  "type": null,
                  "default": "()",
                  "description": ""
                },
                {
                  "name": "solver_kwargs",
                  "type": null,
                  "default": "{}",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "n",
              "description": "",
              "type": null,
              "value": "3"
            },
            {
              "name": "m",
              "description": "",
              "type": null,
              "value": "2"
            },
            {
              "name": "history",
              "description": "",
              "type": null,
              "value": "deque([], maxlen=3)"
            },
            {
              "name": "history_dt",
              "description": "",
              "type": null,
              "value": "deque([], maxlen=3)"
            }
          ],
          "parameters": [
            {
              "name": "solver_args",
              "type": null,
              "default": "()",
              "description": ""
            },
            {
              "name": "solver_kwargs",
              "type": null,
              "default": "{}",
              "description": ""
            }
          ]
        },
        {
          "name": "GEAR43",
          "description": "Variable-step 4th order BDF with 3rd order error estimate.",
          "docstring_html": "<p>Variable-step 4th order BDF with 3rd order error estimate.\n<tt class=\"math\">A(\\alpha)</tt>-stable.</p>\n<p>Uses <tt class=\"docutils literal\">ESDIRK32</tt> as startup solver.</p>\n<div class=\"section\" id=\"characteristics\">\n<h4>Characteristics</h4>\n<ul class=\"simple\">\n<li>Order: 4 (stepping) / 3 (error estimate)</li>\n<li>Implicit variable-step multistep</li>\n<li>Adaptive timestep</li>\n<li><tt class=\"math\">A(\\alpha)</tt>-stable (BDF4 stability wedge, <tt class=\"math\">\\approx 73°</tt>)</li>\n</ul>\n</div>\n<div class=\"section\" id=\"note\">\n<h4>Note</h4>\n<p>Narrower stability wedge than <tt class=\"docutils literal\">GEAR32</tt>. Eigenvalues near the imaginary\naxis may be poorly damped. Use only when the stiff modes are strongly\ndissipative and 4th order accuracy is needed. Otherwise, <tt class=\"docutils literal\">GEAR32</tt> or\n<tt class=\"docutils literal\">ESDIRK43</tt> are safer choices.</p>\n<p><strong>References</strong></p>\n<table class=\"docutils footnote\" frame=\"void\" id=\"footnote-1\" rules=\"none\">\n<colgroup><col class=\"label\" /><col /></colgroup>\n<tbody valign=\"top\">\n<tr><td class=\"label\">[1]</td><td>Gear, C. W. (1971). &quot;Numerical Initial Value Problems in Ordinary\nDifferential Equations&quot;. Prentice-Hall.</td></tr>\n</tbody>\n</table>\n<table class=\"docutils footnote\" frame=\"void\" id=\"footnote-2\" rules=\"none\">\n<colgroup><col class=\"label\" /><col /></colgroup>\n<tbody valign=\"top\">\n<tr><td class=\"label\">[2]</td><td>Hairer, E., &amp; Wanner, G. (1996). &quot;Solving Ordinary Differential\nEquations II: Stiff and Differential-Algebraic Problems&quot;. Springer\nSeries in Computational Mathematics, Vol. 14.\n:doi:`10.1007/978-3-642-05221-7`</td></tr>\n</tbody>\n</table>\n</div>\n",
          "source": "class GEAR43(GEAR):\n    \"\"\"Variable-step 4th order BDF with 3rd order error estimate.\n    :math:`A(\\\\alpha)`-stable.\n\n    Uses ``ESDIRK32`` as startup solver.\n\n    Characteristics\n    ---------------\n    * Order: 4 (stepping) / 3 (error estimate)\n    * Implicit variable-step multistep\n    * Adaptive timestep\n    * :math:`A(\\\\alpha)`-stable (BDF4 stability wedge, :math:`\\\\approx 73°`)\n\n    Note\n    ----\n    Narrower stability wedge than ``GEAR32``. Eigenvalues near the imaginary\n    axis may be poorly damped. Use only when the stiff modes are strongly\n    dissipative and 4th order accuracy is needed. Otherwise, ``GEAR32`` or\n    ``ESDIRK43`` are safer choices.\n\n    References\n    ----------\n    .. [1] Gear, C. W. (1971). \"Numerical Initial Value Problems in Ordinary\n           Differential Equations\". Prentice-Hall.\n    .. [2] Hairer, E., & Wanner, G. (1996). \"Solving Ordinary Differential\n           Equations II: Stiff and Differential-Algebraic Problems\". Springer\n           Series in Computational Mathematics, Vol. 14.\n           :doi:`10.1007/978-3-642-05221-7`\n\n    \"\"\"\n\n    def __init__(self, *solver_args, **solver_kwargs):\n        super().__init__(*solver_args, **solver_kwargs)\n\n        #integration order and order of secondary method\n        self.n = 4\n        self.m = 3\n\n        #gear buffers, here 4\n        self.history = deque([], maxlen=4)\n        self.history_dt = deque([], maxlen=4)",
          "bases": [
            "pathsim.solvers.gear.GEAR"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, *solver_args, **solver_kwargs):\n    super().__init__(*solver_args, **solver_kwargs)\n\n    #integration order and order of secondary method\n    self.n = 4\n    self.m = 3\n\n    #gear buffers, here 4\n    self.history = deque([], maxlen=4)\n    self.history_dt = deque([], maxlen=4)",
              "signature": "(solver_args = (), solver_kwargs = {})",
              "parameters": [
                {
                  "name": "solver_args",
                  "type": null,
                  "default": "()",
                  "description": ""
                },
                {
                  "name": "solver_kwargs",
                  "type": null,
                  "default": "{}",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "n",
              "description": "",
              "type": null,
              "value": "4"
            },
            {
              "name": "m",
              "description": "",
              "type": null,
              "value": "3"
            },
            {
              "name": "history",
              "description": "",
              "type": null,
              "value": "deque([], maxlen=4)"
            },
            {
              "name": "history_dt",
              "description": "",
              "type": null,
              "value": "deque([], maxlen=4)"
            }
          ],
          "parameters": [
            {
              "name": "solver_args",
              "type": null,
              "default": "()",
              "description": ""
            },
            {
              "name": "solver_kwargs",
              "type": null,
              "default": "{}",
              "description": ""
            }
          ]
        },
        {
          "name": "GEAR54",
          "description": "Variable-step 5th order BDF with 4th order error estimate.",
          "docstring_html": "<p>Variable-step 5th order BDF with 4th order error estimate.\n<tt class=\"math\">A(\\alpha)</tt>-stable.</p>\n<p>Uses <tt class=\"docutils literal\">ESDIRK32</tt> as startup solver.</p>\n<div class=\"section\" id=\"characteristics\">\n<h4>Characteristics</h4>\n<ul class=\"simple\">\n<li>Order: 5 (stepping) / 4 (error estimate)</li>\n<li>Implicit variable-step multistep</li>\n<li>Adaptive timestep</li>\n<li><tt class=\"math\">A(\\alpha)</tt>-stable (BDF5 stability wedge, <tt class=\"math\">\\approx 51°</tt>)</li>\n</ul>\n</div>\n<div class=\"section\" id=\"note\">\n<h4>Note</h4>\n<p>The stability wedge is significantly narrower than lower-order GEAR\nvariants. Only justified for mildly stiff problems where 5th order\naccuracy yields a clear efficiency gain. For strongly stiff systems,\n<tt class=\"docutils literal\">GEAR21</tt>/<tt class=\"docutils literal\">GEAR32</tt> or <tt class=\"docutils literal\">ESDIRK54</tt> are more robust.</p>\n<p><strong>References</strong></p>\n<table class=\"docutils footnote\" frame=\"void\" id=\"footnote-1\" rules=\"none\">\n<colgroup><col class=\"label\" /><col /></colgroup>\n<tbody valign=\"top\">\n<tr><td class=\"label\">[1]</td><td>Gear, C. W. (1971). &quot;Numerical Initial Value Problems in Ordinary\nDifferential Equations&quot;. Prentice-Hall.</td></tr>\n</tbody>\n</table>\n<table class=\"docutils footnote\" frame=\"void\" id=\"footnote-2\" rules=\"none\">\n<colgroup><col class=\"label\" /><col /></colgroup>\n<tbody valign=\"top\">\n<tr><td class=\"label\">[2]</td><td>Hairer, E., &amp; Wanner, G. (1996). &quot;Solving Ordinary Differential\nEquations II: Stiff and Differential-Algebraic Problems&quot;. Springer\nSeries in Computational Mathematics, Vol. 14.\n:doi:`10.1007/978-3-642-05221-7`</td></tr>\n</tbody>\n</table>\n</div>\n",
          "source": "class GEAR54(GEAR):\n    \"\"\"Variable-step 5th order BDF with 4th order error estimate.\n    :math:`A(\\\\alpha)`-stable.\n\n    Uses ``ESDIRK32`` as startup solver.\n\n    Characteristics\n    ---------------\n    * Order: 5 (stepping) / 4 (error estimate)\n    * Implicit variable-step multistep\n    * Adaptive timestep\n    * :math:`A(\\\\alpha)`-stable (BDF5 stability wedge, :math:`\\\\approx 51°`)\n\n    Note\n    ----\n    The stability wedge is significantly narrower than lower-order GEAR\n    variants. Only justified for mildly stiff problems where 5th order\n    accuracy yields a clear efficiency gain. For strongly stiff systems,\n    ``GEAR21``/``GEAR32`` or ``ESDIRK54`` are more robust.\n\n    References\n    ----------\n    .. [1] Gear, C. W. (1971). \"Numerical Initial Value Problems in Ordinary\n           Differential Equations\". Prentice-Hall.\n    .. [2] Hairer, E., & Wanner, G. (1996). \"Solving Ordinary Differential\n           Equations II: Stiff and Differential-Algebraic Problems\". Springer\n           Series in Computational Mathematics, Vol. 14.\n           :doi:`10.1007/978-3-642-05221-7`\n\n    \"\"\"\n\n    def __init__(self, *solver_args, **solver_kwargs):\n        super().__init__(*solver_args, **solver_kwargs)\n\n        #integration order and order of secondary method\n        self.n = 5\n        self.m = 4\n\n        #gear, here 5+1\n        self.history = deque([], maxlen=5)\n        self.history_dt = deque([], maxlen=5)",
          "bases": [
            "pathsim.solvers.gear.GEAR"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, *solver_args, **solver_kwargs):\n    super().__init__(*solver_args, **solver_kwargs)\n\n    #integration order and order of secondary method\n    self.n = 5\n    self.m = 4\n\n    #gear, here 5+1\n    self.history = deque([], maxlen=5)\n    self.history_dt = deque([], maxlen=5)",
              "signature": "(solver_args = (), solver_kwargs = {})",
              "parameters": [
                {
                  "name": "solver_args",
                  "type": null,
                  "default": "()",
                  "description": ""
                },
                {
                  "name": "solver_kwargs",
                  "type": null,
                  "default": "{}",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "n",
              "description": "",
              "type": null,
              "value": "5"
            },
            {
              "name": "m",
              "description": "",
              "type": null,
              "value": "4"
            },
            {
              "name": "history",
              "description": "",
              "type": null,
              "value": "deque([], maxlen=5)"
            },
            {
              "name": "history_dt",
              "description": "",
              "type": null,
              "value": "deque([], maxlen=5)"
            }
          ],
          "parameters": [
            {
              "name": "solver_args",
              "type": null,
              "default": "()",
              "description": ""
            },
            {
              "name": "solver_kwargs",
              "type": null,
              "default": "{}",
              "description": ""
            }
          ]
        },
        {
          "name": "GEAR52A",
          "description": "Variable-step, variable-order BDF (orders 2--5). Adapts both timestep",
          "docstring_html": "<p>Variable-step, variable-order BDF (orders 2--5). Adapts both timestep\nand order automatically.</p>\n<p>At each step the error controller compares estimates from orders\n<tt class=\"math\">n-1</tt> and <tt class=\"math\">n+1</tt> and selects the order that minimises the\nnormalised error, allowing larger steps. Analogous to MATLAB's\n<tt class=\"docutils literal\">ode15s</tt>. Uses <tt class=\"docutils literal\">ESDIRK32</tt> as startup solver.</p>\n<div class=\"section\" id=\"characteristics\">\n<h4>Characteristics</h4>\n<ul class=\"simple\">\n<li>Order: variable, 2--5</li>\n<li>Implicit variable-step, variable-order multistep</li>\n<li>Adaptive timestep and order</li>\n<li>Stability: A-stable at order 2, <tt class=\"math\">A(\\alpha)</tt>-stable at orders 3--5</li>\n</ul>\n</div>\n<div class=\"section\" id=\"note\">\n<h4>Note</h4>\n<p>The most autonomous stiff solver in this library. Automatically selects\nhigher orders in smooth regions for larger steps and drops to low order\nin stiff or transient regions for stability. A good default when the\ncharacter of the block diagram is unknown or changes during the\nsimulation (e.g. switching events, varying loads).</p>\n<p><strong>References</strong></p>\n<table class=\"docutils footnote\" frame=\"void\" id=\"footnote-1\" rules=\"none\">\n<colgroup><col class=\"label\" /><col /></colgroup>\n<tbody valign=\"top\">\n<tr><td class=\"label\">[1]</td><td>Gear, C. W. (1971). &quot;Numerical Initial Value Problems in Ordinary\nDifferential Equations&quot;. Prentice-Hall.</td></tr>\n</tbody>\n</table>\n<table class=\"docutils footnote\" frame=\"void\" id=\"footnote-2\" rules=\"none\">\n<colgroup><col class=\"label\" /><col /></colgroup>\n<tbody valign=\"top\">\n<tr><td class=\"label\">[2]</td><td>Shampine, L. F., &amp; Reichelt, M. W. (1997). &quot;The MATLAB ODE\nSuite&quot;. SIAM Journal on Scientific Computing, 18(1), 1-22.\n:doi:`10.1137/S1064827594276424`</td></tr>\n</tbody>\n</table>\n<table class=\"docutils footnote\" frame=\"void\" id=\"footnote-3\" rules=\"none\">\n<colgroup><col class=\"label\" /><col /></colgroup>\n<tbody valign=\"top\">\n<tr><td class=\"label\">[3]</td><td>Hairer, E., &amp; Wanner, G. (1996). &quot;Solving Ordinary Differential\nEquations II: Stiff and Differential-Algebraic Problems&quot;. Springer\nSeries in Computational Mathematics, Vol. 14.\n:doi:`10.1007/978-3-642-05221-7`</td></tr>\n</tbody>\n</table>\n</div>\n",
          "source": "class GEAR52A(GEAR):\n    \"\"\"Variable-step, variable-order BDF (orders 2--5). Adapts both timestep\n    and order automatically.\n\n    At each step the error controller compares estimates from orders\n    :math:`n-1` and :math:`n+1` and selects the order that minimises the\n    normalised error, allowing larger steps. Analogous to MATLAB's\n    ``ode15s``. Uses ``ESDIRK32`` as startup solver.\n\n    Characteristics\n    ---------------\n    * Order: variable, 2--5\n    * Implicit variable-step, variable-order multistep\n    * Adaptive timestep and order\n    * Stability: A-stable at order 2, :math:`A(\\\\alpha)`-stable at orders 3--5\n\n    Note\n    ----\n    The most autonomous stiff solver in this library. Automatically selects\n    higher orders in smooth regions for larger steps and drops to low order\n    in stiff or transient regions for stability. A good default when the\n    character of the block diagram is unknown or changes during the\n    simulation (e.g. switching events, varying loads).\n\n    References\n    ----------\n    .. [1] Gear, C. W. (1971). \"Numerical Initial Value Problems in Ordinary\n           Differential Equations\". Prentice-Hall.\n    .. [2] Shampine, L. F., & Reichelt, M. W. (1997). \"The MATLAB ODE\n           Suite\". SIAM Journal on Scientific Computing, 18(1), 1-22.\n           :doi:`10.1137/S1064827594276424`\n    .. [3] Hairer, E., & Wanner, G. (1996). \"Solving Ordinary Differential\n           Equations II: Stiff and Differential-Algebraic Problems\". Springer\n           Series in Computational Mathematics, Vol. 14.\n           :doi:`10.1007/978-3-642-05221-7`\n\n    \"\"\"\n\n    def __init__(self, *solver_args, **solver_kwargs):\n        super().__init__(*solver_args, **solver_kwargs)\n\n        #initial integration order\n        self.n = 2\n\n        #minimum and maximum BDF order to select\n        self.n_min, self.n_max = 2, 5\n\n        #gear, here 6\n        self.history = deque([], maxlen=6)\n        self.history_dt = deque([], maxlen=6)\n\n\n    def buffer(self, dt):\n        \"\"\"Buffer the state and timestep. Dynamically precompute \n        the variable timestep BDF coefficients on the fly for the \n        current timestep.\n\n        Parameters\n        ----------\n        dt : float\n            integration timestep\n        \"\"\"\n\n        #reset optimizer\n        self.opt.reset()\n\n        #add to histories (solution and timestep)            \n        self.history.appendleft(self.x)\n        self.history_dt.appendleft(dt)\n\n        #flag for startup method\n        self._needs_startup = len(self.history) < 6\n\n        #buffer with startup method\n        if self._needs_startup:\n            self.startup.buffer(dt)\n\n        #precompute coefficients here, where buffers are available\n        self.F, self.K = {}, {}\n        for n, _ in enumerate(self.history_dt, 1):\n            self.F[n], self.K[n] = compute_bdf_coefficients(n, np.array(self.history_dt))\n\n\n    # methods for adaptive timestep solvers --------------------------------------------\n\n    def error_controller(self, tr_m, tr_p):\n        \"\"\"Compute scaling factor for adaptive timestep based on absolute and \n        relative tolerances of the local truncation error estimate obtained from \n        esimated lower and higher order solution. \n\n        Checks if the error tolerance is achieved and returns a success metric.\n\n        Adapts the stepping order such that the normalized error is minimized and \n        larger steps can be taken by the integrator.\n\n        Parameters\n        ----------\n        tr_m : array[float]\n            lower order truncation error estimate\n        tr_p : array[float]\n            higher order truncation error estimate\n\n        Returns \n        -------\n        success : bool\n            True if the timestep was successful\n        error : float\n            estimated error of the internal error controller\n        scale : float\n            estimated timestep rescale factor for error control\n        \"\"\"\n\n        #compute scaling factors (avoid division by zero)\n        scale = self.tolerance_lte_abs + self.tolerance_lte_rel * np.abs(self.x)\n\n        #compute scaled truncation error (element-wise)\n        scaled_error_m = np.abs(tr_m) / scale\n        scaled_error_p = np.abs(tr_p) / scale\n\n        #compute the error norm and clip it\n        error_norm_m = np.clip(float(np.max(scaled_error_m)), TOLERANCE, None)\n        error_norm_p = np.clip(float(np.max(scaled_error_p)), TOLERANCE, None)      \n\n        #success metric (use lower order estimate)\n        success = error_norm_m <= 1.0\n\n        #compute timestep scale factor using accuracy order of truncation error\n        timestep_rescale = self.beta / error_norm_m ** (1/self.n)  \n\n        #clip the rescale factor to a reasonable range\n        timestep_rescale = np.clip(timestep_rescale, SOL_SCALE_MIN, SOL_SCALE_MAX)\n\n        #decrease the order if smaller order is more accurate (stability)\n        if error_norm_m < error_norm_p:\n            self.n = max(self.n-1, self.n_min)\n\n        #increase the order if larger order is more accurate (accuracy -> larger steps)\n        else:\n            self.n = min(self.n+1, self.n_max)\n\n        return success, error_norm_p, timestep_rescale\n\n\n    # methods for timestepping ---------------------------------------------------------\n\n    def solve(self, f, J, dt):\n        \"\"\"Solves the implicit update equation using the optimizer of the engine.\n\n        Parameters\n        ----------\n        f : array_like\n            evaluation of function\n        J : array_like\n            evaluation of jacobian of function\n        dt : float \n            integration timestep\n\n        Returns\n        -------\n        err : float\n            residual error of the fixed point update equation\n\n        \"\"\"\n\n        #not enough history for full order -> solve with startup method\n        if self._needs_startup:\n            err = self.startup.solve(f, J, dt)\n            self.x = self.startup.get()\n            return err\n\n        #fixed-point function update (faster then sum comprehension)\n        g = self.F[self.n] * dt * f\n        for b, k in zip(self.history, self.K[self.n]):\n            g = g + b * k\n\n        #use the jacobian\n        if J is not None:\n\n            #optimizer step with block local jacobian\n            self.x, err = self.opt.step(self.x, g, self.F[self.n] * dt * J)\n\n        else:\n            #optimizer step (pure)\n            self.x, err = self.opt.step(self.x, g, None)\n\n        #return the fixed-point residual\n        return err\n\n\n    def step(self, f, dt):\n        \"\"\"Finalizes the timestep by resetting the solver for the implicit \n        update equation and computing the lower and higher order estimate \n        of the solution. \n\n        Then calls the error controller.\n\n        Parameters\n        ----------\n        f : array_like\n            evaluation of function\n        dt : float \n            integration timestep\n\n        Returns \n        -------\n        success : bool\n            True if the timestep was successful\n        error : float\n            estimated error of the internal error controller\n        scale : float\n            estimated timestep rescale factor for error control\n        \"\"\"\n\n        #not enough history for full order -> step with startup method\n        if self._needs_startup:\n            suc, err, scl = self.startup.step(f, dt)\n            self.x = self.startup.get()\n            return suc, err, scl\n\n        #lower and higher order\n        n_m, n_p = self.n - 1, self.n + 1 \n\n        #estimate truncation error from lower order solution\n        tr_m = self.x - self.F[n_m] * dt * f\n        for b, k in zip(self.history, self.K[n_m]):\n            tr_m = tr_m - b * k\n\n        #estimate truncation error from higher order solution\n        tr_p = self.x - self.F[n_p] * dt * f\n        for b, k in zip(self.history, self.K[n_p]):\n            tr_p = tr_p - b * k\n\n        return self.error_controller(tr_m, tr_p)",
          "bases": [
            "pathsim.solvers.gear.GEAR"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, *solver_args, **solver_kwargs):\n    super().__init__(*solver_args, **solver_kwargs)\n\n    #initial integration order\n    self.n = 2\n\n    #minimum and maximum BDF order to select\n    self.n_min, self.n_max = 2, 5\n\n    #gear, here 6\n    self.history = deque([], maxlen=6)\n    self.history_dt = deque([], maxlen=6)",
              "signature": "(solver_args = (), solver_kwargs = {})",
              "parameters": [
                {
                  "name": "solver_args",
                  "type": null,
                  "default": "()",
                  "description": ""
                },
                {
                  "name": "solver_kwargs",
                  "type": null,
                  "default": "{}",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "buffer",
              "description": "Buffer the state and timestep. Dynamically precompute",
              "docstring_html": "<p>Buffer the state and timestep. Dynamically precompute\nthe variable timestep BDF coefficients on the fly for the\ncurrent timestep.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>integration timestep</dd>\n</dl>\n",
              "source": "def buffer(self, dt):\n    \"\"\"Buffer the state and timestep. Dynamically precompute \n    the variable timestep BDF coefficients on the fly for the \n    current timestep.\n\n    Parameters\n    ----------\n    dt : float\n        integration timestep\n    \"\"\"\n\n    #reset optimizer\n    self.opt.reset()\n\n    #add to histories (solution and timestep)            \n    self.history.appendleft(self.x)\n    self.history_dt.appendleft(dt)\n\n    #flag for startup method\n    self._needs_startup = len(self.history) < 6\n\n    #buffer with startup method\n    if self._needs_startup:\n        self.startup.buffer(dt)\n\n    #precompute coefficients here, where buffers are available\n    self.F, self.K = {}, {}\n    for n, _ in enumerate(self.history_dt, 1):\n        self.F[n], self.K[n] = compute_bdf_coefficients(n, np.array(self.history_dt))",
              "signature": "(dt)",
              "parameters": [
                {
                  "name": "dt",
                  "type": null,
                  "default": null,
                  "description": "integration timestep"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "error_controller",
              "description": "Compute scaling factor for adaptive timestep based on absolute and",
              "docstring_html": "<p>Compute scaling factor for adaptive timestep based on absolute and\nrelative tolerances of the local truncation error estimate obtained from\nesimated lower and higher order solution.</p>\n<p>Checks if the error tolerance is achieved and returns a success metric.</p>\n<p>Adapts the stepping order such that the normalized error is minimized and\nlarger steps can be taken by the integrator.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>tr_m <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array[float]</span></dt>\n<dd>lower order truncation error estimate</dd>\n<dt>tr_p <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array[float]</span></dt>\n<dd>higher order truncation error estimate</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>success <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>True if the timestep was successful</dd>\n<dt>error <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>estimated error of the internal error controller</dd>\n<dt>scale <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>estimated timestep rescale factor for error control</dd>\n</dl>\n",
              "source": "def error_controller(self, tr_m, tr_p):\n    \"\"\"Compute scaling factor for adaptive timestep based on absolute and \n    relative tolerances of the local truncation error estimate obtained from \n    esimated lower and higher order solution. \n\n    Checks if the error tolerance is achieved and returns a success metric.\n\n    Adapts the stepping order such that the normalized error is minimized and \n    larger steps can be taken by the integrator.\n\n    Parameters\n    ----------\n    tr_m : array[float]\n        lower order truncation error estimate\n    tr_p : array[float]\n        higher order truncation error estimate\n\n    Returns \n    -------\n    success : bool\n        True if the timestep was successful\n    error : float\n        estimated error of the internal error controller\n    scale : float\n        estimated timestep rescale factor for error control\n    \"\"\"\n\n    #compute scaling factors (avoid division by zero)\n    scale = self.tolerance_lte_abs + self.tolerance_lte_rel * np.abs(self.x)\n\n    #compute scaled truncation error (element-wise)\n    scaled_error_m = np.abs(tr_m) / scale\n    scaled_error_p = np.abs(tr_p) / scale\n\n    #compute the error norm and clip it\n    error_norm_m = np.clip(float(np.max(scaled_error_m)), TOLERANCE, None)\n    error_norm_p = np.clip(float(np.max(scaled_error_p)), TOLERANCE, None)      \n\n    #success metric (use lower order estimate)\n    success = error_norm_m <= 1.0\n\n    #compute timestep scale factor using accuracy order of truncation error\n    timestep_rescale = self.beta / error_norm_m ** (1/self.n)  \n\n    #clip the rescale factor to a reasonable range\n    timestep_rescale = np.clip(timestep_rescale, SOL_SCALE_MIN, SOL_SCALE_MAX)\n\n    #decrease the order if smaller order is more accurate (stability)\n    if error_norm_m < error_norm_p:\n        self.n = max(self.n-1, self.n_min)\n\n    #increase the order if larger order is more accurate (accuracy -> larger steps)\n    else:\n        self.n = min(self.n+1, self.n_max)\n\n    return success, error_norm_p, timestep_rescale",
              "signature": "(tr_m, tr_p)",
              "parameters": [
                {
                  "name": "tr_m",
                  "type": null,
                  "default": null,
                  "description": "lower order truncation error estimate"
                },
                {
                  "name": "tr_p",
                  "type": null,
                  "default": null,
                  "description": "higher order truncation error estimate"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "solve",
              "description": "Solves the implicit update equation using the optimizer of the engine.",
              "docstring_html": "<p>Solves the implicit update equation using the optimizer of the engine.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>f <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array_like</span></dt>\n<dd>evaluation of function</dd>\n<dt>J <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array_like</span></dt>\n<dd>evaluation of jacobian of function</dd>\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>integration timestep</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>err <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>residual error of the fixed point update equation</dd>\n</dl>\n",
              "source": "def solve(self, f, J, dt):\n    \"\"\"Solves the implicit update equation using the optimizer of the engine.\n\n    Parameters\n    ----------\n    f : array_like\n        evaluation of function\n    J : array_like\n        evaluation of jacobian of function\n    dt : float \n        integration timestep\n\n    Returns\n    -------\n    err : float\n        residual error of the fixed point update equation\n\n    \"\"\"\n\n    #not enough history for full order -> solve with startup method\n    if self._needs_startup:\n        err = self.startup.solve(f, J, dt)\n        self.x = self.startup.get()\n        return err\n\n    #fixed-point function update (faster then sum comprehension)\n    g = self.F[self.n] * dt * f\n    for b, k in zip(self.history, self.K[self.n]):\n        g = g + b * k\n\n    #use the jacobian\n    if J is not None:\n\n        #optimizer step with block local jacobian\n        self.x, err = self.opt.step(self.x, g, self.F[self.n] * dt * J)\n\n    else:\n        #optimizer step (pure)\n        self.x, err = self.opt.step(self.x, g, None)\n\n    #return the fixed-point residual\n    return err",
              "signature": "(f, J, dt)",
              "parameters": [
                {
                  "name": "f",
                  "type": null,
                  "default": null,
                  "description": "evaluation of function"
                },
                {
                  "name": "J",
                  "type": null,
                  "default": null,
                  "description": "evaluation of jacobian of function"
                },
                {
                  "name": "dt",
                  "type": null,
                  "default": null,
                  "description": "integration timestep"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "step",
              "description": "Finalizes the timestep by resetting the solver for the implicit",
              "docstring_html": "<p>Finalizes the timestep by resetting the solver for the implicit\nupdate equation and computing the lower and higher order estimate\nof the solution.</p>\n<p>Then calls the error controller.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>f <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array_like</span></dt>\n<dd>evaluation of function</dd>\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>integration timestep</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>success <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>True if the timestep was successful</dd>\n<dt>error <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>estimated error of the internal error controller</dd>\n<dt>scale <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>estimated timestep rescale factor for error control</dd>\n</dl>\n",
              "source": "def step(self, f, dt):\n    \"\"\"Finalizes the timestep by resetting the solver for the implicit \n    update equation and computing the lower and higher order estimate \n    of the solution. \n\n    Then calls the error controller.\n\n    Parameters\n    ----------\n    f : array_like\n        evaluation of function\n    dt : float \n        integration timestep\n\n    Returns \n    -------\n    success : bool\n        True if the timestep was successful\n    error : float\n        estimated error of the internal error controller\n    scale : float\n        estimated timestep rescale factor for error control\n    \"\"\"\n\n    #not enough history for full order -> step with startup method\n    if self._needs_startup:\n        suc, err, scl = self.startup.step(f, dt)\n        self.x = self.startup.get()\n        return suc, err, scl\n\n    #lower and higher order\n    n_m, n_p = self.n - 1, self.n + 1 \n\n    #estimate truncation error from lower order solution\n    tr_m = self.x - self.F[n_m] * dt * f\n    for b, k in zip(self.history, self.K[n_m]):\n        tr_m = tr_m - b * k\n\n    #estimate truncation error from higher order solution\n    tr_p = self.x - self.F[n_p] * dt * f\n    for b, k in zip(self.history, self.K[n_p]):\n        tr_p = tr_p - b * k\n\n    return self.error_controller(tr_m, tr_p)",
              "signature": "(f, dt)",
              "parameters": [
                {
                  "name": "f",
                  "type": null,
                  "default": null,
                  "description": "evaluation of function"
                },
                {
                  "name": "dt",
                  "type": null,
                  "default": null,
                  "description": "integration timestep"
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "n",
              "description": "",
              "type": null,
              "value": "2"
            },
            {
              "name": "history",
              "description": "",
              "type": null,
              "value": "deque([], maxlen=6)"
            },
            {
              "name": "history_dt",
              "description": "",
              "type": null,
              "value": "deque([], maxlen=6)"
            }
          ],
          "parameters": [
            {
              "name": "solver_args",
              "type": null,
              "default": "()",
              "description": ""
            },
            {
              "name": "solver_kwargs",
              "type": null,
              "default": "{}",
              "description": ""
            }
          ]
        }
      ],
      "functions": [
        {
          "name": "compute_bdf_coefficients",
          "description": "Computes the coefficients for backward differentiation formulas for a given order.",
          "docstring_html": "<p>Computes the coefficients for backward differentiation formulas for a given order.\nThe timesteps can be specified for variable timestep BDF methods.</p>\n<dl class=\"docutils\">\n<dt>For m-th order BDF we have for the n-th timestep:</dt>\n<dd>sum(alpha_i * x_i; i=n-m,...,n) = h_n * f_n(x_n, t_n)</dd>\n<dt>or</dt>\n<dd>x_n = beta * h_n * f_n(x_n, t_n) - sum(alpha_j * x_{n-1-j}; j=0,...,order-1)</dd>\n</dl>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>order <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>order of the integration scheme</dd>\n<dt>timesteps <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array[float]</span></dt>\n<dd>timestep buffer (h_{n-j}; j=0,...,order-1)</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>beta <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>weight for function</dd>\n<dt>alpha <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array[float]</span></dt>\n<dd>weights for previous solutions</dd>\n</dl>\n",
          "source": "def compute_bdf_coefficients(order, timesteps):\n    \"\"\"Computes the coefficients for backward differentiation formulas for a given order.\n    The timesteps can be specified for variable timestep BDF methods. \n\n    For m-th order BDF we have for the n-th timestep:\n        sum(alpha_i * x_i; i=n-m,...,n) = h_n * f_n(x_n, t_n)\n    or \n        x_n = beta * h_n * f_n(x_n, t_n) - sum(alpha_j * x_{n-1-j}; j=0,...,order-1)\n\n    Parameters\n    ----------\n    order : int\n        order of the integration scheme\n    timesteps : array[float]\n        timestep buffer (h_{n-j}; j=0,...,order-1)\n\n    Returns\n    ------- \n    beta : float\n        weight for function\n    alpha : array[float]\n        weights for previous solutions\n    \"\"\"\n\n    #check if valid order\n    if order < 1:\n        raise RuntimeError(f\"BDF coefficients of order '{order}' not possible!\")\n\n    #quit early for no buffer (euler backward)\n    if len(timesteps) < 2:\n        return 1.0, [1.0]\n\n    # Compute timestep ratios rho_j = h_{n-j} / h_n\n    rho = timesteps[1:] / timesteps[0]\n\n    # Compute normalized time differences theta_j\n    theta = -np.ones(order + 1)\n    theta[0] = 0\n    for j in range(2, order + 1):\n        theta[j] -= sum(rho[:j - 1])\n\n    # Set up the linear system (p + 1 equations)\n    A = np.zeros((order + 1, order + 1))\n    b = np.zeros(order + 1)\n    b[1] = 1 \n    for m in range(order + 1):\n        A[m, :] = theta ** m \n\n    # Solve the linear system A * alpha = b\n    alphas = np.linalg.solve(A, b)\n\n    #return function and buffer weights\n    return 1 / alphas[0], -alphas[1:] / alphas[0]",
          "signature": "(order, timesteps)",
          "parameters": [
            {
              "name": "order",
              "type": null,
              "default": null,
              "description": "order of the integration scheme"
            },
            {
              "name": "timesteps",
              "type": null,
              "default": null,
              "description": "timestep buffer (h_{n-j}; j=0,...,order-1)"
            }
          ],
          "returns": null
        }
      ]
    },
    "pathsim.solvers.rk4": {
      "name": "pathsim.solvers.rk4",
      "description": "",
      "docstring_html": "",
      "classes": [
        {
          "name": "RK4",
          "description": "Classical four-stage, 4th order explicit Runge-Kutta method.",
          "docstring_html": "<p>Classical four-stage, 4th order explicit Runge-Kutta method.</p>\n<pre class=\"math\">\n\\begin{aligned}\nk_1 &amp;= f(x_n,\\; t_n) \\\\\nk_2 &amp;= f\\!\\left(x_n + \\tfrac{h}{2}\\,k_1,\\; t_n + \\tfrac{h}{2}\\right) \\\\\nk_3 &amp;= f\\!\\left(x_n + \\tfrac{h}{2}\\,k_2,\\; t_n + \\tfrac{h}{2}\\right) \\\\\nk_4 &amp;= f(x_n + h\\,k_3,\\; t_n + h) \\\\\nx_{n+1} &amp;= x_n + \\tfrac{h}{6}(k_1 + 2k_2 + 2k_3 + k_4)\n\\end{aligned}\n</pre>\n<div class=\"section\" id=\"characteristics\">\n<h4>Characteristics</h4>\n<ul class=\"simple\">\n<li>Order: 4</li>\n<li>Stages: 4</li>\n<li>Explicit, fixed timestep</li>\n</ul>\n</div>\n<div class=\"section\" id=\"note\">\n<h4>Note</h4>\n<p>The standard fixed-step explicit solver. Provides a good cost-to-accuracy\nratio for non-stiff block diagrams where the timestep is known a priori\n(e.g. real-time or hardware-in-the-loop simulation with a fixed clock).\nNot suitable for stiff systems. When accuracy demands vary during a run,\nadaptive methods like <tt class=\"docutils literal\">RKDP54</tt> are more efficient because they\nconcentrate steps where the dynamics change rapidly.</p>\n<p><strong>References</strong></p>\n<table class=\"docutils footnote\" frame=\"void\" id=\"footnote-1\" rules=\"none\">\n<colgroup><col class=\"label\" /><col /></colgroup>\n<tbody valign=\"top\">\n<tr><td class=\"label\">[1]</td><td>Kutta, W. (1901). &quot;Beitrag zur näherungsweisen Integration totaler\nDifferentialgleichungen&quot;. Zeitschrift für Mathematik und Physik,\n46, 435-453.</td></tr>\n</tbody>\n</table>\n<table class=\"docutils footnote\" frame=\"void\" id=\"footnote-2\" rules=\"none\">\n<colgroup><col class=\"label\" /><col /></colgroup>\n<tbody valign=\"top\">\n<tr><td class=\"label\">[2]</td><td>Hairer, E., Nørsett, S. P., &amp; Wanner, G. (1993). &quot;Solving Ordinary\nDifferential Equations I: Nonstiff Problems&quot;. Springer Series in\nComputational Mathematics, Vol. 8.\n:doi:`10.1007/978-3-540-78862-1`</td></tr>\n</tbody>\n</table>\n</div>\n",
          "source": "class RK4(ExplicitRungeKutta):\n    \"\"\"Classical four-stage, 4th order explicit Runge-Kutta method.\n\n    .. math::\n\n        \\\\begin{aligned}\n        k_1 &= f(x_n,\\\\; t_n) \\\\\\\\\n        k_2 &= f\\\\!\\\\left(x_n + \\\\tfrac{h}{2}\\\\,k_1,\\\\; t_n + \\\\tfrac{h}{2}\\\\right) \\\\\\\\\n        k_3 &= f\\\\!\\\\left(x_n + \\\\tfrac{h}{2}\\\\,k_2,\\\\; t_n + \\\\tfrac{h}{2}\\\\right) \\\\\\\\\n        k_4 &= f(x_n + h\\\\,k_3,\\\\; t_n + h) \\\\\\\\\n        x_{n+1} &= x_n + \\\\tfrac{h}{6}(k_1 + 2k_2 + 2k_3 + k_4)\n        \\\\end{aligned}\n\n    Characteristics\n    ---------------\n    * Order: 4\n    * Stages: 4\n    * Explicit, fixed timestep\n\n    Note\n    ----\n    The standard fixed-step explicit solver. Provides a good cost-to-accuracy\n    ratio for non-stiff block diagrams where the timestep is known a priori\n    (e.g. real-time or hardware-in-the-loop simulation with a fixed clock).\n    Not suitable for stiff systems. When accuracy demands vary during a run,\n    adaptive methods like ``RKDP54`` are more efficient because they\n    concentrate steps where the dynamics change rapidly.\n\n    References\n    ----------\n    .. [1] Kutta, W. (1901). \"Beitrag zur näherungsweisen Integration totaler\n           Differentialgleichungen\". Zeitschrift für Mathematik und Physik,\n           46, 435-453.\n    .. [2] Hairer, E., Nørsett, S. P., & Wanner, G. (1993). \"Solving Ordinary\n           Differential Equations I: Nonstiff Problems\". Springer Series in\n           Computational Mathematics, Vol. 8.\n           :doi:`10.1007/978-3-540-78862-1`\n\n    \"\"\"\n\n    def __init__(self, *solver_args, **solver_kwargs):\n        super().__init__(*solver_args, **solver_kwargs)\n\n        #number of stages in RK scheme\n        self.s = 4\n\n        #order of scheme\n        self.n = 4\n\n        #intermediate evaluation times\n        self.eval_stages = [0.0, 0.5, 0.5, 1.0]\n\n        #butcher table\n        self.BT = {\n            0: [1/2],\n            1: [0.0, 1/2],\n            2: [0.0, 0.0, 1.0], \n            3: [1/6, 2/6, 2/6, 1/6]\n            }\n\n\n    def interpolate(self, r, dt):\n        k1, k2, k3, k4 = self.K[0], self.K[1], self.K[2], self.K[3]\n        b1, b2, b3, b4 = r*(1-r)**2/6, r**2*(2-3*r)/2, r**2*(3*r-4)/2, r**3/6\n        return self.x_0 + dt*(b1 * k1 + b2 * k2 + b3 * k3 + b4 * k4)",
          "bases": [
            "pathsim.solvers._rungekutta.ExplicitRungeKutta"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, *solver_args, **solver_kwargs):\n    super().__init__(*solver_args, **solver_kwargs)\n\n    #number of stages in RK scheme\n    self.s = 4\n\n    #order of scheme\n    self.n = 4\n\n    #intermediate evaluation times\n    self.eval_stages = [0.0, 0.5, 0.5, 1.0]\n\n    #butcher table\n    self.BT = {\n        0: [1/2],\n        1: [0.0, 1/2],\n        2: [0.0, 0.0, 1.0], \n        3: [1/6, 2/6, 2/6, 1/6]\n        }",
              "signature": "(solver_args = (), solver_kwargs = {})",
              "parameters": [
                {
                  "name": "solver_args",
                  "type": null,
                  "default": "()",
                  "description": ""
                },
                {
                  "name": "solver_kwargs",
                  "type": null,
                  "default": "{}",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "interpolate",
              "description": "",
              "docstring_html": "",
              "source": "def interpolate(self, r, dt):\n    k1, k2, k3, k4 = self.K[0], self.K[1], self.K[2], self.K[3]\n    b1, b2, b3, b4 = r*(1-r)**2/6, r**2*(2-3*r)/2, r**2*(3*r-4)/2, r**3/6\n    return self.x_0 + dt*(b1 * k1 + b2 * k2 + b3 * k3 + b4 * k4)",
              "signature": "(r, dt)",
              "parameters": [
                {
                  "name": "r",
                  "type": null,
                  "default": null,
                  "description": ""
                },
                {
                  "name": "dt",
                  "type": null,
                  "default": null,
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "s",
              "description": "",
              "type": null,
              "value": "4"
            },
            {
              "name": "n",
              "description": "",
              "type": null,
              "value": "4"
            },
            {
              "name": "eval_stages",
              "description": "",
              "type": null,
              "value": "[0.0, 0.5, 0.5, 1.0]"
            },
            {
              "name": "BT",
              "description": "",
              "type": null,
              "value": "{0: [1 / 2], 1: [0.0, 1 / 2], 2: [0.0, 0.0, 1.0], 3: [1 / 6, 2 / 6, 2 / 6, 1 / 6]}"
            }
          ],
          "parameters": [
            {
              "name": "solver_args",
              "type": null,
              "default": "()",
              "description": ""
            },
            {
              "name": "solver_kwargs",
              "type": null,
              "default": "{}",
              "description": ""
            }
          ]
        }
      ],
      "functions": []
    },
    "pathsim.solvers.rkbs32": {
      "name": "pathsim.solvers.rkbs32",
      "description": "",
      "docstring_html": "",
      "classes": [
        {
          "name": "RKBS32",
          "description": "Bogacki-Shampine 3(2) pair. Four-stage, 3rd order with FSAL property.",
          "docstring_html": "<p>Bogacki-Shampine 3(2) pair. Four-stage, 3rd order with FSAL property.</p>\n<p>The underlying method of MATLAB's <tt class=\"docutils literal\">ode23</tt>. The First-Same-As-Last\n(FSAL) property makes the effective cost three stages per accepted step.</p>\n<div class=\"section\" id=\"characteristics\">\n<h4>Characteristics</h4>\n<ul class=\"simple\">\n<li>Order: 3 (propagating) / 2 (embedded)</li>\n<li>Stages: 4 (3 effective with FSAL)</li>\n<li>Explicit, adaptive timestep</li>\n</ul>\n</div>\n<div class=\"section\" id=\"note\">\n<h4>Note</h4>\n<p>A good default when moderate accuracy suffices and per-step cost matters\nmore than large step sizes. Fewer stages than 5th order pairs, so faster\nper step but needs more steps for the same global error. In a PathSim\nblock diagram with smooth, non-stiff dynamics and relaxed tolerances this\nis often the most efficient explicit choice. Switch to <tt class=\"docutils literal\">RKDP54</tt> when\ntighter tolerances are required.</p>\n<p><strong>References</strong></p>\n<table class=\"docutils footnote\" frame=\"void\" id=\"footnote-1\" rules=\"none\">\n<colgroup><col class=\"label\" /><col /></colgroup>\n<tbody valign=\"top\">\n<tr><td class=\"label\">[1]</td><td>Bogacki, P., &amp; Shampine, L. F. (1989). &quot;A 3(2) pair of\nRunge-Kutta formulas&quot;. Applied Mathematics Letters, 2(4),\n321-325. :doi:`10.1016/0893-9659(89)90079-7`</td></tr>\n</tbody>\n</table>\n<table class=\"docutils footnote\" frame=\"void\" id=\"footnote-2\" rules=\"none\">\n<colgroup><col class=\"label\" /><col /></colgroup>\n<tbody valign=\"top\">\n<tr><td class=\"label\">[2]</td><td>Shampine, L. F., &amp; Reichelt, M. W. (1997). &quot;The MATLAB ODE\nSuite&quot;. SIAM Journal on Scientific Computing, 18(1), 1-22.\n:doi:`10.1137/S1064827594276424`</td></tr>\n</tbody>\n</table>\n</div>\n",
          "source": "class RKBS32(ExplicitRungeKutta):\n    \"\"\"Bogacki-Shampine 3(2) pair. Four-stage, 3rd order with FSAL property.\n\n    The underlying method of MATLAB's ``ode23``. The First-Same-As-Last\n    (FSAL) property makes the effective cost three stages per accepted step.\n\n    Characteristics\n    ---------------\n    * Order: 3 (propagating) / 2 (embedded)\n    * Stages: 4 (3 effective with FSAL)\n    * Explicit, adaptive timestep\n\n    Note\n    ----\n    A good default when moderate accuracy suffices and per-step cost matters\n    more than large step sizes. Fewer stages than 5th order pairs, so faster\n    per step but needs more steps for the same global error. In a PathSim\n    block diagram with smooth, non-stiff dynamics and relaxed tolerances this\n    is often the most efficient explicit choice. Switch to ``RKDP54`` when\n    tighter tolerances are required.\n\n    References\n    ----------\n    .. [1] Bogacki, P., & Shampine, L. F. (1989). \"A 3(2) pair of\n           Runge-Kutta formulas\". Applied Mathematics Letters, 2(4),\n           321-325. :doi:`10.1016/0893-9659(89)90079-7`\n    .. [2] Shampine, L. F., & Reichelt, M. W. (1997). \"The MATLAB ODE\n           Suite\". SIAM Journal on Scientific Computing, 18(1), 1-22.\n           :doi:`10.1137/S1064827594276424`\n\n    \"\"\"\n\n    def __init__(self, *solver_args, **solver_kwargs):\n        super().__init__(*solver_args, **solver_kwargs)\n\n        #number of stages in RK scheme\n        self.s = 4\n\n        #order of scheme and embedded method\n        self.n = 3\n        self.m = 2\n\n        #flag adaptive timestep solver\n        self.is_adaptive = True\n\n        #intermediate evaluation times\n        self.eval_stages = [0.0, 1/2, 3/4, 1.0]\n\n        #extended butcher table\n        self.BT = {\n            0: [1/2],\n            1: [0.0 , 3/4],\n            2: [2/9 , 1/3, 4/9],\n            3: [2/9 , 1/3, 4/9]\n            }\n\n        #coefficients for truncation error estimate\n        self.TR = [-5/72, 1/12, 1/9, -1/8]",
          "bases": [
            "pathsim.solvers._rungekutta.ExplicitRungeKutta"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, *solver_args, **solver_kwargs):\n    super().__init__(*solver_args, **solver_kwargs)\n\n    #number of stages in RK scheme\n    self.s = 4\n\n    #order of scheme and embedded method\n    self.n = 3\n    self.m = 2\n\n    #flag adaptive timestep solver\n    self.is_adaptive = True\n\n    #intermediate evaluation times\n    self.eval_stages = [0.0, 1/2, 3/4, 1.0]\n\n    #extended butcher table\n    self.BT = {\n        0: [1/2],\n        1: [0.0 , 3/4],\n        2: [2/9 , 1/3, 4/9],\n        3: [2/9 , 1/3, 4/9]\n        }\n\n    #coefficients for truncation error estimate\n    self.TR = [-5/72, 1/12, 1/9, -1/8]",
              "signature": "(solver_args = (), solver_kwargs = {})",
              "parameters": [
                {
                  "name": "solver_args",
                  "type": null,
                  "default": "()",
                  "description": ""
                },
                {
                  "name": "solver_kwargs",
                  "type": null,
                  "default": "{}",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "s",
              "description": "",
              "type": null,
              "value": "4"
            },
            {
              "name": "n",
              "description": "",
              "type": null,
              "value": "3"
            },
            {
              "name": "m",
              "description": "",
              "type": null,
              "value": "2"
            },
            {
              "name": "is_adaptive",
              "description": "",
              "type": null,
              "value": "True"
            },
            {
              "name": "eval_stages",
              "description": "",
              "type": null,
              "value": "[0.0, 1 / 2, 3 / 4, 1.0]"
            },
            {
              "name": "BT",
              "description": "",
              "type": null,
              "value": "{0: [1 / 2], 1: [0.0, 3 / 4], 2: [2 / 9, 1 / 3, 4 / 9], 3: [2 / 9, 1 / 3, 4 / 9]}"
            },
            {
              "name": "TR",
              "description": "",
              "type": null,
              "value": "[-5 / 72, 1 / 12, 1 / 9, -1 / 8]"
            }
          ],
          "parameters": [
            {
              "name": "solver_args",
              "type": null,
              "default": "()",
              "description": ""
            },
            {
              "name": "solver_kwargs",
              "type": null,
              "default": "{}",
              "description": ""
            }
          ]
        }
      ],
      "functions": []
    },
    "pathsim.solvers.rkck54": {
      "name": "pathsim.solvers.rkck54",
      "description": "",
      "docstring_html": "",
      "classes": [
        {
          "name": "RKCK54",
          "description": "Cash-Karp 5(4) pair. Six stages, 5th order with embedded 4th order",
          "docstring_html": "<p>Cash-Karp 5(4) pair. Six stages, 5th order with embedded 4th order\nerror estimate.</p>\n<p>Designed to improve on the stability properties of the Fehlberg pair\n(<tt class=\"docutils literal\">RKF45</tt>) while keeping the same stage count.</p>\n<div class=\"section\" id=\"characteristics\">\n<h4>Characteristics</h4>\n<ul class=\"simple\">\n<li>Order: 5 (propagating) / 4 (embedded)</li>\n<li>Stages: 6</li>\n<li>Explicit, adaptive timestep</li>\n</ul>\n</div>\n<div class=\"section\" id=\"note\">\n<h4>Note</h4>\n<p>Comparable to <tt class=\"docutils literal\">RKDP54</tt> in cost and accuracy for most non-stiff block\ndiagrams. Can exhibit slightly better stability on problems with\neigenvalues near the imaginary axis. Both pairs are solid 5th order\nchoices; <tt class=\"docutils literal\">RKDP54</tt> is the more commonly used default.</p>\n<p><strong>References</strong></p>\n<table class=\"docutils footnote\" frame=\"void\" id=\"footnote-1\" rules=\"none\">\n<colgroup><col class=\"label\" /><col /></colgroup>\n<tbody valign=\"top\">\n<tr><td class=\"label\">[1]</td><td>Cash, J. R., &amp; Karp, A. H. (1990). &quot;A variable order Runge-Kutta\nmethod for initial value problems with rapidly varying right-hand\nsides&quot;. ACM Transactions on Mathematical Software, 16(3), 201-222.\n:doi:`10.1145/79505.79507`</td></tr>\n</tbody>\n</table>\n<table class=\"docutils footnote\" frame=\"void\" id=\"footnote-2\" rules=\"none\">\n<colgroup><col class=\"label\" /><col /></colgroup>\n<tbody valign=\"top\">\n<tr><td class=\"label\">[2]</td><td>Hairer, E., Nørsett, S. P., &amp; Wanner, G. (1993). &quot;Solving\nOrdinary Differential Equations I: Nonstiff Problems&quot;. Springer\nSeries in Computational Mathematics, Vol. 8.\n:doi:`10.1007/978-3-540-78862-1`</td></tr>\n</tbody>\n</table>\n</div>\n",
          "source": "class RKCK54(ExplicitRungeKutta):\n    \"\"\"Cash-Karp 5(4) pair. Six stages, 5th order with embedded 4th order\n    error estimate.\n\n    Designed to improve on the stability properties of the Fehlberg pair\n    (``RKF45``) while keeping the same stage count.\n\n    Characteristics\n    ---------------\n    * Order: 5 (propagating) / 4 (embedded)\n    * Stages: 6\n    * Explicit, adaptive timestep\n\n    Note\n    ----\n    Comparable to ``RKDP54`` in cost and accuracy for most non-stiff block\n    diagrams. Can exhibit slightly better stability on problems with\n    eigenvalues near the imaginary axis. Both pairs are solid 5th order\n    choices; ``RKDP54`` is the more commonly used default.\n\n    References\n    ----------\n    .. [1] Cash, J. R., & Karp, A. H. (1990). \"A variable order Runge-Kutta\n           method for initial value problems with rapidly varying right-hand\n           sides\". ACM Transactions on Mathematical Software, 16(3), 201-222.\n           :doi:`10.1145/79505.79507`\n    .. [2] Hairer, E., Nørsett, S. P., & Wanner, G. (1993). \"Solving\n           Ordinary Differential Equations I: Nonstiff Problems\". Springer\n           Series in Computational Mathematics, Vol. 8.\n           :doi:`10.1007/978-3-540-78862-1`\n\n    \"\"\"\n\n    def __init__(self, *solver_args, **solver_kwargs):\n        super().__init__(*solver_args, **solver_kwargs)\n\n        #number of stages in RK scheme\n        self.s = 6\n\n        #order of scheme and embedded method\n        self.n = 5\n        self.m = 4\n\n        #flag adaptive timestep solver\n        self.is_adaptive = True\n\n        #intermediate evaluation times\n        self.eval_stages = [0.0, 1/5, 3/10, 3/5, 1, 7/8]\n\n        #extended butcher table \n        self.BT = {\n            0: [       1/5],\n            1: [      3/40,    9/40],\n            2: [      3/10,   -9/10,       6/5],\n            3: [    -11/54,     5/2,    -70/27,        35/27],\n            4: [1631/55296, 175/512, 575/13824, 44275/110592, 253/4096],\n            5: [    37/378,       0,   250/621,      125/594,        0, 512/1771]\n            }\n\n        #coefficients for local truncation error estimate\n        self.TR = [-277/64512, 0, 6925/370944, -6925/202752, -277/14336, 277/7084]",
          "bases": [
            "pathsim.solvers._rungekutta.ExplicitRungeKutta"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, *solver_args, **solver_kwargs):\n    super().__init__(*solver_args, **solver_kwargs)\n\n    #number of stages in RK scheme\n    self.s = 6\n\n    #order of scheme and embedded method\n    self.n = 5\n    self.m = 4\n\n    #flag adaptive timestep solver\n    self.is_adaptive = True\n\n    #intermediate evaluation times\n    self.eval_stages = [0.0, 1/5, 3/10, 3/5, 1, 7/8]\n\n    #extended butcher table \n    self.BT = {\n        0: [       1/5],\n        1: [      3/40,    9/40],\n        2: [      3/10,   -9/10,       6/5],\n        3: [    -11/54,     5/2,    -70/27,        35/27],\n        4: [1631/55296, 175/512, 575/13824, 44275/110592, 253/4096],\n        5: [    37/378,       0,   250/621,      125/594,        0, 512/1771]\n        }\n\n    #coefficients for local truncation error estimate\n    self.TR = [-277/64512, 0, 6925/370944, -6925/202752, -277/14336, 277/7084]",
              "signature": "(solver_args = (), solver_kwargs = {})",
              "parameters": [
                {
                  "name": "solver_args",
                  "type": null,
                  "default": "()",
                  "description": ""
                },
                {
                  "name": "solver_kwargs",
                  "type": null,
                  "default": "{}",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "s",
              "description": "",
              "type": null,
              "value": "6"
            },
            {
              "name": "n",
              "description": "",
              "type": null,
              "value": "5"
            },
            {
              "name": "m",
              "description": "",
              "type": null,
              "value": "4"
            },
            {
              "name": "is_adaptive",
              "description": "",
              "type": null,
              "value": "True"
            },
            {
              "name": "eval_stages",
              "description": "",
              "type": null,
              "value": "[0.0, 1 / 5, 3 / 10, 3 / 5, 1, 7 / 8]"
            },
            {
              "name": "BT",
              "description": "",
              "type": null,
              "value": "{0: [1 / 5], 1: [3 / 40, 9 / 40], 2: [3 / 10, -9 / 10, 6 / 5], 3: [-11 / 54, 5 / 2, -70 / 27, 35 / 27], 4: [1631 / 55296, 175 / 512, 575 / 13824, 44275 / 110592, 253 / 4096], 5: [37 / 378, 0, 250 / 621, 125 / 594, 0, 512 / 1771]}"
            },
            {
              "name": "TR",
              "description": "",
              "type": null,
              "value": "[-277 / 64512, 0, 6925 / 370944, -6925 / 202752, -277 / 14336, 277 / 7084]"
            }
          ],
          "parameters": [
            {
              "name": "solver_args",
              "type": null,
              "default": "()",
              "description": ""
            },
            {
              "name": "solver_kwargs",
              "type": null,
              "default": "{}",
              "description": ""
            }
          ]
        }
      ],
      "functions": []
    },
    "pathsim.solvers.rkdp54": {
      "name": "pathsim.solvers.rkdp54",
      "description": "",
      "docstring_html": "",
      "classes": [
        {
          "name": "RKDP54",
          "description": "Dormand-Prince 5(4) pair (DOPRI5). Seven stages, 5th order with",
          "docstring_html": "<p>Dormand-Prince 5(4) pair (DOPRI5). Seven stages, 5th order with\nembedded 4th order error estimate.</p>\n<p>The industry-standard adaptive explicit solver and the basis of MATLAB's\n<tt class=\"docutils literal\">ode45</tt>. Has the FSAL property (not exploited in this implementation,\nso all seven stages are evaluated each step).</p>\n<div class=\"section\" id=\"characteristics\">\n<h4>Characteristics</h4>\n<ul class=\"simple\">\n<li>Order: 5 (propagating) / 4 (embedded)</li>\n<li>Stages: 7</li>\n<li>Explicit, adaptive timestep</li>\n</ul>\n</div>\n<div class=\"section\" id=\"note\">\n<h4>Note</h4>\n<p>Recommended default for non-stiff block diagrams. Handles smooth\nnonlinear dynamics, coupled oscillators, and signal-processing chains\nefficiently. If the simulation warns about excessive step rejections or\nvery small timesteps, the system is likely stiff and an implicit solver\n(<tt class=\"docutils literal\">ESDIRK43</tt>, <tt class=\"docutils literal\">GEAR52A</tt>) should be used instead. For very tight\ntolerances on smooth problems, <tt class=\"docutils literal\">RKV65</tt> or <tt class=\"docutils literal\">RKDP87</tt> can be more\nefficient per unit accuracy.</p>\n<p><strong>References</strong></p>\n<table class=\"docutils footnote\" frame=\"void\" id=\"footnote-1\" rules=\"none\">\n<colgroup><col class=\"label\" /><col /></colgroup>\n<tbody valign=\"top\">\n<tr><td class=\"label\">[1]</td><td>Dormand, J. R., &amp; Prince, P. J. (1980). &quot;A family of embedded\nRunge-Kutta formulae&quot;. Journal of Computational and Applied\nMathematics, 6(1), 19-26.\n:doi:`10.1016/0771-050X(80)90013-3`</td></tr>\n</tbody>\n</table>\n<table class=\"docutils footnote\" frame=\"void\" id=\"footnote-2\" rules=\"none\">\n<colgroup><col class=\"label\" /><col /></colgroup>\n<tbody valign=\"top\">\n<tr><td class=\"label\">[2]</td><td>Shampine, L. F., &amp; Reichelt, M. W. (1997). &quot;The MATLAB ODE\nSuite&quot;. SIAM Journal on Scientific Computing, 18(1), 1-22.\n:doi:`10.1137/S1064827594276424`</td></tr>\n</tbody>\n</table>\n</div>\n",
          "source": "class RKDP54(ExplicitRungeKutta):\n    \"\"\"Dormand-Prince 5(4) pair (DOPRI5). Seven stages, 5th order with\n    embedded 4th order error estimate.\n\n    The industry-standard adaptive explicit solver and the basis of MATLAB's\n    ``ode45``. Has the FSAL property (not exploited in this implementation,\n    so all seven stages are evaluated each step).\n\n    Characteristics\n    ---------------\n    * Order: 5 (propagating) / 4 (embedded)\n    * Stages: 7\n    * Explicit, adaptive timestep\n\n    Note\n    ----\n    Recommended default for non-stiff block diagrams. Handles smooth\n    nonlinear dynamics, coupled oscillators, and signal-processing chains\n    efficiently. If the simulation warns about excessive step rejections or\n    very small timesteps, the system is likely stiff and an implicit solver\n    (``ESDIRK43``, ``GEAR52A``) should be used instead. For very tight\n    tolerances on smooth problems, ``RKV65`` or ``RKDP87`` can be more\n    efficient per unit accuracy.\n\n    References\n    ----------\n    .. [1] Dormand, J. R., & Prince, P. J. (1980). \"A family of embedded\n           Runge-Kutta formulae\". Journal of Computational and Applied\n           Mathematics, 6(1), 19-26.\n           :doi:`10.1016/0771-050X(80)90013-3`\n    .. [2] Shampine, L. F., & Reichelt, M. W. (1997). \"The MATLAB ODE\n           Suite\". SIAM Journal on Scientific Computing, 18(1), 1-22.\n           :doi:`10.1137/S1064827594276424`\n\n    \"\"\"\n\n    def __init__(self, *solver_args, **solver_kwargs):\n        super().__init__(*solver_args, **solver_kwargs)\n\n        #number of stages in RK scheme\n        self.s = 7\n\n        #order of scheme and embedded method\n        self.n = 5\n        self.m = 4\n\n        #flag adaptive timestep solver\n        self.is_adaptive = True\n\n        #intermediate evaluation times\n        self.eval_stages = [0.0, 1/5, 3/10, 4/5, 8/9, 1.0, 1.0]\n\n        #extended butcher table\n        self.BT = {\n            0: [       1/5],\n            1: [      3/40,        9/40],\n            2: [     44/45,      -56/15,       32/9], \n            3: [19372/6561, -25360/2187, 64448/6561, -212/729],\n            4: [ 9017/3168,     -355/33, 46732/5247,   49/176, -5103/18656],\n            5: [    35/384,           0,   500/1113,  125/192,  -2187/6784, 11/84],\n            6: [    35/384,           0,   500/1113,  125/192,  -2187/6784, 11/84]\n            }\n\n        #coefficients for local truncation error estimate\n        self.TR = [71/57600, 0, - 71/16695, 71/1920, -17253/339200, 22/525, -1/40]",
          "bases": [
            "pathsim.solvers._rungekutta.ExplicitRungeKutta"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, *solver_args, **solver_kwargs):\n    super().__init__(*solver_args, **solver_kwargs)\n\n    #number of stages in RK scheme\n    self.s = 7\n\n    #order of scheme and embedded method\n    self.n = 5\n    self.m = 4\n\n    #flag adaptive timestep solver\n    self.is_adaptive = True\n\n    #intermediate evaluation times\n    self.eval_stages = [0.0, 1/5, 3/10, 4/5, 8/9, 1.0, 1.0]\n\n    #extended butcher table\n    self.BT = {\n        0: [       1/5],\n        1: [      3/40,        9/40],\n        2: [     44/45,      -56/15,       32/9], \n        3: [19372/6561, -25360/2187, 64448/6561, -212/729],\n        4: [ 9017/3168,     -355/33, 46732/5247,   49/176, -5103/18656],\n        5: [    35/384,           0,   500/1113,  125/192,  -2187/6784, 11/84],\n        6: [    35/384,           0,   500/1113,  125/192,  -2187/6784, 11/84]\n        }\n\n    #coefficients for local truncation error estimate\n    self.TR = [71/57600, 0, - 71/16695, 71/1920, -17253/339200, 22/525, -1/40]",
              "signature": "(solver_args = (), solver_kwargs = {})",
              "parameters": [
                {
                  "name": "solver_args",
                  "type": null,
                  "default": "()",
                  "description": ""
                },
                {
                  "name": "solver_kwargs",
                  "type": null,
                  "default": "{}",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "s",
              "description": "",
              "type": null,
              "value": "7"
            },
            {
              "name": "n",
              "description": "",
              "type": null,
              "value": "5"
            },
            {
              "name": "m",
              "description": "",
              "type": null,
              "value": "4"
            },
            {
              "name": "is_adaptive",
              "description": "",
              "type": null,
              "value": "True"
            },
            {
              "name": "eval_stages",
              "description": "",
              "type": null,
              "value": "[0.0, 1 / 5, 3 / 10, 4 / 5, 8 / 9, 1.0, 1.0]"
            },
            {
              "name": "BT",
              "description": "",
              "type": null,
              "value": "{0: [1 / 5], 1: [3 / 40, 9 / 40], 2: [44 / 45, -56 / 15, 32 / 9], 3: [19372 / 6561, -25360 / 2187, 64448 / 6561, -212 / 729], 4: [9017 / 3168, -355 / 33, 46732 / 5247, 49 / 176, -5103 / 18656], 5: [35 / 384, 0, 500 / 1113, 125 / 192, -2187 / 6784, 11 / 84], 6: [35 / 384, 0, 500 / 1113, 125 / 192, -2187 / 6784, 11 / 84]}"
            },
            {
              "name": "TR",
              "description": "",
              "type": null,
              "value": "[71 / 57600, 0, -71 / 16695, 71 / 1920, -17253 / 339200, 22 / 525, -1 / 40]"
            }
          ],
          "parameters": [
            {
              "name": "solver_args",
              "type": null,
              "default": "()",
              "description": ""
            },
            {
              "name": "solver_kwargs",
              "type": null,
              "default": "{}",
              "description": ""
            }
          ]
        }
      ],
      "functions": []
    },
    "pathsim.solvers.rkdp87": {
      "name": "pathsim.solvers.rkdp87",
      "description": "",
      "docstring_html": "",
      "classes": [
        {
          "name": "RKDP87",
          "description": "Dormand-Prince 8(7) pair (DOP853). Thirteen stages, 8th order with",
          "docstring_html": "<p>Dormand-Prince 8(7) pair (DOP853). Thirteen stages, 8th order with\nembedded 7th order error estimate.</p>\n<p>The highest-order general-purpose explicit pair in this library. Has the\nFSAL property (not exploited in this implementation).</p>\n<div class=\"section\" id=\"characteristics\">\n<h4>Characteristics</h4>\n<ul class=\"simple\">\n<li>Order: 8 (propagating) / 7 (embedded)</li>\n<li>Stages: 13</li>\n<li>Explicit, adaptive timestep</li>\n</ul>\n</div>\n<div class=\"section\" id=\"note\">\n<h4>Note</h4>\n<p>Only worthwhile when the dynamics are very smooth and tolerances are\nextremely tight (roughly <tt class=\"math\">10^{-10}</tt> or below). The 13 function\nevaluations per step are expensive, but the 8th order convergence means\nthe step size can be much larger than with lower-order methods at the\nsame error. Suitable for generating reference solutions to validate other\nsolvers in a block diagram. For typical engineering tolerances\n(<tt class=\"math\">10^{-4}</tt>--<tt class=\"math\">10^{-8}</tt>), <tt class=\"docutils literal\">RKDP54</tt> or <tt class=\"docutils literal\">RKV65</tt> are more\nefficient.</p>\n<p><strong>References</strong></p>\n<table class=\"docutils footnote\" frame=\"void\" id=\"footnote-1\" rules=\"none\">\n<colgroup><col class=\"label\" /><col /></colgroup>\n<tbody valign=\"top\">\n<tr><td class=\"label\">[1]</td><td>Prince, P. J., &amp; Dormand, J. R. (1981). &quot;High order embedded\nRunge-Kutta formulae&quot;. Journal of Computational and Applied\nMathematics, 7(1), 67-75.\n:doi:`10.1016/0771-050X(81)90010-3`</td></tr>\n</tbody>\n</table>\n<table class=\"docutils footnote\" frame=\"void\" id=\"footnote-2\" rules=\"none\">\n<colgroup><col class=\"label\" /><col /></colgroup>\n<tbody valign=\"top\">\n<tr><td class=\"label\">[2]</td><td>Hairer, E., Nørsett, S. P., &amp; Wanner, G. (1993). &quot;Solving\nOrdinary Differential Equations I: Nonstiff Problems&quot;. Springer\nSeries in Computational Mathematics, Vol. 8.\n:doi:`10.1007/978-3-540-78862-1`</td></tr>\n</tbody>\n</table>\n</div>\n",
          "source": "class RKDP87(ExplicitRungeKutta):\n    \"\"\"Dormand-Prince 8(7) pair (DOP853). Thirteen stages, 8th order with\n    embedded 7th order error estimate.\n\n    The highest-order general-purpose explicit pair in this library. Has the\n    FSAL property (not exploited in this implementation).\n\n    Characteristics\n    ---------------\n    * Order: 8 (propagating) / 7 (embedded)\n    * Stages: 13\n    * Explicit, adaptive timestep\n\n    Note\n    ----\n    Only worthwhile when the dynamics are very smooth and tolerances are\n    extremely tight (roughly :math:`10^{-10}` or below). The 13 function\n    evaluations per step are expensive, but the 8th order convergence means\n    the step size can be much larger than with lower-order methods at the\n    same error. Suitable for generating reference solutions to validate other\n    solvers in a block diagram. For typical engineering tolerances\n    (:math:`10^{-4}`--:math:`10^{-8}`), ``RKDP54`` or ``RKV65`` are more\n    efficient.\n\n    References\n    ----------\n    .. [1] Prince, P. J., & Dormand, J. R. (1981). \"High order embedded\n           Runge-Kutta formulae\". Journal of Computational and Applied\n           Mathematics, 7(1), 67-75.\n           :doi:`10.1016/0771-050X(81)90010-3`\n    .. [2] Hairer, E., Nørsett, S. P., & Wanner, G. (1993). \"Solving\n           Ordinary Differential Equations I: Nonstiff Problems\". Springer\n           Series in Computational Mathematics, Vol. 8.\n           :doi:`10.1007/978-3-540-78862-1`\n\n    \"\"\"\n\n    def __init__(self, *solver_args, **solver_kwargs):\n        super().__init__(*solver_args, **solver_kwargs)\n\n        #number of stages in RK scheme\n        self.s = 13\n\n        #order of scheme and embedded method\n        self.n = 8\n        self.m = 7\n\n        #flag adaptive timestep solver\n        self.is_adaptive = True\n\n        #intermediate evaluation times\n        self.eval_stages = [0.0, 1/18, 1/12, 1/8, 5/16, 3/8, 59/400, 93/200, 5490023248/9719169821, 13/20, 1201146811/1299019798, 1.0, 1.0]\n\n        #extended butcher table \n        self.BT = {\n            0:  [1/18],\n            1:  [1/48, 1/16],\n            2:  [1/32, 0, 3/32],\n            3:  [5/16, 0, -75/64, 75/64],\n            4:  [3/80, 0, 0, 3/16, 3/20],\n            5:  [29443841/614563906, 0, 0, 77736538/692538347, -28693883/1125000000, 23124283/1800000000],\n            6:  [16016141/946692911, 0, 0, 61564180/158732637, 22789713/633445777, 545815736/2771057229, -180193667/1043307555],\n            7:  [39632708/573591083, 0, 0, -433636366/683701615, -421739975/2616292301, 100302831/723423059, 790204164/839813087, 800635310/3783071287],\n            8:  [246121993/1340847787, 0, 0, -37695042795/15268766246, -309121744/1061227803, -12992083/490766935, 6005943493/2108947869, 393006217/1396673457, 123872331/1001029789],\n            9:  [-1028468189/846180014, 0, 0, 8478235783/508512852, 1311729495/1432422823, -10304129995/1701304382, -48777925059/3047939560, 15336726248/1032824649, -45442868181/3398467696, 3065993473/597172653],\n            10: [185892177/718116043, 0, 0, -3185094517/667107341, -477755414/1098053517, -703635378/230739211, 5731566787/1027545527, 5232866602/850066563, -4093664535/808688257, 3962137247/1805957418, 65686358/487910083],\n            11: [403863854/491063109, 0, 0, -5068492393/434740067, -411421997/543043805, 652783627/914296604, 11173962825/925320556, -13158990841/6184727034, 3936647629/1978049680, -160528059/685178525, 248638103/1413531060, 0],\n            12: [14005451/335480064, 0, 0, 0, 0, -59238493/1068277825, 181606767/758867731, 561292985/797845732, -1041891430/1371343529, 760417239/1151165299, 118820643/751138087, -528747749/2220607170, 1/4]\n            }\n\n        #coefficients for lower order solution evaluation\n        bh = [13451932/455176623, 0, 0, 0, 0, -808719846/976000145, 1757004468/5645159321, 656045339/265891186, -3867574721/1518517206, 465885868/322736535, 53011238/667516719, 2/45, 0]\n\n        #coefficients for truncation error\n        self.TR = [a-b for a, b in zip(self.BT[12], bh)]",
          "bases": [
            "pathsim.solvers._rungekutta.ExplicitRungeKutta"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, *solver_args, **solver_kwargs):\n    super().__init__(*solver_args, **solver_kwargs)\n\n    #number of stages in RK scheme\n    self.s = 13\n\n    #order of scheme and embedded method\n    self.n = 8\n    self.m = 7\n\n    #flag adaptive timestep solver\n    self.is_adaptive = True\n\n    #intermediate evaluation times\n    self.eval_stages = [0.0, 1/18, 1/12, 1/8, 5/16, 3/8, 59/400, 93/200, 5490023248/9719169821, 13/20, 1201146811/1299019798, 1.0, 1.0]\n\n    #extended butcher table \n    self.BT = {\n        0:  [1/18],\n        1:  [1/48, 1/16],\n        2:  [1/32, 0, 3/32],\n        3:  [5/16, 0, -75/64, 75/64],\n        4:  [3/80, 0, 0, 3/16, 3/20],\n        5:  [29443841/614563906, 0, 0, 77736538/692538347, -28693883/1125000000, 23124283/1800000000],\n        6:  [16016141/946692911, 0, 0, 61564180/158732637, 22789713/633445777, 545815736/2771057229, -180193667/1043307555],\n        7:  [39632708/573591083, 0, 0, -433636366/683701615, -421739975/2616292301, 100302831/723423059, 790204164/839813087, 800635310/3783071287],\n        8:  [246121993/1340847787, 0, 0, -37695042795/15268766246, -309121744/1061227803, -12992083/490766935, 6005943493/2108947869, 393006217/1396673457, 123872331/1001029789],\n        9:  [-1028468189/846180014, 0, 0, 8478235783/508512852, 1311729495/1432422823, -10304129995/1701304382, -48777925059/3047939560, 15336726248/1032824649, -45442868181/3398467696, 3065993473/597172653],\n        10: [185892177/718116043, 0, 0, -3185094517/667107341, -477755414/1098053517, -703635378/230739211, 5731566787/1027545527, 5232866602/850066563, -4093664535/808688257, 3962137247/1805957418, 65686358/487910083],\n        11: [403863854/491063109, 0, 0, -5068492393/434740067, -411421997/543043805, 652783627/914296604, 11173962825/925320556, -13158990841/6184727034, 3936647629/1978049680, -160528059/685178525, 248638103/1413531060, 0],\n        12: [14005451/335480064, 0, 0, 0, 0, -59238493/1068277825, 181606767/758867731, 561292985/797845732, -1041891430/1371343529, 760417239/1151165299, 118820643/751138087, -528747749/2220607170, 1/4]\n        }\n\n    #coefficients for lower order solution evaluation\n    bh = [13451932/455176623, 0, 0, 0, 0, -808719846/976000145, 1757004468/5645159321, 656045339/265891186, -3867574721/1518517206, 465885868/322736535, 53011238/667516719, 2/45, 0]\n\n    #coefficients for truncation error\n    self.TR = [a-b for a, b in zip(self.BT[12], bh)]",
              "signature": "(solver_args = (), solver_kwargs = {})",
              "parameters": [
                {
                  "name": "solver_args",
                  "type": null,
                  "default": "()",
                  "description": ""
                },
                {
                  "name": "solver_kwargs",
                  "type": null,
                  "default": "{}",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "s",
              "description": "",
              "type": null,
              "value": "13"
            },
            {
              "name": "n",
              "description": "",
              "type": null,
              "value": "8"
            },
            {
              "name": "m",
              "description": "",
              "type": null,
              "value": "7"
            },
            {
              "name": "is_adaptive",
              "description": "",
              "type": null,
              "value": "True"
            },
            {
              "name": "eval_stages",
              "description": "",
              "type": null,
              "value": "[0.0, 1 / 18, 1 / 12, 1 / 8, 5 / 16, 3 / 8, 59 / 400, 93 / 200, 5490023248 / 9719169821, 13 / 20, 1201146811 / 1299019798, 1.0, 1.0]"
            },
            {
              "name": "BT",
              "description": "",
              "type": null,
              "value": "{0: [1 / 18], 1: [1 / 48, 1 / 16], 2: [1 / 32, 0, 3 / 32], 3: [5 / 16, 0, -75 / 64, 75 / 64], 4: [3 / 80, 0, 0, 3 / 16, 3 / 20], 5: [29443841 / 614563906, 0, 0, 77736538 / 692538347, -28693883 / 1125000000, 23124283 / 1800000000], 6: [16016141 / 946692911, 0, 0, 61564180 / 158732637, 22789713 / 633445777, 545815736 / 2771057229, -180193667 / 1043307555], 7: [39632708 / 573591083, 0, 0, -433636366 / 683701615, -421739975 / 2616292301, 100302831 / 723423059, 790204164 / 839813087, 800635310 / 3783071287], 8: [246121993 / 1340847787, 0, 0, -37695042795 / 15268766246, -309121744 / 1061227803, -12992083 / 490766935, 6005943493 / 2108947869, 393006217 / 1396673457, 123872331 / 1001029789], 9: [-1028468189 / 846180014, 0, 0, 8478235783 / 508512852, 1311729495 / 1432422823, -10304129995 / 1701304382, -48777925059 / 3047939560, 15336726248 / 1032824649, -45442868181 / 3398467696, 3065993473 / 597172653], 10: [185892177 / 718116043, 0, 0, -3185094517 / 667107341, -477755414 / 1098053517, -703635378 / 230739211, 5731566787 / 1027545527, 5232866602 / 850066563, -4093664535 / 808688257, 3962137247 / 1805957418, 65686358 / 487910083], 11: [403863854 / 491063109, 0, 0, -5068492393 / 434740067, -411421997 / 543043805, 652783627 / 914296604, 11173962825 / 925320556, -13158990841 / 6184727034, 3936647629 / 1978049680, -160528059 / 685178525, 248638103 / 1413531060, 0], 12: [14005451 / 335480064, 0, 0, 0, 0, -59238493 / 1068277825, 181606767 / 758867731, 561292985 / 797845732, -1041891430 / 1371343529, 760417239 / 1151165299, 118820643 / 751138087, -528747749 / 2220607170, 1 / 4]}"
            },
            {
              "name": "TR",
              "description": "",
              "type": null,
              "value": "[(a - b) for a, b in (zip(self.BT[12], bh))]"
            }
          ],
          "parameters": [
            {
              "name": "solver_args",
              "type": null,
              "default": "()",
              "description": ""
            },
            {
              "name": "solver_kwargs",
              "type": null,
              "default": "{}",
              "description": ""
            }
          ]
        }
      ],
      "functions": []
    },
    "pathsim.solvers.rkf21": {
      "name": "pathsim.solvers.rkf21",
      "description": "",
      "docstring_html": "",
      "classes": [
        {
          "name": "RKF21",
          "description": "Three-stage, 2nd order Runge-Kutta-Fehlberg method with embedded 1st order error estimate.",
          "docstring_html": "<p>Three-stage, 2nd order Runge-Kutta-Fehlberg method with embedded 1st order error estimate.</p>\n<div class=\"section\" id=\"characteristics\">\n<h4>Characteristics</h4>\n<ul class=\"simple\">\n<li>Order: 2 (propagating) / 1 (embedded)</li>\n<li>Stages: 3</li>\n<li>Explicit, adaptive timestep</li>\n</ul>\n</div>\n<div class=\"section\" id=\"note\">\n<h4>Note</h4>\n<p>The cheapest adaptive explicit method available. The low order means the\nerror estimate itself is coarse, so step-size control is less reliable\nthan with higher-order pairs. Useful for rough exploratory runs of a new\nblock diagram or when step size is dominated by discrete events (zero\ncrossings, scheduled triggers) rather than truncation error. For\nproduction simulations, <tt class=\"docutils literal\">RKBS32</tt> or <tt class=\"docutils literal\">RKDP54</tt> are almost always\npreferable.</p>\n<p><strong>References</strong></p>\n<table class=\"docutils footnote\" frame=\"void\" id=\"footnote-1\" rules=\"none\">\n<colgroup><col class=\"label\" /><col /></colgroup>\n<tbody valign=\"top\">\n<tr><td class=\"label\">[1]</td><td>Fehlberg, E. (1969). &quot;Low-order classical Runge-Kutta formulas\nwith stepsize control and their application to some heat transfer\nproblems&quot;. NASA Technical Report TR R-315.</td></tr>\n</tbody>\n</table>\n<table class=\"docutils footnote\" frame=\"void\" id=\"footnote-2\" rules=\"none\">\n<colgroup><col class=\"label\" /><col /></colgroup>\n<tbody valign=\"top\">\n<tr><td class=\"label\">[2]</td><td>Hairer, E., Nørsett, S. P., &amp; Wanner, G. (1993). &quot;Solving\nOrdinary Differential Equations I: Nonstiff Problems&quot;. Springer\nSeries in Computational Mathematics, Vol. 8.\n:doi:`10.1007/978-3-540-78862-1`</td></tr>\n</tbody>\n</table>\n</div>\n",
          "source": "class RKF21(ExplicitRungeKutta):\n    \"\"\"Three-stage, 2nd order Runge-Kutta-Fehlberg method with embedded 1st order error estimate.\n\n    Characteristics\n    ---------------\n    * Order: 2 (propagating) / 1 (embedded)\n    * Stages: 3\n    * Explicit, adaptive timestep\n\n    Note\n    ----\n    The cheapest adaptive explicit method available. The low order means the\n    error estimate itself is coarse, so step-size control is less reliable\n    than with higher-order pairs. Useful for rough exploratory runs of a new\n    block diagram or when step size is dominated by discrete events (zero\n    crossings, scheduled triggers) rather than truncation error. For\n    production simulations, ``RKBS32`` or ``RKDP54`` are almost always\n    preferable.\n\n    References\n    ----------\n    .. [1] Fehlberg, E. (1969). \"Low-order classical Runge-Kutta formulas\n           with stepsize control and their application to some heat transfer\n           problems\". NASA Technical Report TR R-315.\n    .. [2] Hairer, E., Nørsett, S. P., & Wanner, G. (1993). \"Solving\n           Ordinary Differential Equations I: Nonstiff Problems\". Springer\n           Series in Computational Mathematics, Vol. 8.\n           :doi:`10.1007/978-3-540-78862-1`\n\n    \"\"\"\n\n    def __init__(self, *solver_args, **solver_kwargs):\n        super().__init__(*solver_args, **solver_kwargs)\n\n        #number of stages in RK scheme\n        self.s = 3\n\n        #order of scheme and embedded method\n        self.n = 2\n        self.m = 1\n\n        #flag adaptive timestep solver\n        self.is_adaptive = True\n\n        #intermediate evaluation times\n        self.eval_stages = [0.0, 1/2, 1]\n\n        #extended butcher table \n        self.BT = {\n            0: [  1/2],\n            1: [1/256, 255/256],\n            2: [1/512, 255/256, 1/512]\n            }\n\n        #coefficients for local truncation error estimate\n        self.TR = [1/512, 0, -1/512]",
          "bases": [
            "pathsim.solvers._rungekutta.ExplicitRungeKutta"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, *solver_args, **solver_kwargs):\n    super().__init__(*solver_args, **solver_kwargs)\n\n    #number of stages in RK scheme\n    self.s = 3\n\n    #order of scheme and embedded method\n    self.n = 2\n    self.m = 1\n\n    #flag adaptive timestep solver\n    self.is_adaptive = True\n\n    #intermediate evaluation times\n    self.eval_stages = [0.0, 1/2, 1]\n\n    #extended butcher table \n    self.BT = {\n        0: [  1/2],\n        1: [1/256, 255/256],\n        2: [1/512, 255/256, 1/512]\n        }\n\n    #coefficients for local truncation error estimate\n    self.TR = [1/512, 0, -1/512]",
              "signature": "(solver_args = (), solver_kwargs = {})",
              "parameters": [
                {
                  "name": "solver_args",
                  "type": null,
                  "default": "()",
                  "description": ""
                },
                {
                  "name": "solver_kwargs",
                  "type": null,
                  "default": "{}",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "s",
              "description": "",
              "type": null,
              "value": "3"
            },
            {
              "name": "n",
              "description": "",
              "type": null,
              "value": "2"
            },
            {
              "name": "m",
              "description": "",
              "type": null,
              "value": "1"
            },
            {
              "name": "is_adaptive",
              "description": "",
              "type": null,
              "value": "True"
            },
            {
              "name": "eval_stages",
              "description": "",
              "type": null,
              "value": "[0.0, 1 / 2, 1]"
            },
            {
              "name": "BT",
              "description": "",
              "type": null,
              "value": "{0: [1 / 2], 1: [1 / 256, 255 / 256], 2: [1 / 512, 255 / 256, 1 / 512]}"
            },
            {
              "name": "TR",
              "description": "",
              "type": null,
              "value": "[1 / 512, 0, -1 / 512]"
            }
          ],
          "parameters": [
            {
              "name": "solver_args",
              "type": null,
              "default": "()",
              "description": ""
            },
            {
              "name": "solver_kwargs",
              "type": null,
              "default": "{}",
              "description": ""
            }
          ]
        }
      ],
      "functions": []
    },
    "pathsim.solvers.rkf45": {
      "name": "pathsim.solvers.rkf45",
      "description": "",
      "docstring_html": "",
      "classes": [
        {
          "name": "RKF45",
          "description": "Runge-Kutta-Fehlberg 4(5) pair. Six stages, 4th order propagation with",
          "docstring_html": "<p>Runge-Kutta-Fehlberg 4(5) pair. Six stages, 4th order propagation with\n5th order error estimate.</p>\n<p>The historically first widely-used embedded pair for automatic step-size\ncontrol. The 4th order solution is propagated; the difference to the 5th\norder solution provides a local error estimate.</p>\n<div class=\"section\" id=\"characteristics\">\n<h4>Characteristics</h4>\n<ul class=\"simple\">\n<li>Order: 4 (propagating) / 5 (error estimate)</li>\n<li>Stages: 6</li>\n<li>Explicit, adaptive timestep</li>\n</ul>\n</div>\n<div class=\"section\" id=\"note\">\n<h4>Note</h4>\n<p>Largely superseded by the Dormand-Prince (<tt class=\"docutils literal\">RKDP54</tt>) and Cash-Karp\n(<tt class=\"docutils literal\">RKCK54</tt>) pairs, which achieve better accuracy per function evaluation\non most problems. Still useful for reproducing legacy results or when\ncomparing against published benchmarks that used RKF45.</p>\n<p><strong>References</strong></p>\n<table class=\"docutils footnote\" frame=\"void\" id=\"footnote-1\" rules=\"none\">\n<colgroup><col class=\"label\" /><col /></colgroup>\n<tbody valign=\"top\">\n<tr><td class=\"label\">[1]</td><td>Fehlberg, E. (1969). &quot;Low-order classical Runge-Kutta formulas\nwith stepsize control and their application to some heat transfer\nproblems&quot;. NASA Technical Report TR R-315.</td></tr>\n</tbody>\n</table>\n<table class=\"docutils footnote\" frame=\"void\" id=\"footnote-2\" rules=\"none\">\n<colgroup><col class=\"label\" /><col /></colgroup>\n<tbody valign=\"top\">\n<tr><td class=\"label\">[2]</td><td>Fehlberg, E. (1970). &quot;Klassische Runge-Kutta-Formeln vierter und\nniedrigerer Ordnung mit Schrittweiten-Kontrolle und ihre Anwendung\nauf Wärmeleitungsprobleme&quot;. Computing, 6(1-2), 61-71.\n:doi:`10.1007/BF02241732`</td></tr>\n</tbody>\n</table>\n</div>\n",
          "source": "class RKF45(ExplicitRungeKutta):\n    \"\"\"Runge-Kutta-Fehlberg 4(5) pair. Six stages, 4th order propagation with\n    5th order error estimate.\n\n    The historically first widely-used embedded pair for automatic step-size\n    control. The 4th order solution is propagated; the difference to the 5th\n    order solution provides a local error estimate.\n\n    Characteristics\n    ---------------\n    * Order: 4 (propagating) / 5 (error estimate)\n    * Stages: 6\n    * Explicit, adaptive timestep\n\n    Note\n    ----\n    Largely superseded by the Dormand-Prince (``RKDP54``) and Cash-Karp\n    (``RKCK54``) pairs, which achieve better accuracy per function evaluation\n    on most problems. Still useful for reproducing legacy results or when\n    comparing against published benchmarks that used RKF45.\n\n    References\n    ----------\n    .. [1] Fehlberg, E. (1969). \"Low-order classical Runge-Kutta formulas\n           with stepsize control and their application to some heat transfer\n           problems\". NASA Technical Report TR R-315.\n    .. [2] Fehlberg, E. (1970). \"Klassische Runge-Kutta-Formeln vierter und\n           niedrigerer Ordnung mit Schrittweiten-Kontrolle und ihre Anwendung\n           auf Wärmeleitungsprobleme\". Computing, 6(1-2), 61-71.\n           :doi:`10.1007/BF02241732`\n\n    \"\"\"\n\n    def __init__(self, *solver_args, **solver_kwargs):\n        super().__init__(*solver_args, **solver_kwargs)\n\n        #number of stages in RK scheme\n        self.s = 6\n\n        #order of scheme and embedded method\n        self.n = 5\n        self.m = 4\n\n        #flag adaptive timestep solver\n        self.is_adaptive = True\n\n        #intermediate evaluation times\n        self.eval_stages = [0.0, 1/4, 3/8, 12/13, 1, 1/2]\n\n        #extended butcher table \n        self.BT = {\n            0: [      1/4],\n            1: [     3/32,       9/32],\n            2: [1932/2197, -7200/2197,  7296/2197],\n            3: [  439/216,         -8,   3680/513, -845/4104],\n            4: [    -8/27,          2, -3554/2565, 1859/4104, -11/40],\n            5: [   25/216,          0,  1408/2565, 2197/4104,   -1/5, 0]\n            }\n\n        #coefficients for local truncation error estimate\n        self.TR = [1/360, 0, -128/4275, -2197/75240, 1/50, 2/55]",
          "bases": [
            "pathsim.solvers._rungekutta.ExplicitRungeKutta"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, *solver_args, **solver_kwargs):\n    super().__init__(*solver_args, **solver_kwargs)\n\n    #number of stages in RK scheme\n    self.s = 6\n\n    #order of scheme and embedded method\n    self.n = 5\n    self.m = 4\n\n    #flag adaptive timestep solver\n    self.is_adaptive = True\n\n    #intermediate evaluation times\n    self.eval_stages = [0.0, 1/4, 3/8, 12/13, 1, 1/2]\n\n    #extended butcher table \n    self.BT = {\n        0: [      1/4],\n        1: [     3/32,       9/32],\n        2: [1932/2197, -7200/2197,  7296/2197],\n        3: [  439/216,         -8,   3680/513, -845/4104],\n        4: [    -8/27,          2, -3554/2565, 1859/4104, -11/40],\n        5: [   25/216,          0,  1408/2565, 2197/4104,   -1/5, 0]\n        }\n\n    #coefficients for local truncation error estimate\n    self.TR = [1/360, 0, -128/4275, -2197/75240, 1/50, 2/55]",
              "signature": "(solver_args = (), solver_kwargs = {})",
              "parameters": [
                {
                  "name": "solver_args",
                  "type": null,
                  "default": "()",
                  "description": ""
                },
                {
                  "name": "solver_kwargs",
                  "type": null,
                  "default": "{}",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "s",
              "description": "",
              "type": null,
              "value": "6"
            },
            {
              "name": "n",
              "description": "",
              "type": null,
              "value": "5"
            },
            {
              "name": "m",
              "description": "",
              "type": null,
              "value": "4"
            },
            {
              "name": "is_adaptive",
              "description": "",
              "type": null,
              "value": "True"
            },
            {
              "name": "eval_stages",
              "description": "",
              "type": null,
              "value": "[0.0, 1 / 4, 3 / 8, 12 / 13, 1, 1 / 2]"
            },
            {
              "name": "BT",
              "description": "",
              "type": null,
              "value": "{0: [1 / 4], 1: [3 / 32, 9 / 32], 2: [1932 / 2197, -7200 / 2197, 7296 / 2197], 3: [439 / 216, -8, 3680 / 513, -845 / 4104], 4: [-8 / 27, 2, -3554 / 2565, 1859 / 4104, -11 / 40], 5: [25 / 216, 0, 1408 / 2565, 2197 / 4104, -1 / 5, 0]}"
            },
            {
              "name": "TR",
              "description": "",
              "type": null,
              "value": "[1 / 360, 0, -128 / 4275, -2197 / 75240, 1 / 50, 2 / 55]"
            }
          ],
          "parameters": [
            {
              "name": "solver_args",
              "type": null,
              "default": "()",
              "description": ""
            },
            {
              "name": "solver_kwargs",
              "type": null,
              "default": "{}",
              "description": ""
            }
          ]
        }
      ],
      "functions": []
    },
    "pathsim.solvers.rkf78": {
      "name": "pathsim.solvers.rkf78",
      "description": "",
      "docstring_html": "",
      "classes": [
        {
          "name": "RKF78",
          "description": "Runge-Kutta-Fehlberg 7(8) pair. Thirteen stages, 7th order propagation",
          "docstring_html": "<p>Runge-Kutta-Fehlberg 7(8) pair. Thirteen stages, 7th order propagation\nwith 8th order error estimate.</p>\n<div class=\"section\" id=\"characteristics\">\n<h4>Characteristics</h4>\n<ul class=\"simple\">\n<li>Order: 7 (propagating) / 8 (error estimate)</li>\n<li>Stages: 13</li>\n<li>Explicit, adaptive timestep</li>\n</ul>\n</div>\n<div class=\"section\" id=\"note\">\n<h4>Note</h4>\n<p>One of the earliest very-high-order embedded pairs. At the same stage\ncount, the Dormand-Prince pair (<tt class=\"docutils literal\">RKDP87</tt>) generally provides better\nerror constants. Consider <tt class=\"docutils literal\">RKDP87</tt> for new work unless Fehlberg-pair\ncompatibility is required.</p>\n<p><strong>References</strong></p>\n<table class=\"docutils footnote\" frame=\"void\" id=\"footnote-1\" rules=\"none\">\n<colgroup><col class=\"label\" /><col /></colgroup>\n<tbody valign=\"top\">\n<tr><td class=\"label\">[1]</td><td>Fehlberg, E. (1968). &quot;Classical fifth-, sixth-, seventh-, and\neighth-order Runge-Kutta formulas with stepsize control&quot;. NASA\nTechnical Report TR R-287.</td></tr>\n</tbody>\n</table>\n<table class=\"docutils footnote\" frame=\"void\" id=\"footnote-2\" rules=\"none\">\n<colgroup><col class=\"label\" /><col /></colgroup>\n<tbody valign=\"top\">\n<tr><td class=\"label\">[2]</td><td>Hairer, E., Nørsett, S. P., &amp; Wanner, G. (1993). &quot;Solving\nOrdinary Differential Equations I: Nonstiff Problems&quot;. Springer\nSeries in Computational Mathematics, Vol. 8.\n:doi:`10.1007/978-3-540-78862-1`</td></tr>\n</tbody>\n</table>\n</div>\n",
          "source": "class RKF78(ExplicitRungeKutta):\n    \"\"\"Runge-Kutta-Fehlberg 7(8) pair. Thirteen stages, 7th order propagation\n    with 8th order error estimate.\n\n    Characteristics\n    ---------------\n    * Order: 7 (propagating) / 8 (error estimate)\n    * Stages: 13\n    * Explicit, adaptive timestep\n\n    Note\n    ----\n    One of the earliest very-high-order embedded pairs. At the same stage\n    count, the Dormand-Prince pair (``RKDP87``) generally provides better\n    error constants. Consider ``RKDP87`` for new work unless Fehlberg-pair\n    compatibility is required.\n\n    References\n    ----------\n    .. [1] Fehlberg, E. (1968). \"Classical fifth-, sixth-, seventh-, and\n           eighth-order Runge-Kutta formulas with stepsize control\". NASA\n           Technical Report TR R-287.\n    .. [2] Hairer, E., Nørsett, S. P., & Wanner, G. (1993). \"Solving\n           Ordinary Differential Equations I: Nonstiff Problems\". Springer\n           Series in Computational Mathematics, Vol. 8.\n           :doi:`10.1007/978-3-540-78862-1`\n\n    \"\"\"\n\n    def __init__(self, *solver_args, **solver_kwargs):\n        super().__init__(*solver_args, **solver_kwargs)\n\n        #number of stages in RK scheme\n        self.s = 13\n\n        #order of scheme and embedded method\n        self.n = 7\n        self.m = 8\n\n        #flag adaptive timestep solver\n        self.is_adaptive = True\n\n        #intermediate evaluation times\n        self.eval_stages = [0, 2/27, 1/9, 1/6, 5/12, 1/2, 5/6, 1/6, 2/3, 1/3, 1, 0, 1]\n\n        #extended butcher table \n        self.BT = {\n            0:  [      2/27],\n            1:  [      1/36, 1/12],\n            2:  [      1/24,    0,    1/8],\n            3:  [      5/12,    0, -25/16,    25/16],\n            4:  [      1/20,    0,      0,      1/4,       1/5],\n            5:  [   -25/108,    0,      0,  125/108,    -65/27,  125/54],\n            6:  [    31/300,    0,      0,        0,    61/225,    -2/9,    13/900],\n            7:  [         2,    0,      0,    -53/6,    704/45,  -107/9,     67/90,     3],\n            8:  [   -91/108,    0,      0,   23/108,  -976/135,  311/54,    -19/60,  17/6,  -1/12],\n            9:  [ 2383/4100,    0,      0, -341/164, 4496/1025, -301/82, 2133/4100, 45/82, 45/164, 18/41],\n            10: [     3/205,    0,      0,        0,         0,   -6/41,    -3/205, -3/41,   3/41,  6/41],\n            11: [-1777/4100,    0,      0, -341/164, 4496/1025, -289/82, 2193/4100, 51/82, 33/164, 12/41,   0, 1],\n            12: [    41/840,    0,      0,        0,         0,  34/105,      9/35,  9/35,  9/280, 9/280, 41/840]\n            }\n\n        #coefficients for local truncation error estimate\n        self.TR = [41/840, 0, 0, 0, 0, 0, 0, 0, 0, 0, 41/840, -41/840, -41/840]",
          "bases": [
            "pathsim.solvers._rungekutta.ExplicitRungeKutta"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, *solver_args, **solver_kwargs):\n    super().__init__(*solver_args, **solver_kwargs)\n\n    #number of stages in RK scheme\n    self.s = 13\n\n    #order of scheme and embedded method\n    self.n = 7\n    self.m = 8\n\n    #flag adaptive timestep solver\n    self.is_adaptive = True\n\n    #intermediate evaluation times\n    self.eval_stages = [0, 2/27, 1/9, 1/6, 5/12, 1/2, 5/6, 1/6, 2/3, 1/3, 1, 0, 1]\n\n    #extended butcher table \n    self.BT = {\n        0:  [      2/27],\n        1:  [      1/36, 1/12],\n        2:  [      1/24,    0,    1/8],\n        3:  [      5/12,    0, -25/16,    25/16],\n        4:  [      1/20,    0,      0,      1/4,       1/5],\n        5:  [   -25/108,    0,      0,  125/108,    -65/27,  125/54],\n        6:  [    31/300,    0,      0,        0,    61/225,    -2/9,    13/900],\n        7:  [         2,    0,      0,    -53/6,    704/45,  -107/9,     67/90,     3],\n        8:  [   -91/108,    0,      0,   23/108,  -976/135,  311/54,    -19/60,  17/6,  -1/12],\n        9:  [ 2383/4100,    0,      0, -341/164, 4496/1025, -301/82, 2133/4100, 45/82, 45/164, 18/41],\n        10: [     3/205,    0,      0,        0,         0,   -6/41,    -3/205, -3/41,   3/41,  6/41],\n        11: [-1777/4100,    0,      0, -341/164, 4496/1025, -289/82, 2193/4100, 51/82, 33/164, 12/41,   0, 1],\n        12: [    41/840,    0,      0,        0,         0,  34/105,      9/35,  9/35,  9/280, 9/280, 41/840]\n        }\n\n    #coefficients for local truncation error estimate\n    self.TR = [41/840, 0, 0, 0, 0, 0, 0, 0, 0, 0, 41/840, -41/840, -41/840]",
              "signature": "(solver_args = (), solver_kwargs = {})",
              "parameters": [
                {
                  "name": "solver_args",
                  "type": null,
                  "default": "()",
                  "description": ""
                },
                {
                  "name": "solver_kwargs",
                  "type": null,
                  "default": "{}",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "s",
              "description": "",
              "type": null,
              "value": "13"
            },
            {
              "name": "n",
              "description": "",
              "type": null,
              "value": "7"
            },
            {
              "name": "m",
              "description": "",
              "type": null,
              "value": "8"
            },
            {
              "name": "is_adaptive",
              "description": "",
              "type": null,
              "value": "True"
            },
            {
              "name": "eval_stages",
              "description": "",
              "type": null,
              "value": "[0, 2 / 27, 1 / 9, 1 / 6, 5 / 12, 1 / 2, 5 / 6, 1 / 6, 2 / 3, 1 / 3, 1, 0, 1]"
            },
            {
              "name": "BT",
              "description": "",
              "type": null,
              "value": "{0: [2 / 27], 1: [1 / 36, 1 / 12], 2: [1 / 24, 0, 1 / 8], 3: [5 / 12, 0, -25 / 16, 25 / 16], 4: [1 / 20, 0, 0, 1 / 4, 1 / 5], 5: [-25 / 108, 0, 0, 125 / 108, -65 / 27, 125 / 54], 6: [31 / 300, 0, 0, 0, 61 / 225, -2 / 9, 13 / 900], 7: [2, 0, 0, -53 / 6, 704 / 45, -107 / 9, 67 / 90, 3], 8: [-91 / 108, 0, 0, 23 / 108, -976 / 135, 311 / 54, -19 / 60, 17 / 6, -1 / 12], 9: [2383 / 4100, 0, 0, -341 / 164, 4496 / 1025, -301 / 82, 2133 / 4100, 45 / 82, 45 / 164, 18 / 41], 10: [3 / 205, 0, 0, 0, 0, -6 / 41, -3 / 205, -3 / 41, 3 / 41, 6 / 41], 11: [-1777 / 4100, 0, 0, -341 / 164, 4496 / 1025, -289 / 82, 2193 / 4100, 51 / 82, 33 / 164, 12 / 41, 0, 1], 12: [41 / 840, 0, 0, 0, 0, 34 / 105, 9 / 35, 9 / 35, 9 / 280, 9 / 280, 41 / 840]}"
            },
            {
              "name": "TR",
              "description": "",
              "type": null,
              "value": "[41 / 840, 0, 0, 0, 0, 0, 0, 0, 0, 0, 41 / 840, -41 / 840, -41 / 840]"
            }
          ],
          "parameters": [
            {
              "name": "solver_args",
              "type": null,
              "default": "()",
              "description": ""
            },
            {
              "name": "solver_kwargs",
              "type": null,
              "default": "{}",
              "description": ""
            }
          ]
        }
      ],
      "functions": []
    },
    "pathsim.solvers.rkv65": {
      "name": "pathsim.solvers.rkv65",
      "description": "",
      "docstring_html": "",
      "classes": [
        {
          "name": "RKV65",
          "description": "Verner 6(5) \"most robust\" pair. Nine stages, 6th order with",
          "docstring_html": "<p>Verner 6(5) &quot;most robust&quot; pair. Nine stages, 6th order with\nembedded 5th order error estimate.</p>\n<div class=\"section\" id=\"characteristics\">\n<h4>Characteristics</h4>\n<ul class=\"simple\">\n<li>Order: 6 (propagating) / 5 (embedded)</li>\n<li>Stages: 9</li>\n<li>Explicit, adaptive timestep</li>\n</ul>\n</div>\n<div class=\"section\" id=\"note\">\n<h4>Note</h4>\n<p>Fills the gap between 5th order pairs (<tt class=\"docutils literal\">RKDP54</tt>) and the expensive 8th\norder <tt class=\"docutils literal\">RKDP87</tt>. The extra stages pay off when the dynamics are smooth\nand tolerances are tight (roughly <tt class=\"math\">10^{-8}</tt> or below), because the\nhigher order allows much larger steps. For tolerances in the\n<tt class=\"math\">10^{-4}</tt>--<tt class=\"math\">10^{-6}</tt> range, <tt class=\"docutils literal\">RKDP54</tt> is usually cheaper\noverall due to fewer stages.</p>\n<p><strong>References</strong></p>\n<table class=\"docutils footnote\" frame=\"void\" id=\"footnote-1\" rules=\"none\">\n<colgroup><col class=\"label\" /><col /></colgroup>\n<tbody valign=\"top\">\n<tr><td class=\"label\">[1]</td><td>Verner, J. H. (2010). &quot;Numerically optimal Runge-Kutta pairs\nwith interpolants&quot;. Numerical Algorithms, 53(2-3), 383-396.\n:doi:`10.1007/s11075-009-9290-3`</td></tr>\n</tbody>\n</table>\n<table class=\"docutils footnote\" frame=\"void\" id=\"footnote-2\" rules=\"none\">\n<colgroup><col class=\"label\" /><col /></colgroup>\n<tbody valign=\"top\">\n<tr><td class=\"label\">[2]</td><td>Hairer, E., Nørsett, S. P., &amp; Wanner, G. (1993). &quot;Solving\nOrdinary Differential Equations I: Nonstiff Problems&quot;. Springer\nSeries in Computational Mathematics, Vol. 8.\n:doi:`10.1007/978-3-540-78862-1`</td></tr>\n</tbody>\n</table>\n</div>\n",
          "source": "class RKV65(ExplicitRungeKutta):\n    \"\"\"Verner 6(5) \"most robust\" pair. Nine stages, 6th order with\n    embedded 5th order error estimate.\n\n    Characteristics\n    ---------------\n    * Order: 6 (propagating) / 5 (embedded)\n    * Stages: 9\n    * Explicit, adaptive timestep\n\n    Note\n    ----\n    Fills the gap between 5th order pairs (``RKDP54``) and the expensive 8th\n    order ``RKDP87``. The extra stages pay off when the dynamics are smooth\n    and tolerances are tight (roughly :math:`10^{-8}` or below), because the\n    higher order allows much larger steps. For tolerances in the\n    :math:`10^{-4}`--:math:`10^{-6}` range, ``RKDP54`` is usually cheaper\n    overall due to fewer stages.\n\n    References\n    ----------\n    .. [1] Verner, J. H. (2010). \"Numerically optimal Runge-Kutta pairs\n           with interpolants\". Numerical Algorithms, 53(2-3), 383-396.\n           :doi:`10.1007/s11075-009-9290-3`\n    .. [2] Hairer, E., Nørsett, S. P., & Wanner, G. (1993). \"Solving\n           Ordinary Differential Equations I: Nonstiff Problems\". Springer\n           Series in Computational Mathematics, Vol. 8.\n           :doi:`10.1007/978-3-540-78862-1`\n\n    \"\"\"\n\n    def __init__(self, *solver_args, **solver_kwargs):\n        super().__init__(*solver_args, **solver_kwargs)\n\n        #number of stages in RK scheme\n        self.s = 9\n\n        #order of scheme and embedded method\n        self.n = 6\n        self.m = 5\n\n        #flag adaptive timestep solver\n        self.is_adaptive = True\n\n        #intermediate evaluation times\n        self.eval_stages = [0.0, 9/50, 1/6, 1/4, 53/100, 3/5, 4/5, 1.0, 1.0]\n\n        #extended butcher table \n        self.BT = {\n            0: [             9/50],\n            1: [           29/324, 25/324],\n            2: [             1/16,      0,           3/16],\n            3: [     79129/250000,      0, -261237/250000,      19663/15625],\n            4: [  1336883/4909125,      0,   -25476/30875,    194159/185250,       8225/78546],\n            5: [-2459386/14727375,      0,    19504/30875, 2377474/13615875, -6157250/5773131,   902/735],\n            6: [        2699/7410,      0,      -252/1235, -1393253/3993990,     236875/72618,   -135/49,   15/22], \n            7: [           11/144,      0,              0,          256/693,                0,   125/504, 125/528,        5/72], \n            8: [           11/144,      0,              0,          256/693,                0,   125/504, 125/528,        5/72]\n            }\n\n        #compute coefficients for truncation error\n        _A1 = [11/144, 0, 0, 256/693,              0,   125/504, 125/528,        5/72, 0]\n        _A2 = [28/477, 0, 0, 212/441, -312500/366177, 2125/1764,       0, -2105/35532, 2995/17766]        \n        self.TR = [a-b for a, b in zip(_A1, _A2)]",
          "bases": [
            "pathsim.solvers._rungekutta.ExplicitRungeKutta"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, *solver_args, **solver_kwargs):\n    super().__init__(*solver_args, **solver_kwargs)\n\n    #number of stages in RK scheme\n    self.s = 9\n\n    #order of scheme and embedded method\n    self.n = 6\n    self.m = 5\n\n    #flag adaptive timestep solver\n    self.is_adaptive = True\n\n    #intermediate evaluation times\n    self.eval_stages = [0.0, 9/50, 1/6, 1/4, 53/100, 3/5, 4/5, 1.0, 1.0]\n\n    #extended butcher table \n    self.BT = {\n        0: [             9/50],\n        1: [           29/324, 25/324],\n        2: [             1/16,      0,           3/16],\n        3: [     79129/250000,      0, -261237/250000,      19663/15625],\n        4: [  1336883/4909125,      0,   -25476/30875,    194159/185250,       8225/78546],\n        5: [-2459386/14727375,      0,    19504/30875, 2377474/13615875, -6157250/5773131,   902/735],\n        6: [        2699/7410,      0,      -252/1235, -1393253/3993990,     236875/72618,   -135/49,   15/22], \n        7: [           11/144,      0,              0,          256/693,                0,   125/504, 125/528,        5/72], \n        8: [           11/144,      0,              0,          256/693,                0,   125/504, 125/528,        5/72]\n        }\n\n    #compute coefficients for truncation error\n    _A1 = [11/144, 0, 0, 256/693,              0,   125/504, 125/528,        5/72, 0]\n    _A2 = [28/477, 0, 0, 212/441, -312500/366177, 2125/1764,       0, -2105/35532, 2995/17766]        \n    self.TR = [a-b for a, b in zip(_A1, _A2)]",
              "signature": "(solver_args = (), solver_kwargs = {})",
              "parameters": [
                {
                  "name": "solver_args",
                  "type": null,
                  "default": "()",
                  "description": ""
                },
                {
                  "name": "solver_kwargs",
                  "type": null,
                  "default": "{}",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "s",
              "description": "",
              "type": null,
              "value": "9"
            },
            {
              "name": "n",
              "description": "",
              "type": null,
              "value": "6"
            },
            {
              "name": "m",
              "description": "",
              "type": null,
              "value": "5"
            },
            {
              "name": "is_adaptive",
              "description": "",
              "type": null,
              "value": "True"
            },
            {
              "name": "eval_stages",
              "description": "",
              "type": null,
              "value": "[0.0, 9 / 50, 1 / 6, 1 / 4, 53 / 100, 3 / 5, 4 / 5, 1.0, 1.0]"
            },
            {
              "name": "BT",
              "description": "",
              "type": null,
              "value": "{0: [9 / 50], 1: [29 / 324, 25 / 324], 2: [1 / 16, 0, 3 / 16], 3: [79129 / 250000, 0, -261237 / 250000, 19663 / 15625], 4: [1336883 / 4909125, 0, -25476 / 30875, 194159 / 185250, 8225 / 78546], 5: [-2459386 / 14727375, 0, 19504 / 30875, 2377474 / 13615875, -6157250 / 5773131, 902 / 735], 6: [2699 / 7410, 0, -252 / 1235, -1393253 / 3993990, 236875 / 72618, -135 / 49, 15 / 22], 7: [11 / 144, 0, 0, 256 / 693, 0, 125 / 504, 125 / 528, 5 / 72], 8: [11 / 144, 0, 0, 256 / 693, 0, 125 / 504, 125 / 528, 5 / 72]}"
            },
            {
              "name": "TR",
              "description": "",
              "type": null,
              "value": "[(a - b) for a, b in (zip(_A1, _A2))]"
            }
          ],
          "parameters": [
            {
              "name": "solver_args",
              "type": null,
              "default": "()",
              "description": ""
            },
            {
              "name": "solver_kwargs",
              "type": null,
              "default": "{}",
              "description": ""
            }
          ]
        }
      ],
      "functions": []
    },
    "pathsim.solvers.ssprk22": {
      "name": "pathsim.solvers.ssprk22",
      "description": "",
      "docstring_html": "",
      "classes": [
        {
          "name": "SSPRK22",
          "description": "Two-stage, 2nd order Strong Stability Preserving (SSP) Runge-Kutta method.",
          "docstring_html": "<p>Two-stage, 2nd order Strong Stability Preserving (SSP) Runge-Kutta method.</p>\n<p>Also known as Heun's method. SSP methods preserve monotonicity and total\nvariation diminishing (TVD) properties of the spatial discretisation under\na timestep restriction scaled by the SSP coefficient.</p>\n<div class=\"section\" id=\"characteristics\">\n<h4>Characteristics</h4>\n<ul class=\"simple\">\n<li>Order: 2</li>\n<li>Stages: 2</li>\n<li>Explicit, fixed timestep</li>\n<li>SSP coefficient <tt class=\"math\">\\mathcal{C} = 1</tt></li>\n</ul>\n</div>\n<div class=\"section\" id=\"note\">\n<h4>Note</h4>\n<p>Relevant when a block diagram wraps a method-of-lines discretisation of a\nhyperbolic PDE (e.g. shallow water, compressible Euler) inside an <tt class=\"docutils literal\">ODE</tt>\nblock and the spatial operator is TVD under forward Euler. For typical\nODE-based block diagrams without such structure, <tt class=\"docutils literal\">RK4</tt> or <tt class=\"docutils literal\">RKDP54</tt>\nare more appropriate choices.</p>\n<p><strong>References</strong></p>\n<table class=\"docutils footnote\" frame=\"void\" id=\"footnote-1\" rules=\"none\">\n<colgroup><col class=\"label\" /><col /></colgroup>\n<tbody valign=\"top\">\n<tr><td class=\"label\">[1]</td><td>Shu, C.-W., &amp; Osher, S. (1988). &quot;Efficient implementation of\nessentially non-oscillatory shock-capturing schemes&quot;. Journal of\nComputational Physics, 77(2), 439-471.\n:doi:`10.1016/0021-9991(88)90177-5`</td></tr>\n</tbody>\n</table>\n<table class=\"docutils footnote\" frame=\"void\" id=\"footnote-2\" rules=\"none\">\n<colgroup><col class=\"label\" /><col /></colgroup>\n<tbody valign=\"top\">\n<tr><td class=\"label\">[2]</td><td>Gottlieb, S., Shu, C.-W., &amp; Tadmor, E. (2001). &quot;Strong\nstability-preserving high-order time discretization methods&quot;.\nSIAM Review, 43(1), 89-112.\n:doi:`10.1137/S003614450036757X`</td></tr>\n</tbody>\n</table>\n</div>\n",
          "source": "class SSPRK22(ExplicitRungeKutta):\n    \"\"\"Two-stage, 2nd order Strong Stability Preserving (SSP) Runge-Kutta method.\n\n    Also known as Heun's method. SSP methods preserve monotonicity and total\n    variation diminishing (TVD) properties of the spatial discretisation under\n    a timestep restriction scaled by the SSP coefficient.\n\n    Characteristics\n    ---------------\n    * Order: 2\n    * Stages: 2\n    * Explicit, fixed timestep\n    * SSP coefficient :math:`\\\\mathcal{C} = 1`\n\n    Note\n    ----\n    Relevant when a block diagram wraps a method-of-lines discretisation of a\n    hyperbolic PDE (e.g. shallow water, compressible Euler) inside an ``ODE``\n    block and the spatial operator is TVD under forward Euler. For typical\n    ODE-based block diagrams without such structure, ``RK4`` or ``RKDP54``\n    are more appropriate choices.\n\n    References\n    ----------\n    .. [1] Shu, C.-W., & Osher, S. (1988). \"Efficient implementation of\n           essentially non-oscillatory shock-capturing schemes\". Journal of\n           Computational Physics, 77(2), 439-471.\n           :doi:`10.1016/0021-9991(88)90177-5`\n    .. [2] Gottlieb, S., Shu, C.-W., & Tadmor, E. (2001). \"Strong\n           stability-preserving high-order time discretization methods\".\n           SIAM Review, 43(1), 89-112.\n           :doi:`10.1137/S003614450036757X`\n\n    \"\"\"\n\n    def __init__(self, *solver_args, **solver_kwargs):\n        super().__init__(*solver_args, **solver_kwargs)\n\n        #number of stages in RK scheme\n        self.s = 2\n\n        #order of scheme\n        self.n = 2\n\n        #intermediate evaluation times\n        self.eval_stages = [0.0, 1.0]\n\n        #butcher table\n        self.BT = {\n            0: [1.0],\n            1: [1/2, 1/2]\n            }\n\n\n    def interpolate(self, r, dt):\n        k1, k2 = self.K[0], self.K[1]\n        b1, b2 = r*(2-r)/2, r**2/2\n        return self.x_0 + dt*(b1 * k1 + b2 * k2)",
          "bases": [
            "pathsim.solvers._rungekutta.ExplicitRungeKutta"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, *solver_args, **solver_kwargs):\n    super().__init__(*solver_args, **solver_kwargs)\n\n    #number of stages in RK scheme\n    self.s = 2\n\n    #order of scheme\n    self.n = 2\n\n    #intermediate evaluation times\n    self.eval_stages = [0.0, 1.0]\n\n    #butcher table\n    self.BT = {\n        0: [1.0],\n        1: [1/2, 1/2]\n        }",
              "signature": "(solver_args = (), solver_kwargs = {})",
              "parameters": [
                {
                  "name": "solver_args",
                  "type": null,
                  "default": "()",
                  "description": ""
                },
                {
                  "name": "solver_kwargs",
                  "type": null,
                  "default": "{}",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "interpolate",
              "description": "",
              "docstring_html": "",
              "source": "def interpolate(self, r, dt):\n    k1, k2 = self.K[0], self.K[1]\n    b1, b2 = r*(2-r)/2, r**2/2\n    return self.x_0 + dt*(b1 * k1 + b2 * k2)",
              "signature": "(r, dt)",
              "parameters": [
                {
                  "name": "r",
                  "type": null,
                  "default": null,
                  "description": ""
                },
                {
                  "name": "dt",
                  "type": null,
                  "default": null,
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "s",
              "description": "",
              "type": null,
              "value": "2"
            },
            {
              "name": "n",
              "description": "",
              "type": null,
              "value": "2"
            },
            {
              "name": "eval_stages",
              "description": "",
              "type": null,
              "value": "[0.0, 1.0]"
            },
            {
              "name": "BT",
              "description": "",
              "type": null,
              "value": "{0: [1.0], 1: [1 / 2, 1 / 2]}"
            }
          ],
          "parameters": [
            {
              "name": "solver_args",
              "type": null,
              "default": "()",
              "description": ""
            },
            {
              "name": "solver_kwargs",
              "type": null,
              "default": "{}",
              "description": ""
            }
          ]
        }
      ],
      "functions": []
    },
    "pathsim.solvers.ssprk33": {
      "name": "pathsim.solvers.ssprk33",
      "description": "",
      "docstring_html": "",
      "classes": [
        {
          "name": "SSPRK33",
          "description": "Three-stage, 3rd order optimal SSP Runge-Kutta method.",
          "docstring_html": "<p>Three-stage, 3rd order optimal SSP Runge-Kutta method.</p>\n<p>The unique optimal three-stage, 3rd order SSP scheme. Commonly paired\nwith WENO and ENO spatial discretisations for hyperbolic conservation\nlaws.</p>\n<div class=\"section\" id=\"characteristics\">\n<h4>Characteristics</h4>\n<ul class=\"simple\">\n<li>Order: 3</li>\n<li>Stages: 3</li>\n<li>Explicit, fixed timestep</li>\n<li>SSP coefficient <tt class=\"math\">\\mathcal{C} = 1</tt></li>\n</ul>\n</div>\n<div class=\"section\" id=\"note\">\n<h4>Note</h4>\n<p>The standard SSP time integrator for method-of-lines PDE discretisations\ninside <tt class=\"docutils literal\">ODE</tt> blocks. If the spatial operator is TVD under forward Euler,\nthis method preserves that property at the same timestep restriction.\nWhen stability is borderline, <tt class=\"docutils literal\">SSPRK34</tt> allows roughly twice the\ntimestep at the cost of one extra stage.</p>\n<p><strong>References</strong></p>\n<table class=\"docutils footnote\" frame=\"void\" id=\"footnote-1\" rules=\"none\">\n<colgroup><col class=\"label\" /><col /></colgroup>\n<tbody valign=\"top\">\n<tr><td class=\"label\">[1]</td><td>Shu, C.-W., &amp; Osher, S. (1988). &quot;Efficient implementation of\nessentially non-oscillatory shock-capturing schemes&quot;. Journal of\nComputational Physics, 77(2), 439-471.\n:doi:`10.1016/0021-9991(88)90177-5`</td></tr>\n</tbody>\n</table>\n<table class=\"docutils footnote\" frame=\"void\" id=\"footnote-2\" rules=\"none\">\n<colgroup><col class=\"label\" /><col /></colgroup>\n<tbody valign=\"top\">\n<tr><td class=\"label\">[2]</td><td>Gottlieb, S., Shu, C.-W., &amp; Tadmor, E. (2001). &quot;Strong\nstability-preserving high-order time discretization methods&quot;.\nSIAM Review, 43(1), 89-112.\n:doi:`10.1137/S003614450036757X`</td></tr>\n</tbody>\n</table>\n<table class=\"docutils footnote\" frame=\"void\" id=\"footnote-3\" rules=\"none\">\n<colgroup><col class=\"label\" /><col /></colgroup>\n<tbody valign=\"top\">\n<tr><td class=\"label\">[3]</td><td>Gottlieb, S., Ketcheson, D. I., &amp; Shu, C.-W. (2011). &quot;Strong\nStability Preserving Runge-Kutta and Multistep Time\nDiscretizations&quot;. World Scientific. :doi:`10.1142/7498`</td></tr>\n</tbody>\n</table>\n</div>\n",
          "source": "class SSPRK33(ExplicitRungeKutta):\n    \"\"\"Three-stage, 3rd order optimal SSP Runge-Kutta method.\n\n    The unique optimal three-stage, 3rd order SSP scheme. Commonly paired\n    with WENO and ENO spatial discretisations for hyperbolic conservation\n    laws.\n\n    Characteristics\n    ---------------\n    * Order: 3\n    * Stages: 3\n    * Explicit, fixed timestep\n    * SSP coefficient :math:`\\\\mathcal{C} = 1`\n\n    Note\n    ----\n    The standard SSP time integrator for method-of-lines PDE discretisations\n    inside ``ODE`` blocks. If the spatial operator is TVD under forward Euler,\n    this method preserves that property at the same timestep restriction.\n    When stability is borderline, ``SSPRK34`` allows roughly twice the\n    timestep at the cost of one extra stage.\n\n    References\n    ----------\n    .. [1] Shu, C.-W., & Osher, S. (1988). \"Efficient implementation of\n           essentially non-oscillatory shock-capturing schemes\". Journal of\n           Computational Physics, 77(2), 439-471.\n           :doi:`10.1016/0021-9991(88)90177-5`\n    .. [2] Gottlieb, S., Shu, C.-W., & Tadmor, E. (2001). \"Strong\n           stability-preserving high-order time discretization methods\".\n           SIAM Review, 43(1), 89-112.\n           :doi:`10.1137/S003614450036757X`\n    .. [3] Gottlieb, S., Ketcheson, D. I., & Shu, C.-W. (2011). \"Strong\n           Stability Preserving Runge-Kutta and Multistep Time\n           Discretizations\". World Scientific. :doi:`10.1142/7498`\n\n    \"\"\"\n\n    def __init__(self, *solver_args, **solver_kwargs):\n        super().__init__(*solver_args, **solver_kwargs)\n\n        #number of stages in RK scheme\n        self.s = 3\n\n        #order of scheme\n        self.n = 3\n\n        #intermediate evaluation times\n        self.eval_stages = [0.0, 1.0, 0.5]\n\n        #butcher table\n        self.BT = {\n            0: [1.0],\n            1: [1/4, 1/4],\n            2: [1/6, 1/6, 2/3]\n            }\n\n    def interpolate(self, r, dt):\n        k1, k2, k3 = self.K[0], self.K[1], self.K[2]\n        b1, b2, b3 = r*(2-r)**2/2, r**2*(3-2*r)/2, r**3\n        return self.x_0 + dt*(b1 * k1 + b2 * k2 + b3 * k3)",
          "bases": [
            "pathsim.solvers._rungekutta.ExplicitRungeKutta"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, *solver_args, **solver_kwargs):\n    super().__init__(*solver_args, **solver_kwargs)\n\n    #number of stages in RK scheme\n    self.s = 3\n\n    #order of scheme\n    self.n = 3\n\n    #intermediate evaluation times\n    self.eval_stages = [0.0, 1.0, 0.5]\n\n    #butcher table\n    self.BT = {\n        0: [1.0],\n        1: [1/4, 1/4],\n        2: [1/6, 1/6, 2/3]\n        }",
              "signature": "(solver_args = (), solver_kwargs = {})",
              "parameters": [
                {
                  "name": "solver_args",
                  "type": null,
                  "default": "()",
                  "description": ""
                },
                {
                  "name": "solver_kwargs",
                  "type": null,
                  "default": "{}",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "interpolate",
              "description": "",
              "docstring_html": "",
              "source": "def interpolate(self, r, dt):\n    k1, k2, k3 = self.K[0], self.K[1], self.K[2]\n    b1, b2, b3 = r*(2-r)**2/2, r**2*(3-2*r)/2, r**3\n    return self.x_0 + dt*(b1 * k1 + b2 * k2 + b3 * k3)",
              "signature": "(r, dt)",
              "parameters": [
                {
                  "name": "r",
                  "type": null,
                  "default": null,
                  "description": ""
                },
                {
                  "name": "dt",
                  "type": null,
                  "default": null,
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "s",
              "description": "",
              "type": null,
              "value": "3"
            },
            {
              "name": "n",
              "description": "",
              "type": null,
              "value": "3"
            },
            {
              "name": "eval_stages",
              "description": "",
              "type": null,
              "value": "[0.0, 1.0, 0.5]"
            },
            {
              "name": "BT",
              "description": "",
              "type": null,
              "value": "{0: [1.0], 1: [1 / 4, 1 / 4], 2: [1 / 6, 1 / 6, 2 / 3]}"
            }
          ],
          "parameters": [
            {
              "name": "solver_args",
              "type": null,
              "default": "()",
              "description": ""
            },
            {
              "name": "solver_kwargs",
              "type": null,
              "default": "{}",
              "description": ""
            }
          ]
        }
      ],
      "functions": []
    },
    "pathsim.solvers.ssprk34": {
      "name": "pathsim.solvers.ssprk34",
      "description": "",
      "docstring_html": "",
      "classes": [
        {
          "name": "SSPRK34",
          "description": "Four-stage, 3rd order SSP Runge-Kutta method with SSP coefficient 2.",
          "docstring_html": "<p>Four-stage, 3rd order SSP Runge-Kutta method with SSP coefficient 2.</p>\n<p>An extra stage compared to <tt class=\"docutils literal\">SSPRK33</tt> doubles the allowable SSP timestep\n(<tt class=\"math\">\\mathcal{C} = 2</tt>), giving a larger effective stability region\nalong the negative real axis.</p>\n<div class=\"section\" id=\"characteristics\">\n<h4>Characteristics</h4>\n<ul class=\"simple\">\n<li>Order: 3</li>\n<li>Stages: 4</li>\n<li>Explicit, fixed timestep</li>\n<li>SSP coefficient <tt class=\"math\">\\mathcal{C} = 2</tt></li>\n</ul>\n</div>\n<div class=\"section\" id=\"note\">\n<h4>Note</h4>\n<p>Preferable over <tt class=\"docutils literal\">SSPRK33</tt> when a method-of-lines <tt class=\"docutils literal\">ODE</tt> block is close\nto the SSP timestep limit and the cost of one additional stage per step is\nacceptable in exchange for a factor-of-two relaxation in the CFL\nconstraint.</p>\n<p><strong>References</strong></p>\n<table class=\"docutils footnote\" frame=\"void\" id=\"footnote-1\" rules=\"none\">\n<colgroup><col class=\"label\" /><col /></colgroup>\n<tbody valign=\"top\">\n<tr><td class=\"label\">[1]</td><td>Spiteri, R. J., &amp; Ruuth, S. J. (2002). &quot;A new class of optimal\nhigh-order strong-stability-preserving time discretization methods&quot;.\nSIAM Journal on Numerical Analysis, 40(2), 469-491.\n:doi:`10.1137/S0036142901389025`</td></tr>\n</tbody>\n</table>\n<table class=\"docutils footnote\" frame=\"void\" id=\"footnote-2\" rules=\"none\">\n<colgroup><col class=\"label\" /><col /></colgroup>\n<tbody valign=\"top\">\n<tr><td class=\"label\">[2]</td><td>Gottlieb, S., Ketcheson, D. I., &amp; Shu, C.-W. (2011). &quot;Strong\nStability Preserving Runge-Kutta and Multistep Time\nDiscretizations&quot;. World Scientific. :doi:`10.1142/7498`</td></tr>\n</tbody>\n</table>\n</div>\n",
          "source": "class SSPRK34(ExplicitRungeKutta):\n    \"\"\"Four-stage, 3rd order SSP Runge-Kutta method with SSP coefficient 2.\n\n    An extra stage compared to ``SSPRK33`` doubles the allowable SSP timestep\n    (:math:`\\\\mathcal{C} = 2`), giving a larger effective stability region\n    along the negative real axis.\n\n    Characteristics\n    ---------------\n    * Order: 3\n    * Stages: 4\n    * Explicit, fixed timestep\n    * SSP coefficient :math:`\\\\mathcal{C} = 2`\n\n    Note\n    ----\n    Preferable over ``SSPRK33`` when a method-of-lines ``ODE`` block is close\n    to the SSP timestep limit and the cost of one additional stage per step is\n    acceptable in exchange for a factor-of-two relaxation in the CFL\n    constraint.\n\n    References\n    ----------\n    .. [1] Spiteri, R. J., & Ruuth, S. J. (2002). \"A new class of optimal\n           high-order strong-stability-preserving time discretization methods\".\n           SIAM Journal on Numerical Analysis, 40(2), 469-491.\n           :doi:`10.1137/S0036142901389025`\n    .. [2] Gottlieb, S., Ketcheson, D. I., & Shu, C.-W. (2011). \"Strong\n           Stability Preserving Runge-Kutta and Multistep Time\n           Discretizations\". World Scientific. :doi:`10.1142/7498`\n\n    \"\"\"\n\n    def __init__(self, *solver_args, **solver_kwargs):\n        super().__init__(*solver_args, **solver_kwargs)\n\n        #number of stages in RK scheme\n        self.s = 4\n\n        #order of scheme\n        self.n = 3\n\n        #intermediate evaluation times\n        self.eval_stages = [0.0, 1/2, 1, 1/2]\n\n        #butcher table\n        self.BT = {\n            0: [1/2],\n            1: [1/2, 1/2],\n            2: [1/6, 1/6, 1/6],\n            3: [1/6, 1/6, 1/6, 1/2]\n            }",
          "bases": [
            "pathsim.solvers._rungekutta.ExplicitRungeKutta"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, *solver_args, **solver_kwargs):\n    super().__init__(*solver_args, **solver_kwargs)\n\n    #number of stages in RK scheme\n    self.s = 4\n\n    #order of scheme\n    self.n = 3\n\n    #intermediate evaluation times\n    self.eval_stages = [0.0, 1/2, 1, 1/2]\n\n    #butcher table\n    self.BT = {\n        0: [1/2],\n        1: [1/2, 1/2],\n        2: [1/6, 1/6, 1/6],\n        3: [1/6, 1/6, 1/6, 1/2]\n        }",
              "signature": "(solver_args = (), solver_kwargs = {})",
              "parameters": [
                {
                  "name": "solver_args",
                  "type": null,
                  "default": "()",
                  "description": ""
                },
                {
                  "name": "solver_kwargs",
                  "type": null,
                  "default": "{}",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "s",
              "description": "",
              "type": null,
              "value": "4"
            },
            {
              "name": "n",
              "description": "",
              "type": null,
              "value": "3"
            },
            {
              "name": "eval_stages",
              "description": "",
              "type": null,
              "value": "[0.0, 1 / 2, 1, 1 / 2]"
            },
            {
              "name": "BT",
              "description": "",
              "type": null,
              "value": "{0: [1 / 2], 1: [1 / 2, 1 / 2], 2: [1 / 6, 1 / 6, 1 / 6], 3: [1 / 6, 1 / 6, 1 / 6, 1 / 2]}"
            }
          ],
          "parameters": [
            {
              "name": "solver_args",
              "type": null,
              "default": "()",
              "description": ""
            },
            {
              "name": "solver_kwargs",
              "type": null,
              "default": "{}",
              "description": ""
            }
          ]
        }
      ],
      "functions": []
    },
    "pathsim.solvers.steadystate": {
      "name": "pathsim.solvers.steadystate",
      "description": "",
      "docstring_html": "",
      "classes": [
        {
          "name": "SteadyState",
          "description": "Pseudo-solver for computing the DC operating point (steady state).",
          "docstring_html": "<p>Pseudo-solver for computing the DC operating point (steady state).</p>\n<p>Solves <tt class=\"math\">f(x, u, t) = 0</tt> by iterating the fixed-point map\n<tt class=\"math\">x \\leftarrow x + f(x, u, t)</tt> using the internal optimizer\n(Newton-Anderson). Not a time-stepping method.</p>\n<div class=\"section\" id=\"characteristics\">\n<h4>Characteristics</h4>\n<ul class=\"simple\">\n<li>Purpose: find <tt class=\"math\">\\dot{x} = 0</tt></li>\n<li>Implicit (uses optimizer)</li>\n<li>No time integration</li>\n</ul>\n</div>\n<div class=\"section\" id=\"note\">\n<h4>Note</h4>\n<p>Used by <tt class=\"docutils literal\">Simulation.steady_state()</tt> to initialise block diagrams at\ntheir equilibrium before a transient run. Particularly useful when\ndynamic blocks (<tt class=\"docutils literal\">Integrator</tt>, <tt class=\"docutils literal\">ODE</tt>, <tt class=\"docutils literal\">LTI</tt>) have non-trivial\nequilibria that depend on the surrounding algebraic network.</p>\n</div>\n",
          "source": "class SteadyState(ImplicitSolver):\n    \"\"\"Pseudo-solver for computing the DC operating point (steady state).\n\n    Solves :math:`f(x, u, t) = 0` by iterating the fixed-point map\n    :math:`x \\\\leftarrow x + f(x, u, t)` using the internal optimizer\n    (Newton-Anderson). Not a time-stepping method.\n\n    Characteristics\n    ---------------\n    * Purpose: find :math:`\\\\dot{x} = 0`\n    * Implicit (uses optimizer)\n    * No time integration\n\n    Note\n    ----\n    Used by ``Simulation.steady_state()`` to initialise block diagrams at\n    their equilibrium before a transient run. Particularly useful when\n    dynamic blocks (``Integrator``, ``ODE``, ``LTI``) have non-trivial\n    equilibria that depend on the surrounding algebraic network.\n\n    \"\"\"\n\n    def solve(self, f, J, dt):\n        \"\"\"Solve for steady state by finding x where f(x,u,t) = 0\n        using the fixed point equation x = x + f(x,u,t).\n\n        Parameters\n        ----------\n        f : array_like\n            evaluation of function\n        J : array_like\n            evaluation of jacobian of function\n        dt : float \n            integration timestep\n\n        Returns\n        -------\n        err : float\n            residual error of the fixed point update equation\n        \"\"\"\n\n        #fixed point equation g(x) = x + f(x,u,t)\n        g = self.x + f\n\n        if J is not None:\n\n            #jacobian of g is I + df/dx\n            jac_g = np.eye(len(self.x)) + J\n\n            #optimizer step with block local jacobian\n            self.x, err = self.opt.step(self.x, g, jac_g)\n\n        else:\n\n            #optimizer step without jacobian\n            self.x, err = self.opt.step(self.x, g)\n\n        return err",
          "bases": [
            "pathsim.solvers._solver.ImplicitSolver"
          ],
          "methods": [
            {
              "name": "solve",
              "description": "Solve for steady state by finding x where f(x,u,t) = 0",
              "docstring_html": "<p>Solve for steady state by finding x where f(x,u,t) = 0\nusing the fixed point equation x = x + f(x,u,t).</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>f <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array_like</span></dt>\n<dd>evaluation of function</dd>\n<dt>J <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array_like</span></dt>\n<dd>evaluation of jacobian of function</dd>\n<dt>dt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>integration timestep</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>err <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>residual error of the fixed point update equation</dd>\n</dl>\n",
              "source": "def solve(self, f, J, dt):\n    \"\"\"Solve for steady state by finding x where f(x,u,t) = 0\n    using the fixed point equation x = x + f(x,u,t).\n\n    Parameters\n    ----------\n    f : array_like\n        evaluation of function\n    J : array_like\n        evaluation of jacobian of function\n    dt : float \n        integration timestep\n\n    Returns\n    -------\n    err : float\n        residual error of the fixed point update equation\n    \"\"\"\n\n    #fixed point equation g(x) = x + f(x,u,t)\n    g = self.x + f\n\n    if J is not None:\n\n        #jacobian of g is I + df/dx\n        jac_g = np.eye(len(self.x)) + J\n\n        #optimizer step with block local jacobian\n        self.x, err = self.opt.step(self.x, g, jac_g)\n\n    else:\n\n        #optimizer step without jacobian\n        self.x, err = self.opt.step(self.x, g)\n\n    return err",
              "signature": "(f, J, dt)",
              "parameters": [
                {
                  "name": "f",
                  "type": null,
                  "default": null,
                  "description": "evaluation of function"
                },
                {
                  "name": "J",
                  "type": null,
                  "default": null,
                  "description": "evaluation of jacobian of function"
                },
                {
                  "name": "dt",
                  "type": null,
                  "default": null,
                  "description": "integration timestep"
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [],
          "parameters": []
        }
      ],
      "functions": []
    },
    "pathsim.events._event": {
      "name": "pathsim.events._event",
      "description": "",
      "docstring_html": "",
      "classes": [
        {
          "name": "Event",
          "description": "This is the base class of the event handling system.",
          "docstring_html": "<p>This is the base class of the event handling system.</p>\n<p>Monitors system state by evaluating an event function (func_evt) with scalar output.</p>\n<pre class=\"code literal-block\">\nfunc_evt(time) -&gt; event?\n</pre>\n<p>If an event is detected, some action (func_act) is performed on the states of the blocks.</p>\n<pre class=\"code literal-block\">\nfunc_evt(time) == True -&gt; event -&gt; func_act(time)\n</pre>\n<p>The methods are structured such that event detection can be separated from event\nresolution. This is required for adaptive timestep solvers to approach the event\nand only resolve it when the event tolerance ('tolerance') is satisfied.</p>\n<p>If no action function (func_act) is specified, the event will only be detected but other\nthan that, no action will be triggered. For general state monitoring.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>func_evt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">callable</span></dt>\n<dd>event function, where zeros are events</dd>\n<dt>func_act <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">callable</span></dt>\n<dd>action function for event resolution</dd>\n<dt>tolerance <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>tolerance to check if detection is close to actual event</dd>\n</dl>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>_history <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">tuple[None, float], tuple[float, float], tuple[bool, float]</span></dt>\n<dd>history of event function evaluation after buffering</dd>\n<dt>_times <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">list[float]</span></dt>\n<dd>tracking the event times</dd>\n<dt>_active <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>flag that sets event active or inactive</dd>\n</dl>\n",
          "source": "class Event:\n    \"\"\"This is the base class of the event handling system.\n\n    Monitors system state by evaluating an event function (func_evt) with scalar output.\n\n    .. code-block::\n\n        func_evt(time) -> event?\n\n    If an event is detected, some action (func_act) is performed on the states of the blocks.\n\n    .. code-block::\n\n        func_evt(time) == True -> event -> func_act(time)\n\n    The methods are structured such that event detection can be separated from event \n    resolution. This is required for adaptive timestep solvers to approach the event \n    and only resolve it when the event tolerance ('tolerance') is satisfied.\n\n    If no action function (func_act) is specified, the event will only be detected but other \n    than that, no action will be triggered. For general state monitoring.    \n\n    Parameters\n    ----------\n    func_evt : callable\n        event function, where zeros are events\n    func_act : callable\n        action function for event resolution \n    tolerance : float\n        tolerance to check if detection is close to actual event\n\n    Attributes\n    ----------\n    _history : tuple[None, float], tuple[float, float], tuple[bool, float]\n        history of event function evaluation after buffering\n    _times : list[float]\n        tracking the event times\n    _active : bool\n        flag that sets event active or inactive\n    \"\"\"\n\n    def __init__(\n        self, \n        func_evt=None, \n        func_act=None, \n        tolerance=EVT_TOLERANCE\n        ):\n\n        #event detection function\n        self.func_evt = func_evt\n\n        #event action function -> event resolution (must not be callable)\n        self.func_act = func_act\n\n        #tolerance for checking if close to actual event\n        self.tolerance = tolerance\n\n        #event function evaluation and evaluation time history (eval, time)\n        self._history = None, 0.0\n\n        #recording the event times\n        self._times = []\n\n        #flag for active event checking\n        self._active = True\n\n\n    def __len__(self):\n        \"\"\"\n        Return the number of detected (or rather resolved) events.\n\n        Returns\n        -------\n        length : int\n            number of events detected\n\n        \"\"\"\n        return len(self._times)\n\n\n    def __iter__(self):\n        \"\"\"\n        Yields the recorded times at which events are detected.\n        \"\"\"\n        for t in self._times:\n            yield t\n\n\n    def __bool__(self):\n        return self._active\n\n\n    # external methods ------------------------------------------------------------------\n\n    def on(self): self._active = True\n    def off(self): self._active = False\n\n\n    def reset(self):\n        \"\"\"\n        Reset the recorded event times. Resetting the history is not \n        required because of the 'buffer' method. Reactivates event tracking.\n        \"\"\"\n        self._history = None, 0.0\n        self._times = []\n        self._active = True\n\n\n    def buffer(self, t):\n        \"\"\"Buffer the event function evaluation before the timestep is \n        taken and the evaluation time. \n\n        Parameters\n        ----------\n        t : float\n            evaluation time for buffering history\n        \"\"\"\n        if self.func_evt is not None:\n            self._history = self.func_evt(t), t\n\n\n    def estimate(self, t):\n        \"\"\"Estimate the time of the next event, based on history or internal schedule.\n\n        This improves simulation performance by estimating events before the simulation \n        step such that fewer steps have to be rejected for event location. \n\n        Parameters\n        ----------\n        t : float \n            evaluation time for estimation \n\n        Returns\n        -------\n        float | None\n            estimated time until next event\n        \"\"\"\n        return None\n\n\n    def detect(self, t):\n        \"\"\"Evaluate the event function and decide if an event has occurred. \n        Can also use the history of the event function evaluation from \n        before the timestep.\n\n        Notes\n        -----\n        This does nothing and needs to be implemented for specific events!!!\n\n        Parameters\n        ----------\n        t : float\n            evaluation time for detection \n\n        Returns\n        -------\n        detected : bool\n            was an event detected?\n        close : bool\n            are we close to the event?\n        ratio : float\n            interpolated event location as ratio of timestep\n        \"\"\"\n\n        return False, False, 1.0\n\n\n    def resolve(self, t):\n        \"\"\"Resolve the event and record the time (t) at which it occurs. \n\n        Resolves event using the action function (func_act) if it is defined. \n\n        Otherwise this just marks the location of the event in time.\n\n        Parameters\n        ----------\n        t : float\n            evaluation time for event resolution \n        \"\"\"\n\n        #save the time of event resolution\n        self._times.append(t)\n\n        #action function for event resolution\n        if self.func_act is not None:\n            self.func_act(t)",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(\n    self, \n    func_evt=None, \n    func_act=None, \n    tolerance=EVT_TOLERANCE\n    ):\n\n    #event detection function\n    self.func_evt = func_evt\n\n    #event action function -> event resolution (must not be callable)\n    self.func_act = func_act\n\n    #tolerance for checking if close to actual event\n    self.tolerance = tolerance\n\n    #event function evaluation and evaluation time history (eval, time)\n    self._history = None, 0.0\n\n    #recording the event times\n    self._times = []\n\n    #flag for active event checking\n    self._active = True",
              "signature": "(func_evt = None, func_act = None, tolerance = EVT_TOLERANCE)",
              "parameters": [
                {
                  "name": "func_evt",
                  "type": null,
                  "default": "None",
                  "description": ""
                },
                {
                  "name": "func_act",
                  "type": null,
                  "default": "None",
                  "description": ""
                },
                {
                  "name": "tolerance",
                  "type": null,
                  "default": "EVT_TOLERANCE",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "on",
              "description": "",
              "docstring_html": "",
              "source": "def on(self): self._active = True",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "off",
              "description": "",
              "docstring_html": "",
              "source": "def off(self): self._active = False",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "reset",
              "description": "Reset the recorded event times. Resetting the history is not",
              "docstring_html": "<p>Reset the recorded event times. Resetting the history is not\nrequired because of the 'buffer' method. Reactivates event tracking.</p>\n",
              "source": "def reset(self):\n    \"\"\"\n    Reset the recorded event times. Resetting the history is not \n    required because of the 'buffer' method. Reactivates event tracking.\n    \"\"\"\n    self._history = None, 0.0\n    self._times = []\n    self._active = True",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "buffer",
              "description": "Buffer the event function evaluation before the timestep is",
              "docstring_html": "<p>Buffer the event function evaluation before the timestep is\ntaken and the evaluation time.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time for buffering history</dd>\n</dl>\n",
              "source": "def buffer(self, t):\n    \"\"\"Buffer the event function evaluation before the timestep is \n    taken and the evaluation time. \n\n    Parameters\n    ----------\n    t : float\n        evaluation time for buffering history\n    \"\"\"\n    if self.func_evt is not None:\n        self._history = self.func_evt(t), t",
              "signature": "(t)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time for buffering history"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "estimate",
              "description": "Estimate the time of the next event, based on history or internal schedule.",
              "docstring_html": "<p>Estimate the time of the next event, based on history or internal schedule.</p>\n<p>This improves simulation performance by estimating events before the simulation\nstep such that fewer steps have to be rejected for event location.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time for estimation</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>float | None</dt>\n<dd>estimated time until next event</dd>\n</dl>\n",
              "source": "def estimate(self, t):\n    \"\"\"Estimate the time of the next event, based on history or internal schedule.\n\n    This improves simulation performance by estimating events before the simulation \n    step such that fewer steps have to be rejected for event location. \n\n    Parameters\n    ----------\n    t : float \n        evaluation time for estimation \n\n    Returns\n    -------\n    float | None\n        estimated time until next event\n    \"\"\"\n    return None",
              "signature": "(t)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time for estimation"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "detect",
              "description": "Evaluate the event function and decide if an event has occurred.",
              "docstring_html": "<p>Evaluate the event function and decide if an event has occurred.\nCan also use the history of the event function evaluation from\nbefore the timestep.</p>\n<p><strong>Notes</strong></p>\n<p>This does nothing and needs to be implemented for specific events!!!</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time for detection</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>detected <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>was an event detected?</dd>\n<dt>close <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>are we close to the event?</dd>\n<dt>ratio <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>interpolated event location as ratio of timestep</dd>\n</dl>\n",
              "source": "def detect(self, t):\n    \"\"\"Evaluate the event function and decide if an event has occurred. \n    Can also use the history of the event function evaluation from \n    before the timestep.\n\n    Notes\n    -----\n    This does nothing and needs to be implemented for specific events!!!\n\n    Parameters\n    ----------\n    t : float\n        evaluation time for detection \n\n    Returns\n    -------\n    detected : bool\n        was an event detected?\n    close : bool\n        are we close to the event?\n    ratio : float\n        interpolated event location as ratio of timestep\n    \"\"\"\n\n    return False, False, 1.0",
              "signature": "(t)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time for detection"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "resolve",
              "description": "Resolve the event and record the time (t) at which it occurs.",
              "docstring_html": "<p>Resolve the event and record the time (t) at which it occurs.</p>\n<p>Resolves event using the action function (func_act) if it is defined.</p>\n<p>Otherwise this just marks the location of the event in time.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time for event resolution</dd>\n</dl>\n",
              "source": "def resolve(self, t):\n    \"\"\"Resolve the event and record the time (t) at which it occurs. \n\n    Resolves event using the action function (func_act) if it is defined. \n\n    Otherwise this just marks the location of the event in time.\n\n    Parameters\n    ----------\n    t : float\n        evaluation time for event resolution \n    \"\"\"\n\n    #save the time of event resolution\n    self._times.append(t)\n\n    #action function for event resolution\n    if self.func_act is not None:\n        self.func_act(t)",
              "signature": "(t)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time for event resolution"
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "func_evt",
              "description": "",
              "type": null,
              "value": "func_evt"
            },
            {
              "name": "func_act",
              "description": "",
              "type": null,
              "value": "func_act"
            },
            {
              "name": "tolerance",
              "description": "",
              "type": null,
              "value": "tolerance"
            },
            {
              "name": "_history",
              "description": "",
              "type": null,
              "value": "(None, 0.0)"
            },
            {
              "name": "_times",
              "description": "",
              "type": null,
              "value": "[]"
            },
            {
              "name": "_active",
              "description": "",
              "type": null,
              "value": "True"
            }
          ],
          "parameters": [
            {
              "name": "func_evt",
              "type": null,
              "default": "None",
              "description": "event function, where zeros are events"
            },
            {
              "name": "func_act",
              "type": null,
              "default": "None",
              "description": "action function for event resolution"
            },
            {
              "name": "tolerance",
              "type": null,
              "default": "EVT_TOLERANCE",
              "description": "tolerance to check if detection is close to actual event"
            }
          ]
        }
      ],
      "functions": []
    },
    "pathsim.events.condition": {
      "name": "pathsim.events.condition",
      "description": "",
      "docstring_html": "",
      "classes": [
        {
          "name": "Condition",
          "description": "Subclass of base 'Event' that triggers if the event function evaluates to 'True',",
          "docstring_html": "<p>Subclass of base 'Event' that triggers if the event function evaluates to 'True',\ni.e. the condition is satisfied.</p>\n<p>Monitors system state by evaluating an event function (func_evt) with boolean output.\nThe event is considered detected when the event function evaluates to 'True' for the\nfirst time. Subsequent evaluations to 'True' are not considered unless the event is reset.</p>\n<pre class=\"code literal-block\">\nfunc_evt(time) -&gt; event?\n</pre>\n<p>If an event is detected, some action (func_act) is performed on the system state.</p>\n<pre class=\"code literal-block\">\nfunc_evt(time) == True -&gt; event -&gt; func_act(time)\n</pre>\n<div class=\"section\" id=\"note\">\n<h4>Note</h4>\n<p>Condition event functions evaluate to boolean and are therefore not smooth.\nTherefore uses bisection method for event location instead of secant method.</p>\n</div>\n<div class=\"section\" id=\"example\">\n<h4>Example</h4>\n<p>Initialize a conditional event handler like this:</p>\n<pre class=\"code python literal-block\">\n<span class=\"c1\">#define the event function</span><span class=\"w\">\n</span><span class=\"k\">def</span><span class=\"w\"> </span><span class=\"nf\">evt</span><span class=\"p\">(</span><span class=\"n\">t</span><span class=\"p\">):</span><span class=\"w\">\n</span>    <span class=\"k\">return</span> <span class=\"n\">t</span> <span class=\"o\">&gt;</span> <span class=\"mi\">10</span><span class=\"w\">\n\n</span><span class=\"c1\">#define the action function (callback)</span><span class=\"w\">\n</span><span class=\"k\">def</span><span class=\"w\"> </span><span class=\"nf\">act</span><span class=\"p\">(</span><span class=\"n\">t</span><span class=\"p\">):</span><span class=\"w\">\n</span>    <span class=\"c1\">#do something at event resolution</span><span class=\"w\">\n</span>    <span class=\"k\">pass</span><span class=\"w\">\n\n</span><span class=\"c1\">#initialize the event manager</span><span class=\"w\">\n</span><span class=\"n\">E</span> <span class=\"o\">=</span> <span class=\"n\">Condition</span><span class=\"p\">(</span><span class=\"w\">\n</span>    <span class=\"n\">func_evt</span><span class=\"o\">=</span><span class=\"n\">evt</span><span class=\"p\">,</span>  <span class=\"c1\">#the event function</span><span class=\"w\">\n</span>    <span class=\"n\">func_act</span><span class=\"o\">=</span><span class=\"n\">act</span>   <span class=\"c1\">#the action function</span><span class=\"w\">\n</span>    <span class=\"p\">)</span>\n</pre>\n</div>\n",
          "source": "class Condition(Event):\n    \"\"\"Subclass of base 'Event' that triggers if the event function evaluates to 'True', \n    i.e. the condition is satisfied.\n\n    Monitors system state by evaluating an event function (func_evt) with boolean output. \n    The event is considered detected when the event function evaluates to 'True' for the \n    first time. Subsequent evaluations to 'True' are not considered unless the event is reset.\n\n    .. code-block::\n\n        func_evt(time) -> event?\n\n    If an event is detected, some action (func_act) is performed on the system state.\n\n    .. code-block::\n\n        func_evt(time) == True -> event -> func_act(time)\n\n    Note\n    ----\n    Condition event functions evaluate to boolean and are therefore not smooth. \n    Therefore uses bisection method for event location instead of secant method.\n\n    Example\n    -------\n    Initialize a conditional event handler like this:\n\n    .. code-block:: python\n\n        #define the event function\n        def evt(t):\n            return t > 10\n\n        #define the action function (callback)\n        def act(t):\n            #do something at event resolution\n            pass\n\n        #initialize the event manager\n        E = Condition(\n            func_evt=evt,  #the event function\n            func_act=act   #the action function\n            )    \n\n    \"\"\"\n\n    def detect(self, t):\n        \"\"\"\n        Evaluate the event function and check if condition is satisfied. \n\n        The event function is not differentiable, so we use bisection to \n        narrow down its location to some tolerance.\n\n        Parameters\n        ----------\n        t : float\n            evaluation time for detection \n\n        Returns\n        -------\n        detected : bool\n            was an event detected?\n        close : bool\n            are we close to the event?\n        ratio : float\n            adjust timestep to locate event\n        \"\"\"\n\n        #unpack history\n        _result, _t = self._history\n\n        #evaluate event function\n        result = self.func_evt(t)\n\n        #check if interval narrowed down sufficiently\n        close = result and (t - _t) < self.tolerance\n\n        #close enough to event\n        if close: return True, True, 1.0\n\n        #half the stepsize to creep closer to event (bisection)\n        return result, False, 0.5\n\n\n    def resolve(self, t):\n        \"\"\"Resolve the event and record the time (t) at which it occurs. \n        Resolves event using the action function (func_act) if it is defined. \n\n        Deactivates the event tracking upon first resolution.\n\n        Parameters\n        ----------\n        t : float\n            evaluation time for event resolution \n        \"\"\"\n\n        #save the time of event resolution\n        self._times.append(t)\n\n        #action function for event resolution\n        if self.func_act is not None:\n            self.func_act(t)\n\n        #deactivate condition tracking\n        self.off()",
          "bases": [
            "pathsim.events._event.Event"
          ],
          "methods": [
            {
              "name": "detect",
              "description": "Evaluate the event function and check if condition is satisfied.",
              "docstring_html": "<p>Evaluate the event function and check if condition is satisfied.</p>\n<p>The event function is not differentiable, so we use bisection to\nnarrow down its location to some tolerance.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time for detection</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>detected <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>was an event detected?</dd>\n<dt>close <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>are we close to the event?</dd>\n<dt>ratio <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>adjust timestep to locate event</dd>\n</dl>\n",
              "source": "def detect(self, t):\n    \"\"\"\n    Evaluate the event function and check if condition is satisfied. \n\n    The event function is not differentiable, so we use bisection to \n    narrow down its location to some tolerance.\n\n    Parameters\n    ----------\n    t : float\n        evaluation time for detection \n\n    Returns\n    -------\n    detected : bool\n        was an event detected?\n    close : bool\n        are we close to the event?\n    ratio : float\n        adjust timestep to locate event\n    \"\"\"\n\n    #unpack history\n    _result, _t = self._history\n\n    #evaluate event function\n    result = self.func_evt(t)\n\n    #check if interval narrowed down sufficiently\n    close = result and (t - _t) < self.tolerance\n\n    #close enough to event\n    if close: return True, True, 1.0\n\n    #half the stepsize to creep closer to event (bisection)\n    return result, False, 0.5",
              "signature": "(t)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time for detection"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "resolve",
              "description": "Resolve the event and record the time (t) at which it occurs.",
              "docstring_html": "<p>Resolve the event and record the time (t) at which it occurs.\nResolves event using the action function (func_act) if it is defined.</p>\n<p>Deactivates the event tracking upon first resolution.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time for event resolution</dd>\n</dl>\n",
              "source": "def resolve(self, t):\n    \"\"\"Resolve the event and record the time (t) at which it occurs. \n    Resolves event using the action function (func_act) if it is defined. \n\n    Deactivates the event tracking upon first resolution.\n\n    Parameters\n    ----------\n    t : float\n        evaluation time for event resolution \n    \"\"\"\n\n    #save the time of event resolution\n    self._times.append(t)\n\n    #action function for event resolution\n    if self.func_act is not None:\n        self.func_act(t)\n\n    #deactivate condition tracking\n    self.off()",
              "signature": "(t)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time for event resolution"
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [],
          "parameters": []
        }
      ],
      "functions": []
    },
    "pathsim.events.schedule": {
      "name": "pathsim.events.schedule",
      "description": "",
      "docstring_html": "",
      "classes": [
        {
          "name": "Schedule",
          "description": "Subclass of base 'Event' that triggers dependent on the evaluation time.",
          "docstring_html": "<p>Subclass of base 'Event' that triggers dependent on the evaluation time.</p>\n<p>Monitors time in every timestep and triggers periodically (period). This event\ndoes not have an event function as the event condition only depends on time.</p>\n<pre class=\"code literal-block\">\ntime == next_schedule_time -&gt; event\n</pre>\n<div class=\"section\" id=\"example\">\n<h4>Example</h4>\n<p>Initialize a scheduled event handler like this:</p>\n<pre class=\"code python literal-block\">\n<span class=\"c1\">#define the action function (callback)</span><span class=\"w\">\n</span><span class=\"k\">def</span><span class=\"w\"> </span><span class=\"nf\">act</span><span class=\"p\">(</span><span class=\"n\">t</span><span class=\"p\">):</span><span class=\"w\">\n</span>    <span class=\"c1\">#do something at event resolution</span><span class=\"w\">\n</span>    <span class=\"k\">pass</span><span class=\"w\">\n\n</span><span class=\"c1\">#initialize the event manager</span><span class=\"w\">\n</span><span class=\"n\">E</span> <span class=\"o\">=</span> <span class=\"n\">Schedule</span><span class=\"p\">(</span><span class=\"w\">\n</span>    <span class=\"n\">t_start</span><span class=\"o\">=</span><span class=\"mi\">0</span><span class=\"p\">,</span>    <span class=\"c1\">#starting at t=0</span><span class=\"w\">\n</span>    <span class=\"n\">t_end</span><span class=\"o\">=</span><span class=\"kc\">None</span><span class=\"p\">,</span>   <span class=\"c1\">#never ending</span><span class=\"w\">\n</span>    <span class=\"n\">t_period</span><span class=\"o\">=</span><span class=\"mi\">3</span><span class=\"p\">,</span>   <span class=\"c1\">#triggering every 3 time units</span><span class=\"w\">\n</span>    <span class=\"n\">func_act</span><span class=\"o\">=</span><span class=\"n\">act</span>  <span class=\"c1\">#resulting in a callback</span><span class=\"w\">\n</span>    <span class=\"p\">)</span>\n</pre>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t_start <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>starting time for schedule</dd>\n<dt>t_end <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>termination time for schedule</dd>\n<dt>t_period <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>time period of schedule, when events are triggered</dd>\n<dt>func_act <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">callable</span></dt>\n<dd>action function for event resolution</dd>\n<dt>tolerance <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>tolerance to check if detection is close to actual event</dd>\n</dl>\n</div>\n",
          "source": "class Schedule(Event):\n    \"\"\"Subclass of base 'Event' that triggers dependent on the evaluation time. \n\n    Monitors time in every timestep and triggers periodically (period). This event\n    does not have an event function as the event condition only depends on time.\n\n    .. code-block::\n\n        time == next_schedule_time -> event\n\n    Example\n    -------\n    Initialize a scheduled event handler like this:\n\n    .. code-block:: python\n\n        #define the action function (callback)\n        def act(t):\n            #do something at event resolution\n            pass\n\n        #initialize the event manager\n        E = Schedule(\n            t_start=0,    #starting at t=0\n            t_end=None,   #never ending\n            t_period=3,   #triggering every 3 time units\n            func_act=act  #resulting in a callback\n            )   \n\n    Parameters\n    ----------\n    t_start : float\n        starting time for schedule\n    t_end : float\n        termination time for schedule\n    t_period : float\n        time period of schedule, when events are triggered\n    func_act : callable\n        action function for event resolution \n    tolerance : float\n        tolerance to check if detection is close to actual event\n    \"\"\"\n\n    def __init__(\n        self, \n        t_start=0, \n        t_end=None, \n        t_period=1, \n        func_act=None,      \n        tolerance=TOLERANCE\n        ):\n        super().__init__(None, func_act, tolerance)\n\n        #schedule times\n        self.t_start = t_start\n        self.t_period = t_period        \n        self.t_end = t_end\n\n\n    def _next(self):\n        \"\"\"\n        return the next period break\n        \"\"\"\n        return self.t_start + len(self._times) * self.t_period\n\n\n    def estimate(self, t):\n        \"\"\"Estimate the time until the next scheduled event.\n\n        Parameters\n        ----------\n        t : float \n            evaluation time for estimation \n\n        Returns\n        -------\n        float\n            estimated time until next event\n        \"\"\"\n        return self._next() - t\n\n\n    def buffer(self, t):\n        \"\"\"Buffer the current time to history\n\n        Parameters\n        ----------\n        t : float\n            buffer time\n        \"\"\"\n        self._history = None, t\n\n\n    def detect(self, t):\n        \"\"\"Check if the event condition is satisfied, i.e. if the \n        time period switch is within the current timestep.\n\n        Parameters\n        ----------\n        t : float\n            evaluation time for detection \n\n        Returns\n        -------\n        detected : bool\n            was an event detected?\n        close : bool\n            are we close to the event?\n        ratio : float\n            interpolated event location ratio in timestep\n        \"\"\"\n\n        #get next period break\n        t_next = self._next()\n\n        #end time reached? -> deactivate event, quit early\n        if self.t_end is not None and t_next > self.t_end:\n            self.off()\n            return False, False, 1.0\n\n        #no event -> quit early\n        if t_next > t:\n            return False, False, 1.0\n\n        #are we close enough to the scheduled event?\n        if abs(t_next - t) <= self.tolerance:\n            return True, True, 0.0 \n\n        #unpack history\n        _, _t = self._history\n\n        #have we already passed the event -> first timestep\n        if _t >= t_next:\n            return True, True, 0.0        \n\n        #whats the timestep ratio?\n        ratio = (t_next - _t) / np.clip(t - _t, TOLERANCE, None)\n\n        return True, False, ratio",
          "bases": [
            "pathsim.events._event.Event"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(\n    self, \n    t_start=0, \n    t_end=None, \n    t_period=1, \n    func_act=None,      \n    tolerance=TOLERANCE\n    ):\n    super().__init__(None, func_act, tolerance)\n\n    #schedule times\n    self.t_start = t_start\n    self.t_period = t_period        \n    self.t_end = t_end",
              "signature": "(t_start = 0, t_end = None, t_period = 1, func_act = None, tolerance = TOLERANCE)",
              "parameters": [
                {
                  "name": "t_start",
                  "type": null,
                  "default": "0",
                  "description": ""
                },
                {
                  "name": "t_end",
                  "type": null,
                  "default": "None",
                  "description": ""
                },
                {
                  "name": "t_period",
                  "type": null,
                  "default": "1",
                  "description": ""
                },
                {
                  "name": "func_act",
                  "type": null,
                  "default": "None",
                  "description": ""
                },
                {
                  "name": "tolerance",
                  "type": null,
                  "default": "TOLERANCE",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "_next",
              "description": "return the next period break",
              "docstring_html": "<p>return the next period break</p>\n",
              "source": "def _next(self):\n    \"\"\"\n    return the next period break\n    \"\"\"\n    return self.t_start + len(self._times) * self.t_period",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "estimate",
              "description": "Estimate the time until the next scheduled event.",
              "docstring_html": "<p>Estimate the time until the next scheduled event.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time for estimation</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>float</dt>\n<dd>estimated time until next event</dd>\n</dl>\n",
              "source": "def estimate(self, t):\n    \"\"\"Estimate the time until the next scheduled event.\n\n    Parameters\n    ----------\n    t : float \n        evaluation time for estimation \n\n    Returns\n    -------\n    float\n        estimated time until next event\n    \"\"\"\n    return self._next() - t",
              "signature": "(t)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time for estimation"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "buffer",
              "description": "Buffer the current time to history",
              "docstring_html": "<p>Buffer the current time to history</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>buffer time</dd>\n</dl>\n",
              "source": "def buffer(self, t):\n    \"\"\"Buffer the current time to history\n\n    Parameters\n    ----------\n    t : float\n        buffer time\n    \"\"\"\n    self._history = None, t",
              "signature": "(t)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "buffer time"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "detect",
              "description": "Check if the event condition is satisfied, i.e. if the",
              "docstring_html": "<p>Check if the event condition is satisfied, i.e. if the\ntime period switch is within the current timestep.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time for detection</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>detected <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>was an event detected?</dd>\n<dt>close <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>are we close to the event?</dd>\n<dt>ratio <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>interpolated event location ratio in timestep</dd>\n</dl>\n",
              "source": "def detect(self, t):\n    \"\"\"Check if the event condition is satisfied, i.e. if the \n    time period switch is within the current timestep.\n\n    Parameters\n    ----------\n    t : float\n        evaluation time for detection \n\n    Returns\n    -------\n    detected : bool\n        was an event detected?\n    close : bool\n        are we close to the event?\n    ratio : float\n        interpolated event location ratio in timestep\n    \"\"\"\n\n    #get next period break\n    t_next = self._next()\n\n    #end time reached? -> deactivate event, quit early\n    if self.t_end is not None and t_next > self.t_end:\n        self.off()\n        return False, False, 1.0\n\n    #no event -> quit early\n    if t_next > t:\n        return False, False, 1.0\n\n    #are we close enough to the scheduled event?\n    if abs(t_next - t) <= self.tolerance:\n        return True, True, 0.0 \n\n    #unpack history\n    _, _t = self._history\n\n    #have we already passed the event -> first timestep\n    if _t >= t_next:\n        return True, True, 0.0        \n\n    #whats the timestep ratio?\n    ratio = (t_next - _t) / np.clip(t - _t, TOLERANCE, None)\n\n    return True, False, ratio",
              "signature": "(t)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time for detection"
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "t_start",
              "description": "",
              "type": null,
              "value": "t_start"
            },
            {
              "name": "t_period",
              "description": "",
              "type": null,
              "value": "t_period"
            },
            {
              "name": "t_end",
              "description": "",
              "type": null,
              "value": "t_end"
            }
          ],
          "parameters": [
            {
              "name": "t_start",
              "type": null,
              "default": "0",
              "description": "starting time for schedule"
            },
            {
              "name": "t_end",
              "type": null,
              "default": "None",
              "description": "termination time for schedule"
            },
            {
              "name": "t_period",
              "type": null,
              "default": "1",
              "description": "time period of schedule, when events are triggered"
            },
            {
              "name": "func_act",
              "type": null,
              "default": "None",
              "description": "action function for event resolution"
            },
            {
              "name": "tolerance",
              "type": null,
              "default": "TOLERANCE",
              "description": "tolerance to check if detection is close to actual event"
            }
          ]
        },
        {
          "name": "ScheduleList",
          "description": "Subclass of base 'Schedule' that triggers dependent on the evaluation time.",
          "docstring_html": "<p>Subclass of base 'Schedule' that triggers dependent on the evaluation time.</p>\n<p>Monitors time in every timestep and triggers at the next event time from the\ntime list. This event does not have an event function as the event condition\nonly depends on time.</p>\n<pre class=\"code literal-block\">\ntime == next_scheduled_time -&gt; event\n</pre>\n<div class=\"section\" id=\"example\">\n<h4>Example</h4>\n<p>Initialize a scheduled event handler like this:</p>\n<pre class=\"code python literal-block\">\n<span class=\"c1\">#define the action function (callback)</span><span class=\"w\">\n</span><span class=\"k\">def</span><span class=\"w\"> </span><span class=\"nf\">act</span><span class=\"p\">(</span><span class=\"n\">t</span><span class=\"p\">):</span><span class=\"w\">\n</span>    <span class=\"c1\">#do something at event resolution</span><span class=\"w\">\n</span>    <span class=\"k\">pass</span><span class=\"w\">\n\n</span><span class=\"c1\">#initialize the event manager</span><span class=\"w\">\n</span><span class=\"n\">E</span> <span class=\"o\">=</span> <span class=\"n\">ScheduleList</span><span class=\"p\">(</span><span class=\"w\">\n</span>    <span class=\"n\">times_evt</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">5</span><span class=\"p\">,</span> <span class=\"mi\">12</span><span class=\"p\">,</span> <span class=\"mi\">300</span><span class=\"p\">],</span>  <span class=\"c1\">#event times where to trigger</span><span class=\"w\">\n</span>    <span class=\"n\">func_act</span><span class=\"o\">=</span><span class=\"n\">act</span>                <span class=\"c1\">#resulting in a callback</span><span class=\"w\">\n</span>    <span class=\"p\">)</span>\n</pre>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>times_evt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">list[float]</span></dt>\n<dd>list of event times in ascending order</dd>\n<dt>func_act <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">callable</span></dt>\n<dd>action function for event resolution</dd>\n<dt>tolerance <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>tolerance to check if detection is close to actual event</dd>\n</dl>\n</div>\n",
          "source": "class ScheduleList(Schedule):\n    \"\"\"Subclass of base 'Schedule' that triggers dependent on the evaluation time. \n\n    Monitors time in every timestep and triggers at the next event time from the \n    time list. This event does not have an event function as the event condition \n    only depends on time.\n\n    .. code-block::\n\n        time == next_scheduled_time -> event\n\n    Example\n    -------\n    Initialize a scheduled event handler like this:\n\n    .. code-block:: python\n\n        #define the action function (callback)\n        def act(t):\n            #do something at event resolution\n            pass\n\n        #initialize the event manager\n        E = ScheduleList(\n            times_evt=[1, 5, 12, 300],  #event times where to trigger\n            func_act=act                #resulting in a callback\n            )   \n\n    Parameters\n    ----------\n    times_evt : list[float]\n        list of event times in ascending order\n    func_act : callable\n        action function for event resolution \n    tolerance : float\n        tolerance to check if detection is close to actual event\n    \"\"\"\n\n    def __init__(\n        self, \n        times_evt, \n        func_act=None,      \n        tolerance=TOLERANCE\n        ):\n        super().__init__(t_start=None, func_act=func_act, tolerance=tolerance)\n\n        #input validation for times\n        if len(times_evt) > 1 and np.any(np.diff(times_evt) <= 0.0):\n            raise ValueError(\"'times_evt' need to be in ascending order!\")\n\n        #schedule times\n        self.times_evt = times_evt\n\n\n    def _next(self):\n        \"\"\"return the next event from the event time list by index\"\"\"\n        _n = len(self._times)\n        if _n < len(self.times_evt): \n            return self.times_evt[_n]\n        return self.times_evt[-1]\n\n\n    def detect(self, t):\n        \"\"\"Check if the event condition is satisfied, i.e. if the \n        time period switch is within the current timestep.\n\n        Parameters\n        ----------\n        t : float\n            evaluation time for detection \n\n        Returns\n        -------\n        detected : bool\n            was an event detected?\n        close : bool\n            are we close to the event?\n        ratio : float\n            interpolated event location ratio in timestep\n        \"\"\"\n\n        #check if out of bounds\n        _n = len(self._times)\n        if _n >= len(self.times_evt): \n            self.off()\n            return False, False, 1.0\n\n        #get next event time\n        t_next = self._next()\n\n        #no event -> quit early\n        if t_next > t:\n            return False, False, 1.0\n\n        #are we close enough to the scheduled event?\n        if abs(t_next - t) <= self.tolerance:\n            return True, True, 0.0 \n\n        #unpack history\n        _, _t = self._history\n\n        #have we already passed the event -> first timestep\n        if _t >= t_next:\n            return True, True, 0.0        \n\n        #whats the timestep ratio?\n        ratio = (t_next - _t) / np.clip(t - _t, TOLERANCE, None)\n\n        return True, False, ratio",
          "bases": [
            "pathsim.events.schedule.Schedule"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(\n    self, \n    times_evt, \n    func_act=None,      \n    tolerance=TOLERANCE\n    ):\n    super().__init__(t_start=None, func_act=func_act, tolerance=tolerance)\n\n    #input validation for times\n    if len(times_evt) > 1 and np.any(np.diff(times_evt) <= 0.0):\n        raise ValueError(\"'times_evt' need to be in ascending order!\")\n\n    #schedule times\n    self.times_evt = times_evt",
              "signature": "(times_evt, func_act = None, tolerance = TOLERANCE)",
              "parameters": [
                {
                  "name": "times_evt",
                  "type": null,
                  "default": null,
                  "description": ""
                },
                {
                  "name": "func_act",
                  "type": null,
                  "default": "None",
                  "description": ""
                },
                {
                  "name": "tolerance",
                  "type": null,
                  "default": "TOLERANCE",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "_next",
              "description": "return the next event from the event time list by index",
              "docstring_html": "<p>return the next event from the event time list by index</p>\n",
              "source": "def _next(self):\n    \"\"\"return the next event from the event time list by index\"\"\"\n    _n = len(self._times)\n    if _n < len(self.times_evt): \n        return self.times_evt[_n]\n    return self.times_evt[-1]",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "detect",
              "description": "Check if the event condition is satisfied, i.e. if the",
              "docstring_html": "<p>Check if the event condition is satisfied, i.e. if the\ntime period switch is within the current timestep.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time for detection</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>detected <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>was an event detected?</dd>\n<dt>close <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>are we close to the event?</dd>\n<dt>ratio <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>interpolated event location ratio in timestep</dd>\n</dl>\n",
              "source": "def detect(self, t):\n    \"\"\"Check if the event condition is satisfied, i.e. if the \n    time period switch is within the current timestep.\n\n    Parameters\n    ----------\n    t : float\n        evaluation time for detection \n\n    Returns\n    -------\n    detected : bool\n        was an event detected?\n    close : bool\n        are we close to the event?\n    ratio : float\n        interpolated event location ratio in timestep\n    \"\"\"\n\n    #check if out of bounds\n    _n = len(self._times)\n    if _n >= len(self.times_evt): \n        self.off()\n        return False, False, 1.0\n\n    #get next event time\n    t_next = self._next()\n\n    #no event -> quit early\n    if t_next > t:\n        return False, False, 1.0\n\n    #are we close enough to the scheduled event?\n    if abs(t_next - t) <= self.tolerance:\n        return True, True, 0.0 \n\n    #unpack history\n    _, _t = self._history\n\n    #have we already passed the event -> first timestep\n    if _t >= t_next:\n        return True, True, 0.0        \n\n    #whats the timestep ratio?\n    ratio = (t_next - _t) / np.clip(t - _t, TOLERANCE, None)\n\n    return True, False, ratio",
              "signature": "(t)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time for detection"
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "times_evt",
              "description": "",
              "type": null,
              "value": "times_evt"
            }
          ],
          "parameters": [
            {
              "name": "times_evt",
              "type": null,
              "default": null,
              "description": "list of event times in ascending order"
            },
            {
              "name": "func_act",
              "type": null,
              "default": "None",
              "description": "action function for event resolution"
            },
            {
              "name": "tolerance",
              "type": null,
              "default": "TOLERANCE",
              "description": "tolerance to check if detection is close to actual event"
            }
          ]
        }
      ],
      "functions": []
    },
    "pathsim.events.zerocrossing": {
      "name": "pathsim.events.zerocrossing",
      "description": "",
      "docstring_html": "",
      "classes": [
        {
          "name": "ZeroCrossing",
          "description": "Subclass of base 'Event' that triggers if the event function crosses zero.",
          "docstring_html": "<p>Subclass of base 'Event' that triggers if the event function crosses zero.\nThis is a bidirectional zero-crossing detector.</p>\n<p>Monitors system state by evaluating an event function (func_evt) with scalar output and\ntesting for zero crossings (sign changes).</p>\n<pre class=\"code literal-block\">\nfunc_evt(time) -&gt; event?\n</pre>\n<p>If an event is detected, some action (func_act) is performed on the system state.</p>\n<pre class=\"code literal-block\">\nfunc_evt(time) == 0 -&gt; event -&gt; func_act(time)\n</pre>\n<div class=\"section\" id=\"example\">\n<h4>Example</h4>\n<p>Initialize a zero-crossing event handler like this:</p>\n<pre class=\"code python literal-block\">\n<span class=\"c1\"># define the event function</span><span class=\"w\">\n</span><span class=\"k\">def</span><span class=\"w\"> </span><span class=\"nf\">evt</span><span class=\"p\">(</span><span class=\"n\">t</span><span class=\"p\">):</span><span class=\"w\">\n</span>    <span class=\"c1\"># here we have a zero-crossing at 't==10'</span><span class=\"w\">\n</span>    <span class=\"k\">return</span> <span class=\"n\">t</span> <span class=\"o\">-</span> <span class=\"mi\">10</span><span class=\"w\">\n\n</span><span class=\"c1\"># define the action function (callback)</span><span class=\"w\">\n</span><span class=\"k\">def</span><span class=\"w\"> </span><span class=\"nf\">act</span><span class=\"p\">(</span><span class=\"n\">t</span><span class=\"p\">):</span><span class=\"w\">\n</span>    <span class=\"c1\"># do something at event resolution</span><span class=\"w\">\n</span>    <span class=\"k\">pass</span><span class=\"w\">\n\n</span><span class=\"c1\"># initialize the event manager</span><span class=\"w\">\n</span><span class=\"n\">E</span> <span class=\"o\">=</span> <span class=\"n\">ZeroCrossing</span><span class=\"p\">(</span><span class=\"w\">\n</span>    <span class=\"n\">func_evt</span><span class=\"o\">=</span><span class=\"n\">evt</span><span class=\"p\">,</span>  <span class=\"c1\"># the event function</span><span class=\"w\">\n</span>    <span class=\"n\">func_act</span><span class=\"o\">=</span><span class=\"n\">act</span>   <span class=\"c1\"># the action function</span><span class=\"w\">\n</span>    <span class=\"p\">)</span>\n</pre>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>func_evt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">callable</span></dt>\n<dd>event function, where zeros are events</dd>\n<dt>func_act <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">callable</span></dt>\n<dd>action function for event resolution</dd>\n<dt>tolerance <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>tolerance to check if detection is close to actual event</dd>\n</dl>\n</div>\n",
          "source": "class ZeroCrossing(Event):\n    \"\"\"Subclass of base 'Event' that triggers if the event function crosses zero. \n    This is a bidirectional zero-crossing detector. \n\n    Monitors system state by evaluating an event function (func_evt) with scalar output and \n    testing for zero crossings (sign changes). \n\n    .. code-block::\n\n        func_evt(time) -> event?\n\n    If an event is detected, some action (func_act) is performed on the system state.\n\n    .. code-block::\n\n        func_evt(time) == 0 -> event -> func_act(time)\n\n    Example\n    -------\n    Initialize a zero-crossing event handler like this:\n\n    .. code-block:: python\n\n        # define the event function\n        def evt(t):\n            # here we have a zero-crossing at 't==10'\n            return t - 10\n\n        # define the action function (callback)\n        def act(t):\n            # do something at event resolution\n            pass\n\n        # initialize the event manager\n        E = ZeroCrossing(\n            func_evt=evt,  # the event function\n            func_act=act   # the action function\n            )    \n\n    Parameters\n    ----------\n    func_evt : callable\n        event function, where zeros are events\n    func_act : callable\n        action function for event resolution \n    tolerance : float\n        tolerance to check if detection is close to actual event\n    \"\"\"\n\n    def detect(self, t):\n        \"\"\"Evaluate the event function and check for zero-crossings\n\n        Parameters\n        ----------\n        t : float\n            evaluation time for detection \n\n        Returns\n        -------\n        detected : bool\n            was an event detected?\n        close : bool\n            are we close to the event?\n        ratio : float\n            interpolated event location as ratio of timestep\n        \"\"\"\n\n        # unpack history\n        _result, _t = self._history\n\n        # no history -> no zero crossing\n        if _result is None:\n            return False, False, 1.0\n\n        # evaluate event function\n        result = self.func_evt(t)\n\n        # exactly hit zero -> quit early\n        if result == 0.0 and _result != 0.0:\n            return True, True, 1.0\n\n        # are we close to the actual event?\n        close = abs(result) <= self.tolerance\n\n        # check for zero crossing (sign change, + to - and - to +)\n        is_event = np.sign(result * _result) < 0\n\n        # definitely no event detected -> quit early\n        if not is_event:\n            return False, False, 1.0\n\n        # linear interpolation to find event time ratio (secant crosses x-axis)\n        ratio = abs(_result) / np.clip(abs(_result - result), TOLERANCE, None)\n\n        # convert to scalar if needed to avoid numpy deprecation warning\n        if isinstance(ratio, np.ndarray):\n            ratio = ratio.item()\n\n        return True, close, float(ratio)",
          "bases": [
            "pathsim.events._event.Event"
          ],
          "methods": [
            {
              "name": "detect",
              "description": "Evaluate the event function and check for zero-crossings",
              "docstring_html": "<p>Evaluate the event function and check for zero-crossings</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time for detection</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>detected <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>was an event detected?</dd>\n<dt>close <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>are we close to the event?</dd>\n<dt>ratio <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>interpolated event location as ratio of timestep</dd>\n</dl>\n",
              "source": "def detect(self, t):\n    \"\"\"Evaluate the event function and check for zero-crossings\n\n    Parameters\n    ----------\n    t : float\n        evaluation time for detection \n\n    Returns\n    -------\n    detected : bool\n        was an event detected?\n    close : bool\n        are we close to the event?\n    ratio : float\n        interpolated event location as ratio of timestep\n    \"\"\"\n\n    # unpack history\n    _result, _t = self._history\n\n    # no history -> no zero crossing\n    if _result is None:\n        return False, False, 1.0\n\n    # evaluate event function\n    result = self.func_evt(t)\n\n    # exactly hit zero -> quit early\n    if result == 0.0 and _result != 0.0:\n        return True, True, 1.0\n\n    # are we close to the actual event?\n    close = abs(result) <= self.tolerance\n\n    # check for zero crossing (sign change, + to - and - to +)\n    is_event = np.sign(result * _result) < 0\n\n    # definitely no event detected -> quit early\n    if not is_event:\n        return False, False, 1.0\n\n    # linear interpolation to find event time ratio (secant crosses x-axis)\n    ratio = abs(_result) / np.clip(abs(_result - result), TOLERANCE, None)\n\n    # convert to scalar if needed to avoid numpy deprecation warning\n    if isinstance(ratio, np.ndarray):\n        ratio = ratio.item()\n\n    return True, close, float(ratio)",
              "signature": "(t)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time for detection"
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [],
          "parameters": []
        },
        {
          "name": "ZeroCrossingUp",
          "description": "Modification of standard 'ZeroCrossing' event where events are only triggered",
          "docstring_html": "<p>Modification of standard 'ZeroCrossing' event where events are only triggered\nif the event function changes sign from negative to positive (up). Also called\nunidirectional zero-crossing.</p>\n",
          "source": "class ZeroCrossingUp(Event):\n    \"\"\"Modification of standard 'ZeroCrossing' event where events are only triggered \n    if the event function changes sign from negative to positive (up). Also called\n    unidirectional zero-crossing.\n    \"\"\"\n\n    def detect(self, t):\n        \"\"\"Evaluate the event function and check for zero-crossings\n\n        Parameters\n        ----------\n        t : float\n            evaluation time for detection \n\n        Returns\n        -------\n        detected : bool\n            was an event detected?\n        close : bool\n            are we close to the event?\n        ratio : float\n            interpolated event location as ratio of timestep\n        \"\"\"\n\n        # evaluate event function\n        result = self.func_evt(t)\n\n        # unpack history\n        _result, _t = self._history\n\n        # no history -> no zero crossing\n        if _result is None:\n            return False, False, 1.0\n\n        # exactly hit zero -> quit early\n        if result == 0.0 and _result < 0.0:\n            return True, True, 1.0\n\n        # are we close to the actual event?\n        close = abs(result) <= self.tolerance\n\n        # check for zero crossing (sign change, negative to positive)\n        is_event = np.sign(result * _result) < 0 and result > _result\n\n        # no event detected or wrong direction -> quit early\n        if not is_event or _result >= 0:\n            return False, False, 1.0\n\n        # linear interpolation to find event time ratio (secant crosses x-axis)\n        ratio = abs(_result) / np.clip(abs(_result - result), TOLERANCE, None)\n\n        # convert to scalar if needed to avoid numpy deprecation warning\n        if isinstance(ratio, np.ndarray):\n            ratio = ratio.item()\n\n        return True, close, float(ratio)",
          "bases": [
            "pathsim.events._event.Event"
          ],
          "methods": [
            {
              "name": "detect",
              "description": "Evaluate the event function and check for zero-crossings",
              "docstring_html": "<p>Evaluate the event function and check for zero-crossings</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time for detection</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>detected <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>was an event detected?</dd>\n<dt>close <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>are we close to the event?</dd>\n<dt>ratio <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>interpolated event location as ratio of timestep</dd>\n</dl>\n",
              "source": "def detect(self, t):\n    \"\"\"Evaluate the event function and check for zero-crossings\n\n    Parameters\n    ----------\n    t : float\n        evaluation time for detection \n\n    Returns\n    -------\n    detected : bool\n        was an event detected?\n    close : bool\n        are we close to the event?\n    ratio : float\n        interpolated event location as ratio of timestep\n    \"\"\"\n\n    # evaluate event function\n    result = self.func_evt(t)\n\n    # unpack history\n    _result, _t = self._history\n\n    # no history -> no zero crossing\n    if _result is None:\n        return False, False, 1.0\n\n    # exactly hit zero -> quit early\n    if result == 0.0 and _result < 0.0:\n        return True, True, 1.0\n\n    # are we close to the actual event?\n    close = abs(result) <= self.tolerance\n\n    # check for zero crossing (sign change, negative to positive)\n    is_event = np.sign(result * _result) < 0 and result > _result\n\n    # no event detected or wrong direction -> quit early\n    if not is_event or _result >= 0:\n        return False, False, 1.0\n\n    # linear interpolation to find event time ratio (secant crosses x-axis)\n    ratio = abs(_result) / np.clip(abs(_result - result), TOLERANCE, None)\n\n    # convert to scalar if needed to avoid numpy deprecation warning\n    if isinstance(ratio, np.ndarray):\n        ratio = ratio.item()\n\n    return True, close, float(ratio)",
              "signature": "(t)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time for detection"
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [],
          "parameters": []
        },
        {
          "name": "ZeroCrossingDown",
          "description": "Modification of standard 'ZeroCrossing' event where events are only triggered",
          "docstring_html": "<p>Modification of standard 'ZeroCrossing' event where events are only triggered\nif the event function changes sign from positive to negative (down). Also called\nunidirectional zero-crossing.</p>\n",
          "source": "class ZeroCrossingDown(Event):\n    \"\"\"Modification of standard 'ZeroCrossing' event where events are only triggered \n    if the event function changes sign from positive to negative (down). Also called\n    unidirectional zero-crossing.\n    \"\"\"\n\n    def detect(self, t):\n        \"\"\"Evaluate the event function and check for zero-crossings\n\n        Parameters\n        ----------\n        t : float\n            evaluation time for detection \n\n        Returns\n        -------\n        detected : bool\n            was an event detected?\n        close : bool\n            are we close to the event?\n        ratio : float\n            interpolated event location as ratio of timestep\n        \"\"\"\n\n        # evaluate event function\n        result = self.func_evt(t)\n\n        # unpack history\n        _result, _t = self._history\n\n        # no history -> no zero crossing\n        if _result is None:\n            return False, False, 1.0\n\n        # exactly hit zero -> quit early\n        if result == 0.0 and _result > 0.0:\n            return True, True, 1.0\n\n        # are we close to the actual event?\n        close = abs(result) <= self.tolerance\n\n        # check for zero crossing (sign change, positive to negative)\n        is_event = np.sign(result * _result) < 0 and result < _result\n\n        # no event detected or wrong direction -> quit early\n        if not is_event or _result <= 0:\n            return False, False, 1.0\n\n        # linear interpolation to find event time ratio (secant crosses x-axis)\n        ratio = abs(_result) / np.clip(abs(_result - result), TOLERANCE, None)\n\n        # convert to scalar if needed to avoid numpy deprecation warning\n        if isinstance(ratio, np.ndarray):\n            ratio = ratio.item()\n\n        return True, close, float(ratio)",
          "bases": [
            "pathsim.events._event.Event"
          ],
          "methods": [
            {
              "name": "detect",
              "description": "Evaluate the event function and check for zero-crossings",
              "docstring_html": "<p>Evaluate the event function and check for zero-crossings</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>evaluation time for detection</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>detected <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>was an event detected?</dd>\n<dt>close <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>are we close to the event?</dd>\n<dt>ratio <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>interpolated event location as ratio of timestep</dd>\n</dl>\n",
              "source": "def detect(self, t):\n    \"\"\"Evaluate the event function and check for zero-crossings\n\n    Parameters\n    ----------\n    t : float\n        evaluation time for detection \n\n    Returns\n    -------\n    detected : bool\n        was an event detected?\n    close : bool\n        are we close to the event?\n    ratio : float\n        interpolated event location as ratio of timestep\n    \"\"\"\n\n    # evaluate event function\n    result = self.func_evt(t)\n\n    # unpack history\n    _result, _t = self._history\n\n    # no history -> no zero crossing\n    if _result is None:\n        return False, False, 1.0\n\n    # exactly hit zero -> quit early\n    if result == 0.0 and _result > 0.0:\n        return True, True, 1.0\n\n    # are we close to the actual event?\n    close = abs(result) <= self.tolerance\n\n    # check for zero crossing (sign change, positive to negative)\n    is_event = np.sign(result * _result) < 0 and result < _result\n\n    # no event detected or wrong direction -> quit early\n    if not is_event or _result <= 0:\n        return False, False, 1.0\n\n    # linear interpolation to find event time ratio (secant crosses x-axis)\n    ratio = abs(_result) / np.clip(abs(_result - result), TOLERANCE, None)\n\n    # convert to scalar if needed to avoid numpy deprecation warning\n    if isinstance(ratio, np.ndarray):\n        ratio = ratio.item()\n\n    return True, close, float(ratio)",
              "signature": "(t)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "evaluation time for detection"
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [],
          "parameters": []
        }
      ],
      "functions": []
    },
    "pathsim.optim.anderson": {
      "name": "pathsim.optim.anderson",
      "description": "",
      "docstring_html": "",
      "classes": [
        {
          "name": "Anderson",
          "description": "Anderson acceleration for fixed-point iteration.",
          "docstring_html": "<p>Anderson acceleration for fixed-point iteration.</p>\n<p>Solves nonlinear equations in fixed-point form <tt class=\"math\">x = g(x)</tt> by\ncomputing the next iterate as a linear combination of previous iterates\nwhose coefficients minimise the least-squares residual.</p>\n<pre class=\"math\">\nx_{k+1} = \\sum_{i=0}^{m_k} \\alpha_i^{(k)}\\, g(x_{k-m_k+i})\n\\quad\\text{with}\\quad\n\\alpha^{(k)} = \\arg\\min \\bigl\\|\\sum_i \\alpha_i\\, r_{k-m_k+i}\\bigr\\|\n</pre>\n<p>where <tt class=\"math\">r_k = g(x_k) - x_k</tt> and <tt class=\"math\">m_k \\le m</tt> is the current\nbuffer depth.</p>\n<p>In PathSim this class is the inner fixed-point solver used by the\nsimulation engine to resolve algebraic loops (cycles in the block\ndiagram). Each loop-closing <tt class=\"docutils literal\">ConnectionBooster</tt> owns an <tt class=\"docutils literal\">Anderson</tt>\ninstance that accelerates convergence of the fixed-point iteration\nover the loop. The buffer depth <tt class=\"docutils literal\">m</tt> controls how many previous\niterates are retained; larger values improve convergence on difficult\nloops at the cost of a small least-squares solve per iteration.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>m <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>buffer depth (number of stored iterates)</dd>\n<dt>restart <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>if True, clear the buffer once it reaches depth <tt class=\"docutils literal\">m</tt></dd>\n</dl>\n<p><strong>References</strong></p>\n<table class=\"docutils footnote\" frame=\"void\" id=\"footnote-1\" rules=\"none\">\n<colgroup><col class=\"label\" /><col /></colgroup>\n<tbody valign=\"top\">\n<tr><td class=\"label\">[1]</td><td>Anderson, D. G. (1965). &quot;Iterative Procedures for Nonlinear\nIntegral Equations&quot;. Journal of the ACM, 12(4), 547--560.\n:doi:`10.1145/321296.321305`</td></tr>\n</tbody>\n</table>\n<table class=\"docutils footnote\" frame=\"void\" id=\"footnote-2\" rules=\"none\">\n<colgroup><col class=\"label\" /><col /></colgroup>\n<tbody valign=\"top\">\n<tr><td class=\"label\">[2]</td><td>Walker, H. F., &amp; Ni, P. (2011). &quot;Anderson Acceleration for\nFixed-Point Iterations&quot;. SIAM Journal on Numerical Analysis,\n49(4), 1715--1735. :doi:`10.1137/10078356X`</td></tr>\n</tbody>\n</table>\n",
          "source": "class Anderson:\n    \"\"\"Anderson acceleration for fixed-point iteration.\n\n    Solves nonlinear equations in fixed-point form :math:`x = g(x)` by\n    computing the next iterate as a linear combination of previous iterates\n    whose coefficients minimise the least-squares residual.\n\n    .. math::\n\n        x_{k+1} = \\\\sum_{i=0}^{m_k} \\\\alpha_i^{(k)}\\\\, g(x_{k-m_k+i})\n        \\\\quad\\\\text{with}\\\\quad\n        \\\\alpha^{(k)} = \\\\arg\\\\min \\\\bigl\\\\|\\\\sum_i \\\\alpha_i\\\\, r_{k-m_k+i}\\\\bigr\\\\|\n\n    where :math:`r_k = g(x_k) - x_k` and :math:`m_k \\\\le m` is the current\n    buffer depth.\n\n    In PathSim this class is the inner fixed-point solver used by the\n    simulation engine to resolve algebraic loops (cycles in the block\n    diagram). Each loop-closing ``ConnectionBooster`` owns an ``Anderson``\n    instance that accelerates convergence of the fixed-point iteration\n    over the loop. The buffer depth ``m`` controls how many previous\n    iterates are retained; larger values improve convergence on difficult\n    loops at the cost of a small least-squares solve per iteration.\n\n    Parameters\n    ----------\n    m : int\n        buffer depth (number of stored iterates)\n    restart : bool\n        if True, clear the buffer once it reaches depth ``m``\n\n    References\n    ----------\n    .. [1] Anderson, D. G. (1965). \"Iterative Procedures for Nonlinear\n           Integral Equations\". Journal of the ACM, 12(4), 547--560.\n           :doi:`10.1145/321296.321305`\n    .. [2] Walker, H. F., & Ni, P. (2011). \"Anderson Acceleration for\n           Fixed-Point Iterations\". SIAM Journal on Numerical Analysis,\n           49(4), 1715--1735. :doi:`10.1137/10078356X`\n    \"\"\"\n\n    def __init__(self, m=OPT_HISTORY, restart=OPT_RESTART):\n\n        #length of buffer for next estimate\n        self.m = m\n\n        #restart after buffer length is reached?\n        self.restart = restart\n\n        #rolling difference buffers\n        self.dx_buffer = deque(maxlen=self.m)\n        self.dr_buffer = deque(maxlen=self.m)\n\n        #prvious values\n        self.x_prev = None\n        self.r_prev = None\n\n\n    def __bool__(self):\n        return True\n\n\n    def __len__(self):\n        return len(self.dx_buffer[0]) if self.dx_buffer else 0\n\n\n    def solve(self, func, x0, iterations_max=100, tolerance=1e-6):\n        \"\"\"Solve the function 'func' with initial \n        value 'x0' up to a certain tolerance.\n\n        Note\n        ----\n        This method is for testing purposes only and \n        not used in the simulation loop.\n\n        Parameters\n        ----------\n        func : callable\n            function to solve\n        x0 : numeric\n            starting value for solution\n        iterations_max : int\n            maximum number of solver iterations\n        tolerance : float\n            convergence condition\n\n        Returns\n        -------\n        x : numeric\n            solution\n        res : float\n            residual\n        i : int\n            iteration count\n        \"\"\"\n\n        _x = x0.copy()\n        for i in range(iterations_max):\n            _x, _res = self.step(_x, func(_x)+_x)\n            if _res < tolerance:\n                return _x, _res, i\n\n        raise RuntimeError(f\"did not converge in {iterations_max} steps\")\n\n\n    def reset(self):\n        \"\"\"reset the anderson accelerator\"\"\"\n\n        #clear difference buffers\n        self.dx_buffer.clear()\n        self.dr_buffer.clear()\n\n        #clear previous values\n        self.x_prev = None\n        self.r_prev = None\n\n\n    def step(self, x, g):\n        \"\"\"Perform one iteration on the fixed-point solution.\n\n        Parameters\n        ----------\n        x : float, array\n            current solution\n        g : float, array\n            current evaluation of g(x)\n\n        Returns\n        -------\n        x : float, array\n            new solution\n        res : float\n            residual norm, fixed point error\n        \"\"\"\n\n        #make numeric if value\n        _x = np.asarray(x).flatten()\n        _g = np.asarray(g).flatten()\n\n        #residual (this gets minimized)\n        _res = _g - _x\n\n        #fallback to regular fpi if 'm == 0'\n        if self.m == 0:\n            return _g, np.linalg.norm(_res)\n\n        #if no buffer, regular fixed-point update\n        if self.x_prev is None:\n\n            #save values for next iteration\n            self.x_prev = _x\n            self.r_prev = _res\n\n            return _g, np.linalg.norm(_res)\n\n        #append to difference buffer\n        self.dx_buffer.append(_x - self.x_prev)\n        self.dr_buffer.append(_res - self.r_prev)\n\n        #save values for next iteration\n        self.x_prev = _x\n        self.r_prev = _res\n\n        #if buffer size 'm' reached, restart\n        if self.restart and len(self.dx_buffer) >= self.m:\n            self.reset()\n            return _g, np.linalg.norm(_res)\n\n        #get difference matrices \n        dX = np.vstack(self.dx_buffer)\n        dR = np.vstack(self.dr_buffer)\n\n        #exit for scalar values (size-1 arrays after flatten)\n        if _res.size == 1:\n\n            #flatten to 1D for dot products\n            dR_flat = dR.flatten()\n            dX_flat = dX.flatten()\n\n            #delta squared norm\n            dR2 = np.dot(dR_flat, dR_flat)\n\n            #catch division by zero\n            if dR2 <= TOLERANCE:\n                return _g, abs(_res[0])\n\n            #new solution and residual\n            return _x - _res[0] * np.dot(dR_flat, dX_flat) / dR2, abs(_res[0])\n\n        #compute coefficients from least squares problem\n        C, *_ = np.linalg.lstsq(dR.T, _res, rcond=None)\n\n        #new solution and residual norm\n        return _x - C @ dX, np.linalg.norm(_res)",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, m=OPT_HISTORY, restart=OPT_RESTART):\n\n    #length of buffer for next estimate\n    self.m = m\n\n    #restart after buffer length is reached?\n    self.restart = restart\n\n    #rolling difference buffers\n    self.dx_buffer = deque(maxlen=self.m)\n    self.dr_buffer = deque(maxlen=self.m)\n\n    #prvious values\n    self.x_prev = None\n    self.r_prev = None",
              "signature": "(m = OPT_HISTORY, restart = OPT_RESTART)",
              "parameters": [
                {
                  "name": "m",
                  "type": null,
                  "default": "OPT_HISTORY",
                  "description": ""
                },
                {
                  "name": "restart",
                  "type": null,
                  "default": "OPT_RESTART",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "solve",
              "description": "Solve the function 'func' with initial",
              "docstring_html": "<p>Solve the function 'func' with initial\nvalue 'x0' up to a certain tolerance.</p>\n<div class=\"section\" id=\"note\">\n<h4>Note</h4>\n<p>This method is for testing purposes only and\nnot used in the simulation loop.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>func <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">callable</span></dt>\n<dd>function to solve</dd>\n<dt>x0 <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">numeric</span></dt>\n<dd>starting value for solution</dd>\n<dt>iterations_max <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>maximum number of solver iterations</dd>\n<dt>tolerance <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>convergence condition</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>x <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">numeric</span></dt>\n<dd>solution</dd>\n<dt>res <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>residual</dd>\n<dt>i <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>iteration count</dd>\n</dl>\n</div>\n",
              "source": "def solve(self, func, x0, iterations_max=100, tolerance=1e-6):\n    \"\"\"Solve the function 'func' with initial \n    value 'x0' up to a certain tolerance.\n\n    Note\n    ----\n    This method is for testing purposes only and \n    not used in the simulation loop.\n\n    Parameters\n    ----------\n    func : callable\n        function to solve\n    x0 : numeric\n        starting value for solution\n    iterations_max : int\n        maximum number of solver iterations\n    tolerance : float\n        convergence condition\n\n    Returns\n    -------\n    x : numeric\n        solution\n    res : float\n        residual\n    i : int\n        iteration count\n    \"\"\"\n\n    _x = x0.copy()\n    for i in range(iterations_max):\n        _x, _res = self.step(_x, func(_x)+_x)\n        if _res < tolerance:\n            return _x, _res, i\n\n    raise RuntimeError(f\"did not converge in {iterations_max} steps\")",
              "signature": "(func, x0, iterations_max = 100, tolerance = 1e-06)",
              "parameters": [
                {
                  "name": "func",
                  "type": null,
                  "default": null,
                  "description": "function to solve"
                },
                {
                  "name": "x0",
                  "type": null,
                  "default": null,
                  "description": "starting value for solution"
                },
                {
                  "name": "iterations_max",
                  "type": null,
                  "default": "100",
                  "description": "maximum number of solver iterations"
                },
                {
                  "name": "tolerance",
                  "type": null,
                  "default": "1e-06",
                  "description": "convergence condition"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "reset",
              "description": "reset the anderson accelerator",
              "docstring_html": "<p>reset the anderson accelerator</p>\n",
              "source": "def reset(self):\n    \"\"\"reset the anderson accelerator\"\"\"\n\n    #clear difference buffers\n    self.dx_buffer.clear()\n    self.dr_buffer.clear()\n\n    #clear previous values\n    self.x_prev = None\n    self.r_prev = None",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "step",
              "description": "Perform one iteration on the fixed-point solution.",
              "docstring_html": "<p>Perform one iteration on the fixed-point solution.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>x <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float, array</span></dt>\n<dd>current solution</dd>\n<dt>g <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float, array</span></dt>\n<dd>current evaluation of g(x)</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>x <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float, array</span></dt>\n<dd>new solution</dd>\n<dt>res <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>residual norm, fixed point error</dd>\n</dl>\n",
              "source": "def step(self, x, g):\n    \"\"\"Perform one iteration on the fixed-point solution.\n\n    Parameters\n    ----------\n    x : float, array\n        current solution\n    g : float, array\n        current evaluation of g(x)\n\n    Returns\n    -------\n    x : float, array\n        new solution\n    res : float\n        residual norm, fixed point error\n    \"\"\"\n\n    #make numeric if value\n    _x = np.asarray(x).flatten()\n    _g = np.asarray(g).flatten()\n\n    #residual (this gets minimized)\n    _res = _g - _x\n\n    #fallback to regular fpi if 'm == 0'\n    if self.m == 0:\n        return _g, np.linalg.norm(_res)\n\n    #if no buffer, regular fixed-point update\n    if self.x_prev is None:\n\n        #save values for next iteration\n        self.x_prev = _x\n        self.r_prev = _res\n\n        return _g, np.linalg.norm(_res)\n\n    #append to difference buffer\n    self.dx_buffer.append(_x - self.x_prev)\n    self.dr_buffer.append(_res - self.r_prev)\n\n    #save values for next iteration\n    self.x_prev = _x\n    self.r_prev = _res\n\n    #if buffer size 'm' reached, restart\n    if self.restart and len(self.dx_buffer) >= self.m:\n        self.reset()\n        return _g, np.linalg.norm(_res)\n\n    #get difference matrices \n    dX = np.vstack(self.dx_buffer)\n    dR = np.vstack(self.dr_buffer)\n\n    #exit for scalar values (size-1 arrays after flatten)\n    if _res.size == 1:\n\n        #flatten to 1D for dot products\n        dR_flat = dR.flatten()\n        dX_flat = dX.flatten()\n\n        #delta squared norm\n        dR2 = np.dot(dR_flat, dR_flat)\n\n        #catch division by zero\n        if dR2 <= TOLERANCE:\n            return _g, abs(_res[0])\n\n        #new solution and residual\n        return _x - _res[0] * np.dot(dR_flat, dX_flat) / dR2, abs(_res[0])\n\n    #compute coefficients from least squares problem\n    C, *_ = np.linalg.lstsq(dR.T, _res, rcond=None)\n\n    #new solution and residual norm\n    return _x - C @ dX, np.linalg.norm(_res)",
              "signature": "(x, g)",
              "parameters": [
                {
                  "name": "x",
                  "type": null,
                  "default": null,
                  "description": "current solution"
                },
                {
                  "name": "g",
                  "type": null,
                  "default": null,
                  "description": "current evaluation of g(x)"
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "m",
              "description": "",
              "type": null,
              "value": "m"
            },
            {
              "name": "restart",
              "description": "",
              "type": null,
              "value": "restart"
            },
            {
              "name": "dx_buffer",
              "description": "",
              "type": null,
              "value": "deque(maxlen=(self.m))"
            },
            {
              "name": "dr_buffer",
              "description": "",
              "type": null,
              "value": "deque(maxlen=(self.m))"
            },
            {
              "name": "x_prev",
              "description": "",
              "type": null,
              "value": "None"
            },
            {
              "name": "r_prev",
              "description": "",
              "type": null,
              "value": "None"
            }
          ],
          "parameters": [
            {
              "name": "m",
              "type": null,
              "default": "OPT_HISTORY",
              "description": "buffer depth (number of stored iterates)"
            },
            {
              "name": "restart",
              "type": null,
              "default": "OPT_RESTART",
              "description": "if True, clear the buffer once it reaches depth ``m``"
            }
          ]
        },
        {
          "name": "NewtonAnderson",
          "description": "Hybrid Newton--Anderson fixed-point solver.",
          "docstring_html": "<p>Hybrid Newton--Anderson fixed-point solver.</p>\n<p>Extends :class:`Anderson` by prepending a Newton step when a Jacobian\nof <tt class=\"math\">g</tt> is available.  The Newton step</p>\n<pre class=\"math\">\n\\tilde{x} = x - (J_g - I)^{-1}\\,(g(x) - x)\n</pre>\n<p>provides a quadratically convergent initial correction; the subsequent\nAnderson mixing step then stabilises the iteration and damps\noscillations.</p>\n<p>In PathSim this solver is used inside every implicit ODE integration\nengine (BDF, DIRK, ESDIRK).  When a block provides a local Jacobian\n(e.g. <tt class=\"docutils literal\">ODE</tt> or <tt class=\"docutils literal\">LTI</tt> blocks), the Newton pre-step yields much\nfaster convergence of the implicit update equation, reducing the\nnumber of fixed-point iterations per timestep.  Without a Jacobian the\nsolver falls back to pure Anderson acceleration.</p>\n<p><strong>References</strong></p>\n<table class=\"docutils footnote\" frame=\"void\" id=\"footnote-1\" rules=\"none\">\n<colgroup><col class=\"label\" /><col /></colgroup>\n<tbody valign=\"top\">\n<tr><td class=\"label\">[1]</td><td>Anderson, D. G. (1965). &quot;Iterative Procedures for Nonlinear\nIntegral Equations&quot;. Journal of the ACM, 12(4), 547--560.\n:doi:`10.1145/321296.321305`</td></tr>\n</tbody>\n</table>\n<table class=\"docutils footnote\" frame=\"void\" id=\"footnote-2\" rules=\"none\">\n<colgroup><col class=\"label\" /><col /></colgroup>\n<tbody valign=\"top\">\n<tr><td class=\"label\">[2]</td><td>Walker, H. F., &amp; Ni, P. (2011). &quot;Anderson Acceleration for\nFixed-Point Iterations&quot;. SIAM Journal on Numerical Analysis,\n49(4), 1715--1735. :doi:`10.1137/10078356X`</td></tr>\n</tbody>\n</table>\n",
          "source": "class NewtonAnderson(Anderson):\n    \"\"\"Hybrid Newton--Anderson fixed-point solver.\n\n    Extends :class:`Anderson` by prepending a Newton step when a Jacobian\n    of :math:`g` is available.  The Newton step\n\n    .. math::\n\n        \\\\tilde{x} = x - (J_g - I)^{-1}\\\\,(g(x) - x)\n\n    provides a quadratically convergent initial correction; the subsequent\n    Anderson mixing step then stabilises the iteration and damps\n    oscillations.\n\n    In PathSim this solver is used inside every implicit ODE integration\n    engine (BDF, DIRK, ESDIRK).  When a block provides a local Jacobian\n    (e.g. ``ODE`` or ``LTI`` blocks), the Newton pre-step yields much\n    faster convergence of the implicit update equation, reducing the\n    number of fixed-point iterations per timestep.  Without a Jacobian the\n    solver falls back to pure Anderson acceleration.\n\n    References\n    ----------\n    .. [1] Anderson, D. G. (1965). \"Iterative Procedures for Nonlinear\n           Integral Equations\". Journal of the ACM, 12(4), 547--560.\n           :doi:`10.1145/321296.321305`\n    .. [2] Walker, H. F., & Ni, P. (2011). \"Anderson Acceleration for\n           Fixed-Point Iterations\". SIAM Journal on Numerical Analysis,\n           49(4), 1715--1735. :doi:`10.1137/10078356X`\n    \"\"\"\n\n\n    def solve(self, func, x0, jac=None, iterations_max=100, tolerance=1e-6):\n        \"\"\"Solve the function 'func' with initial value \n        'x0' up to a certain tolerance.\n\n        Parameters\n        ----------\n        func : callable\n            function to solve\n        x0 : numeric\n            starting value for solution\n        jac : callable\n            jacobian of 'func'\n        iterations_max : int\n            maximum number of solver iterations\n        tolerance : float\n            convergence condition\n\n        Note\n        ----\n        This method is for testing purposes only and \n        not used in the simulation loop.\n\n        Returns\n        -------\n        x : numeric\n            solution\n        res : float\n            residual\n        i : int\n            iteration count\n        \"\"\"\n\n        _x = x0.copy()\n        for i in range(iterations_max):\n            _x, _res = self.step(_x, func(_x)+_x, None if jac is None else jac(_x))\n            if _res < tolerance:\n                return _x, _res, i\n\n        raise RuntimeError(f\"did not converge in {iterations_max} steps\")\n\n\n    def _newton(self, x, g, jac):\n        \"\"\"Newton step on solution, where 'f=g-x' is the \n        residual and 'jac' is the jacobian of 'g'.\n\n        Parameters\n        ----------\n        x : float, array\n            current solution\n        g : float, array\n            current evaluation of g(x)\n        jac : array\n            evaluation of jacobian of 'g'\n\n        Returns\n        -------\n        x : float, array\n            new solution\n        res : float\n            residual norm\n        \"\"\"\n\n        #preprocess formats\n        _x = np.asarray(x).flatten()\n        _g = np.asarray(g).flatten()\n\n        _jac = np.asarray(jac)\n\n        #compute residual\n        _res = _g - _x\n\n        #early exit for scalar or purely vectorial values\n        if _res.size == 1 or np.ndim(_jac) == 1:\n\n            return _x - _res / (_jac - 1.0), np.linalg.norm(_res)\n\n        #vectorial values (newton raphson)\n        return _x - np.linalg.solve(_jac - np.eye(len(_res)), _res), np.linalg.norm(_res)\n\n\n    def step(self, x, g, jac=None):\n        \"\"\"Perform one iteration on the fixed-point solution. \n\n        If the jacobian of g 'jac' is provided, a newton step \n        is performed previous to anderson acceleration.\n\n        Parameters\n        ----------\n        x : float, array\n            current solution\n        g : float, array\n            current evaluation of g(x)\n        jac : array\n            evaluation of jacobian of 'g'\n\n        Returns\n        -------\n        x : float, array\n            new solution\n        res : float\n            residual norm\n        \"\"\"\n\n        #newton step if jacobian available\n        if jac is None: \n\n            #regular anderson step with residual\n            return super().step(x, g)\n        else: \n            #newton step with residual\n            _x, res_norm = self._newton(x, g, jac)\n\n            #anderson step with no residual\n            y, _ = super().step(_x, g)\n\n            return y, res_norm",
          "bases": [
            "pathsim.optim.anderson.Anderson"
          ],
          "methods": [
            {
              "name": "solve",
              "description": "Solve the function 'func' with initial value",
              "docstring_html": "<p>Solve the function 'func' with initial value\n'x0' up to a certain tolerance.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>func <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">callable</span></dt>\n<dd>function to solve</dd>\n<dt>x0 <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">numeric</span></dt>\n<dd>starting value for solution</dd>\n<dt>jac <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">callable</span></dt>\n<dd>jacobian of 'func'</dd>\n<dt>iterations_max <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>maximum number of solver iterations</dd>\n<dt>tolerance <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>convergence condition</dd>\n</dl>\n<div class=\"section\" id=\"note\">\n<h4>Note</h4>\n<p>This method is for testing purposes only and\nnot used in the simulation loop.</p>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>x <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">numeric</span></dt>\n<dd>solution</dd>\n<dt>res <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>residual</dd>\n<dt>i <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>iteration count</dd>\n</dl>\n</div>\n",
              "source": "def solve(self, func, x0, jac=None, iterations_max=100, tolerance=1e-6):\n    \"\"\"Solve the function 'func' with initial value \n    'x0' up to a certain tolerance.\n\n    Parameters\n    ----------\n    func : callable\n        function to solve\n    x0 : numeric\n        starting value for solution\n    jac : callable\n        jacobian of 'func'\n    iterations_max : int\n        maximum number of solver iterations\n    tolerance : float\n        convergence condition\n\n    Note\n    ----\n    This method is for testing purposes only and \n    not used in the simulation loop.\n\n    Returns\n    -------\n    x : numeric\n        solution\n    res : float\n        residual\n    i : int\n        iteration count\n    \"\"\"\n\n    _x = x0.copy()\n    for i in range(iterations_max):\n        _x, _res = self.step(_x, func(_x)+_x, None if jac is None else jac(_x))\n        if _res < tolerance:\n            return _x, _res, i\n\n    raise RuntimeError(f\"did not converge in {iterations_max} steps\")",
              "signature": "(func, x0, jac = None, iterations_max = 100, tolerance = 1e-06)",
              "parameters": [
                {
                  "name": "func",
                  "type": null,
                  "default": null,
                  "description": "function to solve"
                },
                {
                  "name": "x0",
                  "type": null,
                  "default": null,
                  "description": "starting value for solution"
                },
                {
                  "name": "jac",
                  "type": null,
                  "default": "None",
                  "description": "jacobian of 'func'"
                },
                {
                  "name": "iterations_max",
                  "type": null,
                  "default": "100",
                  "description": "maximum number of solver iterations"
                },
                {
                  "name": "tolerance",
                  "type": null,
                  "default": "1e-06",
                  "description": "convergence condition"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "_newton",
              "description": "Newton step on solution, where 'f=g-x' is the",
              "docstring_html": "<p>Newton step on solution, where 'f=g-x' is the\nresidual and 'jac' is the jacobian of 'g'.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>x <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float, array</span></dt>\n<dd>current solution</dd>\n<dt>g <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float, array</span></dt>\n<dd>current evaluation of g(x)</dd>\n<dt>jac <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array</span></dt>\n<dd>evaluation of jacobian of 'g'</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>x <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float, array</span></dt>\n<dd>new solution</dd>\n<dt>res <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>residual norm</dd>\n</dl>\n",
              "source": "def _newton(self, x, g, jac):\n    \"\"\"Newton step on solution, where 'f=g-x' is the \n    residual and 'jac' is the jacobian of 'g'.\n\n    Parameters\n    ----------\n    x : float, array\n        current solution\n    g : float, array\n        current evaluation of g(x)\n    jac : array\n        evaluation of jacobian of 'g'\n\n    Returns\n    -------\n    x : float, array\n        new solution\n    res : float\n        residual norm\n    \"\"\"\n\n    #preprocess formats\n    _x = np.asarray(x).flatten()\n    _g = np.asarray(g).flatten()\n\n    _jac = np.asarray(jac)\n\n    #compute residual\n    _res = _g - _x\n\n    #early exit for scalar or purely vectorial values\n    if _res.size == 1 or np.ndim(_jac) == 1:\n\n        return _x - _res / (_jac - 1.0), np.linalg.norm(_res)\n\n    #vectorial values (newton raphson)\n    return _x - np.linalg.solve(_jac - np.eye(len(_res)), _res), np.linalg.norm(_res)",
              "signature": "(x, g, jac)",
              "parameters": [
                {
                  "name": "x",
                  "type": null,
                  "default": null,
                  "description": "current solution"
                },
                {
                  "name": "g",
                  "type": null,
                  "default": null,
                  "description": "current evaluation of g(x)"
                },
                {
                  "name": "jac",
                  "type": null,
                  "default": null,
                  "description": "evaluation of jacobian of 'g'"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "step",
              "description": "Perform one iteration on the fixed-point solution.",
              "docstring_html": "<p>Perform one iteration on the fixed-point solution.</p>\n<p>If the jacobian of g 'jac' is provided, a newton step\nis performed previous to anderson acceleration.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>x <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float, array</span></dt>\n<dd>current solution</dd>\n<dt>g <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float, array</span></dt>\n<dd>current evaluation of g(x)</dd>\n<dt>jac <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array</span></dt>\n<dd>evaluation of jacobian of 'g'</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>x <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float, array</span></dt>\n<dd>new solution</dd>\n<dt>res <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>residual norm</dd>\n</dl>\n",
              "source": "def step(self, x, g, jac=None):\n    \"\"\"Perform one iteration on the fixed-point solution. \n\n    If the jacobian of g 'jac' is provided, a newton step \n    is performed previous to anderson acceleration.\n\n    Parameters\n    ----------\n    x : float, array\n        current solution\n    g : float, array\n        current evaluation of g(x)\n    jac : array\n        evaluation of jacobian of 'g'\n\n    Returns\n    -------\n    x : float, array\n        new solution\n    res : float\n        residual norm\n    \"\"\"\n\n    #newton step if jacobian available\n    if jac is None: \n\n        #regular anderson step with residual\n        return super().step(x, g)\n    else: \n        #newton step with residual\n        _x, res_norm = self._newton(x, g, jac)\n\n        #anderson step with no residual\n        y, _ = super().step(_x, g)\n\n        return y, res_norm",
              "signature": "(x, g, jac = None)",
              "parameters": [
                {
                  "name": "x",
                  "type": null,
                  "default": null,
                  "description": "current solution"
                },
                {
                  "name": "g",
                  "type": null,
                  "default": null,
                  "description": "current evaluation of g(x)"
                },
                {
                  "name": "jac",
                  "type": null,
                  "default": "None",
                  "description": "evaluation of jacobian of 'g'"
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [],
          "parameters": []
        }
      ],
      "functions": []
    },
    "pathsim.optim.booster": {
      "name": "pathsim.optim.booster",
      "description": "",
      "docstring_html": "",
      "classes": [
        {
          "name": "ConnectionBooster",
          "description": "Wraps a `Connection` instance and injects a fixed point accelerator.",
          "docstring_html": "<p>Wraps a <cite>Connection</cite> instance and injects a fixed point accelerator.</p>\n<p>This class is part of the solver structure and intended to improve the\nalgebraic loop solver of the simulation.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>connection <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">Connection</span></dt>\n<dd>connection instance to be boosted with an algebraic loop accelerator</dd>\n</dl>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>accelerator <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">Anderson</span></dt>\n<dd>internal fixed point accelerator instance</dd>\n<dt>history <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float | int | array_like</span></dt>\n<dd>history, previous evaliation of the connection value</dd>\n</dl>\n",
          "source": "class ConnectionBooster:\n    \"\"\"Wraps a `Connection` instance and injects a fixed point accelerator. \n\n    This class is part of the solver structure and intended to improve the \n    algebraic loop solver of the simulation.\n\n    Parameters\n    ----------\n    connection : Connection\n        connection instance to be boosted with an algebraic loop accelerator\n\n    Attributes\n    ----------\n    accelerator : Anderson\n        internal fixed point accelerator instance\n    history : float | int | array_like\n        history, previous evaliation of the connection value\n    \"\"\"\n\n    def __init__(self, connection):\n        self.connection = connection\n        self.history = self.get()\n\n        # initialize optimizer (default args)\n        self.accelerator = Anderson()\n\n\n    def __bool__(self):\n        return len(self.connections) > 0\n\n\n    def get(self):\n        \"\"\"Return the output values of the source block that is referenced in \n        the connection.\n\n        Return \n        ------\n        out : float | int | array_like\n            output values of source, referenced in connection\n        \"\"\"\n        return self.connection.source.get_outputs()\n\n\n    def set(self, val): \n        \"\"\"Set targets input values.\n\n        Parameters\n        ----------\n        val : float | int | array_like\n            input values to set at inputs of the targets, referenced by the \n            connection\n\n        \"\"\"\n        for trg in self.connection.targets:\n            trg.set_inputs(val)\n\n\n    def reset(self):\n        \"\"\"Reset the internal fixed point accelerator and update the history \n        to the most recent value\n        \"\"\"\n        self.accelerator.reset()\n        self.history = self.get()\n\n\n    def update(self):\n        \"\"\"Wraps the `Connection.update` method for data transfer from source \n        to targets and injects a solver step of the fixed point accelerator, \n        updates the history required for the next solver step, returns the \n        fixed point residual.\n\n        Returns\n        -------\n        res : float\n            fixed point residual of internal lixed point accelerator\n        \"\"\"\n        _val, res = self.accelerator.step(self.history, self.get())\n        self.set(_val)\n        self.history = _val\n        return res",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, connection):\n    self.connection = connection\n    self.history = self.get()\n\n    # initialize optimizer (default args)\n    self.accelerator = Anderson()",
              "signature": "(connection)",
              "parameters": [
                {
                  "name": "connection",
                  "type": null,
                  "default": null,
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "get",
              "description": "Return the output values of the source block that is referenced in",
              "docstring_html": "<p>Return the output values of the source block that is referenced in\nthe connection.</p>\n<div class=\"section\" id=\"return\">\n<h4>Return</h4>\n<dl class=\"docutils\">\n<dt>out <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float | int | array_like</span></dt>\n<dd>output values of source, referenced in connection</dd>\n</dl>\n</div>\n",
              "source": "def get(self):\n    \"\"\"Return the output values of the source block that is referenced in \n    the connection.\n\n    Return \n    ------\n    out : float | int | array_like\n        output values of source, referenced in connection\n    \"\"\"\n    return self.connection.source.get_outputs()",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "set",
              "description": "Set targets input values.",
              "docstring_html": "<p>Set targets input values.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>val <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float | int | array_like</span></dt>\n<dd>input values to set at inputs of the targets, referenced by the\nconnection</dd>\n</dl>\n",
              "source": "def set(self, val): \n    \"\"\"Set targets input values.\n\n    Parameters\n    ----------\n    val : float | int | array_like\n        input values to set at inputs of the targets, referenced by the \n        connection\n\n    \"\"\"\n    for trg in self.connection.targets:\n        trg.set_inputs(val)",
              "signature": "(val)",
              "parameters": [
                {
                  "name": "val",
                  "type": null,
                  "default": null,
                  "description": "input values to set at inputs of the targets, referenced by the connection"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "reset",
              "description": "Reset the internal fixed point accelerator and update the history",
              "docstring_html": "<p>Reset the internal fixed point accelerator and update the history\nto the most recent value</p>\n",
              "source": "def reset(self):\n    \"\"\"Reset the internal fixed point accelerator and update the history \n    to the most recent value\n    \"\"\"\n    self.accelerator.reset()\n    self.history = self.get()",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "update",
              "description": "Wraps the `Connection.update` method for data transfer from source",
              "docstring_html": "<p>Wraps the <cite>Connection.update</cite> method for data transfer from source\nto targets and injects a solver step of the fixed point accelerator,\nupdates the history required for the next solver step, returns the\nfixed point residual.</p>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>res <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>fixed point residual of internal lixed point accelerator</dd>\n</dl>\n",
              "source": "def update(self):\n    \"\"\"Wraps the `Connection.update` method for data transfer from source \n    to targets and injects a solver step of the fixed point accelerator, \n    updates the history required for the next solver step, returns the \n    fixed point residual.\n\n    Returns\n    -------\n    res : float\n        fixed point residual of internal lixed point accelerator\n    \"\"\"\n    _val, res = self.accelerator.step(self.history, self.get())\n    self.set(_val)\n    self.history = _val\n    return res",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "connection",
              "description": "",
              "type": null,
              "value": "connection"
            },
            {
              "name": "history",
              "description": "",
              "type": null,
              "value": "self.get()"
            },
            {
              "name": "accelerator",
              "description": "",
              "type": null,
              "value": "Anderson()"
            }
          ],
          "parameters": [
            {
              "name": "connection",
              "type": null,
              "default": null,
              "description": "connection instance to be boosted with an algebraic loop accelerator"
            }
          ]
        }
      ],
      "functions": []
    },
    "pathsim.optim.numerical": {
      "name": "pathsim.optim.numerical",
      "description": "",
      "docstring_html": "",
      "classes": [],
      "functions": [
        {
          "name": "num_jac",
          "description": "Numerically computes the jacobian of the function 'func'",
          "docstring_html": "<p>Numerically computes the jacobian of the function 'func'\nby central differences.</p>\n<p>The stepsize 'h' is adaptively computed as a relative perturbation\n'r' with a small offset to avoid division by zero.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>func <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">callable</span></dt>\n<dd>function to compute jacobian for</dd>\n<dt>x <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float, array[float]</span></dt>\n<dd>value for function at which the jacobian is evaluated</dd>\n<dt>r <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>relative perturbation</dd>\n<dt>tol <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>tolerance for division by zero clipping</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>jac <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array[array[float]]</span></dt>\n<dd>2d jacobian array</dd>\n</dl>\n",
          "source": "def num_jac(func, x, r=1e-3, tol=TOLERANCE):\n    \"\"\"Numerically computes the jacobian of the function 'func' \n    by central differences. \n\n    The stepsize 'h' is adaptively computed as a relative perturbation \n    'r' with a small offset to avoid division by zero.\n\n    Parameters\n    ----------\n    func : callable\n        function to compute jacobian for\n    x : float, array[float] \n        value for function at which the jacobian is evaluated\n    r : float\n        relative perturbation\n    tol : float\n        tolerance for division by zero clipping\n\n    Returns\n    -------\n    jac : array[array[float]]\n        2d jacobian array\n    \"\"\"\n\n    #stepsize relative to value with clipping\n    H = np.clip(abs(r*x), tol, None)\n\n    #catch scalar case (gradient)\n    if np.isscalar(x):\n        return 0.5 * (func(x + H) - func(x - H)) / H\n\n    #perturbation matrix and jacobian\n    return 0.5 * np.array(\n        [(func(x + hv) - func(x - hv)) / h \n            for hv, h in zip(np.diag(H), H)]\n        ).T",
          "signature": "(func, x, r = 0.001, tol = TOLERANCE)",
          "parameters": [
            {
              "name": "func",
              "type": null,
              "default": null,
              "description": "function to compute jacobian for"
            },
            {
              "name": "x",
              "type": null,
              "default": null,
              "description": "value for function at which the jacobian is evaluated"
            },
            {
              "name": "r",
              "type": null,
              "default": "0.001",
              "description": "relative perturbation"
            },
            {
              "name": "tol",
              "type": null,
              "default": "TOLERANCE",
              "description": "tolerance for division by zero clipping"
            }
          ],
          "returns": null
        },
        {
          "name": "num_autojac",
          "description": "Wraps a function object such that it computes the jacobian",
          "docstring_html": "<p>Wraps a function object such that it computes the jacobian\nof the function with respect to the first argument.</p>\n<p>This is intended to compute the jacobian 'jac(x, u, t)' of\nthe right hand side function 'func(x, u, t)' of numerical\nintegrators with respect to 'x'.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>func <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">callable</span></dt>\n<dd>function to wrap for jacobian</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>wrap_func <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">callable</span></dt>\n<dd>wrapped funtion as numerical jacobian of 'func'</dd>\n</dl>\n",
          "source": "def num_autojac(func):\n    \"\"\"Wraps a function object such that it computes the jacobian \n    of the function with respect to the first argument.\n\n    This is intended to compute the jacobian 'jac(x, u, t)' of \n    the right hand side function 'func(x, u, t)' of numerical \n    integrators with respect to 'x'.\n\n    Parameters\n    ----------\n    func : callable\n        function to wrap for jacobian \n\n    Returns\n    -------\n    wrap_func : callable\n        wrapped funtion as numerical jacobian of 'func'\n    \"\"\"\n    def wrap_func(*args):\n        _x, *_args = args\n        return num_jac(lambda x: func(x, *_args), _x)\n    return wrap_func",
          "signature": "(func)",
          "parameters": [
            {
              "name": "func",
              "type": null,
              "default": null,
              "description": "function to wrap for jacobian"
            }
          ],
          "returns": null
        }
      ]
    },
    "pathsim.optim.operator": {
      "name": "pathsim.optim.operator",
      "description": "",
      "docstring_html": "",
      "classes": [
        {
          "name": "Operator",
          "description": "Operator class for function evaluation and linearization.",
          "docstring_html": "<p>Operator class for function evaluation and linearization.</p>\n<p>This class wraps a function to provide both direct evaluation and linear approximation\ncapabilities. When linearized around a point x0, subsequent calls use the first-order\nTaylor approximation</p>\n<pre class=\"math\">\nf(x) \\approx f(x_0) + \\mathbf{J}(x_0) (x - x_0)\n</pre>\n<p>instead of evaluating the function.</p>\n<p>The class supports multiple methods for Jacobian computation: user-provided analytical\nJacobians, automatic differentiation via the Value class, and numerical differentiation\nas a fallback.</p>\n<div class=\"section\" id=\"example\">\n<h4>Example</h4>\n<p>Basic usage with automatic differentiation:</p>\n<pre class=\"code python literal-block\">\n<span class=\"k\">def</span><span class=\"w\"> </span><span class=\"nf\">f</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">):</span><span class=\"w\">\n</span>    <span class=\"k\">return</span> <span class=\"n\">x</span><span class=\"o\">**</span><span class=\"mi\">2</span> <span class=\"o\">+</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">sin</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span><span class=\"w\">\n\n</span><span class=\"n\">op</span> <span class=\"o\">=</span> <span class=\"n\">Operator</span><span class=\"p\">(</span><span class=\"n\">f</span><span class=\"p\">)</span><span class=\"w\">\n\n</span><span class=\"c1\"># Direct function evaluation</span><span class=\"w\">\n</span><span class=\"n\">y1</span> <span class=\"o\">=</span> <span class=\"n\">op</span><span class=\"p\">(</span><span class=\"mf\">2.0</span><span class=\"p\">)</span><span class=\"w\">\n\n</span><span class=\"c1\"># Linearize at current point</span><span class=\"w\">\n</span><span class=\"n\">op</span><span class=\"o\">.</span><span class=\"n\">linearize</span><span class=\"p\">(</span><span class=\"mf\">2.0</span><span class=\"p\">)</span><span class=\"w\">\n\n</span><span class=\"c1\"># Use linear approximation</span><span class=\"w\">\n</span><span class=\"n\">y2</span> <span class=\"o\">=</span> <span class=\"n\">op</span><span class=\"p\">(</span><span class=\"mf\">2.1</span><span class=\"p\">)</span>  <span class=\"c1\"># Returns f(2.0) + J(2.0) (2.1-2.0)</span>\n</pre>\n<p>With user-provided Jacobian:</p>\n<pre class=\"code python literal-block\">\n<span class=\"k\">def</span><span class=\"w\"> </span><span class=\"nf\">f</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">):</span><span class=\"w\">\n</span>    <span class=\"k\">return</span> <span class=\"n\">x</span><span class=\"o\">**</span><span class=\"mi\">2</span> <span class=\"o\">+</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">sin</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span><span class=\"w\">\n\n</span><span class=\"k\">def</span><span class=\"w\"> </span><span class=\"nf\">df_dx</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">):</span><span class=\"w\">\n</span>    <span class=\"k\">return</span> <span class=\"mi\">2</span><span class=\"o\">*</span><span class=\"n\">x</span> <span class=\"o\">+</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">cos</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span><span class=\"w\">\n\n</span><span class=\"n\">op</span> <span class=\"o\">=</span> <span class=\"n\">Operator</span><span class=\"p\">(</span><span class=\"n\">f</span><span class=\"p\">,</span> <span class=\"n\">jac</span><span class=\"o\">=</span><span class=\"n\">df_dx</span><span class=\"p\">)</span><span class=\"w\">\n\n</span><span class=\"n\">op</span><span class=\"o\">.</span><span class=\"n\">linearize</span><span class=\"p\">(</span><span class=\"mf\">2.0</span><span class=\"p\">)</span>  <span class=\"c1\"># Uses df_dx for Jacobian</span>\n</pre>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>func <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">callable</span></dt>\n<dd>The function to wrap</dd>\n<dt>jac <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">callable, optional</span></dt>\n<dd>Optional analytical Jacobian of func. If None, automatic or numerical\ndifferentiation will be used.</dd>\n</dl>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>f0 <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array_like</span></dt>\n<dd>function evaluation at operating point</dd>\n<dt>x0 <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array_like</span></dt>\n<dd>operating point</dd>\n<dt>J <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array_like</span></dt>\n<dd>jacobian matrix at operating point</dd>\n</dl>\n</div>\n",
          "source": "class Operator(object):\n    \"\"\"Operator class for function evaluation and linearization.\n\n    This class wraps a function to provide both direct evaluation and linear approximation\n    capabilities. When linearized around a point x0, subsequent calls use the first-order\n    Taylor approximation \n\n    .. math::\n\n        f(x) \\\\approx f(x_0) + \\\\mathbf{J}(x_0) (x - x_0)\n\n\n    instead of evaluating the function.\n\n    The class supports multiple methods for Jacobian computation: user-provided analytical\n    Jacobians, automatic differentiation via the Value class, and numerical differentiation\n    as a fallback.\n\n    Example\n    -------\n    Basic usage with automatic differentiation:\n\n    .. code-block:: python\n\n        def f(x):\n            return x**2 + np.sin(x)\n\n        op = Operator(f)\n\n        # Direct function evaluation\n        y1 = op(2.0)\n\n        # Linearize at current point\n        op.linearize(2.0)\n\n        # Use linear approximation\n        y2 = op(2.1)  # Returns f(2.0) + J(2.0) (2.1-2.0)\n\n    With user-provided Jacobian:\n\n    .. code-block:: python\n\n        def f(x):\n            return x**2 + np.sin(x)\n\n        def df_dx(x):\n            return 2*x + np.cos(x)\n\n        op = Operator(f, jac=df_dx)\n\n        op.linearize(2.0)  # Uses df_dx for Jacobian\n\n    Parameters\n    ----------\n    func : callable\n        The function to wrap\n    jac : callable, optional\n        Optional analytical Jacobian of func. If None, automatic or numerical\n        differentiation will be used.\n\n    Attributes\n    ----------\n    f0 : array_like\n        function evaluation at operating point\n    x0 : array_like\n        operating point\n    J : array_like\n        jacobian matrix at operating point\n\n    \"\"\"\n\n    def __init__(self, func, jac=None):\n        self._func = func\n        self._jac = jac\n        self.f0 = None\n        self.x0 = None\n        self.J = None\n\n\n    def __bool__(self):\n        return True\n\n\n    def __call__(self, x):\n        \"\"\"Evaluate the function or its linear approximation.\n\n        If the operator has been linearized (f0 is not None), returns the linear\n        approximation \n\n        .. math::\n\n            f(x_0) + \\\\mathbf{J}(x_0) (x - x_0)\n\n\n        otherwise, returns f(x) directly.\n\n        Parameters\n        ----------\n        x : array_like\n            Point at which to evaluate\n\n        Returns\n        -------\n        value : array_like\n            Function value or linear approximation\n        \"\"\"\n        if self.f0 is None: \n            return self._func(x)\n        dx = np.atleast_1d(x - self.x0)\n        return self.f0 + np.dot(self.J, dx)\n\n\n    def jac(self, x):\n        \"\"\"Compute the Jacobian matrix at point x.\n\n        Uses the following methods in order of preference:\n        1. User-provided analytical Jacobian if available\n        2. Automatic differentiation via Value class\n        3. Numerical differentiation as fallback\n\n        Parameters\n        ----------\n        x : array_like\n            Point at which to evaluate the Jacobian\n\n        Returns\n        -------\n        jacobian : ndarray\n            Jacobian matrix at x\n        \"\"\"\n        if self._jac is None:\n            # Fallback to numerical differentiation\n            return num_jac(self._func, x)\n        else:\n            # Use analytical jacobian\n            return self._jac(x)\n\n\n    def linearize(self, x):\n        \"\"\"Linearize the function at point x.\n\n        Computes and stores both the function value and its Jacobian at x.\n        After linearization, calls to the operator will use the linear\n        approximation until reset() is called.\n\n        Parameters\n        ----------\n        x : array_like\n            Point at which to linearize the function\n        \"\"\"\n        self.x0, self.f0, self.J = x, self._func(x), self.jac(x)\n\n\n    def reset(self):\n        \"\"\"Reset the linearization.\n\n        Clears the stored linearization point and Jacobian, causing the\n        operator to evaluate the function directly on subsequent calls.\n        \"\"\"\n        self.x0, self.f0, self.J = None, None, None",
          "bases": [
            "object"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, func, jac=None):\n    self._func = func\n    self._jac = jac\n    self.f0 = None\n    self.x0 = None\n    self.J = None",
              "signature": "(func, jac = None)",
              "parameters": [
                {
                  "name": "func",
                  "type": null,
                  "default": null,
                  "description": ""
                },
                {
                  "name": "jac",
                  "type": null,
                  "default": "None",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "jac",
              "description": "Compute the Jacobian matrix at point x.",
              "docstring_html": "<p>Compute the Jacobian matrix at point x.</p>\n<p>Uses the following methods in order of preference:\n1. User-provided analytical Jacobian if available\n2. Automatic differentiation via Value class\n3. Numerical differentiation as fallback</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>x <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array_like</span></dt>\n<dd>Point at which to evaluate the Jacobian</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>jacobian <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">ndarray</span></dt>\n<dd>Jacobian matrix at x</dd>\n</dl>\n",
              "source": "def jac(self, x):\n    \"\"\"Compute the Jacobian matrix at point x.\n\n    Uses the following methods in order of preference:\n    1. User-provided analytical Jacobian if available\n    2. Automatic differentiation via Value class\n    3. Numerical differentiation as fallback\n\n    Parameters\n    ----------\n    x : array_like\n        Point at which to evaluate the Jacobian\n\n    Returns\n    -------\n    jacobian : ndarray\n        Jacobian matrix at x\n    \"\"\"\n    if self._jac is None:\n        # Fallback to numerical differentiation\n        return num_jac(self._func, x)\n    else:\n        # Use analytical jacobian\n        return self._jac(x)",
              "signature": "(x)",
              "parameters": [
                {
                  "name": "x",
                  "type": null,
                  "default": null,
                  "description": "Point at which to evaluate the Jacobian Returns -------"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "linearize",
              "description": "Linearize the function at point x.",
              "docstring_html": "<p>Linearize the function at point x.</p>\n<p>Computes and stores both the function value and its Jacobian at x.\nAfter linearization, calls to the operator will use the linear\napproximation until reset() is called.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>x <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array_like</span></dt>\n<dd>Point at which to linearize the function</dd>\n</dl>\n",
              "source": "def linearize(self, x):\n    \"\"\"Linearize the function at point x.\n\n    Computes and stores both the function value and its Jacobian at x.\n    After linearization, calls to the operator will use the linear\n    approximation until reset() is called.\n\n    Parameters\n    ----------\n    x : array_like\n        Point at which to linearize the function\n    \"\"\"\n    self.x0, self.f0, self.J = x, self._func(x), self.jac(x)",
              "signature": "(x)",
              "parameters": [
                {
                  "name": "x",
                  "type": null,
                  "default": null,
                  "description": "Point at which to linearize the function"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "reset",
              "description": "Reset the linearization.",
              "docstring_html": "<p>Reset the linearization.</p>\n<p>Clears the stored linearization point and Jacobian, causing the\noperator to evaluate the function directly on subsequent calls.</p>\n",
              "source": "def reset(self):\n    \"\"\"Reset the linearization.\n\n    Clears the stored linearization point and Jacobian, causing the\n    operator to evaluate the function directly on subsequent calls.\n    \"\"\"\n    self.x0, self.f0, self.J = None, None, None",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "_func",
              "description": "",
              "type": null,
              "value": "func"
            },
            {
              "name": "_jac",
              "description": "",
              "type": null,
              "value": "jac"
            },
            {
              "name": "f0",
              "description": "",
              "type": null,
              "value": "None"
            },
            {
              "name": "x0",
              "description": "",
              "type": null,
              "value": "None"
            },
            {
              "name": "J",
              "description": "",
              "type": null,
              "value": "None"
            }
          ],
          "parameters": [
            {
              "name": "func",
              "type": null,
              "default": null,
              "description": "The function to wrap"
            },
            {
              "name": "jac",
              "type": null,
              "default": "None",
              "description": "Optional analytical Jacobian of func. If None, automatic or numerical differentiation will be used."
            }
          ]
        },
        {
          "name": "DynamicOperator",
          "description": "Operator class for dynamic system function evaluation and linearization.",
          "docstring_html": "<p>Operator class for dynamic system function evaluation and linearization.</p>\n<p>This class wraps a dynamic system function with signature f(x, u, t) to provide\nboth direct evaluation and linear approximation capabilities. When linearized\naround operating points (x0, u0), subsequent calls use the first-order Taylor\napproximation</p>\n<pre class=\"math\">\nf(x, u, t) \\approx f(x_0, u_0, t) + J_x(x_0, u_0, t) (x - x_0) + J_u(x_0, u_0, t) (u - u_0)\n</pre>\n<p>instead of evaluating the function.</p>\n<p>The class supports multiple methods for Jacobian computation: user-provided analytical\nJacobians, automatic differentiation via the Value class, and numerical differentiation\nas a fallback.</p>\n<div class=\"section\" id=\"example\">\n<h4>Example</h4>\n<p>Basic usage with automatic differentiation:</p>\n<pre class=\"code python literal-block\">\n<span class=\"k\">def</span><span class=\"w\"> </span><span class=\"nf\">system</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">u</span><span class=\"p\">,</span> <span class=\"n\">t</span><span class=\"p\">):</span><span class=\"w\">\n</span>    <span class=\"k\">return</span> <span class=\"o\">-</span><span class=\"mf\">0.5</span><span class=\"o\">*</span><span class=\"n\">x</span> <span class=\"o\">+</span> <span class=\"mi\">2</span><span class=\"o\">*</span><span class=\"n\">u</span><span class=\"w\">\n\n</span><span class=\"n\">op</span> <span class=\"o\">=</span> <span class=\"n\">Operator</span><span class=\"p\">(</span><span class=\"n\">system</span><span class=\"p\">)</span><span class=\"w\">\n\n</span><span class=\"c1\"># Direct function evaluation</span><span class=\"w\">\n</span><span class=\"n\">y1</span> <span class=\"o\">=</span> <span class=\"n\">op</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"o\">=</span><span class=\"mf\">1.0</span><span class=\"p\">,</span> <span class=\"n\">u</span><span class=\"o\">=</span><span class=\"mf\">0.5</span><span class=\"p\">,</span> <span class=\"n\">t</span><span class=\"o\">=</span><span class=\"mf\">0.0</span><span class=\"p\">)</span><span class=\"w\">\n\n</span><span class=\"c1\"># Linearize at current point</span><span class=\"w\">\n</span><span class=\"n\">op</span><span class=\"o\">.</span><span class=\"n\">linearize</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"o\">=</span><span class=\"mf\">1.0</span><span class=\"p\">,</span> <span class=\"n\">u</span><span class=\"o\">=</span><span class=\"mf\">0.5</span><span class=\"p\">,</span> <span class=\"n\">t</span><span class=\"o\">=</span><span class=\"mf\">0.0</span><span class=\"p\">)</span><span class=\"w\">\n\n</span><span class=\"c1\"># Use linear approximation</span><span class=\"w\">\n</span><span class=\"n\">y2</span> <span class=\"o\">=</span> <span class=\"n\">op</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"o\">=</span><span class=\"mf\">1.1</span><span class=\"p\">,</span> <span class=\"n\">u</span><span class=\"o\">=</span><span class=\"mf\">0.6</span><span class=\"p\">,</span> <span class=\"n\">t</span><span class=\"o\">=</span><span class=\"mf\">0.1</span><span class=\"p\">)</span>\n</pre>\n<p>With user-provided Jacobians:</p>\n<pre class=\"code python literal-block\">\n<span class=\"k\">def</span><span class=\"w\"> </span><span class=\"nf\">system</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">u</span><span class=\"p\">,</span> <span class=\"n\">t</span><span class=\"p\">):</span><span class=\"w\">\n</span>    <span class=\"k\">return</span> <span class=\"o\">-</span><span class=\"mf\">0.5</span><span class=\"o\">*</span><span class=\"n\">x</span> <span class=\"o\">+</span> <span class=\"mi\">2</span><span class=\"o\">*</span><span class=\"n\">u</span><span class=\"w\">\n\n</span><span class=\"k\">def</span><span class=\"w\"> </span><span class=\"nf\">jac_x</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">u</span><span class=\"p\">,</span> <span class=\"n\">t</span><span class=\"p\">):</span><span class=\"w\">\n</span>    <span class=\"k\">return</span> <span class=\"o\">-</span><span class=\"mf\">0.5</span><span class=\"w\">\n\n</span><span class=\"k\">def</span><span class=\"w\"> </span><span class=\"nf\">jac_u</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">u</span><span class=\"p\">,</span> <span class=\"n\">t</span><span class=\"p\">):</span><span class=\"w\">\n</span>    <span class=\"k\">return</span> <span class=\"mf\">2.0</span><span class=\"w\">\n\n</span><span class=\"n\">op</span> <span class=\"o\">=</span> <span class=\"n\">Operator</span><span class=\"p\">(</span><span class=\"n\">system</span><span class=\"p\">,</span> <span class=\"n\">jac_x</span><span class=\"o\">=</span><span class=\"n\">jac_x</span><span class=\"p\">,</span> <span class=\"n\">jac_u</span><span class=\"o\">=</span><span class=\"n\">jac_u</span><span class=\"p\">)</span><span class=\"w\">\n\n</span><span class=\"n\">op</span><span class=\"o\">.</span><span class=\"n\">linearize</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"o\">=</span><span class=\"mf\">1.0</span><span class=\"p\">,</span> <span class=\"n\">u</span><span class=\"o\">=</span><span class=\"mf\">0.5</span><span class=\"p\">,</span> <span class=\"n\">t</span><span class=\"o\">=</span><span class=\"mf\">0.0</span><span class=\"p\">)</span>\n</pre>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>func <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">callable</span></dt>\n<dd>The function to wrap with signature func(x, u, t)</dd>\n<dt>jac_x <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">callable, optional</span></dt>\n<dd>Optional analytical Jacobian with respect to x. If None, automatic or\nnumerical differentiation will be used.</dd>\n<dt>jac_u <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">callable, optional</span></dt>\n<dd>Optional analytical Jacobian with respect to u. If None, automatic or\nnumerical differentiation will be used.</dd>\n</dl>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>f0 <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array_like</span></dt>\n<dd>Function evaluation at operating point</dd>\n<dt>x0 <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array_like</span></dt>\n<dd>State operating point</dd>\n<dt>u0 <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array_like</span></dt>\n<dd>Input operating point</dd>\n<dt>Jx <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array_like</span></dt>\n<dd>Jacobian matrix with respect to x at operating point</dd>\n<dt>Ju <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array_like</span></dt>\n<dd>Jacobian matrix with respect to u at operating point</dd>\n</dl>\n</div>\n",
          "source": "class DynamicOperator(object):\n    \"\"\"Operator class for dynamic system function evaluation and linearization.\n\n    This class wraps a dynamic system function with signature f(x, u, t) to provide \n    both direct evaluation and linear approximation capabilities. When linearized \n    around operating points (x0, u0), subsequent calls use the first-order Taylor \n    approximation \n\n    .. math::\n\n        f(x, u, t) \\\\approx f(x_0, u_0, t) + J_x(x_0, u_0, t) (x - x_0) + J_u(x_0, u_0, t) (u - u_0)\n\n    instead of evaluating the function.\n\n    The class supports multiple methods for Jacobian computation: user-provided analytical\n    Jacobians, automatic differentiation via the Value class, and numerical differentiation\n    as a fallback.\n\n    Example\n    -------\n    Basic usage with automatic differentiation:\n\n    .. code-block:: python\n\n        def system(x, u, t):\n            return -0.5*x + 2*u\n\n        op = Operator(system)\n\n        # Direct function evaluation\n        y1 = op(x=1.0, u=0.5, t=0.0)\n\n        # Linearize at current point\n        op.linearize(x=1.0, u=0.5, t=0.0)\n\n        # Use linear approximation\n        y2 = op(x=1.1, u=0.6, t=0.1)\n\n    With user-provided Jacobians:\n\n    .. code-block:: python\n\n        def system(x, u, t):\n            return -0.5*x + 2*u\n\n        def jac_x(x, u, t):\n            return -0.5\n\n        def jac_u(x, u, t):\n            return 2.0\n\n        op = Operator(system, jac_x=jac_x, jac_u=jac_u)\n\n        op.linearize(x=1.0, u=0.5, t=0.0)\n\n    Parameters\n    ----------\n    func : callable\n        The function to wrap with signature func(x, u, t)\n    jac_x : callable, optional\n        Optional analytical Jacobian with respect to x. If None, automatic or \n        numerical differentiation will be used.\n    jac_u : callable, optional\n        Optional analytical Jacobian with respect to u. If None, automatic or \n        numerical differentiation will be used.\n\n    Attributes\n    ----------\n    f0 : array_like\n        Function evaluation at operating point\n    x0 : array_like\n        State operating point\n    u0 : array_like\n        Input operating point\n    Jx : array_like\n        Jacobian matrix with respect to x at operating point\n    Ju : array_like\n        Jacobian matrix with respect to u at operating point\n    \"\"\"\n\n    def __init__(self, func, jac_x=None, jac_u=None):\n\n        self._func = func\n\n        self._jac_x = jac_x\n        self._jac_u = jac_u\n\n        self.f0 = None\n        self.x0 = None\n        self.u0 = None\n        self.Jx = None\n        self.Ju = None\n\n\n    def __bool__(self):\n        return True\n\n\n    def __call__(self, x, u, t):\n        \"\"\"Evaluate the function or its linear approximation.\n\n        If the operator has been linearized (f0 is not None), returns the linear\n        approximation \n\n        .. math::\n\n            f(x_0, u_0, t_0) + J_x(x_0, u_0, t_0) (x - x_0) + J_u(x_0, u_0, t_0) (u - u_0)\n\n        otherwise, returns f(x, u, t) directly.\n\n        Parameters\n        ----------\n        x : array_like\n            State vector\n        u : array_like\n            Input vector\n        t : float\n            Time\n\n        Returns\n        -------\n        value : array_like\n            Function value or linear approximation\n        \"\"\"\n        #no linearization available\n        if self.f0 is None:\n            return self._func(x, u, t)\n\n        #linearization in x available\n        if self.x0 is None: _fx = 0.0\n        else: _fx = np.dot(self.Jx, np.atleast_1d(x - self.x0))\n\n        #linearization in u available\n        if self.u0 is None: _fu = 0.0\n        else: _fu = np.dot(self.Ju, np.atleast_1d(u - self.u0))\n\n        return self.f0 + _fx + _fu\n\n\n    def jac_x(self, x, u, t):\n        \"\"\"Compute the Jacobian matrix with respect to x.\n\n        Uses the following methods in order of preference:\n        1. User-provided analytical Jacobian if available\n        2. Automatic differentiation via Value class\n        3. Numerical differentiation as fallback\n\n        Parameters\n        ----------\n        x : array_like\n            State vector\n        u : array_like\n            Input vector\n        t : float\n            Time\n\n        Returns\n        -------\n        jacobian : ndarray\n            Jacobian matrix with respect to x\n        \"\"\"\n        if self._jac_x is None:\n            # Keep u and t as is\n            def func_x(_x):\n                return self._func(_x, u, t)\n            # Fallback to numerical differentiation\n            return num_jac(func_x, x)\n        else:\n            # Use analytical jacobian\n            return self._jac_x(x, u, t)\n\n\n    def jac_u(self, x, u, t):\n        \"\"\"Compute the Jacobian matrix with respect to u.\n\n        Uses the following methods in order of preference:\n        1. User-provided analytical Jacobian if available\n        2. Automatic differentiation via Value class\n        3. Numerical differentiation as fallback\n\n        Parameters\n        ----------\n        x : array_like\n            State vector\n        u : array_like\n            Input vector\n        t : float\n            Time\n\n        Returns\n        -------\n        jacobian : ndarray\n            Jacobian matrix with respect to u\n        \"\"\"\n        if self._jac_u is None:\n            # Keep x and t as is\n            def func_u(_u):\n                return self._func(x, _u, t)\n            # Fallback to numerical differentiation\n            return num_jac(func_u, u)\n        else:\n            # Use analytical jacobian\n            return self._jac_u(x, u, t)\n\n\n    def linearize(self, x, u, t):\n        \"\"\"Linearize the function at point (x, u, t).\n\n        Computes and stores the function value and Jacobians at the operating point.\n        After linearization, calls to the operator will use the linear\n        approximation until reset() is called.\n\n        Parameters\n        ----------\n        x : array_like\n            State vector\n        u : array_like\n            Input vector\n        t : float\n            Time\n        \"\"\"\n        self.f0 = self._func(x, u, t)\n        if x is not None:\n            self.x0, self.Jx = np.atleast_1d(x), self.jac_x(x, u, t)\n        if u is not None:\n            self.u0, self.Ju = np.atleast_1d(u), self.jac_u(x, u, t)\n\n\n    def reset(self):\n        \"\"\"Reset the linearization.\n\n        Clears the stored linearization points and Jacobians, causing the\n        operator to evaluate the function directly on subsequent calls.\n        \"\"\"\n        self.f0 = None\n        self.x0, self.Jx = None, None\n        self.u0, self.Ju = None, None",
          "bases": [
            "object"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, func, jac_x=None, jac_u=None):\n\n    self._func = func\n\n    self._jac_x = jac_x\n    self._jac_u = jac_u\n\n    self.f0 = None\n    self.x0 = None\n    self.u0 = None\n    self.Jx = None\n    self.Ju = None",
              "signature": "(func, jac_x = None, jac_u = None)",
              "parameters": [
                {
                  "name": "func",
                  "type": null,
                  "default": null,
                  "description": ""
                },
                {
                  "name": "jac_x",
                  "type": null,
                  "default": "None",
                  "description": ""
                },
                {
                  "name": "jac_u",
                  "type": null,
                  "default": "None",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "jac_x",
              "description": "Compute the Jacobian matrix with respect to x.",
              "docstring_html": "<p>Compute the Jacobian matrix with respect to x.</p>\n<p>Uses the following methods in order of preference:\n1. User-provided analytical Jacobian if available\n2. Automatic differentiation via Value class\n3. Numerical differentiation as fallback</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>x <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array_like</span></dt>\n<dd>State vector</dd>\n<dt>u <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array_like</span></dt>\n<dd>Input vector</dd>\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>Time</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>jacobian <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">ndarray</span></dt>\n<dd>Jacobian matrix with respect to x</dd>\n</dl>\n",
              "source": "def jac_x(self, x, u, t):\n    \"\"\"Compute the Jacobian matrix with respect to x.\n\n    Uses the following methods in order of preference:\n    1. User-provided analytical Jacobian if available\n    2. Automatic differentiation via Value class\n    3. Numerical differentiation as fallback\n\n    Parameters\n    ----------\n    x : array_like\n        State vector\n    u : array_like\n        Input vector\n    t : float\n        Time\n\n    Returns\n    -------\n    jacobian : ndarray\n        Jacobian matrix with respect to x\n    \"\"\"\n    if self._jac_x is None:\n        # Keep u and t as is\n        def func_x(_x):\n            return self._func(_x, u, t)\n        # Fallback to numerical differentiation\n        return num_jac(func_x, x)\n    else:\n        # Use analytical jacobian\n        return self._jac_x(x, u, t)",
              "signature": "(x, u, t)",
              "parameters": [
                {
                  "name": "x",
                  "type": null,
                  "default": null,
                  "description": "State vector"
                },
                {
                  "name": "u",
                  "type": null,
                  "default": null,
                  "description": "Input vector"
                },
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "Time Returns -------"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "jac_u",
              "description": "Compute the Jacobian matrix with respect to u.",
              "docstring_html": "<p>Compute the Jacobian matrix with respect to u.</p>\n<p>Uses the following methods in order of preference:\n1. User-provided analytical Jacobian if available\n2. Automatic differentiation via Value class\n3. Numerical differentiation as fallback</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>x <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array_like</span></dt>\n<dd>State vector</dd>\n<dt>u <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array_like</span></dt>\n<dd>Input vector</dd>\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>Time</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>jacobian <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">ndarray</span></dt>\n<dd>Jacobian matrix with respect to u</dd>\n</dl>\n",
              "source": "def jac_u(self, x, u, t):\n    \"\"\"Compute the Jacobian matrix with respect to u.\n\n    Uses the following methods in order of preference:\n    1. User-provided analytical Jacobian if available\n    2. Automatic differentiation via Value class\n    3. Numerical differentiation as fallback\n\n    Parameters\n    ----------\n    x : array_like\n        State vector\n    u : array_like\n        Input vector\n    t : float\n        Time\n\n    Returns\n    -------\n    jacobian : ndarray\n        Jacobian matrix with respect to u\n    \"\"\"\n    if self._jac_u is None:\n        # Keep x and t as is\n        def func_u(_u):\n            return self._func(x, _u, t)\n        # Fallback to numerical differentiation\n        return num_jac(func_u, u)\n    else:\n        # Use analytical jacobian\n        return self._jac_u(x, u, t)",
              "signature": "(x, u, t)",
              "parameters": [
                {
                  "name": "x",
                  "type": null,
                  "default": null,
                  "description": "State vector"
                },
                {
                  "name": "u",
                  "type": null,
                  "default": null,
                  "description": "Input vector"
                },
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "Time Returns -------"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "linearize",
              "description": "Linearize the function at point (x, u, t).",
              "docstring_html": "<p>Linearize the function at point (x, u, t).</p>\n<p>Computes and stores the function value and Jacobians at the operating point.\nAfter linearization, calls to the operator will use the linear\napproximation until reset() is called.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>x <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array_like</span></dt>\n<dd>State vector</dd>\n<dt>u <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array_like</span></dt>\n<dd>Input vector</dd>\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>Time</dd>\n</dl>\n",
              "source": "def linearize(self, x, u, t):\n    \"\"\"Linearize the function at point (x, u, t).\n\n    Computes and stores the function value and Jacobians at the operating point.\n    After linearization, calls to the operator will use the linear\n    approximation until reset() is called.\n\n    Parameters\n    ----------\n    x : array_like\n        State vector\n    u : array_like\n        Input vector\n    t : float\n        Time\n    \"\"\"\n    self.f0 = self._func(x, u, t)\n    if x is not None:\n        self.x0, self.Jx = np.atleast_1d(x), self.jac_x(x, u, t)\n    if u is not None:\n        self.u0, self.Ju = np.atleast_1d(u), self.jac_u(x, u, t)",
              "signature": "(x, u, t)",
              "parameters": [
                {
                  "name": "x",
                  "type": null,
                  "default": null,
                  "description": "State vector"
                },
                {
                  "name": "u",
                  "type": null,
                  "default": null,
                  "description": "Input vector"
                },
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "Time"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "reset",
              "description": "Reset the linearization.",
              "docstring_html": "<p>Reset the linearization.</p>\n<p>Clears the stored linearization points and Jacobians, causing the\noperator to evaluate the function directly on subsequent calls.</p>\n",
              "source": "def reset(self):\n    \"\"\"Reset the linearization.\n\n    Clears the stored linearization points and Jacobians, causing the\n    operator to evaluate the function directly on subsequent calls.\n    \"\"\"\n    self.f0 = None\n    self.x0, self.Jx = None, None\n    self.u0, self.Ju = None, None",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "_func",
              "description": "",
              "type": null,
              "value": "func"
            },
            {
              "name": "_jac_x",
              "description": "",
              "type": null,
              "value": "jac_x"
            },
            {
              "name": "_jac_u",
              "description": "",
              "type": null,
              "value": "jac_u"
            },
            {
              "name": "f0",
              "description": "",
              "type": null,
              "value": "None"
            },
            {
              "name": "x0",
              "description": "",
              "type": null,
              "value": "None"
            },
            {
              "name": "u0",
              "description": "",
              "type": null,
              "value": "None"
            },
            {
              "name": "Jx",
              "description": "",
              "type": null,
              "value": "None"
            },
            {
              "name": "Ju",
              "description": "",
              "type": null,
              "value": "None"
            }
          ],
          "parameters": [
            {
              "name": "func",
              "type": null,
              "default": null,
              "description": "The function to wrap with signature func(x, u, t)"
            },
            {
              "name": "jac_x",
              "type": null,
              "default": "None",
              "description": "Optional analytical Jacobian with respect to x. If None, automatic or numerical differentiation will be used."
            },
            {
              "name": "jac_u",
              "type": null,
              "default": "None",
              "description": "Optional analytical Jacobian with respect to u. If None, automatic or numerical differentiation will be used."
            }
          ]
        }
      ],
      "functions": []
    },
    "pathsim.utils.adaptivebuffer": {
      "name": "pathsim.utils.adaptivebuffer",
      "description": "",
      "docstring_html": "",
      "classes": [
        {
          "name": "AdaptiveBuffer",
          "description": "A class that manages an adaptive buffer for delay modeling which is primarily",
          "docstring_html": "<p>A class that manages an adaptive buffer for delay modeling which is primarily\nused in the pathsim 'Delay' block but might have future applications aswell.</p>\n<p>It implements a linear interpolation for arbitrary time lookup.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>delay <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>time delay in seconds</dd>\n</dl>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>buffer_t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">deque</span></dt>\n<dd>deque that collects the time data for buffering</dd>\n<dt>buffer_v <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">deque</span></dt>\n<dd>deque that collects the value data for buffering</dd>\n<dt>ns <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>safety for buffer truncation</dd>\n</dl>\n",
          "source": "class AdaptiveBuffer:\n    \"\"\"A class that manages an adaptive buffer for delay modeling which is primarily \n    used in the pathsim 'Delay' block but might have future applications aswell.\n\n    It implements a linear interpolation for arbitrary time lookup.\n\n    Parameters\n    ----------\n    delay : float\n        time delay in seconds\n\n    Attributes\n    ----------\n    buffer_t : deque\n        deque that collects the time data for buffering\n    buffer_v : deque\n        deque that collects the value data for buffering\n    ns : int\n        safety for buffer truncation\n    \"\"\"\n\n    def __init__(self, delay):\n\n        #the buffer uses a double ended queue\n        self.delay = delay\n        self.buffer_t = deque()\n        self.buffer_v = deque()\n\n        #safety for buffer truncation\n        self.ns = 5\n\n\n    def __len__(self):\n        return len(self.buffer_t)\n\n\n    def add(self, t, value):\n        \"\"\"adding a new datapoint to the buffer\n\n        Parameters\n        ----------\n        t : float\n            time to add\n        value : float, int, complex\n            numerical value to add\n        \"\"\"\n\n        #add the time-value tuple\n        self.buffer_t.append(t)\n        self.buffer_v.append(value)\n\n        #remove values after safety from buffer -> enable interpolation\n        if len(self.buffer_t) > self.ns:\n            while t - self.buffer_t[self.ns] > self.delay:\n                self.buffer_t.popleft()\n                self.buffer_v.popleft()\n\n\n    def interp(self, t):\n        \"\"\"interpolate buffer at defined lookup time\n\n        Parameters\n        ----------\n        t : float\n            time for interpolation\n\n        Returns\n        -------\n        out : float, array\n            interpolated value\n        \"\"\"\n\n        #empty or time too small -> return zero\n        if not self.buffer_t or t <= self.buffer_t[0]:\n            return 0.0\n\n        #requested time too large -> return last value\n        if t >= self.buffer_t[-1]:\n            return self.buffer_v[-1]\n\n        #find buffer index for requested time\n        i = bisect_left(self.buffer_t, t)\n        t0, t1 = self.buffer_t[i], self.buffer_t[i-1]\n        y0, y1 = self.buffer_v[i], self.buffer_v[i-1]\n\n        #linear interpolation\n        return y0 + (y1 - y0) * (t - t0) / (t1 - t0)\n\n\n    def get(self, t):\n        \"\"\"lookup datapoint from buffer with \n        delay at `t_lookup = t - delay`\n\n        Parameters\n        ----------\n        t : float\n            time for lookup with delay\n        \"\"\"\n        return self.interp(t - self.delay)\n\n\n    def clear(self):\n        \"\"\"clear the buffer, reset everything\"\"\"\n        self.buffer_t.clear()\n        self.buffer_v.clear()",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, delay):\n\n    #the buffer uses a double ended queue\n    self.delay = delay\n    self.buffer_t = deque()\n    self.buffer_v = deque()\n\n    #safety for buffer truncation\n    self.ns = 5",
              "signature": "(delay)",
              "parameters": [
                {
                  "name": "delay",
                  "type": null,
                  "default": null,
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "add",
              "description": "adding a new datapoint to the buffer",
              "docstring_html": "<p>adding a new datapoint to the buffer</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>time to add</dd>\n<dt>value <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float, int, complex</span></dt>\n<dd>numerical value to add</dd>\n</dl>\n",
              "source": "def add(self, t, value):\n    \"\"\"adding a new datapoint to the buffer\n\n    Parameters\n    ----------\n    t : float\n        time to add\n    value : float, int, complex\n        numerical value to add\n    \"\"\"\n\n    #add the time-value tuple\n    self.buffer_t.append(t)\n    self.buffer_v.append(value)\n\n    #remove values after safety from buffer -> enable interpolation\n    if len(self.buffer_t) > self.ns:\n        while t - self.buffer_t[self.ns] > self.delay:\n            self.buffer_t.popleft()\n            self.buffer_v.popleft()",
              "signature": "(t, value)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "time to add"
                },
                {
                  "name": "value",
                  "type": null,
                  "default": null,
                  "description": "numerical value to add"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "interp",
              "description": "interpolate buffer at defined lookup time",
              "docstring_html": "<p>interpolate buffer at defined lookup time</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>time for interpolation</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>out <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float, array</span></dt>\n<dd>interpolated value</dd>\n</dl>\n",
              "source": "def interp(self, t):\n    \"\"\"interpolate buffer at defined lookup time\n\n    Parameters\n    ----------\n    t : float\n        time for interpolation\n\n    Returns\n    -------\n    out : float, array\n        interpolated value\n    \"\"\"\n\n    #empty or time too small -> return zero\n    if not self.buffer_t or t <= self.buffer_t[0]:\n        return 0.0\n\n    #requested time too large -> return last value\n    if t >= self.buffer_t[-1]:\n        return self.buffer_v[-1]\n\n    #find buffer index for requested time\n    i = bisect_left(self.buffer_t, t)\n    t0, t1 = self.buffer_t[i], self.buffer_t[i-1]\n    y0, y1 = self.buffer_v[i], self.buffer_v[i-1]\n\n    #linear interpolation\n    return y0 + (y1 - y0) * (t - t0) / (t1 - t0)",
              "signature": "(t)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "time for interpolation"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "get",
              "description": "lookup datapoint from buffer with",
              "docstring_html": "<p>lookup datapoint from buffer with\ndelay at <cite>t_lookup = t - delay</cite></p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>t <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>time for lookup with delay</dd>\n</dl>\n",
              "source": "def get(self, t):\n    \"\"\"lookup datapoint from buffer with \n    delay at `t_lookup = t - delay`\n\n    Parameters\n    ----------\n    t : float\n        time for lookup with delay\n    \"\"\"\n    return self.interp(t - self.delay)",
              "signature": "(t)",
              "parameters": [
                {
                  "name": "t",
                  "type": null,
                  "default": null,
                  "description": "time for lookup with delay"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "clear",
              "description": "clear the buffer, reset everything",
              "docstring_html": "<p>clear the buffer, reset everything</p>\n",
              "source": "def clear(self):\n    \"\"\"clear the buffer, reset everything\"\"\"\n    self.buffer_t.clear()\n    self.buffer_v.clear()",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "delay",
              "description": "",
              "type": null,
              "value": "delay"
            },
            {
              "name": "buffer_t",
              "description": "",
              "type": null,
              "value": "deque()"
            },
            {
              "name": "buffer_v",
              "description": "",
              "type": null,
              "value": "deque()"
            },
            {
              "name": "ns",
              "description": "",
              "type": null,
              "value": "5"
            }
          ],
          "parameters": [
            {
              "name": "delay",
              "type": null,
              "default": null,
              "description": "time delay in seconds"
            }
          ]
        }
      ],
      "functions": []
    },
    "pathsim.utils.analysis": {
      "name": "pathsim.utils.analysis",
      "description": "",
      "docstring_html": "",
      "classes": [
        {
          "name": "Timer",
          "description": "Context manager that times the execution time",
          "docstring_html": "<p>Context manager that times the execution time\nof the code inside of the context in 'ms' for\ndebugging purposes.</p>\n<div class=\"section\" id=\"example\">\n<h4>Example</h4>\n<pre class=\"code python literal-block\">\n<span class=\"c1\">#time the code within the context</span><span class=\"w\">\n</span><span class=\"k\">with</span> <span class=\"n\">Timer</span><span class=\"p\">()</span> <span class=\"k\">as</span> <span class=\"n\">T</span><span class=\"p\">:</span><span class=\"w\">\n</span>    <span class=\"n\">complicated_function</span><span class=\"p\">()</span><span class=\"w\">\n\n</span><span class=\"c1\">#print the runtime in ms</span><span class=\"w\">\n</span><span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">T</span><span class=\"p\">)</span>\n</pre>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>verbose <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>flag for verbose output (uses logging at DEBUG level)</dd>\n</dl>\n</div>\n",
          "source": "class Timer(ContextDecorator):\n    \"\"\"Context manager that times the execution time\n    of the code inside of the context in 'ms' for\n    debugging purposes.\n\n    Example\n    -------\n\n    .. code-block:: python\n\n        #time the code within the context\n        with Timer() as T:\n            complicated_function()\n\n        #print the runtime in ms\n        print(T)\n\n    Parameters\n    ----------\n    verbose : bool\n        flag for verbose output (uses logging at DEBUG level)\n    \"\"\"\n    def __init__(self, verbose=True):\n        self.verbose = verbose\n        self.time = None\n        self.logger = LoggerManager().get_logger(\"analysis.timer\")\n\n\n    def __float__(self):\n        return self.time\n\n\n    def __repr__(self):\n        if self.time is None: return None\n        return f\"{self.time*1e3:.3f}ms\"\n\n\n    def __enter__(self):\n        self._start = perf_counter()\n        return self\n\n\n    def __exit__(self, type, value, traceback):\n        self.time = perf_counter() - self._start\n        if self.verbose:\n            self.logger.debug(str(self))",
          "bases": [
            "contextlib.ContextDecorator"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, verbose=True):\n    self.verbose = verbose\n    self.time = None\n    self.logger = LoggerManager().get_logger(\"analysis.timer\")",
              "signature": "(verbose = True)",
              "parameters": [
                {
                  "name": "verbose",
                  "type": null,
                  "default": "True",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "verbose",
              "description": "",
              "type": null,
              "value": "verbose"
            },
            {
              "name": "time",
              "description": "",
              "type": null,
              "value": "None"
            },
            {
              "name": "logger",
              "description": "",
              "type": null,
              "value": "LoggerManager().get_logger('analysis.timer')"
            }
          ],
          "parameters": [
            {
              "name": "verbose",
              "type": null,
              "default": "True",
              "description": "flag for verbose output (uses logging at DEBUG level)"
            }
          ]
        },
        {
          "name": "Profiler",
          "description": "Context manager for easy code profiling",
          "docstring_html": "<p>Context manager for easy code profiling</p>\n<div class=\"section\" id=\"example\">\n<h4>Example</h4>\n<pre class=\"code python literal-block\">\n<span class=\"c1\">#profile the code within the context</span><span class=\"w\">\n</span><span class=\"k\">with</span> <span class=\"n\">Profiler</span><span class=\"p\">():</span><span class=\"w\">\n</span>    <span class=\"n\">complicated_function</span><span class=\"p\">()</span>\n</pre>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>top_n <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>track top n function calls</dd>\n<dt>sort_by <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">str</span></dt>\n<dd>method to sort function cally by</dd>\n</dl>\n</div>\n",
          "source": "class Profiler(ContextDecorator):\n\n    \"\"\"Context manager for easy code profiling\n\n    Example\n    -------\n\n    .. code-block:: python \n\n        #profile the code within the context\n        with Profiler():\n            complicated_function()\n\n    Parameters\n    ----------\n    top_n : int\n        track top n function calls\n    sort_by : str\n        method to sort function cally by\n    \"\"\"\n\n    def __init__(self, top_n=50, sort_by=\"cumulative\"):\n        self.top_n = top_n\n        self.sort_by = sort_by\n        if not PROFILE_AVAILABLE:\n            _msg = \"'Profiler' not available, make sure 'cProfile' and 'pstats' is installed!\"\n            raise ImportError(_msg)\n        self.profiler = cProfile.Profile()\n\n\n    def __enter__(self):\n        self.profiler.enable()\n        return self\n\n\n    def __exit__(self, *exc):\n        self.profiler.disable()\n        stats = pstats.Stats(self.profiler)\n        stats.strip_dirs()\n        stats.sort_stats(self.sort_by)\n        stats.print_stats(self.top_n)\n        return False",
          "bases": [
            "contextlib.ContextDecorator"
          ],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, top_n=50, sort_by=\"cumulative\"):\n    self.top_n = top_n\n    self.sort_by = sort_by\n    if not PROFILE_AVAILABLE:\n        _msg = \"'Profiler' not available, make sure 'cProfile' and 'pstats' is installed!\"\n        raise ImportError(_msg)\n    self.profiler = cProfile.Profile()",
              "signature": "(top_n = 50, sort_by = 'cumulative')",
              "parameters": [
                {
                  "name": "top_n",
                  "type": null,
                  "default": "50",
                  "description": ""
                },
                {
                  "name": "sort_by",
                  "type": null,
                  "default": "'cumulative'",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "top_n",
              "description": "",
              "type": null,
              "value": "top_n"
            },
            {
              "name": "sort_by",
              "description": "",
              "type": null,
              "value": "sort_by"
            },
            {
              "name": "profiler",
              "description": "",
              "type": null,
              "value": "cProfile.Profile()"
            }
          ],
          "parameters": [
            {
              "name": "top_n",
              "type": null,
              "default": "50",
              "description": "track top n function calls"
            },
            {
              "name": "sort_by",
              "type": null,
              "default": "'cumulative'",
              "description": "method to sort function cally by"
            }
          ]
        }
      ],
      "functions": [
        {
          "name": "timer",
          "description": "Shows the execution time in milliseconds of the",
          "docstring_html": "<p>Shows the execution time in milliseconds of the\nfunction object passed for debugging purposes (uses\nlogging at DEBUG level).</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>func <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">callable</span></dt>\n<dd>function to track execution time of</dd>\n</dl>\n",
          "source": "def timer(func):\n    \"\"\"Shows the execution time in milliseconds of the\n    function object passed for debugging purposes (uses\n    logging at DEBUG level).\n\n    Parameters\n    ----------\n    func : callable\n        function to track execution time of\n    \"\"\"\n\n    @wraps(func)\n    def wrap_func(*args, **kwargs):\n        logger = LoggerManager().get_logger(\"analysis.profiler\")\n        with Timer(verbose=False) as T:\n            result = func(*args, **kwargs)\n        logger.debug(f\"Function '{func.__name__!r}' executed in {T}\")\n        return result\n    return wrap_func",
          "signature": "(func)",
          "parameters": [
            {
              "name": "func",
              "type": null,
              "default": null,
              "description": "function to track execution time of"
            }
          ],
          "returns": null
        }
      ]
    },
    "pathsim.utils.deprecation": {
      "name": "pathsim.utils.deprecation",
      "description": "",
      "docstring_html": "",
      "classes": [],
      "functions": [
        {
          "name": "deprecated",
          "description": "Decorator to mark functions, methods, or classes as deprecated.",
          "docstring_html": "<p>Decorator to mark functions, methods, or classes as deprecated.</p>\n<p>Emits a DeprecationWarning when the decorated item is called/instantiated\nand adds RST-formatted deprecation notice to the docstring.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>version <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">str | None</span></dt>\n<dd>Version when the item will be removed (e.g., &quot;1.0.0&quot;)</dd>\n<dt>replacement <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">str | None</span></dt>\n<dd>Name of the replacement to use instead (e.g., &quot;new_function&quot;)</dd>\n<dt>reason <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">str | None</span></dt>\n<dd>Additional explanation for the deprecation</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>decorator <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">callable</span></dt>\n<dd>Decorator function</dd>\n</dl>\n<div class=\"section\" id=\"example\">\n<h4>Example</h4>\n<pre class=\"code python literal-block\">\n<span class=\"nd\">&#64;deprecated</span><span class=\"p\">(</span><span class=\"n\">version</span><span class=\"o\">=</span><span class=\"s2\">&quot;1.0.0&quot;</span><span class=\"p\">,</span> <span class=\"n\">replacement</span><span class=\"o\">=</span><span class=\"s2\">&quot;new_function&quot;</span><span class=\"p\">)</span><span class=\"w\">\n</span><span class=\"k\">def</span><span class=\"w\"> </span><span class=\"nf\">old_function</span><span class=\"p\">():</span><span class=\"w\">\n</span>    <span class=\"k\">pass</span><span class=\"w\">\n\n</span><span class=\"nd\">&#64;deprecated</span><span class=\"p\">(</span><span class=\"n\">version</span><span class=\"o\">=</span><span class=\"s2\">&quot;2.0.0&quot;</span><span class=\"p\">,</span> <span class=\"n\">reason</span><span class=\"o\">=</span><span class=\"s2\">&quot;No longer needed&quot;</span><span class=\"p\">)</span><span class=\"w\">\n</span><span class=\"k\">class</span><span class=\"w\"> </span><span class=\"nc\">OldClass</span><span class=\"p\">:</span><span class=\"w\">\n</span>    <span class=\"k\">pass</span>\n</pre>\n</div>\n",
          "source": "def deprecated(version=None, replacement=None, reason=None):\n    \"\"\"Decorator to mark functions, methods, or classes as deprecated.\n\n    Emits a DeprecationWarning when the decorated item is called/instantiated\n    and adds RST-formatted deprecation notice to the docstring.\n\n    Parameters\n    ----------\n    version : str | None\n        Version when the item will be removed (e.g., \"1.0.0\")\n    replacement : str | None\n        Name of the replacement to use instead (e.g., \"new_function\")\n    reason : str | None\n        Additional explanation for the deprecation\n\n    Returns\n    -------\n    decorator : callable\n        Decorator function\n\n    Example\n    -------\n    .. code-block:: python\n\n        @deprecated(version=\"1.0.0\", replacement=\"new_function\")\n        def old_function():\n            pass\n\n        @deprecated(version=\"2.0.0\", reason=\"No longer needed\")\n        class OldClass:\n            pass\n    \"\"\"\n\n    def decorator(obj):\n        # Build warning message\n        obj_name = obj.__name__\n        if version:\n            msg_parts = [f\"'{obj_name}' is deprecated and will be removed in version {version}.\"]\n        else:\n            msg_parts = [f\"'{obj_name}' is deprecated.\"]\n\n        if replacement:\n            msg_parts.append(f\"Use '{replacement}' instead.\")\n\n        if reason:\n            msg_parts.append(reason)\n\n        warning_msg = \" \".join(msg_parts)\n\n        # Build RST docstring addition\n        rst_parts = [f\".. deprecated:: {version}\" if version else \".. deprecated::\"]\n        if replacement:\n            rst_parts.append(f\"   Use :func:`{replacement}` instead.\")\n        if reason:\n            rst_parts.append(f\"   {reason}\")\n        rst_notice = \"\\n\".join(rst_parts)\n\n        if isinstance(obj, type):\n            # Decorating a class\n            original_init = obj.__init__\n\n            @functools.wraps(original_init)\n            def new_init(self, *args, **kwargs):\n                warnings.warn(warning_msg, DeprecationWarning, stacklevel=2)\n                return original_init(self, *args, **kwargs)\n\n            obj.__init__ = new_init\n\n            # Update class docstring\n            obj.__doc__ = _prepend_deprecation_notice(obj.__doc__, rst_notice)\n\n            return obj\n        else:\n            # Decorating a function or method\n            @functools.wraps(obj)\n            def wrapper(*args, **kwargs):\n                warnings.warn(warning_msg, DeprecationWarning, stacklevel=2)\n                return obj(*args, **kwargs)\n\n            # Update function docstring\n            wrapper.__doc__ = _prepend_deprecation_notice(obj.__doc__, rst_notice)\n\n            return wrapper\n\n    return decorator",
          "signature": "(version = None, replacement = None, reason = None)",
          "parameters": [
            {
              "name": "version",
              "type": null,
              "default": "None",
              "description": "Version when the item will be removed (e.g., \"1.0.0\")"
            },
            {
              "name": "replacement",
              "type": null,
              "default": "None",
              "description": "Name of the replacement to use instead (e.g., \"new_function\")"
            },
            {
              "name": "reason",
              "type": null,
              "default": "None",
              "description": "Additional explanation for the deprecation"
            }
          ],
          "returns": null
        },
        {
          "name": "_prepend_deprecation_notice",
          "description": "Prepend deprecation notice to docstring.",
          "docstring_html": "<p>Prepend deprecation notice to docstring.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>docstring <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">str | None</span></dt>\n<dd>Original docstring</dd>\n<dt>notice <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">str</span></dt>\n<dd>RST-formatted deprecation notice</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>new_docstring <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">str</span></dt>\n<dd>Docstring with deprecation notice prepended</dd>\n</dl>\n",
          "source": "def _prepend_deprecation_notice(docstring, notice):\n    \"\"\"Prepend deprecation notice to docstring.\n\n    Parameters\n    ----------\n    docstring : str | None\n        Original docstring\n    notice : str\n        RST-formatted deprecation notice\n\n    Returns\n    -------\n    new_docstring : str\n        Docstring with deprecation notice prepended\n    \"\"\"\n    if docstring is None:\n        return notice + \"\\n\"\n\n    # Find indentation from existing docstring\n    lines = docstring.split('\\n')\n    indent = \"\"\n    for line in lines[1:]:  # Skip first line\n        stripped = line.lstrip()\n        if stripped:\n            indent = line[:len(line) - len(stripped)]\n            break\n\n    # Indent the notice to match docstring\n    indented_notice = \"\\n\".join(\n        indent + line if line.strip() else line\n        for line in notice.split('\\n')\n    )\n\n    # Insert after first line (summary) with blank line\n    if len(lines) > 1:\n        return lines[0] + \"\\n\\n\" + indented_notice + \"\\n\" + \"\\n\".join(lines[1:])\n    else:\n        return docstring + \"\\n\\n\" + indented_notice",
          "signature": "(docstring, notice)",
          "parameters": [
            {
              "name": "docstring",
              "type": null,
              "default": null,
              "description": "Original docstring"
            },
            {
              "name": "notice",
              "type": null,
              "default": null,
              "description": "RST-formatted deprecation notice"
            }
          ],
          "returns": null
        }
      ]
    },
    "pathsim.utils.fmuwrapper": {
      "name": "pathsim.utils.fmuwrapper",
      "description": "",
      "docstring_html": "",
      "classes": [
        {
          "name": "EventInfo",
          "description": "Unified event information structure for both FMI 2.0 and 3.0.",
          "docstring_html": "<p>Unified event information structure for both FMI 2.0 and 3.0.</p>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>discrete_states_need_update <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>whether discrete state iteration is needed</dd>\n<dt>terminate_simulation <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>whether FMU requests simulation termination</dd>\n<dt>nominals_changed <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>whether nominal values of continuous states changed</dd>\n<dt>values_changed <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>whether continuous state values changed</dd>\n<dt>next_event_time_defined <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>whether FMU has scheduled a next time event</dd>\n<dt>next_event_time <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>time of next scheduled event (if defined)</dd>\n</dl>\n",
          "source": "@dataclass\nclass EventInfo:\n    \"\"\"Unified event information structure for both FMI 2.0 and 3.0.\n\n    Attributes\n    ----------\n    discrete_states_need_update : bool\n        whether discrete state iteration is needed\n    terminate_simulation : bool\n        whether FMU requests simulation termination\n    nominals_changed : bool\n        whether nominal values of continuous states changed\n    values_changed : bool\n        whether continuous state values changed\n    next_event_time_defined : bool\n        whether FMU has scheduled a next time event\n    next_event_time : float\n        time of next scheduled event (if defined)\n    \"\"\"\n    discrete_states_need_update: bool = False\n    terminate_simulation: bool = False\n    nominals_changed: bool = False\n    values_changed: bool = False\n    next_event_time_defined: bool = False\n    next_event_time: float = 0.0",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": null,
              "signature": "(discrete_states_need_update: bool = False, terminate_simulation: bool = False, nominals_changed: bool = False, values_changed: bool = False, next_event_time_defined: bool = False, next_event_time: float = 0.0)",
              "parameters": [
                {
                  "name": "discrete_states_need_update",
                  "type": "bool",
                  "default": "False",
                  "description": ""
                },
                {
                  "name": "terminate_simulation",
                  "type": "bool",
                  "default": "False",
                  "description": ""
                },
                {
                  "name": "nominals_changed",
                  "type": "bool",
                  "default": "False",
                  "description": ""
                },
                {
                  "name": "values_changed",
                  "type": "bool",
                  "default": "False",
                  "description": ""
                },
                {
                  "name": "next_event_time_defined",
                  "type": "bool",
                  "default": "False",
                  "description": ""
                },
                {
                  "name": "next_event_time",
                  "type": "float",
                  "default": "0.0",
                  "description": ""
                }
              ],
              "returns": "None",
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "discrete_states_need_update",
              "description": "",
              "type": "bool",
              "value": "False"
            },
            {
              "name": "terminate_simulation",
              "description": "",
              "type": "bool",
              "value": "False"
            },
            {
              "name": "nominals_changed",
              "description": "",
              "type": "bool",
              "value": "False"
            },
            {
              "name": "values_changed",
              "description": "",
              "type": "bool",
              "value": "False"
            },
            {
              "name": "next_event_time_defined",
              "description": "",
              "type": "bool",
              "value": "False"
            },
            {
              "name": "next_event_time",
              "description": "",
              "type": "float",
              "value": "0.0"
            }
          ],
          "parameters": [
            {
              "name": "discrete_states_need_update",
              "type": "bool",
              "default": "False",
              "description": "whether discrete state iteration is needed"
            },
            {
              "name": "terminate_simulation",
              "type": "bool",
              "default": "False",
              "description": "whether FMU requests simulation termination"
            },
            {
              "name": "nominals_changed",
              "type": "bool",
              "default": "False",
              "description": "whether nominal values of continuous states changed"
            },
            {
              "name": "values_changed",
              "type": "bool",
              "default": "False",
              "description": "whether continuous state values changed"
            },
            {
              "name": "next_event_time_defined",
              "type": "bool",
              "default": "False",
              "description": "whether FMU has scheduled a next time event"
            },
            {
              "name": "next_event_time",
              "type": "float",
              "default": "0.0",
              "description": "time of next scheduled event (if defined)"
            }
          ]
        },
        {
          "name": "StepResult",
          "description": "Result information from a co-simulation step.",
          "docstring_html": "<p>Result information from a co-simulation step.</p>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>event_encountered <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>whether an event was encountered during step (FMI 3.0 only)</dd>\n<dt>terminate_simulation <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>whether FMU requests simulation termination (FMI 3.0 only)</dd>\n<dt>early_return <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>whether step returned early (FMI 3.0 only)</dd>\n<dt>last_successful_time <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>last time successfully reached (FMI 3.0 only)</dd>\n</dl>\n",
          "source": "@dataclass\nclass StepResult:\n    \"\"\"Result information from a co-simulation step.\n\n    Attributes\n    ----------\n    event_encountered : bool\n        whether an event was encountered during step (FMI 3.0 only)\n    terminate_simulation : bool\n        whether FMU requests simulation termination (FMI 3.0 only)\n    early_return : bool\n        whether step returned early (FMI 3.0 only)\n    last_successful_time : float\n        last time successfully reached (FMI 3.0 only)\n    \"\"\"\n    event_encountered: bool = False\n    terminate_simulation: bool = False\n    early_return: bool = False\n    last_successful_time: float = 0.0",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": null,
              "signature": "(event_encountered: bool = False, terminate_simulation: bool = False, early_return: bool = False, last_successful_time: float = 0.0)",
              "parameters": [
                {
                  "name": "event_encountered",
                  "type": "bool",
                  "default": "False",
                  "description": ""
                },
                {
                  "name": "terminate_simulation",
                  "type": "bool",
                  "default": "False",
                  "description": ""
                },
                {
                  "name": "early_return",
                  "type": "bool",
                  "default": "False",
                  "description": ""
                },
                {
                  "name": "last_successful_time",
                  "type": "float",
                  "default": "0.0",
                  "description": ""
                }
              ],
              "returns": "None",
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "event_encountered",
              "description": "",
              "type": "bool",
              "value": "False"
            },
            {
              "name": "terminate_simulation",
              "description": "",
              "type": "bool",
              "value": "False"
            },
            {
              "name": "early_return",
              "description": "",
              "type": "bool",
              "value": "False"
            },
            {
              "name": "last_successful_time",
              "description": "",
              "type": "float",
              "value": "0.0"
            }
          ],
          "parameters": [
            {
              "name": "event_encountered",
              "type": "bool",
              "default": "False",
              "description": "whether an event was encountered during step (FMI 3.0 only)"
            },
            {
              "name": "terminate_simulation",
              "type": "bool",
              "default": "False",
              "description": "whether FMU requests simulation termination (FMI 3.0 only)"
            },
            {
              "name": "early_return",
              "type": "bool",
              "default": "False",
              "description": "whether step returned early (FMI 3.0 only)"
            },
            {
              "name": "last_successful_time",
              "type": "float",
              "default": "0.0",
              "description": "last time successfully reached (FMI 3.0 only)"
            }
          ]
        },
        {
          "name": "_FMI2Ops",
          "description": "FMI 2.0 specific operations.",
          "docstring_html": "<p>FMI 2.0 specific operations.</p>\n",
          "source": "class _FMI2Ops:\n    \"\"\"FMI 2.0 specific operations.\"\"\"\n\n    @staticmethod\n    def set_real(fmu, refs, values):\n        fmu.setReal(refs, values)\n\n    @staticmethod\n    def get_real(fmu, refs):\n        return fmu.getReal(refs)\n\n    @staticmethod\n    def set_integer(fmu, refs, values):\n        fmu.setInteger(refs, values)\n\n    @staticmethod\n    def get_integer(fmu, refs):\n        return fmu.getInteger(refs)\n\n    @staticmethod\n    def do_step(fmu, current_time, step_size):\n        fmu.doStep(current_time, step_size)\n        return StepResult()\n\n    @staticmethod\n    def get_derivatives(fmu, n_states):\n        if n_states == 0:\n            return np.array([])\n        derivatives = (ctypes.c_double * n_states)()\n        fmu.getDerivatives(derivatives, n_states)\n        return np.array(derivatives)\n\n    @staticmethod\n    def update_discrete_states(fmu):\n        result = fmu.newDiscreteStates()\n        return EventInfo(\n            discrete_states_need_update=result[0],\n            terminate_simulation=result[1],\n            nominals_changed=result[2],\n            values_changed=result[3],\n            next_event_time_defined=result[4],\n            next_event_time=result[5]\n        )\n\n    @staticmethod\n    def setup_experiment(fmu, tolerance, start_time, stop_time):\n        fmu.setupExperiment(tolerance=tolerance, startTime=start_time, stopTime=stop_time)\n\n    @staticmethod\n    def enter_initialization_mode(fmu, tolerance, start_time, stop_time):\n        fmu.enterInitializationMode()\n\n    @staticmethod\n    def exit_initialization_mode(fmu, mode):\n        result = fmu.exitInitializationMode()\n        # FMI 2.0 doesn't return event info from exitInitializationMode\n        return None",
          "bases": [],
          "methods": [
            {
              "name": "set_real",
              "description": "",
              "docstring_html": "",
              "source": "@staticmethod\ndef set_real(fmu, refs, values):\n    fmu.setReal(refs, values)",
              "signature": "(fmu, refs, values)",
              "parameters": [
                {
                  "name": "fmu",
                  "type": null,
                  "default": null,
                  "description": ""
                },
                {
                  "name": "refs",
                  "type": null,
                  "default": null,
                  "description": ""
                },
                {
                  "name": "values",
                  "type": null,
                  "default": null,
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "staticmethod"
            },
            {
              "name": "get_real",
              "description": "",
              "docstring_html": "",
              "source": "@staticmethod\ndef get_real(fmu, refs):\n    return fmu.getReal(refs)",
              "signature": "(fmu, refs)",
              "parameters": [
                {
                  "name": "fmu",
                  "type": null,
                  "default": null,
                  "description": ""
                },
                {
                  "name": "refs",
                  "type": null,
                  "default": null,
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "staticmethod"
            },
            {
              "name": "set_integer",
              "description": "",
              "docstring_html": "",
              "source": "@staticmethod\ndef set_integer(fmu, refs, values):\n    fmu.setInteger(refs, values)",
              "signature": "(fmu, refs, values)",
              "parameters": [
                {
                  "name": "fmu",
                  "type": null,
                  "default": null,
                  "description": ""
                },
                {
                  "name": "refs",
                  "type": null,
                  "default": null,
                  "description": ""
                },
                {
                  "name": "values",
                  "type": null,
                  "default": null,
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "staticmethod"
            },
            {
              "name": "get_integer",
              "description": "",
              "docstring_html": "",
              "source": "@staticmethod\ndef get_integer(fmu, refs):\n    return fmu.getInteger(refs)",
              "signature": "(fmu, refs)",
              "parameters": [
                {
                  "name": "fmu",
                  "type": null,
                  "default": null,
                  "description": ""
                },
                {
                  "name": "refs",
                  "type": null,
                  "default": null,
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "staticmethod"
            },
            {
              "name": "do_step",
              "description": "",
              "docstring_html": "",
              "source": "@staticmethod\ndef do_step(fmu, current_time, step_size):\n    fmu.doStep(current_time, step_size)\n    return StepResult()",
              "signature": "(fmu, current_time, step_size)",
              "parameters": [
                {
                  "name": "fmu",
                  "type": null,
                  "default": null,
                  "description": ""
                },
                {
                  "name": "current_time",
                  "type": null,
                  "default": null,
                  "description": ""
                },
                {
                  "name": "step_size",
                  "type": null,
                  "default": null,
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "staticmethod"
            },
            {
              "name": "get_derivatives",
              "description": "",
              "docstring_html": "",
              "source": "@staticmethod\ndef get_derivatives(fmu, n_states):\n    if n_states == 0:\n        return np.array([])\n    derivatives = (ctypes.c_double * n_states)()\n    fmu.getDerivatives(derivatives, n_states)\n    return np.array(derivatives)",
              "signature": "(fmu, n_states)",
              "parameters": [
                {
                  "name": "fmu",
                  "type": null,
                  "default": null,
                  "description": ""
                },
                {
                  "name": "n_states",
                  "type": null,
                  "default": null,
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "staticmethod"
            },
            {
              "name": "update_discrete_states",
              "description": "",
              "docstring_html": "",
              "source": "@staticmethod\ndef update_discrete_states(fmu):\n    result = fmu.newDiscreteStates()\n    return EventInfo(\n        discrete_states_need_update=result[0],\n        terminate_simulation=result[1],\n        nominals_changed=result[2],\n        values_changed=result[3],\n        next_event_time_defined=result[4],\n        next_event_time=result[5]\n    )",
              "signature": "(fmu)",
              "parameters": [
                {
                  "name": "fmu",
                  "type": null,
                  "default": null,
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "staticmethod"
            },
            {
              "name": "setup_experiment",
              "description": "",
              "docstring_html": "",
              "source": "@staticmethod\ndef setup_experiment(fmu, tolerance, start_time, stop_time):\n    fmu.setupExperiment(tolerance=tolerance, startTime=start_time, stopTime=stop_time)",
              "signature": "(fmu, tolerance, start_time, stop_time)",
              "parameters": [
                {
                  "name": "fmu",
                  "type": null,
                  "default": null,
                  "description": ""
                },
                {
                  "name": "tolerance",
                  "type": null,
                  "default": null,
                  "description": ""
                },
                {
                  "name": "start_time",
                  "type": null,
                  "default": null,
                  "description": ""
                },
                {
                  "name": "stop_time",
                  "type": null,
                  "default": null,
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "staticmethod"
            },
            {
              "name": "enter_initialization_mode",
              "description": "",
              "docstring_html": "",
              "source": "@staticmethod\ndef enter_initialization_mode(fmu, tolerance, start_time, stop_time):\n    fmu.enterInitializationMode()",
              "signature": "(fmu, tolerance, start_time, stop_time)",
              "parameters": [
                {
                  "name": "fmu",
                  "type": null,
                  "default": null,
                  "description": ""
                },
                {
                  "name": "tolerance",
                  "type": null,
                  "default": null,
                  "description": ""
                },
                {
                  "name": "start_time",
                  "type": null,
                  "default": null,
                  "description": ""
                },
                {
                  "name": "stop_time",
                  "type": null,
                  "default": null,
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "staticmethod"
            },
            {
              "name": "exit_initialization_mode",
              "description": "",
              "docstring_html": "",
              "source": "@staticmethod\ndef exit_initialization_mode(fmu, mode):\n    result = fmu.exitInitializationMode()\n    # FMI 2.0 doesn't return event info from exitInitializationMode\n    return None",
              "signature": "(fmu, mode)",
              "parameters": [
                {
                  "name": "fmu",
                  "type": null,
                  "default": null,
                  "description": ""
                },
                {
                  "name": "mode",
                  "type": null,
                  "default": null,
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "staticmethod"
            }
          ],
          "attributes": [],
          "parameters": []
        },
        {
          "name": "_FMI3Ops",
          "description": "FMI 3.0 specific operations.",
          "docstring_html": "<p>FMI 3.0 specific operations.</p>\n",
          "source": "class _FMI3Ops:\n    \"\"\"FMI 3.0 specific operations.\"\"\"\n\n    @staticmethod\n    def set_real(fmu, refs, values):\n        fmu.setFloat64(refs, values)\n\n    @staticmethod\n    def get_real(fmu, refs):\n        return fmu.getFloat64(refs)\n\n    @staticmethod\n    def set_integer(fmu, refs, values):\n        fmu.setInt64(refs, values)\n\n    @staticmethod\n    def get_integer(fmu, refs):\n        return fmu.getInt64(refs)\n\n    @staticmethod\n    def do_step(fmu, current_time, step_size):\n        event, terminate, early, last_time = fmu.doStep(current_time, step_size)\n        return StepResult(\n            event_encountered=event,\n            terminate_simulation=terminate,\n            early_return=early,\n            last_successful_time=last_time\n        )\n\n    @staticmethod\n    def get_derivatives(fmu, n_states):\n        if n_states == 0:\n            return np.array([])\n        derivatives = (ctypes.c_double * n_states)()\n        fmu.getContinuousStateDerivatives(derivatives, n_states)\n        return np.array(derivatives)\n\n    @staticmethod\n    def update_discrete_states(fmu):\n        result = fmu.updateDiscreteStates()\n        return EventInfo(\n            discrete_states_need_update=result[0],\n            terminate_simulation=result[1],\n            nominals_changed=result[2],\n            values_changed=result[3],\n            next_event_time_defined=result[4],\n            next_event_time=result[5]\n        )\n\n    @staticmethod\n    def setup_experiment(fmu, tolerance, start_time, stop_time):\n        # FMI 3.0 passes these to enterInitializationMode instead\n        pass\n\n    @staticmethod\n    def enter_initialization_mode(fmu, tolerance, start_time, stop_time):\n        fmu.enterInitializationMode(tolerance=tolerance, startTime=start_time, stopTime=stop_time)\n\n    @staticmethod\n    def exit_initialization_mode(fmu, mode):\n        result = fmu.exitInitializationMode()\n        # FMI 3.0 Model Exchange returns event info\n        if mode == 'model_exchange' and hasattr(result, 'nextEventTimeDefined'):\n            return EventInfo(\n                discrete_states_need_update=bool(getattr(result, 'discreteStatesNeedUpdate', False)),\n                terminate_simulation=bool(getattr(result, 'terminateSimulation', False)),\n                nominals_changed=bool(getattr(result, 'nominalsOfContinuousStatesChanged', False)),\n                values_changed=bool(getattr(result, 'valuesOfContinuousStatesChanged', False)),\n                next_event_time_defined=bool(getattr(result, 'nextEventTimeDefined', False)),\n                next_event_time=float(getattr(result, 'nextEventTime', 0.0))\n            )\n        return None",
          "bases": [],
          "methods": [
            {
              "name": "set_real",
              "description": "",
              "docstring_html": "",
              "source": "@staticmethod\ndef set_real(fmu, refs, values):\n    fmu.setFloat64(refs, values)",
              "signature": "(fmu, refs, values)",
              "parameters": [
                {
                  "name": "fmu",
                  "type": null,
                  "default": null,
                  "description": ""
                },
                {
                  "name": "refs",
                  "type": null,
                  "default": null,
                  "description": ""
                },
                {
                  "name": "values",
                  "type": null,
                  "default": null,
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "staticmethod"
            },
            {
              "name": "get_real",
              "description": "",
              "docstring_html": "",
              "source": "@staticmethod\ndef get_real(fmu, refs):\n    return fmu.getFloat64(refs)",
              "signature": "(fmu, refs)",
              "parameters": [
                {
                  "name": "fmu",
                  "type": null,
                  "default": null,
                  "description": ""
                },
                {
                  "name": "refs",
                  "type": null,
                  "default": null,
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "staticmethod"
            },
            {
              "name": "set_integer",
              "description": "",
              "docstring_html": "",
              "source": "@staticmethod\ndef set_integer(fmu, refs, values):\n    fmu.setInt64(refs, values)",
              "signature": "(fmu, refs, values)",
              "parameters": [
                {
                  "name": "fmu",
                  "type": null,
                  "default": null,
                  "description": ""
                },
                {
                  "name": "refs",
                  "type": null,
                  "default": null,
                  "description": ""
                },
                {
                  "name": "values",
                  "type": null,
                  "default": null,
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "staticmethod"
            },
            {
              "name": "get_integer",
              "description": "",
              "docstring_html": "",
              "source": "@staticmethod\ndef get_integer(fmu, refs):\n    return fmu.getInt64(refs)",
              "signature": "(fmu, refs)",
              "parameters": [
                {
                  "name": "fmu",
                  "type": null,
                  "default": null,
                  "description": ""
                },
                {
                  "name": "refs",
                  "type": null,
                  "default": null,
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "staticmethod"
            },
            {
              "name": "do_step",
              "description": "",
              "docstring_html": "",
              "source": "@staticmethod\ndef do_step(fmu, current_time, step_size):\n    event, terminate, early, last_time = fmu.doStep(current_time, step_size)\n    return StepResult(\n        event_encountered=event,\n        terminate_simulation=terminate,\n        early_return=early,\n        last_successful_time=last_time\n    )",
              "signature": "(fmu, current_time, step_size)",
              "parameters": [
                {
                  "name": "fmu",
                  "type": null,
                  "default": null,
                  "description": ""
                },
                {
                  "name": "current_time",
                  "type": null,
                  "default": null,
                  "description": ""
                },
                {
                  "name": "step_size",
                  "type": null,
                  "default": null,
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "staticmethod"
            },
            {
              "name": "get_derivatives",
              "description": "",
              "docstring_html": "",
              "source": "@staticmethod\ndef get_derivatives(fmu, n_states):\n    if n_states == 0:\n        return np.array([])\n    derivatives = (ctypes.c_double * n_states)()\n    fmu.getContinuousStateDerivatives(derivatives, n_states)\n    return np.array(derivatives)",
              "signature": "(fmu, n_states)",
              "parameters": [
                {
                  "name": "fmu",
                  "type": null,
                  "default": null,
                  "description": ""
                },
                {
                  "name": "n_states",
                  "type": null,
                  "default": null,
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "staticmethod"
            },
            {
              "name": "update_discrete_states",
              "description": "",
              "docstring_html": "",
              "source": "@staticmethod\ndef update_discrete_states(fmu):\n    result = fmu.updateDiscreteStates()\n    return EventInfo(\n        discrete_states_need_update=result[0],\n        terminate_simulation=result[1],\n        nominals_changed=result[2],\n        values_changed=result[3],\n        next_event_time_defined=result[4],\n        next_event_time=result[5]\n    )",
              "signature": "(fmu)",
              "parameters": [
                {
                  "name": "fmu",
                  "type": null,
                  "default": null,
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "staticmethod"
            },
            {
              "name": "setup_experiment",
              "description": "",
              "docstring_html": "",
              "source": "@staticmethod\ndef setup_experiment(fmu, tolerance, start_time, stop_time):\n    # FMI 3.0 passes these to enterInitializationMode instead\n    pass",
              "signature": "(fmu, tolerance, start_time, stop_time)",
              "parameters": [
                {
                  "name": "fmu",
                  "type": null,
                  "default": null,
                  "description": ""
                },
                {
                  "name": "tolerance",
                  "type": null,
                  "default": null,
                  "description": ""
                },
                {
                  "name": "start_time",
                  "type": null,
                  "default": null,
                  "description": ""
                },
                {
                  "name": "stop_time",
                  "type": null,
                  "default": null,
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "staticmethod"
            },
            {
              "name": "enter_initialization_mode",
              "description": "",
              "docstring_html": "",
              "source": "@staticmethod\ndef enter_initialization_mode(fmu, tolerance, start_time, stop_time):\n    fmu.enterInitializationMode(tolerance=tolerance, startTime=start_time, stopTime=stop_time)",
              "signature": "(fmu, tolerance, start_time, stop_time)",
              "parameters": [
                {
                  "name": "fmu",
                  "type": null,
                  "default": null,
                  "description": ""
                },
                {
                  "name": "tolerance",
                  "type": null,
                  "default": null,
                  "description": ""
                },
                {
                  "name": "start_time",
                  "type": null,
                  "default": null,
                  "description": ""
                },
                {
                  "name": "stop_time",
                  "type": null,
                  "default": null,
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "staticmethod"
            },
            {
              "name": "exit_initialization_mode",
              "description": "",
              "docstring_html": "",
              "source": "@staticmethod\ndef exit_initialization_mode(fmu, mode):\n    result = fmu.exitInitializationMode()\n    # FMI 3.0 Model Exchange returns event info\n    if mode == 'model_exchange' and hasattr(result, 'nextEventTimeDefined'):\n        return EventInfo(\n            discrete_states_need_update=bool(getattr(result, 'discreteStatesNeedUpdate', False)),\n            terminate_simulation=bool(getattr(result, 'terminateSimulation', False)),\n            nominals_changed=bool(getattr(result, 'nominalsOfContinuousStatesChanged', False)),\n            values_changed=bool(getattr(result, 'valuesOfContinuousStatesChanged', False)),\n            next_event_time_defined=bool(getattr(result, 'nextEventTimeDefined', False)),\n            next_event_time=float(getattr(result, 'nextEventTime', 0.0))\n        )\n    return None",
              "signature": "(fmu, mode)",
              "parameters": [
                {
                  "name": "fmu",
                  "type": null,
                  "default": null,
                  "description": ""
                },
                {
                  "name": "mode",
                  "type": null,
                  "default": null,
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "staticmethod"
            }
          ],
          "attributes": [],
          "parameters": []
        },
        {
          "name": "FMUWrapper",
          "description": "Version-agnostic wrapper for FMI 2.0 and 3.0 FMUs.",
          "docstring_html": "<p>Version-agnostic wrapper for FMI 2.0 and 3.0 FMUs.</p>\n<p>This class provides a unified interface for working with FMUs regardless of\nFMI version (2.0 or 3.0) or interface type (Co-Simulation or Model Exchange).\nIt handles all version-specific API differences internally.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>fmu_path <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">str</span></dt>\n<dd>path to the FMU file (.fmu)</dd>\n<dt>instance_name <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">str, optional</span></dt>\n<dd>name for the FMU instance (default: 'fmu_instance')</dd>\n<dt>mode <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">str, optional</span></dt>\n<dd>FMU interface mode: 'cosimulation' or 'model_exchange' (default: 'cosimulation')</dd>\n</dl>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>fmu_path <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">str</span></dt>\n<dd>path to the FMU file</dd>\n<dt>instance_name <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">str</span></dt>\n<dd>name of the FMU instance</dd>\n<dt>mode <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">str</span></dt>\n<dd>interface mode ('cosimulation' or 'model_exchange')</dd>\n<dt>model_description <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">ModelDescription</span></dt>\n<dd>FMI model description from FMPy (use this for metadata access)</dd>\n<dt>fmu <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">FMU2Slave | FMU3Slave | FMU2Model | FMU3Model</span></dt>\n<dd>underlying FMPy FMU instance</dd>\n<dt>fmi_version <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">str</span></dt>\n<dd>detected FMI version ('2.0' or '3.0')</dd>\n<dt>n_states <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>number of continuous states (Model Exchange only)</dd>\n<dt>n_event_indicators <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>number of event indicators (Model Exchange only)</dd>\n<dt>input_refs <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">dict</span></dt>\n<dd>mapping from input variable names to value references</dd>\n<dt>output_refs <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">dict</span></dt>\n<dd>mapping from output variable names to value references</dd>\n</dl>\n",
          "source": "class FMUWrapper:\n    \"\"\"Version-agnostic wrapper for FMI 2.0 and 3.0 FMUs.\n\n    This class provides a unified interface for working with FMUs regardless of\n    FMI version (2.0 or 3.0) or interface type (Co-Simulation or Model Exchange).\n    It handles all version-specific API differences internally.\n\n    Parameters\n    ----------\n    fmu_path : str\n        path to the FMU file (.fmu)\n    instance_name : str, optional\n        name for the FMU instance (default: 'fmu_instance')\n    mode : str, optional\n        FMU interface mode: 'cosimulation' or 'model_exchange' (default: 'cosimulation')\n\n    Attributes\n    ----------\n    fmu_path : str\n        path to the FMU file\n    instance_name : str\n        name of the FMU instance\n    mode : str\n        interface mode ('cosimulation' or 'model_exchange')\n    model_description : ModelDescription\n        FMI model description from FMPy (use this for metadata access)\n    fmu : FMU2Slave | FMU3Slave | FMU2Model | FMU3Model\n        underlying FMPy FMU instance\n    fmi_version : str\n        detected FMI version ('2.0' or '3.0')\n    n_states : int\n        number of continuous states (Model Exchange only)\n    n_event_indicators : int\n        number of event indicators (Model Exchange only)\n    input_refs : dict\n        mapping from input variable names to value references\n    output_refs : dict\n        mapping from output variable names to value references\n    \"\"\"\n\n    def __init__(self, fmu_path, instance_name=\"fmu_instance\", mode=\"cosimulation\"):\n\n        # Import FMPy (lazy import to avoid dependency if not used)\n        try:\n            from fmpy import read_model_description, extract\n            from fmpy.fmi2 import FMU2Slave, FMU2Model\n            from fmpy.fmi3 import FMU3Slave, FMU3Model\n        except ImportError:\n            raise ImportError(\"FMPy is required for FMU support. Install with: pip install fmpy\")\n\n        self.fmu_path = fmu_path\n        self.instance_name = instance_name\n        self.mode = mode.lower()\n\n        if self.mode not in ['cosimulation', 'model_exchange']:\n            raise ValueError(f\"Invalid mode '{mode}'. Must be 'cosimulation' or 'model_exchange'\")\n\n        # Read model description and detect FMI version\n        self.model_description = read_model_description(fmu_path)\n        self.fmi_version = self.model_description.fmiVersion\n\n        # Select version-specific operations\n        self._ops = _FMI2Ops if self.fmi_version.startswith('2.') else _FMI3Ops\n\n        # Extract FMU\n        self.unzipdir = extract(fmu_path)\n\n        # Build variable lookup maps\n        self._build_variable_maps()\n\n        # Get state and event info for Model Exchange\n        if self.mode == 'model_exchange':\n            self.n_states = self.model_description.numberOfContinuousStates\n            self.n_event_indicators = self.model_description.numberOfEventIndicators\n            self._build_state_derivative_maps()\n        else:\n            self.n_states = 0\n            self.n_event_indicators = 0\n            self._state_refs = []\n            self._derivative_refs = []\n\n        # Instantiate appropriate FMU class based on version and mode\n        self.fmu = self._create_fmu_instance(FMU2Slave, FMU2Model, FMU3Slave, FMU3Model)\n\n    def _create_fmu_instance(self, FMU2Slave, FMU2Model, FMU3Slave, FMU3Model):\n        \"\"\"Create the appropriate FMU instance based on version and mode.\"\"\"\n        md = self.model_description\n\n        if self.fmi_version.startswith('2.'):\n            if self.mode == 'cosimulation':\n                return FMU2Slave(\n                    guid=md.guid,\n                    unzipDirectory=self.unzipdir,\n                    modelIdentifier=md.coSimulation.modelIdentifier,\n                    instanceName=self.instance_name\n                )\n            else:\n                return FMU2Model(\n                    guid=md.guid,\n                    unzipDirectory=self.unzipdir,\n                    modelIdentifier=md.modelExchange.modelIdentifier,\n                    instanceName=self.instance_name\n                )\n        elif self.fmi_version.startswith('3.'):\n            if self.mode == 'cosimulation':\n                return FMU3Slave(\n                    guid=md.guid,\n                    unzipDirectory=self.unzipdir,\n                    modelIdentifier=md.coSimulation.modelIdentifier,\n                    instanceName=self.instance_name\n                )\n            else:\n                return FMU3Model(\n                    guid=md.guid,\n                    unzipDirectory=self.unzipdir,\n                    modelIdentifier=md.modelExchange.modelIdentifier,\n                    instanceName=self.instance_name\n                )\n        else:\n            raise ValueError(f\"Unsupported FMI version: {self.fmi_version}\")\n\n    def _build_variable_maps(self):\n        \"\"\"Build internal variable name to reference mappings.\"\"\"\n        self.variable_map = {var.name: var for var in self.model_description.modelVariables}\n        self.input_refs = {}\n        self.output_refs = {}\n\n        for variable in self.model_description.modelVariables:\n            if variable.causality == 'input':\n                self.input_refs[variable.name] = variable.valueReference\n            elif variable.causality == 'output':\n                self.output_refs[variable.name] = variable.valueReference\n\n    def _build_state_derivative_maps(self):\n        \"\"\"Build state and derivative value reference lists (Model Exchange only).\n\n        In FMI, state variables have a 'derivative' attribute pointing to their\n        derivative variable. This method extracts the ordered lists of value\n        references needed for Jacobian computation via directional derivatives.\n        \"\"\"\n        self._state_refs = []\n        self._derivative_refs = []\n\n        for var in self.model_description.modelVariables:\n            if var.derivative is not None:\n                # This variable is a state (it has a derivative)\n                self._state_refs.append(var.valueReference)\n                self._derivative_refs.append(var.derivative.valueReference)\n\n    # ===================================================================================\n    # CONVENIENCE METHODS FOR BLOCK INITIALIZATION\n    # ===================================================================================\n\n    def create_port_registers(self) -> Tuple[Register, Register]:\n        \"\"\"Create input and output registers for block I/O.\n\n        Returns\n        -------\n        inputs : Register\n            input register with FMU input variable names as labels\n        outputs : Register\n            output register with FMU output variable names as labels\n        \"\"\"\n        port_map_in = {name: idx for idx, name in enumerate(self.input_refs.keys())}\n        port_map_out = {name: idx for idx, name in enumerate(self.output_refs.keys())}\n\n        inputs = Register(size=len(port_map_in), mapping=port_map_in)\n        outputs = Register(size=len(port_map_out), mapping=port_map_out)\n\n        return inputs, outputs\n\n    def initialize(self, start_values=None, start_time=0.0, stop_time=None,\n                   tolerance=None) -> Optional[EventInfo]:\n        \"\"\"Complete FMU initialization sequence.\n\n        Performs: instantiate -> setup_experiment -> enter_initialization_mode\n        -> set start values -> exit_initialization_mode\n\n        Parameters\n        ----------\n        start_values : dict, optional\n            dictionary of variable names and their initial values\n        start_time : float, optional\n            simulation start time (default: 0.0)\n        stop_time : float, optional\n            simulation stop time\n        tolerance : float, optional\n            tolerance for integration/event detection\n\n        Returns\n        -------\n        event_info : EventInfo or None\n            event information for FMI 3.0 Model Exchange, None otherwise\n        \"\"\"\n        self.instantiate()\n        self.setup_experiment(tolerance=tolerance, start_time=start_time, stop_time=stop_time)\n        self.enter_initialization_mode()\n\n        if start_values:\n            for name, value in start_values.items():\n                self.set_variable(name, value)\n\n        return self.exit_initialization_mode()\n\n    @property\n    def default_step_size(self) -> Optional[float]:\n        \"\"\"Get default step size from FMU's default experiment, if defined.\"\"\"\n        de = self.model_description.defaultExperiment\n        if de is not None:\n            return getattr(de, 'stepSize', None)\n        return None\n\n    @property\n    def default_tolerance(self) -> Optional[float]:\n        \"\"\"Get default tolerance from FMU's default experiment, if defined.\"\"\"\n        de = self.model_description.defaultExperiment\n        if de is not None:\n            return getattr(de, 'tolerance', None)\n        return None\n\n    @property\n    def needs_completed_integrator_step(self) -> bool:\n        \"\"\"Check if FMU requires completedIntegratorStep notifications (Model Exchange only).\"\"\"\n        if self.mode != 'model_exchange':\n            return False\n        me = self.model_description.modelExchange\n        return not getattr(me, 'completedIntegratorStepNotNeeded', False)\n\n    @property\n    def provides_jacobian(self) -> bool:\n        \"\"\"Check if FMU provides directional derivatives for Jacobian computation.\"\"\"\n        if self.mode == 'model_exchange':\n            me = self.model_description.modelExchange\n            return getattr(me, 'providesDirectionalDerivative', False)\n        elif self.mode == 'cosimulation':\n            cs = self.model_description.coSimulation\n            return getattr(cs, 'providesDirectionalDerivative', False)\n        return False\n\n    def get_state_jacobian(self):\n        \"\"\"Compute Jacobian of state derivatives w.r.t. states (Model Exchange only).\n\n        Uses FMU's directional derivative capability to compute ∂ẋ/∂x.\n        Requires the FMU to have providesDirectionalDerivative=true.\n\n        Returns\n        -------\n        jacobian : np.ndarray\n            n_states x n_states Jacobian matrix, or None if not supported\n        \"\"\"\n        if self.mode != 'model_exchange':\n            raise RuntimeError(\"get_state_jacobian() is only available for Model Exchange FMUs\")\n\n        if not self.provides_jacobian:\n            return None\n\n        if self.n_states == 0:\n            return np.array([]).reshape(0, 0)\n\n        # Build Jacobian column by column using directional derivatives\n        jacobian = np.zeros((self.n_states, self.n_states))\n        seed = np.zeros(self.n_states)\n\n        for j in range(self.n_states):\n            seed[j] = 1.0\n            col = self.fmu.getDirectionalDerivative(\n                self._derivative_refs,\n                self._state_refs,\n                seed.tolist()\n            )\n            jacobian[:, j] = col\n            seed[j] = 0.0\n\n        return jacobian\n\n    # ===================================================================================\n    # FMU LIFECYCLE METHODS\n    # ===================================================================================\n\n    def instantiate(self, visible=False, logging_on=False):\n        \"\"\"Instantiate the FMU.\"\"\"\n        self.fmu.instantiate(visible=visible, loggingOn=logging_on)\n\n    def setup_experiment(self, tolerance=None, start_time=0.0, stop_time=None):\n        \"\"\"Setup experiment parameters.\"\"\"\n        self._tolerance = tolerance\n        self._start_time = start_time\n        self._stop_time = stop_time\n        self._ops.setup_experiment(self.fmu, tolerance, start_time, stop_time)\n\n    def enter_initialization_mode(self):\n        \"\"\"Enter initialization mode.\"\"\"\n        self._ops.enter_initialization_mode(\n            self.fmu, self._tolerance, self._start_time, self._stop_time\n        )\n\n    def exit_initialization_mode(self) -> Optional[EventInfo]:\n        \"\"\"Exit initialization mode and return event information.\"\"\"\n        return self._ops.exit_initialization_mode(self.fmu, self.mode)\n\n    def reset(self):\n        \"\"\"Reset FMU to initial state.\"\"\"\n        self.fmu.reset()\n\n    def terminate(self):\n        \"\"\"Terminate FMU.\"\"\"\n        self.fmu.terminate()\n\n    def free_instance(self):\n        \"\"\"Free FMU instance and resources.\"\"\"\n        self.fmu.freeInstance()\n\n    # ===================================================================================\n    # VARIABLE ACCESS METHODS\n    # ===================================================================================\n\n    def set_real(self, refs, values):\n        \"\"\"Set real-valued variables by reference.\"\"\"\n        values = np.atleast_1d(values)\n        self._ops.set_real(self.fmu, refs, values)\n\n    def get_real(self, refs):\n        \"\"\"Get real-valued variables by reference.\"\"\"\n        return np.array(self._ops.get_real(self.fmu, refs))\n\n    def set_variable(self, name, value):\n        \"\"\"Set a single variable by name (automatically detects type).\"\"\"\n        variable = self.variable_map.get(name)\n        if variable is None:\n            raise ValueError(f\"Variable '{name}' not found in FMU\")\n\n        vr = variable.valueReference\n        var_type = variable.type\n\n        if var_type in ['Real', 'Float64', 'Float32']:\n            self._ops.set_real(self.fmu, [vr], [float(value)])\n        elif var_type in ['Integer', 'Int64', 'Int32', 'Int16', 'Int8']:\n            self._ops.set_integer(self.fmu, [vr], [int(value)])\n        elif var_type == 'Boolean':\n            self.fmu.setBoolean([vr], [bool(value)])\n        else:\n            raise ValueError(f\"Unsupported variable type: {var_type}\")\n\n    def set_inputs_from_array(self, values):\n        \"\"\"Set all FMU inputs from an array.\"\"\"\n        if len(self.input_refs) > 0:\n            input_vrefs = list(self.input_refs.values())\n            self.set_real(input_vrefs, values)\n\n    def get_outputs_as_array(self):\n        \"\"\"Get all FMU outputs as an array.\"\"\"\n        if len(self.output_refs) == 0:\n            return np.array([])\n        output_vrefs = list(self.output_refs.values())\n        return self.get_real(output_vrefs)\n\n    # ===================================================================================\n    # CO-SIMULATION METHODS\n    # ===================================================================================\n\n    def do_step(self, current_time, step_size) -> StepResult:\n        \"\"\"Perform a co-simulation step.\"\"\"\n        if self.mode != 'cosimulation':\n            raise RuntimeError(\"do_step() is only available for Co-Simulation FMUs\")\n        return self._ops.do_step(self.fmu, current_time, step_size)\n\n    # ===================================================================================\n    # MODEL EXCHANGE METHODS\n    # ===================================================================================\n\n    def set_time(self, time):\n        \"\"\"Set current time (Model Exchange only).\"\"\"\n        if self.mode != 'model_exchange':\n            raise RuntimeError(\"set_time() is only available for Model Exchange FMUs\")\n        self.fmu.setTime(time)\n\n    def set_continuous_states(self, states):\n        \"\"\"Set continuous states (Model Exchange only).\"\"\"\n        if self.mode != 'model_exchange':\n            raise RuntimeError(\"set_continuous_states() is only available for Model Exchange FMUs\")\n        if self.n_states == 0:\n            return\n        states = np.atleast_1d(states)\n        x_ctypes = (ctypes.c_double * self.n_states)(*states)\n        self.fmu.setContinuousStates(x_ctypes, self.n_states)\n\n    def get_continuous_states(self):\n        \"\"\"Get continuous states (Model Exchange only).\"\"\"\n        if self.mode != 'model_exchange':\n            raise RuntimeError(\"get_continuous_states() is only available for Model Exchange FMUs\")\n        if self.n_states == 0:\n            return np.array([])\n        states = (ctypes.c_double * self.n_states)()\n        self.fmu.getContinuousStates(states, self.n_states)\n        return np.array(states)\n\n    def get_derivatives(self):\n        \"\"\"Get state derivatives (Model Exchange only).\"\"\"\n        if self.mode != 'model_exchange':\n            raise RuntimeError(\"get_derivatives() is only available for Model Exchange FMUs\")\n        return self._ops.get_derivatives(self.fmu, self.n_states)\n\n    def get_event_indicators(self):\n        \"\"\"Get event indicators (Model Exchange only).\"\"\"\n        if self.mode != 'model_exchange':\n            raise RuntimeError(\"get_event_indicators() is only available for Model Exchange FMUs\")\n        if self.n_event_indicators == 0:\n            return np.array([])\n        indicators = (ctypes.c_double * self.n_event_indicators)()\n        self.fmu.getEventIndicators(indicators, self.n_event_indicators)\n        return np.array(indicators)\n\n    def enter_event_mode(self):\n        \"\"\"Enter event mode (Model Exchange only).\"\"\"\n        if self.mode != 'model_exchange':\n            raise RuntimeError(\"enter_event_mode() is only available for Model Exchange FMUs\")\n        self.fmu.enterEventMode()\n\n    def enter_continuous_time_mode(self):\n        \"\"\"Enter continuous time mode (Model Exchange only).\"\"\"\n        if self.mode != 'model_exchange':\n            raise RuntimeError(\"enter_continuous_time_mode() is only available for Model Exchange FMUs\")\n        self.fmu.enterContinuousTimeMode()\n\n    def update_discrete_states(self) -> EventInfo:\n        \"\"\"Update discrete states during event iteration (Model Exchange only).\"\"\"\n        if self.mode != 'model_exchange':\n            raise RuntimeError(\"update_discrete_states() is only available for Model Exchange FMUs\")\n        return self._ops.update_discrete_states(self.fmu)\n\n    def completed_integrator_step(self) -> Tuple[bool, bool]:\n        \"\"\"Notify FMU that integrator step completed (Model Exchange only).\n\n        Returns\n        -------\n        enter_event_mode : bool\n            whether FMU requests event mode\n        terminate_simulation : bool\n            whether FMU requests simulation termination\n        \"\"\"\n        if self.mode != 'model_exchange':\n            raise RuntimeError(\"completed_integrator_step() is only available for Model Exchange FMUs\")\n        return self.fmu.completedIntegratorStep()\n\n    def __del__(self):\n        \"\"\"Cleanup FMU resources on deletion.\"\"\"\n        try:\n            self.terminate()\n            self.free_instance()\n        except:\n            pass",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, fmu_path, instance_name=\"fmu_instance\", mode=\"cosimulation\"):\n\n    # Import FMPy (lazy import to avoid dependency if not used)\n    try:\n        from fmpy import read_model_description, extract\n        from fmpy.fmi2 import FMU2Slave, FMU2Model\n        from fmpy.fmi3 import FMU3Slave, FMU3Model\n    except ImportError:\n        raise ImportError(\"FMPy is required for FMU support. Install with: pip install fmpy\")\n\n    self.fmu_path = fmu_path\n    self.instance_name = instance_name\n    self.mode = mode.lower()\n\n    if self.mode not in ['cosimulation', 'model_exchange']:\n        raise ValueError(f\"Invalid mode '{mode}'. Must be 'cosimulation' or 'model_exchange'\")\n\n    # Read model description and detect FMI version\n    self.model_description = read_model_description(fmu_path)\n    self.fmi_version = self.model_description.fmiVersion\n\n    # Select version-specific operations\n    self._ops = _FMI2Ops if self.fmi_version.startswith('2.') else _FMI3Ops\n\n    # Extract FMU\n    self.unzipdir = extract(fmu_path)\n\n    # Build variable lookup maps\n    self._build_variable_maps()\n\n    # Get state and event info for Model Exchange\n    if self.mode == 'model_exchange':\n        self.n_states = self.model_description.numberOfContinuousStates\n        self.n_event_indicators = self.model_description.numberOfEventIndicators\n        self._build_state_derivative_maps()\n    else:\n        self.n_states = 0\n        self.n_event_indicators = 0\n        self._state_refs = []\n        self._derivative_refs = []\n\n    # Instantiate appropriate FMU class based on version and mode\n    self.fmu = self._create_fmu_instance(FMU2Slave, FMU2Model, FMU3Slave, FMU3Model)",
              "signature": "(fmu_path, instance_name = 'fmu_instance', mode = 'cosimulation')",
              "parameters": [
                {
                  "name": "fmu_path",
                  "type": null,
                  "default": null,
                  "description": ""
                },
                {
                  "name": "instance_name",
                  "type": null,
                  "default": "'fmu_instance'",
                  "description": ""
                },
                {
                  "name": "mode",
                  "type": null,
                  "default": "'cosimulation'",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "_create_fmu_instance",
              "description": "Create the appropriate FMU instance based on version and mode.",
              "docstring_html": "<p>Create the appropriate FMU instance based on version and mode.</p>\n",
              "source": "def _create_fmu_instance(self, FMU2Slave, FMU2Model, FMU3Slave, FMU3Model):\n    \"\"\"Create the appropriate FMU instance based on version and mode.\"\"\"\n    md = self.model_description\n\n    if self.fmi_version.startswith('2.'):\n        if self.mode == 'cosimulation':\n            return FMU2Slave(\n                guid=md.guid,\n                unzipDirectory=self.unzipdir,\n                modelIdentifier=md.coSimulation.modelIdentifier,\n                instanceName=self.instance_name\n            )\n        else:\n            return FMU2Model(\n                guid=md.guid,\n                unzipDirectory=self.unzipdir,\n                modelIdentifier=md.modelExchange.modelIdentifier,\n                instanceName=self.instance_name\n            )\n    elif self.fmi_version.startswith('3.'):\n        if self.mode == 'cosimulation':\n            return FMU3Slave(\n                guid=md.guid,\n                unzipDirectory=self.unzipdir,\n                modelIdentifier=md.coSimulation.modelIdentifier,\n                instanceName=self.instance_name\n            )\n        else:\n            return FMU3Model(\n                guid=md.guid,\n                unzipDirectory=self.unzipdir,\n                modelIdentifier=md.modelExchange.modelIdentifier,\n                instanceName=self.instance_name\n            )\n    else:\n        raise ValueError(f\"Unsupported FMI version: {self.fmi_version}\")",
              "signature": "(FMU2Slave, FMU2Model, FMU3Slave, FMU3Model)",
              "parameters": [
                {
                  "name": "FMU2Slave",
                  "type": null,
                  "default": null,
                  "description": ""
                },
                {
                  "name": "FMU2Model",
                  "type": null,
                  "default": null,
                  "description": ""
                },
                {
                  "name": "FMU3Slave",
                  "type": null,
                  "default": null,
                  "description": ""
                },
                {
                  "name": "FMU3Model",
                  "type": null,
                  "default": null,
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "_build_variable_maps",
              "description": "Build internal variable name to reference mappings.",
              "docstring_html": "<p>Build internal variable name to reference mappings.</p>\n",
              "source": "def _build_variable_maps(self):\n    \"\"\"Build internal variable name to reference mappings.\"\"\"\n    self.variable_map = {var.name: var for var in self.model_description.modelVariables}\n    self.input_refs = {}\n    self.output_refs = {}\n\n    for variable in self.model_description.modelVariables:\n        if variable.causality == 'input':\n            self.input_refs[variable.name] = variable.valueReference\n        elif variable.causality == 'output':\n            self.output_refs[variable.name] = variable.valueReference",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "_build_state_derivative_maps",
              "description": "Build state and derivative value reference lists (Model Exchange only).",
              "docstring_html": "<p>Build state and derivative value reference lists (Model Exchange only).</p>\n<p>In FMI, state variables have a 'derivative' attribute pointing to their\nderivative variable. This method extracts the ordered lists of value\nreferences needed for Jacobian computation via directional derivatives.</p>\n",
              "source": "def _build_state_derivative_maps(self):\n    \"\"\"Build state and derivative value reference lists (Model Exchange only).\n\n    In FMI, state variables have a 'derivative' attribute pointing to their\n    derivative variable. This method extracts the ordered lists of value\n    references needed for Jacobian computation via directional derivatives.\n    \"\"\"\n    self._state_refs = []\n    self._derivative_refs = []\n\n    for var in self.model_description.modelVariables:\n        if var.derivative is not None:\n            # This variable is a state (it has a derivative)\n            self._state_refs.append(var.valueReference)\n            self._derivative_refs.append(var.derivative.valueReference)",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "create_port_registers",
              "description": "Create input and output registers for block I/O.",
              "docstring_html": "<p>Create input and output registers for block I/O.</p>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>inputs <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">Register</span></dt>\n<dd>input register with FMU input variable names as labels</dd>\n<dt>outputs <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">Register</span></dt>\n<dd>output register with FMU output variable names as labels</dd>\n</dl>\n",
              "source": "def create_port_registers(self) -> Tuple[Register, Register]:\n    \"\"\"Create input and output registers for block I/O.\n\n    Returns\n    -------\n    inputs : Register\n        input register with FMU input variable names as labels\n    outputs : Register\n        output register with FMU output variable names as labels\n    \"\"\"\n    port_map_in = {name: idx for idx, name in enumerate(self.input_refs.keys())}\n    port_map_out = {name: idx for idx, name in enumerate(self.output_refs.keys())}\n\n    inputs = Register(size=len(port_map_in), mapping=port_map_in)\n    outputs = Register(size=len(port_map_out), mapping=port_map_out)\n\n    return inputs, outputs",
              "signature": "()",
              "parameters": [],
              "returns": "Tuple[Register, Register]",
              "method_type": "method"
            },
            {
              "name": "initialize",
              "description": "Complete FMU initialization sequence.",
              "docstring_html": "<p>Complete FMU initialization sequence.</p>\n<p>Performs: instantiate -&gt; setup_experiment -&gt; enter_initialization_mode\n-&gt; set start values -&gt; exit_initialization_mode</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>start_values <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">dict, optional</span></dt>\n<dd>dictionary of variable names and their initial values</dd>\n<dt>start_time <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float, optional</span></dt>\n<dd>simulation start time (default: 0.0)</dd>\n<dt>stop_time <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float, optional</span></dt>\n<dd>simulation stop time</dd>\n<dt>tolerance <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float, optional</span></dt>\n<dd>tolerance for integration/event detection</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>event_info <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">EventInfo or None</span></dt>\n<dd>event information for FMI 3.0 Model Exchange, None otherwise</dd>\n</dl>\n",
              "source": "def initialize(self, start_values=None, start_time=0.0, stop_time=None,\n               tolerance=None) -> Optional[EventInfo]:\n    \"\"\"Complete FMU initialization sequence.\n\n    Performs: instantiate -> setup_experiment -> enter_initialization_mode\n    -> set start values -> exit_initialization_mode\n\n    Parameters\n    ----------\n    start_values : dict, optional\n        dictionary of variable names and their initial values\n    start_time : float, optional\n        simulation start time (default: 0.0)\n    stop_time : float, optional\n        simulation stop time\n    tolerance : float, optional\n        tolerance for integration/event detection\n\n    Returns\n    -------\n    event_info : EventInfo or None\n        event information for FMI 3.0 Model Exchange, None otherwise\n    \"\"\"\n    self.instantiate()\n    self.setup_experiment(tolerance=tolerance, start_time=start_time, stop_time=stop_time)\n    self.enter_initialization_mode()\n\n    if start_values:\n        for name, value in start_values.items():\n            self.set_variable(name, value)\n\n    return self.exit_initialization_mode()",
              "signature": "(start_values = None, start_time = 0.0, stop_time = None, tolerance = None)",
              "parameters": [
                {
                  "name": "start_values",
                  "type": null,
                  "default": "None",
                  "description": "dictionary of variable names and their initial values"
                },
                {
                  "name": "start_time",
                  "type": null,
                  "default": "0.0",
                  "description": "simulation start time (default: 0.0)"
                },
                {
                  "name": "stop_time",
                  "type": null,
                  "default": "None",
                  "description": "simulation stop time"
                },
                {
                  "name": "tolerance",
                  "type": null,
                  "default": "None",
                  "description": "tolerance for integration/event detection"
                }
              ],
              "returns": "Optional[EventInfo]",
              "method_type": "method"
            },
            {
              "name": "get_state_jacobian",
              "description": "Compute Jacobian of state derivatives w.r.t. states (Model Exchange only).",
              "docstring_html": "<p>Compute Jacobian of state derivatives w.r.t. states (Model Exchange only).</p>\n<p>Uses FMU's directional derivative capability to compute ∂ẋ/∂x.\nRequires the FMU to have providesDirectionalDerivative=true.</p>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>jacobian <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">np.ndarray</span></dt>\n<dd>n_states x n_states Jacobian matrix, or None if not supported</dd>\n</dl>\n",
              "source": "def get_state_jacobian(self):\n    \"\"\"Compute Jacobian of state derivatives w.r.t. states (Model Exchange only).\n\n    Uses FMU's directional derivative capability to compute ∂ẋ/∂x.\n    Requires the FMU to have providesDirectionalDerivative=true.\n\n    Returns\n    -------\n    jacobian : np.ndarray\n        n_states x n_states Jacobian matrix, or None if not supported\n    \"\"\"\n    if self.mode != 'model_exchange':\n        raise RuntimeError(\"get_state_jacobian() is only available for Model Exchange FMUs\")\n\n    if not self.provides_jacobian:\n        return None\n\n    if self.n_states == 0:\n        return np.array([]).reshape(0, 0)\n\n    # Build Jacobian column by column using directional derivatives\n    jacobian = np.zeros((self.n_states, self.n_states))\n    seed = np.zeros(self.n_states)\n\n    for j in range(self.n_states):\n        seed[j] = 1.0\n        col = self.fmu.getDirectionalDerivative(\n            self._derivative_refs,\n            self._state_refs,\n            seed.tolist()\n        )\n        jacobian[:, j] = col\n        seed[j] = 0.0\n\n    return jacobian",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "instantiate",
              "description": "Instantiate the FMU.",
              "docstring_html": "<p>Instantiate the FMU.</p>\n",
              "source": "def instantiate(self, visible=False, logging_on=False):\n    \"\"\"Instantiate the FMU.\"\"\"\n    self.fmu.instantiate(visible=visible, loggingOn=logging_on)",
              "signature": "(visible = False, logging_on = False)",
              "parameters": [
                {
                  "name": "visible",
                  "type": null,
                  "default": "False",
                  "description": ""
                },
                {
                  "name": "logging_on",
                  "type": null,
                  "default": "False",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "setup_experiment",
              "description": "Setup experiment parameters.",
              "docstring_html": "<p>Setup experiment parameters.</p>\n",
              "source": "def setup_experiment(self, tolerance=None, start_time=0.0, stop_time=None):\n    \"\"\"Setup experiment parameters.\"\"\"\n    self._tolerance = tolerance\n    self._start_time = start_time\n    self._stop_time = stop_time\n    self._ops.setup_experiment(self.fmu, tolerance, start_time, stop_time)",
              "signature": "(tolerance = None, start_time = 0.0, stop_time = None)",
              "parameters": [
                {
                  "name": "tolerance",
                  "type": null,
                  "default": "None",
                  "description": ""
                },
                {
                  "name": "start_time",
                  "type": null,
                  "default": "0.0",
                  "description": ""
                },
                {
                  "name": "stop_time",
                  "type": null,
                  "default": "None",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "enter_initialization_mode",
              "description": "Enter initialization mode.",
              "docstring_html": "<p>Enter initialization mode.</p>\n",
              "source": "def enter_initialization_mode(self):\n    \"\"\"Enter initialization mode.\"\"\"\n    self._ops.enter_initialization_mode(\n        self.fmu, self._tolerance, self._start_time, self._stop_time\n    )",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "exit_initialization_mode",
              "description": "Exit initialization mode and return event information.",
              "docstring_html": "<p>Exit initialization mode and return event information.</p>\n",
              "source": "def exit_initialization_mode(self) -> Optional[EventInfo]:\n    \"\"\"Exit initialization mode and return event information.\"\"\"\n    return self._ops.exit_initialization_mode(self.fmu, self.mode)",
              "signature": "()",
              "parameters": [],
              "returns": "Optional[EventInfo]",
              "method_type": "method"
            },
            {
              "name": "reset",
              "description": "Reset FMU to initial state.",
              "docstring_html": "<p>Reset FMU to initial state.</p>\n",
              "source": "def reset(self):\n    \"\"\"Reset FMU to initial state.\"\"\"\n    self.fmu.reset()",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "terminate",
              "description": "Terminate FMU.",
              "docstring_html": "<p>Terminate FMU.</p>\n",
              "source": "def terminate(self):\n    \"\"\"Terminate FMU.\"\"\"\n    self.fmu.terminate()",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "free_instance",
              "description": "Free FMU instance and resources.",
              "docstring_html": "<p>Free FMU instance and resources.</p>\n",
              "source": "def free_instance(self):\n    \"\"\"Free FMU instance and resources.\"\"\"\n    self.fmu.freeInstance()",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "set_real",
              "description": "Set real-valued variables by reference.",
              "docstring_html": "<p>Set real-valued variables by reference.</p>\n",
              "source": "def set_real(self, refs, values):\n    \"\"\"Set real-valued variables by reference.\"\"\"\n    values = np.atleast_1d(values)\n    self._ops.set_real(self.fmu, refs, values)",
              "signature": "(refs, values)",
              "parameters": [
                {
                  "name": "refs",
                  "type": null,
                  "default": null,
                  "description": ""
                },
                {
                  "name": "values",
                  "type": null,
                  "default": null,
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "get_real",
              "description": "Get real-valued variables by reference.",
              "docstring_html": "<p>Get real-valued variables by reference.</p>\n",
              "source": "def get_real(self, refs):\n    \"\"\"Get real-valued variables by reference.\"\"\"\n    return np.array(self._ops.get_real(self.fmu, refs))",
              "signature": "(refs)",
              "parameters": [
                {
                  "name": "refs",
                  "type": null,
                  "default": null,
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "set_variable",
              "description": "Set a single variable by name (automatically detects type).",
              "docstring_html": "<p>Set a single variable by name (automatically detects type).</p>\n",
              "source": "def set_variable(self, name, value):\n    \"\"\"Set a single variable by name (automatically detects type).\"\"\"\n    variable = self.variable_map.get(name)\n    if variable is None:\n        raise ValueError(f\"Variable '{name}' not found in FMU\")\n\n    vr = variable.valueReference\n    var_type = variable.type\n\n    if var_type in ['Real', 'Float64', 'Float32']:\n        self._ops.set_real(self.fmu, [vr], [float(value)])\n    elif var_type in ['Integer', 'Int64', 'Int32', 'Int16', 'Int8']:\n        self._ops.set_integer(self.fmu, [vr], [int(value)])\n    elif var_type == 'Boolean':\n        self.fmu.setBoolean([vr], [bool(value)])\n    else:\n        raise ValueError(f\"Unsupported variable type: {var_type}\")",
              "signature": "(name, value)",
              "parameters": [
                {
                  "name": "name",
                  "type": null,
                  "default": null,
                  "description": ""
                },
                {
                  "name": "value",
                  "type": null,
                  "default": null,
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "set_inputs_from_array",
              "description": "Set all FMU inputs from an array.",
              "docstring_html": "<p>Set all FMU inputs from an array.</p>\n",
              "source": "def set_inputs_from_array(self, values):\n    \"\"\"Set all FMU inputs from an array.\"\"\"\n    if len(self.input_refs) > 0:\n        input_vrefs = list(self.input_refs.values())\n        self.set_real(input_vrefs, values)",
              "signature": "(values)",
              "parameters": [
                {
                  "name": "values",
                  "type": null,
                  "default": null,
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "get_outputs_as_array",
              "description": "Get all FMU outputs as an array.",
              "docstring_html": "<p>Get all FMU outputs as an array.</p>\n",
              "source": "def get_outputs_as_array(self):\n    \"\"\"Get all FMU outputs as an array.\"\"\"\n    if len(self.output_refs) == 0:\n        return np.array([])\n    output_vrefs = list(self.output_refs.values())\n    return self.get_real(output_vrefs)",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "do_step",
              "description": "Perform a co-simulation step.",
              "docstring_html": "<p>Perform a co-simulation step.</p>\n",
              "source": "def do_step(self, current_time, step_size) -> StepResult:\n    \"\"\"Perform a co-simulation step.\"\"\"\n    if self.mode != 'cosimulation':\n        raise RuntimeError(\"do_step() is only available for Co-Simulation FMUs\")\n    return self._ops.do_step(self.fmu, current_time, step_size)",
              "signature": "(current_time, step_size)",
              "parameters": [
                {
                  "name": "current_time",
                  "type": null,
                  "default": null,
                  "description": ""
                },
                {
                  "name": "step_size",
                  "type": null,
                  "default": null,
                  "description": ""
                }
              ],
              "returns": "StepResult",
              "method_type": "method"
            },
            {
              "name": "set_time",
              "description": "Set current time (Model Exchange only).",
              "docstring_html": "<p>Set current time (Model Exchange only).</p>\n",
              "source": "def set_time(self, time):\n    \"\"\"Set current time (Model Exchange only).\"\"\"\n    if self.mode != 'model_exchange':\n        raise RuntimeError(\"set_time() is only available for Model Exchange FMUs\")\n    self.fmu.setTime(time)",
              "signature": "(time)",
              "parameters": [
                {
                  "name": "time",
                  "type": null,
                  "default": null,
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "set_continuous_states",
              "description": "Set continuous states (Model Exchange only).",
              "docstring_html": "<p>Set continuous states (Model Exchange only).</p>\n",
              "source": "def set_continuous_states(self, states):\n    \"\"\"Set continuous states (Model Exchange only).\"\"\"\n    if self.mode != 'model_exchange':\n        raise RuntimeError(\"set_continuous_states() is only available for Model Exchange FMUs\")\n    if self.n_states == 0:\n        return\n    states = np.atleast_1d(states)\n    x_ctypes = (ctypes.c_double * self.n_states)(*states)\n    self.fmu.setContinuousStates(x_ctypes, self.n_states)",
              "signature": "(states)",
              "parameters": [
                {
                  "name": "states",
                  "type": null,
                  "default": null,
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "get_continuous_states",
              "description": "Get continuous states (Model Exchange only).",
              "docstring_html": "<p>Get continuous states (Model Exchange only).</p>\n",
              "source": "def get_continuous_states(self):\n    \"\"\"Get continuous states (Model Exchange only).\"\"\"\n    if self.mode != 'model_exchange':\n        raise RuntimeError(\"get_continuous_states() is only available for Model Exchange FMUs\")\n    if self.n_states == 0:\n        return np.array([])\n    states = (ctypes.c_double * self.n_states)()\n    self.fmu.getContinuousStates(states, self.n_states)\n    return np.array(states)",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "get_derivatives",
              "description": "Get state derivatives (Model Exchange only).",
              "docstring_html": "<p>Get state derivatives (Model Exchange only).</p>\n",
              "source": "def get_derivatives(self):\n    \"\"\"Get state derivatives (Model Exchange only).\"\"\"\n    if self.mode != 'model_exchange':\n        raise RuntimeError(\"get_derivatives() is only available for Model Exchange FMUs\")\n    return self._ops.get_derivatives(self.fmu, self.n_states)",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "get_event_indicators",
              "description": "Get event indicators (Model Exchange only).",
              "docstring_html": "<p>Get event indicators (Model Exchange only).</p>\n",
              "source": "def get_event_indicators(self):\n    \"\"\"Get event indicators (Model Exchange only).\"\"\"\n    if self.mode != 'model_exchange':\n        raise RuntimeError(\"get_event_indicators() is only available for Model Exchange FMUs\")\n    if self.n_event_indicators == 0:\n        return np.array([])\n    indicators = (ctypes.c_double * self.n_event_indicators)()\n    self.fmu.getEventIndicators(indicators, self.n_event_indicators)\n    return np.array(indicators)",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "enter_event_mode",
              "description": "Enter event mode (Model Exchange only).",
              "docstring_html": "<p>Enter event mode (Model Exchange only).</p>\n",
              "source": "def enter_event_mode(self):\n    \"\"\"Enter event mode (Model Exchange only).\"\"\"\n    if self.mode != 'model_exchange':\n        raise RuntimeError(\"enter_event_mode() is only available for Model Exchange FMUs\")\n    self.fmu.enterEventMode()",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "enter_continuous_time_mode",
              "description": "Enter continuous time mode (Model Exchange only).",
              "docstring_html": "<p>Enter continuous time mode (Model Exchange only).</p>\n",
              "source": "def enter_continuous_time_mode(self):\n    \"\"\"Enter continuous time mode (Model Exchange only).\"\"\"\n    if self.mode != 'model_exchange':\n        raise RuntimeError(\"enter_continuous_time_mode() is only available for Model Exchange FMUs\")\n    self.fmu.enterContinuousTimeMode()",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "update_discrete_states",
              "description": "Update discrete states during event iteration (Model Exchange only).",
              "docstring_html": "<p>Update discrete states during event iteration (Model Exchange only).</p>\n",
              "source": "def update_discrete_states(self) -> EventInfo:\n    \"\"\"Update discrete states during event iteration (Model Exchange only).\"\"\"\n    if self.mode != 'model_exchange':\n        raise RuntimeError(\"update_discrete_states() is only available for Model Exchange FMUs\")\n    return self._ops.update_discrete_states(self.fmu)",
              "signature": "()",
              "parameters": [],
              "returns": "EventInfo",
              "method_type": "method"
            },
            {
              "name": "completed_integrator_step",
              "description": "Notify FMU that integrator step completed (Model Exchange only).",
              "docstring_html": "<p>Notify FMU that integrator step completed (Model Exchange only).</p>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>enter_event_mode <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>whether FMU requests event mode</dd>\n<dt>terminate_simulation <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>whether FMU requests simulation termination</dd>\n</dl>\n",
              "source": "def completed_integrator_step(self) -> Tuple[bool, bool]:\n    \"\"\"Notify FMU that integrator step completed (Model Exchange only).\n\n    Returns\n    -------\n    enter_event_mode : bool\n        whether FMU requests event mode\n    terminate_simulation : bool\n        whether FMU requests simulation termination\n    \"\"\"\n    if self.mode != 'model_exchange':\n        raise RuntimeError(\"completed_integrator_step() is only available for Model Exchange FMUs\")\n    return self.fmu.completedIntegratorStep()",
              "signature": "()",
              "parameters": [],
              "returns": "Tuple[bool, bool]",
              "method_type": "method"
            },
            {
              "name": "__del__",
              "description": "Cleanup FMU resources on deletion.",
              "docstring_html": "<p>Cleanup FMU resources on deletion.</p>\n",
              "source": "def __del__(self):\n    \"\"\"Cleanup FMU resources on deletion.\"\"\"\n    try:\n        self.terminate()\n        self.free_instance()\n    except:\n        pass",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "fmu_path",
              "description": "",
              "type": null,
              "value": "fmu_path"
            },
            {
              "name": "instance_name",
              "description": "",
              "type": null,
              "value": "instance_name"
            },
            {
              "name": "mode",
              "description": "",
              "type": null,
              "value": "mode.lower()"
            },
            {
              "name": "model_description",
              "description": "",
              "type": null,
              "value": "read_model_description(fmu_path)"
            },
            {
              "name": "fmi_version",
              "description": "",
              "type": null,
              "value": "self.model_description.fmiVersion"
            },
            {
              "name": "_ops",
              "description": "",
              "type": null,
              "value": "_FMI2Ops if self.fmi_version.startswith('2.') else _FMI3Ops"
            },
            {
              "name": "unzipdir",
              "description": "",
              "type": null,
              "value": "extract(fmu_path)"
            },
            {
              "name": "n_states",
              "description": "",
              "type": null,
              "value": "self.model_description.numberOfContinuousStates"
            },
            {
              "name": "n_event_indicators",
              "description": "",
              "type": null,
              "value": "self.model_description.numberOfEventIndicators"
            },
            {
              "name": "_state_refs",
              "description": "",
              "type": null,
              "value": "[]"
            },
            {
              "name": "_derivative_refs",
              "description": "",
              "type": null,
              "value": "[]"
            },
            {
              "name": "fmu",
              "description": "",
              "type": null,
              "value": "self._create_fmu_instance(FMU2Slave, FMU2Model, FMU3Slave, FMU3Model)"
            },
            {
              "name": "default_step_size",
              "description": "Get default step size from FMU's default experiment, if defined.",
              "type": "Optional[float]",
              "value": null
            },
            {
              "name": "default_tolerance",
              "description": "Get default tolerance from FMU's default experiment, if defined.",
              "type": "Optional[float]",
              "value": null
            },
            {
              "name": "needs_completed_integrator_step",
              "description": "Check if FMU requires completedIntegratorStep notifications (Model Exchange only).",
              "type": "bool",
              "value": null
            },
            {
              "name": "provides_jacobian",
              "description": "Check if FMU provides directional derivatives for Jacobian computation.",
              "type": "bool",
              "value": null
            }
          ],
          "parameters": [
            {
              "name": "fmu_path",
              "type": null,
              "default": null,
              "description": "path to the FMU file (.fmu)"
            },
            {
              "name": "instance_name",
              "type": null,
              "default": "'fmu_instance'",
              "description": "name for the FMU instance (default: 'fmu_instance')"
            },
            {
              "name": "mode",
              "type": null,
              "default": "'cosimulation'",
              "description": "FMU interface mode: 'cosimulation' or 'model_exchange' (default: 'cosimulation')"
            }
          ]
        }
      ],
      "functions": []
    },
    "pathsim.utils.gilbert": {
      "name": "pathsim.utils.gilbert",
      "description": "",
      "docstring_html": "",
      "classes": [],
      "functions": [
        {
          "name": "gilbert_realization",
          "description": "Build real valued statespace model from transfer function",
          "docstring_html": "<p>Build real valued statespace model from transfer function\nin pole residue form by Gilbert's method and an additional\nsimilarity transformation to get fully real valued matrices.</p>\n<p>pole residue form:</p>\n<pre class=\"math\">\n\\mathbf{H}(s) = \\mathbf{D} + \\sum_{n=1}^N \\frac{\\mathbf{R}_n}{s - p_n}\n</pre>\n<p>statespace form:</p>\n<pre class=\"math\">\n\\mathbf{H}(s) = \\mathbf{C} (s \\mathbf{I} - \\mathbf{A})^{-1} \\mathbf{B} + \\mathbf{D}\n</pre>\n<p><strong>Notes</strong></p>\n<p>The resulting system is identical to the so-called\n'Modal Form' and is a minimal realization.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>Poles <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array</span></dt>\n<dd>real and complex poles</dd>\n<dt>Residues <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array</span></dt>\n<dd>array of real and complex residue matrices</dd>\n<dt>Const <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array</span></dt>\n<dd>matrix for constant term</dd>\n<dt>tolerance <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>relative tolerance for checking real poles</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>A <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array</span></dt>\n<dd>state matrix</dd>\n<dt>B <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array</span></dt>\n<dd>input mapping matrix</dd>\n<dt>C <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array</span></dt>\n<dd>state to output projection matrix</dd>\n<dt>D <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array, float</span></dt>\n<dd>direct passthrough</dd>\n</dl>\n<div class=\"section\" id=\"note\">\n<h4>Note</h4>\n<p>If some poles are complex-valued, their conjugate-values are automatically\nadded if missing, to enforce the model realness and stability.</p>\n</div>\n",
          "source": "def gilbert_realization(Poles=[], Residues=[], Const=0.0, tolerance=1e-9): \n    \"\"\"Build real valued statespace model from transfer function \n    in pole residue form by Gilbert's method and an additional\n    similarity transformation to get fully real valued matrices.\n\n    pole residue form:\n\n    .. math::\n\n        \\\\mathbf{H}(s) = \\\\mathbf{D} + \\\\sum_{n=1}^N \\\\frac{\\\\mathbf{R}_n}{s - p_n}\n\n    statespace form:\n\n    .. math::\n\n        \\\\mathbf{H}(s) = \\\\mathbf{C} (s \\\\mathbf{I} - \\\\mathbf{A})^{-1} \\\\mathbf{B} + \\\\mathbf{D} \n\n    Notes\n    -----  \n    The resulting system is identical to the so-called \n    'Modal Form' and is a minimal realization.\n\n    Parameters\n    ---------- \n    Poles : array\n        real and complex poles\n    Residues : array\n        array of real and complex residue matrices\n    Const : array\n        matrix for constant term\n    tolerance : float\n        relative tolerance for checking real poles\n\n    Returns \n    -------\n    A : array\n        state matrix\n    B : array \n        input mapping matrix\n    C : array\n        state to output projection matrix\n    D : array, float\n        direct passthrough\n\n    Note\n    ----\n    If some poles are complex-valued, their conjugate-values are automatically\n    added if missing, to enforce the model realness and stability.\n\n    \"\"\"\n\n    #make arrays\n    Poles = np.atleast_1d(Poles)\n    Residues = np.atleast_1d(Residues)\n\n    #check validity of args\n    if not len(Poles) or not len(Residues):\n        raise ValueError(\"No 'Poles' and 'Residues' defined!\")\n\n    if len(Poles) != len(Residues):\n        raise ValueError(\"Same number of 'Poles' and 'Residues' have to be given!\")\n\n    #go through poles and handle missing conjugate pairs if any\n    _Poles, _Residues = [], []\n    for p, R in zip(Poles, Residues):\n        # real pole\n        if np.isreal(p) or abs(np.imag(p) / np.real(p)) < tolerance:\n            _Poles.append(p.real)\n            _Residues.append(R.real)\n        # complex pole\n        else:\n            if not p in _Poles:\n                _Poles.append(p)\n                _Residues.append(R)\n            # add eventual missing conjugate pair\n            if not np.conj(p) in _Poles:\n                _Poles.append(np.conj(p))\n                _Residues.append(np.conj(R))\n    _Poles = np.asarray(_Poles)\n    _Residues = np.asarray(_Residues)\n\n    #check shape of residues for MIMO, etc\n    if _Residues.ndim == 1:\n        N, m, n = _Residues.size, 1, 1\n        _Residues = np.reshape(_Residues, (N, m, n))\n    elif _Residues.ndim == 2:\n        N, m, n = *_Residues.shape, 1\n        _Residues = np.reshape(_Residues, (N, m, n))\n    elif _Residues.ndim == 3:\n        N, m, n = _Residues.shape\n    else:\n        raise ValueError(f\"shape mismatch of 'Residues': Residues.shape={_Residues.shape}\")\n\n    #initialize companion matrix\n    a = np.zeros((N, N))\n    b = np.zeros(N)\n\n    #residues\n    C = np.ones((m, n*N))\n\n    #build real companion matrix from the poles\n    p_old = 0.0\n    for k, (p, R) in enumerate(zip(_Poles, _Residues)):\n\n        #check if complex conjugate\n        is_cc = (p.imag != 0.0 and p == np.conj(p_old))\n        p_old = p\n\n        a[k,k] = np.real(p)\n        b[k] = 1.0\n        if is_cc:\n            a[k, k-1] = - np.imag(p)\n            a[k-1, k] = np.imag(p)\n            b[k]   = 0.0\n            b[k-1] = 2.0\n\n        #iterate columns of residue\n        for i in range(n):\n            C[:,k+N*i] = np.imag(R[:,i]) if is_cc else np.real(R[:,i])  \n\n    #build block diagonal\n    A = np.kron(np.eye(n, dtype=float), a)\n    B = np.kron(np.eye(n, dtype=float), b).T\n    D = Const * np.ones((m, n)) if np.isscalar(Const) else Const\n\n    return  A, B, C, D",
          "signature": "(Poles = [], Residues = [], Const = 0.0, tolerance = 1e-09)",
          "parameters": [
            {
              "name": "Poles",
              "type": null,
              "default": "[]",
              "description": "real and complex poles"
            },
            {
              "name": "Residues",
              "type": null,
              "default": "[]",
              "description": "array of real and complex residue matrices"
            },
            {
              "name": "Const",
              "type": null,
              "default": "0.0",
              "description": "matrix for constant term"
            },
            {
              "name": "tolerance",
              "type": null,
              "default": "1e-09",
              "description": "relative tolerance for checking real poles"
            }
          ],
          "returns": null
        }
      ]
    },
    "pathsim.utils.graph": {
      "name": "pathsim.utils.graph",
      "description": "",
      "docstring_html": "",
      "classes": [
        {
          "name": "Graph",
          "description": "Optimized graph representation with efficient assembly and cycle detection.",
          "docstring_html": "<p>Optimized graph representation with efficient assembly and cycle detection.</p>\n<p>The Graph class analyzes block diagrams represented as directed graphs to identify\nalgebraic loops, compute evaluation depths, and organize blocks into levels for\nefficient simulation. Uses iterative algorithms to avoid recursion limits.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>blocks <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">list, optional</span></dt>\n<dd>list of block objects to include in the graph</dd>\n<dt>connections <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">list, optional</span></dt>\n<dd>list of Connection objects defining the graph edges</dd>\n</dl>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>has_loops <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>flag indicating presence of algebraic loops (cycles)</dd>\n</dl>\n<p><strong>Examples</strong></p>\n<p>Create a simple graph with two blocks:</p>\n<pre class=\"code python literal-block\">\n<span class=\"kn\">from</span><span class=\"w\"> </span><span class=\"nn\">pathsim.blocks</span><span class=\"w\"> </span><span class=\"kn\">import</span> <span class=\"n\">Amplifier</span><span class=\"p\">,</span> <span class=\"n\">Integrator</span><span class=\"w\">\n</span><span class=\"kn\">from</span><span class=\"w\"> </span><span class=\"nn\">pathsim.connection</span><span class=\"w\"> </span><span class=\"kn\">import</span> <span class=\"n\">Connection</span><span class=\"w\">\n</span><span class=\"kn\">from</span><span class=\"w\"> </span><span class=\"nn\">pathsim.utils.graph</span><span class=\"w\"> </span><span class=\"kn\">import</span> <span class=\"n\">Graph</span><span class=\"w\">\n\n</span><span class=\"n\">amp</span> <span class=\"o\">=</span> <span class=\"n\">Amplifier</span><span class=\"p\">(</span><span class=\"n\">gain</span><span class=\"o\">=</span><span class=\"mf\">2.0</span><span class=\"p\">)</span><span class=\"w\">\n</span><span class=\"n\">integ</span> <span class=\"o\">=</span> <span class=\"n\">Integrator</span><span class=\"p\">(</span><span class=\"mf\">0.0</span><span class=\"p\">)</span><span class=\"w\">\n\n</span><span class=\"n\">conn</span> <span class=\"o\">=</span> <span class=\"n\">Connection</span><span class=\"p\">(</span><span class=\"n\">amp</span><span class=\"p\">,</span> <span class=\"n\">integ</span><span class=\"p\">)</span><span class=\"w\">\n\n</span><span class=\"n\">graph</span> <span class=\"o\">=</span> <span class=\"n\">Graph</span><span class=\"p\">([</span><span class=\"n\">amp</span><span class=\"p\">,</span> <span class=\"n\">integ</span><span class=\"p\">],</span> <span class=\"p\">[</span><span class=\"n\">conn</span><span class=\"p\">])</span>\n</pre>\n",
          "source": "class Graph:\n    \"\"\"Optimized graph representation with efficient assembly and cycle detection.\n\n    The Graph class analyzes block diagrams represented as directed graphs to identify\n    algebraic loops, compute evaluation depths, and organize blocks into levels for\n    efficient simulation. Uses iterative algorithms to avoid recursion limits.\n\n    Parameters\n    ----------\n    blocks : list, optional\n        list of block objects to include in the graph\n    connections : list, optional\n        list of Connection objects defining the graph edges\n\n    Attributes\n    ----------\n    has_loops : bool\n        flag indicating presence of algebraic loops (cycles)\n\n    Examples\n    --------\n    Create a simple graph with two blocks:\n\n    .. code-block:: python\n\n        from pathsim.blocks import Amplifier, Integrator\n        from pathsim.connection import Connection\n        from pathsim.utils.graph import Graph\n\n        amp = Amplifier(gain=2.0)\n        integ = Integrator(0.0)\n\n        conn = Connection(amp, integ)\n\n        graph = Graph([amp, integ], [conn])\n    \"\"\"\n\n    def __init__(self, blocks=None, connections=None):\n        self.blocks = list(blocks) if blocks else []\n        self.connections = list(connections) if connections else []\n\n        # First check the connections for port conflicts\n        self._validate_connections()\n\n        # loop flag\n        self.has_loops = False\n\n        # depths\n        self._alg_depth = 0\n        self._loop_depth = 0\n\n        # initialize graph orderings\n        self._blocks_dag = defaultdict(list)\n        self._blocks_loop_dag = defaultdict(list)\n        self._connections_dag = defaultdict(list)\n        self._connections_loop_dag = defaultdict(list)\n        self._loop_closing_connections = []\n\n        # Build maps in single pass\n        self._build_all_maps()\n\n        # assemble dag and loops\n        self._assemble()\n\n\n    def __bool__(self):\n        return True\n\n\n    def __len__(self):\n        return len(self.blocks)\n\n\n    @property\n    def size(self):\n        \"\"\"Returns the size of the graph as (number of blocks, number of connections).\n\n        Returns\n        -------\n        tuple\n            (number of blocks, total number of connection targets)\n        \"\"\"\n        return len(self.blocks), sum(len(con.targets) for con in self.connections)\n\n\n    @property\n    def depth(self):\n        \"\"\"Returns the depths of the graph as (algebraic depth, loop depth).\n\n        The algebraic depth is the maximum number of levels in the acyclic part\n        of the graph. The loop depth is the maximum number of levels within\n        algebraic loops.\n\n        Returns\n        -------\n        tuple\n            (algebraic depth, loop depth)\n        \"\"\"\n        return self._alg_depth, self._loop_depth\n\n\n    def _validate_connections(self):\n        \"\"\"Fast O(N) validation that no connections overwrite each other.\n\n        Checks that no two connections target the same (block, port) pair.\n        \"\"\"\n        # {(block, port_idx): connection}\n        connected_targets = set()\n\n        for connection in self.connections:\n            for target in connection.targets:\n                target_block = target.block\n                for port_idx in target.ports:\n                    key = (target_block, port_idx)\n                    if key in connected_targets:\n                        raise ValueError(\n                            f\"Connection conflict detected\"\n                        )\n                    connected_targets.add(key)\n\n\n    def _build_all_maps(self):\n        \"\"\"Build all connection maps in a single pass for efficiency.\n\n        Creates internal dictionaries mapping blocks to their upstream/downstream\n        neighbors and outgoing connections. Ensures deterministic ordering by sorting\n        connections based on pre-computed block order.\n        \"\"\"\n\n        self._alg_blocks = set()\n        self._dyn_blocks = set()\n\n        for blk in self.blocks:\n            if len(blk) > 0:\n                self._alg_blocks.add(blk)\n            else:\n                self._dyn_blocks.add(blk)\n\n        self._upst_blk_blk_map = defaultdict(set)\n        self._dnst_blk_blk_map = defaultdict(set)\n        self._outg_blk_con_map = defaultdict(list)\n\n        for con in self.connections:\n            src_blk = con.source.block\n            self._outg_blk_con_map[src_blk].append(con)\n\n            for trg in con.targets:\n                tgt_blk = trg.block\n                self._dnst_blk_blk_map[src_blk].add(tgt_blk)\n                self._upst_blk_blk_map[tgt_blk].add(src_blk)\n\n\n    def _assemble(self):\n        \"\"\"Optimized assembly using DFS with proper cycle detection.\n\n        Analyzes the graph structure to separate acyclic (DAG) and cyclic (loop)\n        components. Computes depths for all blocks and organizes them into levels\n        for efficient evaluation during simulation.\n        \"\"\"\n        self._blocks_dag.clear()\n        self._connections_dag.clear()\n        self._blocks_loop_dag.clear()\n        self._connections_loop_dag.clear()\n        self._loop_closing_connections.clear()\n        self.has_loops = False\n\n        # No blocks -> early exit\n        if not self.blocks:\n            return\n\n        # Handle dynamic blocks at depth 0\n        for blk in self._dyn_blocks:\n            self._blocks_dag[0].append(blk)\n            for con in self._outg_blk_con_map[blk]:\n                self._connections_dag[0].append(con)\n\n        # No algebraic blocks -> early exit\n        if not self._alg_blocks:\n            self._alg_depth = 1\n            self._loop_depth = 0\n            return\n\n        # Compute depths with cycle detection\n        depths = self._compute_depths_iterative()\n\n        blocks_loop = set()\n\n        # Single pass to categorize blocks\n        for blk in self._alg_blocks:\n            depth = depths[blk]\n\n            if depth is None:\n                blocks_loop.add(blk)\n                self.has_loops = True\n            else:\n                self._blocks_dag[depth].append(blk)\n                for con in self._outg_blk_con_map[blk]:\n                    self._connections_dag[depth].append(con)\n\n        self._alg_depth = (max(self._blocks_dag) + 1) if self._blocks_dag else 0\n\n        if self.has_loops:\n            self._process_loops(blocks_loop)\n        else:\n            self._loop_depth = 0\n\n\n    def _compute_depths_iterative(self):\n        \"\"\"Compute algebraic depths using iterative DFS (no recursion limit).\n\n        Uses a stack-based depth-first search with pre-visit and post-visit phases\n        to compute the maximum upstream algebraic path length for each block.\n        Detects cycles by marking nodes with None depth when back edges are found.\n\n        Returns\n        -------\n        dict\n            mapping from blocks to their algebraic depths (None for cyclic blocks)\n        \"\"\"\n\n        # Register states for ALL blocks\n        WHITE, GRAY, BLACK = 0, 1, 2\n        state = {blk: WHITE for blk in self.blocks}\n\n        depths = {}\n\n        for start_node in self._alg_blocks:\n            if state[start_node] != WHITE:\n                continue\n\n            # Stack: (node, 'pre'|'post', predecessors_to_check)\n            stack = [(start_node, 'pre', None)]\n\n            while stack:\n                node, visit_type, preds_remaining = stack.pop()\n\n                # Using O(1) set lookup\n                is_dyn = node in self._dyn_blocks\n\n                if visit_type == 'pre':\n                    # Pre-visit: first time seeing this node\n\n                    # Handle terminal cases \n                    if is_dyn:\n                        depths[node] = 0\n                        state[node] = BLACK\n                        continue\n\n                    # Already fully processed\n                    if state[node] == BLACK:\n                        continue\n\n                    # Back edge = cycle\n                    if state[node] == GRAY:\n                        depths[node] = None\n                        state[node] = BLACK\n                        continue\n\n                    # Mark as being processed\n                    state[node] = GRAY\n\n                    # Get predecessors and filtered algebraic\n                    preds = list(self._upst_blk_blk_map[node])\n                    alg_preds = [prd for prd in preds if prd in self._alg_blocks]\n\n                    if not preds:\n                        # No predecessors\n                        depths[node] = 0\n                        state[node] = BLACK\n                        continue\n                    elif not alg_preds:\n                        # Has predecessors, but all are dynamic\n                        depths[node] = 1\n                        state[node] = BLACK  \n                        continue\n\n                    # Schedule post-visit after all predecessors\n                    stack.append((node, 'post', preds))\n\n                    # Schedule predecessor visits (in reverse for correct order)\n                    for pred in reversed(preds):\n                        if state[pred] == WHITE:\n                            stack.append((pred, 'pre', None))\n\n                else:  # visit_type == 'post'\n                    # Post-visit: all predecessors have been processed\n\n                    max_depth = 0\n                    has_cycle = False\n\n                    # Check all predecessor depths\n                    for pred in preds_remaining:\n\n                        # Predecessor not finished = back edge = cycle\n                        if state[pred] != BLACK:\n                            has_cycle = True\n                            break\n\n                        pred_depth = depths.get(pred)\n                        if pred_depth is None:\n                            has_cycle = True\n                            break\n\n                        if pred_depth > max_depth:\n                            max_depth = pred_depth\n\n                    if has_cycle:\n                        depths[node] = None\n                    else:\n                        depths[node] = max_depth + int(not is_dyn)\n\n                    state[node] = BLACK\n\n        return depths\n\n\n    def _process_loops(self, blocks_loop):\n        \"\"\"Optimized loop processing with minimal overhead.\n\n        Finds strongly connected components (SCCs) within the loop blocks, determines\n        entry points for each SCC, and performs BFS to assign local depths. Identifies\n        loop-closing connections (back edges) that need special handling.\n\n        Parameters\n        ----------\n        blocks_loop : set\n            set of blocks that are part of algebraic loops\n        \"\"\"\n        if not blocks_loop:\n            return\n\n        # Find SCCs (already optimized)\n        sccs = self._find_strongly_connected_components(blocks_loop)\n\n        current_depth = 0\n\n        for scc in sccs:\n            scc_set = set(scc)\n\n            # Pre-filter downstream neighbors for this SCC once\n            scc_neighbors = {}\n            for blk in scc:\n                neighbors = self._dnst_blk_blk_map.get(blk, ())\n                # Filter and sort once, store as list\n                scc_neighbors[blk] = [n for n in neighbors if n in scc_set]\n\n            # Find entry points efficiently\n            entry_points = []\n            for blk in scc:\n                pred = self._upst_blk_blk_map.get(blk, set())\n                # Quick check: if any predecessor not in SCC, it's an entry point\n                has_external = any(p not in scc_set for p in pred)\n                has_internal = any(p in scc_set for p in pred)\n\n                if has_external or not has_internal:\n                    entry_points.append(blk)\n\n            if not entry_points:\n                entry_points = [scc[0]]\n\n            # Optimized BFS: single-pass with correct visitation\n            local_depths = {}\n            max_local_depth = 0\n            queue = deque()\n\n            # Initialize with entry points\n            for ep in entry_points:\n                local_depths[ep] = 0\n                queue.append((ep, 0))\n\n            while queue:\n                blk, depth = queue.popleft()\n\n                # Skip if we've already processed this node at a shallower depth\n                if depth > local_depths.get(blk, float('inf')):\n                    continue\n\n                if depth > max_local_depth:\n                    max_local_depth = depth\n\n                # Process neighbors (already filtered and in cache)\n                for next_blk in scc_neighbors.get(blk, []):\n                    next_depth = depth + 1\n\n                    # Only enqueue if we found a shorter path\n                    if next_depth < local_depths.get(next_blk, float('inf')):\n                        local_depths[next_blk] = next_depth\n                        queue.append((next_blk, next_depth))\n\n            # Assign global depths and classify connections\n            for blk in scc:\n                blk_local_depth = local_depths.get(blk, 0)\n                global_depth = current_depth + blk_local_depth\n                self._blocks_loop_dag[global_depth].append(blk)\n\n                # Process connections (already sorted in map)\n                for con in self._outg_blk_con_map[blk]:\n                    is_loop_closing = False\n\n                    # Check all targets\n                    for target in con.targets:\n                        target_blk = target.block\n                        if target_blk in scc_set:\n                            target_local_depth = local_depths.get(target_blk, 0)\n\n                            # Back edge if target depth <= source depth\n                            if target_local_depth <= blk_local_depth:\n                                self._loop_closing_connections.append(con)\n                                is_loop_closing = True\n                                break\n\n                    if not is_loop_closing:\n                        self._connections_loop_dag[global_depth].append(con)\n\n            current_depth += max_local_depth + 1\n\n        self._loop_depth = (max(self._blocks_loop_dag) + 1) if self._blocks_loop_dag else 0\n\n\n    def _find_strongly_connected_components(self, blocks):\n        \"\"\"Iterative Tarjan's algorithm using cleaner state machine.\n\n        Finds strongly connected components (cycles) within the given blocks using\n        an iterative implementation of Tarjan's algorithm. Avoids recursion limits\n        that can occur with deep graphs.\n\n        Parameters\n        ----------\n        blocks : list\n            list of blocks to analyze for SCCs\n\n        Returns\n        -------\n        list\n            list of SCCs, where each SCC is a list of blocks forming a cycle\n        \"\"\"\n        if not blocks:\n            return []\n\n        block_set = set(blocks)\n        index_counter = [0]\n        index = {}\n        lowlink = {}\n        onstack = set()\n        scc_stack = []\n        result = []\n\n        # Pre-filter successors\n        successors_cache = defaultdict(list)\n        for blk in blocks:\n            succ = self._dnst_blk_blk_map[blk]\n            successors_cache[blk] = [n for n in succ if n in block_set]\n\n        for start_node in blocks:\n            if start_node in index:\n                continue\n\n            # Work stack: each entry is (node, successor_index)\n            # successor_index = -1 means node not yet initialized\n            work_stack = [(start_node, -1)]\n\n            while work_stack:\n                node, succ_idx = work_stack[-1]\n\n                # Initialize node on first visit\n                if succ_idx == -1:\n                    idx = index_counter[0]\n                    index[node] = idx\n                    lowlink[node] = idx\n                    index_counter[0] += 1\n\n                    scc_stack.append(node)\n                    onstack.add(node)\n\n                    # Update to start processing successors\n                    work_stack[-1] = (node, 0)\n                    continue\n\n                # Get successors for this node\n                successors = successors_cache[node]\n\n                # Check if we've processed all successors\n                if succ_idx >= len(successors):\n                    # All successors processed - finalize this node\n                    work_stack.pop()\n\n                    # Check if this is an SCC root\n                    if lowlink[node] == index[node]:\n                        # Extract SCC\n                        scc = []\n                        while True:\n                            w = scc_stack.pop()\n                            onstack.remove(w)\n                            scc.append(w)\n                            if w == node:\n                                break\n\n                        # Keep only actual cycles\n                        if len(scc) > 1:\n                            result.append(scc)\n                        elif scc[0] in successors_cache[scc[0]]:\n                            result.append(scc)\n\n                    # Update parent's lowlink if there is a parent\n                    if work_stack:\n                        parent, parent_succ_idx = work_stack[-1]\n                        if lowlink[node] < lowlink[parent]:\n                            lowlink[parent] = lowlink[node]\n\n                    continue\n\n                # Process current successor\n                succ = successors[succ_idx]\n\n                # Move to next successor for next iteration\n                work_stack[-1] = (node, succ_idx + 1)\n\n                if succ not in index:\n                    # Unvisited successor - recurse\n                    work_stack.append((succ, -1))\n                elif succ in onstack:\n                    # Back edge - update lowlink\n                    if index[succ] < lowlink[node]:\n                        lowlink[node] = index[succ]\n\n        return result\n\n\n    def is_algebraic_path(self, start_block, end_block):\n        \"\"\"Check if blocks are connected through an algebraic path.\n\n        Determines whether there exists a path from start_block to end_block that\n        only passes through algebraic blocks (blocks with non-zero length). Uses\n        iterative DFS with early termination for efficiency.\n\n        Parameters\n        ----------\n        start_block : Block\n            starting block of the path\n        end_block : Block\n            ending block of the path\n\n        Returns\n        -------\n        bool\n            True if an algebraic path exists, False otherwise\n        \"\"\"\n        # Quick checks\n        if start_block is end_block:\n            # Self-loop case: need to find path that leaves and returns\n            return self._has_algebraic_self_loop(start_block)\n\n        # Check if start has any outgoing connections\n        if start_block not in self._dnst_blk_blk_map:\n            return False\n\n        # Check if end is algebraic (non-algebraic blocks can't be part of algebraic path)\n        if end_block in self._dyn_blocks:\n            return False\n\n        # Iterative DFS with visited set\n        visited = set()\n        # Stack: just nodes (no need for iterators or depth)\n        stack = [start_block]\n\n        while stack:\n            node = stack.pop()\n\n            if node in visited:\n                continue\n\n            visited.add(node)\n\n            # Get neighbors - use cached list if available\n            neighbors = self._dnst_blk_blk_map[node]\n\n            for nbr in neighbors:\n                # Found the target!\n                if nbr is end_block:\n                    return True\n\n                # Skip non-algebraic blocks\n                if nbr in self._dyn_blocks:\n                    continue\n\n                # Skip already visited\n                if nbr not in visited:\n                    stack.append(nbr)\n\n        return False\n\n\n    def _has_algebraic_self_loop(self, block):\n        \"\"\"Check if a block has an algebraic path back to itself.\n\n        For self-loops, verifies that the path actually leaves the block and\n        returns through other algebraic blocks (not just a direct self-connection).\n\n        Parameters\n        ----------\n        block : Block\n            block to check for self-loop\n\n        Returns\n        -------\n        bool\n            True if an algebraic self-loop exists, False otherwise\n        \"\"\"\n        # Check if block is algebraic\n        if block in self._dyn_blocks:\n            return False\n\n        # Get immediate neighbors\n        neighbors = self._dnst_blk_blk_map[block]\n\n        if not neighbors:\n            return False\n\n        # BFS from neighbors to see if any path back\n        visited = {block}  # Don't revisit start immediately\n        stack = list(neighbors)\n\n        while stack:\n            node = stack.pop()\n\n            if node in visited:\n                continue\n\n            # Found path back to start!\n            if node is block:\n                return True\n\n            visited.add(node)\n\n            # Skip non-algebraic\n            if node in self._dyn_blocks:\n                continue\n\n            # Add neighbors\n            for nbr in self._dnst_blk_blk_map[node]:\n                if nbr not in visited:\n                    stack.append(nbr)\n\n        return False\n\n\n    def outgoing_connections(self, block):\n        \"\"\"Returns outgoing connections of a block.\n\n        Parameters\n        ----------\n        block : Block\n            block to get outgoing connections for\n\n        Returns\n        -------\n        list\n            list of Connection objects originating from the block\n        \"\"\"\n        return self._outg_blk_con_map[block]\n\n\n    def dag(self):\n        \"\"\"Generator for DAG levels.\n\n        Yields tuples of (depth, blocks, connections) for each level in the\n        acyclic part of the graph, ordered from lowest to highest depth.\n\n        Yields\n        ------\n        tuple\n            (depth level, list of blocks at this depth, list of connections at this depth)\n        \"\"\"\n        for d in range(self._alg_depth):\n            yield (d, self._blocks_dag[d], self._connections_dag[d])\n\n\n    def loop(self):\n        \"\"\"Generator for loop DAG levels.\n\n        Yields tuples of (depth, blocks, connections) for each level in the\n        algebraic loop part of the graph, ordered from lowest to highest depth.\n\n        Yields\n        ------\n        tuple\n            (depth level, list of blocks at this depth, list of connections at this depth)\n        \"\"\"\n        for d in range(self._loop_depth):\n            yield (d, self._blocks_loop_dag[d], self._connections_loop_dag[d])\n\n\n    def loop_closing_connections(self):\n        \"\"\"Returns loop-closing connections.\n\n        Loop-closing connections are back edges in the graph that create algebraic\n        loops. These connections need special handling during simulation to resolve\n        the implicit equations.\n\n        Returns\n        -------\n        list\n            list of Connection objects that close algebraic loops\n        \"\"\"\n        return self._loop_closing_connections",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, blocks=None, connections=None):\n    self.blocks = list(blocks) if blocks else []\n    self.connections = list(connections) if connections else []\n\n    # First check the connections for port conflicts\n    self._validate_connections()\n\n    # loop flag\n    self.has_loops = False\n\n    # depths\n    self._alg_depth = 0\n    self._loop_depth = 0\n\n    # initialize graph orderings\n    self._blocks_dag = defaultdict(list)\n    self._blocks_loop_dag = defaultdict(list)\n    self._connections_dag = defaultdict(list)\n    self._connections_loop_dag = defaultdict(list)\n    self._loop_closing_connections = []\n\n    # Build maps in single pass\n    self._build_all_maps()\n\n    # assemble dag and loops\n    self._assemble()",
              "signature": "(blocks = None, connections = None)",
              "parameters": [
                {
                  "name": "blocks",
                  "type": null,
                  "default": "None",
                  "description": ""
                },
                {
                  "name": "connections",
                  "type": null,
                  "default": "None",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "_validate_connections",
              "description": "Fast O(N) validation that no connections overwrite each other.",
              "docstring_html": "<p>Fast O(N) validation that no connections overwrite each other.</p>\n<p>Checks that no two connections target the same (block, port) pair.</p>\n",
              "source": "def _validate_connections(self):\n    \"\"\"Fast O(N) validation that no connections overwrite each other.\n\n    Checks that no two connections target the same (block, port) pair.\n    \"\"\"\n    # {(block, port_idx): connection}\n    connected_targets = set()\n\n    for connection in self.connections:\n        for target in connection.targets:\n            target_block = target.block\n            for port_idx in target.ports:\n                key = (target_block, port_idx)\n                if key in connected_targets:\n                    raise ValueError(\n                        f\"Connection conflict detected\"\n                    )\n                connected_targets.add(key)",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "_build_all_maps",
              "description": "Build all connection maps in a single pass for efficiency.",
              "docstring_html": "<p>Build all connection maps in a single pass for efficiency.</p>\n<p>Creates internal dictionaries mapping blocks to their upstream/downstream\nneighbors and outgoing connections. Ensures deterministic ordering by sorting\nconnections based on pre-computed block order.</p>\n",
              "source": "def _build_all_maps(self):\n    \"\"\"Build all connection maps in a single pass for efficiency.\n\n    Creates internal dictionaries mapping blocks to their upstream/downstream\n    neighbors and outgoing connections. Ensures deterministic ordering by sorting\n    connections based on pre-computed block order.\n    \"\"\"\n\n    self._alg_blocks = set()\n    self._dyn_blocks = set()\n\n    for blk in self.blocks:\n        if len(blk) > 0:\n            self._alg_blocks.add(blk)\n        else:\n            self._dyn_blocks.add(blk)\n\n    self._upst_blk_blk_map = defaultdict(set)\n    self._dnst_blk_blk_map = defaultdict(set)\n    self._outg_blk_con_map = defaultdict(list)\n\n    for con in self.connections:\n        src_blk = con.source.block\n        self._outg_blk_con_map[src_blk].append(con)\n\n        for trg in con.targets:\n            tgt_blk = trg.block\n            self._dnst_blk_blk_map[src_blk].add(tgt_blk)\n            self._upst_blk_blk_map[tgt_blk].add(src_blk)",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "_assemble",
              "description": "Optimized assembly using DFS with proper cycle detection.",
              "docstring_html": "<p>Optimized assembly using DFS with proper cycle detection.</p>\n<p>Analyzes the graph structure to separate acyclic (DAG) and cyclic (loop)\ncomponents. Computes depths for all blocks and organizes them into levels\nfor efficient evaluation during simulation.</p>\n",
              "source": "def _assemble(self):\n    \"\"\"Optimized assembly using DFS with proper cycle detection.\n\n    Analyzes the graph structure to separate acyclic (DAG) and cyclic (loop)\n    components. Computes depths for all blocks and organizes them into levels\n    for efficient evaluation during simulation.\n    \"\"\"\n    self._blocks_dag.clear()\n    self._connections_dag.clear()\n    self._blocks_loop_dag.clear()\n    self._connections_loop_dag.clear()\n    self._loop_closing_connections.clear()\n    self.has_loops = False\n\n    # No blocks -> early exit\n    if not self.blocks:\n        return\n\n    # Handle dynamic blocks at depth 0\n    for blk in self._dyn_blocks:\n        self._blocks_dag[0].append(blk)\n        for con in self._outg_blk_con_map[blk]:\n            self._connections_dag[0].append(con)\n\n    # No algebraic blocks -> early exit\n    if not self._alg_blocks:\n        self._alg_depth = 1\n        self._loop_depth = 0\n        return\n\n    # Compute depths with cycle detection\n    depths = self._compute_depths_iterative()\n\n    blocks_loop = set()\n\n    # Single pass to categorize blocks\n    for blk in self._alg_blocks:\n        depth = depths[blk]\n\n        if depth is None:\n            blocks_loop.add(blk)\n            self.has_loops = True\n        else:\n            self._blocks_dag[depth].append(blk)\n            for con in self._outg_blk_con_map[blk]:\n                self._connections_dag[depth].append(con)\n\n    self._alg_depth = (max(self._blocks_dag) + 1) if self._blocks_dag else 0\n\n    if self.has_loops:\n        self._process_loops(blocks_loop)\n    else:\n        self._loop_depth = 0",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "_compute_depths_iterative",
              "description": "Compute algebraic depths using iterative DFS (no recursion limit).",
              "docstring_html": "<p>Compute algebraic depths using iterative DFS (no recursion limit).</p>\n<p>Uses a stack-based depth-first search with pre-visit and post-visit phases\nto compute the maximum upstream algebraic path length for each block.\nDetects cycles by marking nodes with None depth when back edges are found.</p>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>dict</dt>\n<dd>mapping from blocks to their algebraic depths (None for cyclic blocks)</dd>\n</dl>\n",
              "source": "def _compute_depths_iterative(self):\n    \"\"\"Compute algebraic depths using iterative DFS (no recursion limit).\n\n    Uses a stack-based depth-first search with pre-visit and post-visit phases\n    to compute the maximum upstream algebraic path length for each block.\n    Detects cycles by marking nodes with None depth when back edges are found.\n\n    Returns\n    -------\n    dict\n        mapping from blocks to their algebraic depths (None for cyclic blocks)\n    \"\"\"\n\n    # Register states for ALL blocks\n    WHITE, GRAY, BLACK = 0, 1, 2\n    state = {blk: WHITE for blk in self.blocks}\n\n    depths = {}\n\n    for start_node in self._alg_blocks:\n        if state[start_node] != WHITE:\n            continue\n\n        # Stack: (node, 'pre'|'post', predecessors_to_check)\n        stack = [(start_node, 'pre', None)]\n\n        while stack:\n            node, visit_type, preds_remaining = stack.pop()\n\n            # Using O(1) set lookup\n            is_dyn = node in self._dyn_blocks\n\n            if visit_type == 'pre':\n                # Pre-visit: first time seeing this node\n\n                # Handle terminal cases \n                if is_dyn:\n                    depths[node] = 0\n                    state[node] = BLACK\n                    continue\n\n                # Already fully processed\n                if state[node] == BLACK:\n                    continue\n\n                # Back edge = cycle\n                if state[node] == GRAY:\n                    depths[node] = None\n                    state[node] = BLACK\n                    continue\n\n                # Mark as being processed\n                state[node] = GRAY\n\n                # Get predecessors and filtered algebraic\n                preds = list(self._upst_blk_blk_map[node])\n                alg_preds = [prd for prd in preds if prd in self._alg_blocks]\n\n                if not preds:\n                    # No predecessors\n                    depths[node] = 0\n                    state[node] = BLACK\n                    continue\n                elif not alg_preds:\n                    # Has predecessors, but all are dynamic\n                    depths[node] = 1\n                    state[node] = BLACK  \n                    continue\n\n                # Schedule post-visit after all predecessors\n                stack.append((node, 'post', preds))\n\n                # Schedule predecessor visits (in reverse for correct order)\n                for pred in reversed(preds):\n                    if state[pred] == WHITE:\n                        stack.append((pred, 'pre', None))\n\n            else:  # visit_type == 'post'\n                # Post-visit: all predecessors have been processed\n\n                max_depth = 0\n                has_cycle = False\n\n                # Check all predecessor depths\n                for pred in preds_remaining:\n\n                    # Predecessor not finished = back edge = cycle\n                    if state[pred] != BLACK:\n                        has_cycle = True\n                        break\n\n                    pred_depth = depths.get(pred)\n                    if pred_depth is None:\n                        has_cycle = True\n                        break\n\n                    if pred_depth > max_depth:\n                        max_depth = pred_depth\n\n                if has_cycle:\n                    depths[node] = None\n                else:\n                    depths[node] = max_depth + int(not is_dyn)\n\n                state[node] = BLACK\n\n    return depths",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "_process_loops",
              "description": "Optimized loop processing with minimal overhead.",
              "docstring_html": "<p>Optimized loop processing with minimal overhead.</p>\n<p>Finds strongly connected components (SCCs) within the loop blocks, determines\nentry points for each SCC, and performs BFS to assign local depths. Identifies\nloop-closing connections (back edges) that need special handling.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>blocks_loop <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">set</span></dt>\n<dd>set of blocks that are part of algebraic loops</dd>\n</dl>\n",
              "source": "def _process_loops(self, blocks_loop):\n    \"\"\"Optimized loop processing with minimal overhead.\n\n    Finds strongly connected components (SCCs) within the loop blocks, determines\n    entry points for each SCC, and performs BFS to assign local depths. Identifies\n    loop-closing connections (back edges) that need special handling.\n\n    Parameters\n    ----------\n    blocks_loop : set\n        set of blocks that are part of algebraic loops\n    \"\"\"\n    if not blocks_loop:\n        return\n\n    # Find SCCs (already optimized)\n    sccs = self._find_strongly_connected_components(blocks_loop)\n\n    current_depth = 0\n\n    for scc in sccs:\n        scc_set = set(scc)\n\n        # Pre-filter downstream neighbors for this SCC once\n        scc_neighbors = {}\n        for blk in scc:\n            neighbors = self._dnst_blk_blk_map.get(blk, ())\n            # Filter and sort once, store as list\n            scc_neighbors[blk] = [n for n in neighbors if n in scc_set]\n\n        # Find entry points efficiently\n        entry_points = []\n        for blk in scc:\n            pred = self._upst_blk_blk_map.get(blk, set())\n            # Quick check: if any predecessor not in SCC, it's an entry point\n            has_external = any(p not in scc_set for p in pred)\n            has_internal = any(p in scc_set for p in pred)\n\n            if has_external or not has_internal:\n                entry_points.append(blk)\n\n        if not entry_points:\n            entry_points = [scc[0]]\n\n        # Optimized BFS: single-pass with correct visitation\n        local_depths = {}\n        max_local_depth = 0\n        queue = deque()\n\n        # Initialize with entry points\n        for ep in entry_points:\n            local_depths[ep] = 0\n            queue.append((ep, 0))\n\n        while queue:\n            blk, depth = queue.popleft()\n\n            # Skip if we've already processed this node at a shallower depth\n            if depth > local_depths.get(blk, float('inf')):\n                continue\n\n            if depth > max_local_depth:\n                max_local_depth = depth\n\n            # Process neighbors (already filtered and in cache)\n            for next_blk in scc_neighbors.get(blk, []):\n                next_depth = depth + 1\n\n                # Only enqueue if we found a shorter path\n                if next_depth < local_depths.get(next_blk, float('inf')):\n                    local_depths[next_blk] = next_depth\n                    queue.append((next_blk, next_depth))\n\n        # Assign global depths and classify connections\n        for blk in scc:\n            blk_local_depth = local_depths.get(blk, 0)\n            global_depth = current_depth + blk_local_depth\n            self._blocks_loop_dag[global_depth].append(blk)\n\n            # Process connections (already sorted in map)\n            for con in self._outg_blk_con_map[blk]:\n                is_loop_closing = False\n\n                # Check all targets\n                for target in con.targets:\n                    target_blk = target.block\n                    if target_blk in scc_set:\n                        target_local_depth = local_depths.get(target_blk, 0)\n\n                        # Back edge if target depth <= source depth\n                        if target_local_depth <= blk_local_depth:\n                            self._loop_closing_connections.append(con)\n                            is_loop_closing = True\n                            break\n\n                if not is_loop_closing:\n                    self._connections_loop_dag[global_depth].append(con)\n\n        current_depth += max_local_depth + 1\n\n    self._loop_depth = (max(self._blocks_loop_dag) + 1) if self._blocks_loop_dag else 0",
              "signature": "(blocks_loop)",
              "parameters": [
                {
                  "name": "blocks_loop",
                  "type": null,
                  "default": null,
                  "description": "set of blocks that are part of algebraic loops"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "_find_strongly_connected_components",
              "description": "Iterative Tarjan's algorithm using cleaner state machine.",
              "docstring_html": "<p>Iterative Tarjan's algorithm using cleaner state machine.</p>\n<p>Finds strongly connected components (cycles) within the given blocks using\nan iterative implementation of Tarjan's algorithm. Avoids recursion limits\nthat can occur with deep graphs.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>blocks <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">list</span></dt>\n<dd>list of blocks to analyze for SCCs</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>list</dt>\n<dd>list of SCCs, where each SCC is a list of blocks forming a cycle</dd>\n</dl>\n",
              "source": "def _find_strongly_connected_components(self, blocks):\n    \"\"\"Iterative Tarjan's algorithm using cleaner state machine.\n\n    Finds strongly connected components (cycles) within the given blocks using\n    an iterative implementation of Tarjan's algorithm. Avoids recursion limits\n    that can occur with deep graphs.\n\n    Parameters\n    ----------\n    blocks : list\n        list of blocks to analyze for SCCs\n\n    Returns\n    -------\n    list\n        list of SCCs, where each SCC is a list of blocks forming a cycle\n    \"\"\"\n    if not blocks:\n        return []\n\n    block_set = set(blocks)\n    index_counter = [0]\n    index = {}\n    lowlink = {}\n    onstack = set()\n    scc_stack = []\n    result = []\n\n    # Pre-filter successors\n    successors_cache = defaultdict(list)\n    for blk in blocks:\n        succ = self._dnst_blk_blk_map[blk]\n        successors_cache[blk] = [n for n in succ if n in block_set]\n\n    for start_node in blocks:\n        if start_node in index:\n            continue\n\n        # Work stack: each entry is (node, successor_index)\n        # successor_index = -1 means node not yet initialized\n        work_stack = [(start_node, -1)]\n\n        while work_stack:\n            node, succ_idx = work_stack[-1]\n\n            # Initialize node on first visit\n            if succ_idx == -1:\n                idx = index_counter[0]\n                index[node] = idx\n                lowlink[node] = idx\n                index_counter[0] += 1\n\n                scc_stack.append(node)\n                onstack.add(node)\n\n                # Update to start processing successors\n                work_stack[-1] = (node, 0)\n                continue\n\n            # Get successors for this node\n            successors = successors_cache[node]\n\n            # Check if we've processed all successors\n            if succ_idx >= len(successors):\n                # All successors processed - finalize this node\n                work_stack.pop()\n\n                # Check if this is an SCC root\n                if lowlink[node] == index[node]:\n                    # Extract SCC\n                    scc = []\n                    while True:\n                        w = scc_stack.pop()\n                        onstack.remove(w)\n                        scc.append(w)\n                        if w == node:\n                            break\n\n                    # Keep only actual cycles\n                    if len(scc) > 1:\n                        result.append(scc)\n                    elif scc[0] in successors_cache[scc[0]]:\n                        result.append(scc)\n\n                # Update parent's lowlink if there is a parent\n                if work_stack:\n                    parent, parent_succ_idx = work_stack[-1]\n                    if lowlink[node] < lowlink[parent]:\n                        lowlink[parent] = lowlink[node]\n\n                continue\n\n            # Process current successor\n            succ = successors[succ_idx]\n\n            # Move to next successor for next iteration\n            work_stack[-1] = (node, succ_idx + 1)\n\n            if succ not in index:\n                # Unvisited successor - recurse\n                work_stack.append((succ, -1))\n            elif succ in onstack:\n                # Back edge - update lowlink\n                if index[succ] < lowlink[node]:\n                    lowlink[node] = index[succ]\n\n    return result",
              "signature": "(blocks)",
              "parameters": [
                {
                  "name": "blocks",
                  "type": null,
                  "default": null,
                  "description": "list of blocks to analyze for SCCs"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "is_algebraic_path",
              "description": "Check if blocks are connected through an algebraic path.",
              "docstring_html": "<p>Check if blocks are connected through an algebraic path.</p>\n<p>Determines whether there exists a path from start_block to end_block that\nonly passes through algebraic blocks (blocks with non-zero length). Uses\niterative DFS with early termination for efficiency.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>start_block <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">Block</span></dt>\n<dd>starting block of the path</dd>\n<dt>end_block <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">Block</span></dt>\n<dd>ending block of the path</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>bool</dt>\n<dd>True if an algebraic path exists, False otherwise</dd>\n</dl>\n",
              "source": "def is_algebraic_path(self, start_block, end_block):\n    \"\"\"Check if blocks are connected through an algebraic path.\n\n    Determines whether there exists a path from start_block to end_block that\n    only passes through algebraic blocks (blocks with non-zero length). Uses\n    iterative DFS with early termination for efficiency.\n\n    Parameters\n    ----------\n    start_block : Block\n        starting block of the path\n    end_block : Block\n        ending block of the path\n\n    Returns\n    -------\n    bool\n        True if an algebraic path exists, False otherwise\n    \"\"\"\n    # Quick checks\n    if start_block is end_block:\n        # Self-loop case: need to find path that leaves and returns\n        return self._has_algebraic_self_loop(start_block)\n\n    # Check if start has any outgoing connections\n    if start_block not in self._dnst_blk_blk_map:\n        return False\n\n    # Check if end is algebraic (non-algebraic blocks can't be part of algebraic path)\n    if end_block in self._dyn_blocks:\n        return False\n\n    # Iterative DFS with visited set\n    visited = set()\n    # Stack: just nodes (no need for iterators or depth)\n    stack = [start_block]\n\n    while stack:\n        node = stack.pop()\n\n        if node in visited:\n            continue\n\n        visited.add(node)\n\n        # Get neighbors - use cached list if available\n        neighbors = self._dnst_blk_blk_map[node]\n\n        for nbr in neighbors:\n            # Found the target!\n            if nbr is end_block:\n                return True\n\n            # Skip non-algebraic blocks\n            if nbr in self._dyn_blocks:\n                continue\n\n            # Skip already visited\n            if nbr not in visited:\n                stack.append(nbr)\n\n    return False",
              "signature": "(start_block, end_block)",
              "parameters": [
                {
                  "name": "start_block",
                  "type": null,
                  "default": null,
                  "description": "starting block of the path"
                },
                {
                  "name": "end_block",
                  "type": null,
                  "default": null,
                  "description": "ending block of the path"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "_has_algebraic_self_loop",
              "description": "Check if a block has an algebraic path back to itself.",
              "docstring_html": "<p>Check if a block has an algebraic path back to itself.</p>\n<p>For self-loops, verifies that the path actually leaves the block and\nreturns through other algebraic blocks (not just a direct self-connection).</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>block <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">Block</span></dt>\n<dd>block to check for self-loop</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>bool</dt>\n<dd>True if an algebraic self-loop exists, False otherwise</dd>\n</dl>\n",
              "source": "def _has_algebraic_self_loop(self, block):\n    \"\"\"Check if a block has an algebraic path back to itself.\n\n    For self-loops, verifies that the path actually leaves the block and\n    returns through other algebraic blocks (not just a direct self-connection).\n\n    Parameters\n    ----------\n    block : Block\n        block to check for self-loop\n\n    Returns\n    -------\n    bool\n        True if an algebraic self-loop exists, False otherwise\n    \"\"\"\n    # Check if block is algebraic\n    if block in self._dyn_blocks:\n        return False\n\n    # Get immediate neighbors\n    neighbors = self._dnst_blk_blk_map[block]\n\n    if not neighbors:\n        return False\n\n    # BFS from neighbors to see if any path back\n    visited = {block}  # Don't revisit start immediately\n    stack = list(neighbors)\n\n    while stack:\n        node = stack.pop()\n\n        if node in visited:\n            continue\n\n        # Found path back to start!\n        if node is block:\n            return True\n\n        visited.add(node)\n\n        # Skip non-algebraic\n        if node in self._dyn_blocks:\n            continue\n\n        # Add neighbors\n        for nbr in self._dnst_blk_blk_map[node]:\n            if nbr not in visited:\n                stack.append(nbr)\n\n    return False",
              "signature": "(block)",
              "parameters": [
                {
                  "name": "block",
                  "type": null,
                  "default": null,
                  "description": "block to check for self-loop"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "outgoing_connections",
              "description": "Returns outgoing connections of a block.",
              "docstring_html": "<p>Returns outgoing connections of a block.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>block <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">Block</span></dt>\n<dd>block to get outgoing connections for</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>list</dt>\n<dd>list of Connection objects originating from the block</dd>\n</dl>\n",
              "source": "def outgoing_connections(self, block):\n    \"\"\"Returns outgoing connections of a block.\n\n    Parameters\n    ----------\n    block : Block\n        block to get outgoing connections for\n\n    Returns\n    -------\n    list\n        list of Connection objects originating from the block\n    \"\"\"\n    return self._outg_blk_con_map[block]",
              "signature": "(block)",
              "parameters": [
                {
                  "name": "block",
                  "type": null,
                  "default": null,
                  "description": "block to get outgoing connections for"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "dag",
              "description": "Generator for DAG levels.",
              "docstring_html": "<p>Generator for DAG levels.</p>\n<p>Yields tuples of (depth, blocks, connections) for each level in the\nacyclic part of the graph, ordered from lowest to highest depth.</p>\n<p><strong>Yields</strong></p>\n<dl class=\"docutils\">\n<dt>tuple</dt>\n<dd>(depth level, list of blocks at this depth, list of connections at this depth)</dd>\n</dl>\n",
              "source": "def dag(self):\n    \"\"\"Generator for DAG levels.\n\n    Yields tuples of (depth, blocks, connections) for each level in the\n    acyclic part of the graph, ordered from lowest to highest depth.\n\n    Yields\n    ------\n    tuple\n        (depth level, list of blocks at this depth, list of connections at this depth)\n    \"\"\"\n    for d in range(self._alg_depth):\n        yield (d, self._blocks_dag[d], self._connections_dag[d])",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "loop",
              "description": "Generator for loop DAG levels.",
              "docstring_html": "<p>Generator for loop DAG levels.</p>\n<p>Yields tuples of (depth, blocks, connections) for each level in the\nalgebraic loop part of the graph, ordered from lowest to highest depth.</p>\n<p><strong>Yields</strong></p>\n<dl class=\"docutils\">\n<dt>tuple</dt>\n<dd>(depth level, list of blocks at this depth, list of connections at this depth)</dd>\n</dl>\n",
              "source": "def loop(self):\n    \"\"\"Generator for loop DAG levels.\n\n    Yields tuples of (depth, blocks, connections) for each level in the\n    algebraic loop part of the graph, ordered from lowest to highest depth.\n\n    Yields\n    ------\n    tuple\n        (depth level, list of blocks at this depth, list of connections at this depth)\n    \"\"\"\n    for d in range(self._loop_depth):\n        yield (d, self._blocks_loop_dag[d], self._connections_loop_dag[d])",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "loop_closing_connections",
              "description": "Returns loop-closing connections.",
              "docstring_html": "<p>Returns loop-closing connections.</p>\n<p>Loop-closing connections are back edges in the graph that create algebraic\nloops. These connections need special handling during simulation to resolve\nthe implicit equations.</p>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>list</dt>\n<dd>list of Connection objects that close algebraic loops</dd>\n</dl>\n",
              "source": "def loop_closing_connections(self):\n    \"\"\"Returns loop-closing connections.\n\n    Loop-closing connections are back edges in the graph that create algebraic\n    loops. These connections need special handling during simulation to resolve\n    the implicit equations.\n\n    Returns\n    -------\n    list\n        list of Connection objects that close algebraic loops\n    \"\"\"\n    return self._loop_closing_connections",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "blocks",
              "description": "",
              "type": null,
              "value": "list(blocks) if blocks else []"
            },
            {
              "name": "connections",
              "description": "",
              "type": null,
              "value": "list(connections) if connections else []"
            },
            {
              "name": "has_loops",
              "description": "",
              "type": null,
              "value": "False"
            },
            {
              "name": "_alg_depth",
              "description": "",
              "type": null,
              "value": "0"
            },
            {
              "name": "_loop_depth",
              "description": "",
              "type": null,
              "value": "0"
            },
            {
              "name": "_blocks_dag",
              "description": "",
              "type": null,
              "value": "defaultdict(list)"
            },
            {
              "name": "_blocks_loop_dag",
              "description": "",
              "type": null,
              "value": "defaultdict(list)"
            },
            {
              "name": "_connections_dag",
              "description": "",
              "type": null,
              "value": "defaultdict(list)"
            },
            {
              "name": "_connections_loop_dag",
              "description": "",
              "type": null,
              "value": "defaultdict(list)"
            },
            {
              "name": "_loop_closing_connections",
              "description": "",
              "type": null,
              "value": "[]"
            },
            {
              "name": "size",
              "description": "Returns the size of the graph as (number of blocks, number of connections).",
              "type": null,
              "value": null
            },
            {
              "name": "depth",
              "description": "Returns the depths of the graph as (algebraic depth, loop depth).",
              "type": null,
              "value": null
            }
          ],
          "parameters": [
            {
              "name": "blocks",
              "type": null,
              "default": "None",
              "description": "list of block objects to include in the graph"
            },
            {
              "name": "connections",
              "type": null,
              "default": "None",
              "description": "list of Connection objects defining the graph edges"
            }
          ]
        }
      ],
      "functions": []
    },
    "pathsim.utils.logger": {
      "name": "pathsim.utils.logger",
      "description": "",
      "docstring_html": "",
      "classes": [
        {
          "name": "LoggerManager",
          "description": "Singleton class for centralized logging configuration in PathSim.",
          "docstring_html": "<p>Singleton class for centralized logging configuration in PathSim.</p>\n<p>Provides a unified interface for creating and configuring loggers throughout\nthe PathSim package. All loggers follow a hierarchical naming scheme under\nthe 'pathsim' root logger, allowing fine-grained control over logging levels\nand output destinations.</p>\n<p>The singleton pattern ensures that logging configuration is consistent across\nthe entire application, with all modules sharing the same handler setup and\nformatting rules.</p>\n<p><strong>Examples</strong></p>\n<pre class=\"code python literal-block\">\n<span class=\"c1\"># Create and configure logging in one step</span><span class=\"w\">\n</span><span class=\"kn\">from</span><span class=\"w\"> </span><span class=\"nn\">pathsim.utils.logger</span><span class=\"w\"> </span><span class=\"kn\">import</span> <span class=\"n\">LoggerManager</span><span class=\"w\">\n\n</span><span class=\"n\">mgr</span> <span class=\"o\">=</span> <span class=\"n\">LoggerManager</span><span class=\"p\">(</span><span class=\"w\">\n</span>    <span class=\"n\">enabled</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">,</span><span class=\"w\">\n</span>    <span class=\"n\">output</span><span class=\"o\">=</span><span class=\"s2\">&quot;simulation.log&quot;</span><span class=\"p\">,</span>  <span class=\"c1\"># File path or None for stdout</span><span class=\"w\">\n</span>    <span class=\"n\">level</span><span class=\"o\">=</span><span class=\"n\">logging</span><span class=\"o\">.</span><span class=\"n\">INFO</span><span class=\"w\">\n</span><span class=\"p\">)</span><span class=\"w\">\n\n</span><span class=\"c1\"># Get a logger for a specific module</span><span class=\"w\">\n</span><span class=\"n\">logger</span> <span class=\"o\">=</span> <span class=\"n\">mgr</span><span class=\"o\">.</span><span class=\"n\">get_logger</span><span class=\"p\">(</span><span class=\"s2\">&quot;simulation&quot;</span><span class=\"p\">)</span><span class=\"w\">\n</span><span class=\"n\">logger</span><span class=\"o\">.</span><span class=\"n\">info</span><span class=\"p\">(</span><span class=\"s2\">&quot;Simulation started&quot;</span><span class=\"p\">)</span><span class=\"w\">\n\n</span><span class=\"c1\"># Set different log levels for different modules</span><span class=\"w\">\n</span><span class=\"n\">mgr</span><span class=\"o\">.</span><span class=\"n\">set_level</span><span class=\"p\">(</span><span class=\"n\">logging</span><span class=\"o\">.</span><span class=\"n\">DEBUG</span><span class=\"p\">,</span> <span class=\"s2\">&quot;progress&quot;</span><span class=\"p\">)</span><span class=\"w\">\n</span><span class=\"n\">mgr</span><span class=\"o\">.</span><span class=\"n\">set_level</span><span class=\"p\">(</span><span class=\"n\">logging</span><span class=\"o\">.</span><span class=\"n\">WARNING</span><span class=\"p\">,</span> <span class=\"s2\">&quot;analysis&quot;</span><span class=\"p\">)</span><span class=\"w\">\n\n</span><span class=\"c1\"># Reconfigure later if needed</span><span class=\"w\">\n</span><span class=\"n\">mgr</span><span class=\"o\">.</span><span class=\"n\">configure</span><span class=\"p\">(</span><span class=\"n\">enabled</span><span class=\"o\">=</span><span class=\"kc\">False</span><span class=\"p\">)</span>  <span class=\"c1\"># Disable logging</span>\n</pre>\n<p><strong>Notes</strong></p>\n<p>The LoggerManager uses a hierarchical logger structure:</p>\n<ul>\n<li><p class=\"first\">pathsim (root)\n- pathsim.simulation\n- pathsim.progress</p>\n<blockquote>\n<ul class=\"simple\">\n<li>pathsim.progress.TRANSIENT</li>\n<li>pathsim.progress.STEADYSTATE</li>\n</ul>\n</blockquote>\n<ul class=\"simple\">\n<li>pathsim.analysis\n- pathsim.analysis.timer\n- pathsim.analysis.profiler</li>\n</ul>\n</li>\n</ul>\n<p>This hierarchy allows you to control logging at different granularities:\nset the level on 'pathsim' to affect all loggers, or set it on\n'pathsim.progress' to affect only progress tracking loggers.</p>\n",
          "source": "class LoggerManager:\n    \"\"\"Singleton class for centralized logging configuration in PathSim.\n\n    Provides a unified interface for creating and configuring loggers throughout\n    the PathSim package. All loggers follow a hierarchical naming scheme under\n    the 'pathsim' root logger, allowing fine-grained control over logging levels\n    and output destinations.\n\n    The singleton pattern ensures that logging configuration is consistent across\n    the entire application, with all modules sharing the same handler setup and\n    formatting rules.\n\n    Examples\n    --------\n\n    .. code-block:: python\n\n        # Create and configure logging in one step\n        from pathsim.utils.logger import LoggerManager\n\n        mgr = LoggerManager(\n            enabled=True,\n            output=\"simulation.log\",  # File path or None for stdout\n            level=logging.INFO\n        )\n\n        # Get a logger for a specific module\n        logger = mgr.get_logger(\"simulation\")\n        logger.info(\"Simulation started\")\n\n        # Set different log levels for different modules\n        mgr.set_level(logging.DEBUG, \"progress\")\n        mgr.set_level(logging.WARNING, \"analysis\")\n\n        # Reconfigure later if needed\n        mgr.configure(enabled=False)  # Disable logging\n\n\n    Notes\n    -----\n    The LoggerManager uses a hierarchical logger structure:\n\n    - pathsim (root)\n      - pathsim.simulation\n      - pathsim.progress\n        - pathsim.progress.TRANSIENT\n        - pathsim.progress.STEADYSTATE\n      - pathsim.analysis\n        - pathsim.analysis.timer\n        - pathsim.analysis.profiler\n\n    This hierarchy allows you to control logging at different granularities:\n    set the level on 'pathsim' to affect all loggers, or set it on\n    'pathsim.progress' to affect only progress tracking loggers.\n\n    \"\"\"\n\n    _instance = None\n    _initialized = False\n\n    def __new__(cls, enabled=False, output=None, level=logging.INFO,\n                format=None, date_format='%H:%M:%S'):\n        \"\"\"Ensure only one instance exists (singleton pattern).\"\"\"\n        if cls._instance is None:\n            cls._instance = super().__new__(cls)\n        return cls._instance\n\n\n    def __init__(self, enabled=False, output=None, level=logging.INFO,\n                 format=None, date_format='%H:%M:%S'):\n        \"\"\"Initialize the logger manager and setup root logger.\n\n        Configuration is applied immediately on first instantiation if enabled=True.\n        Subsequent instantiations return the existing singleton (parameters ignored).\n        Use configure() to change settings after initialization.\n\n        Parameters\n        ----------\n        enabled : bool, optional\n            Whether logging is enabled. Defaults to False.\n        output : str or None, optional\n            Output destination. If string, logs to file. If None, logs to stdout.\n            Defaults to None.\n        level : int, optional\n            Logging level. Defaults to logging.INFO.\n        format : str or None, optional\n            Log message format. Defaults to \"%(asctime)s - %(levelname)s - %(message)s\".\n        date_format : str or None, optional\n            Date format for timestamps. Defaults to '%H:%M:%S'.\n        \"\"\"\n        if not LoggerManager._initialized:\n            self._setup_root_logger()\n            LoggerManager._initialized = True\n\n            #apply configuration if enabled\n            if enabled:\n                self.configure(\n                    enabled=True,\n                    output=output,\n                    level=level,\n                    format=format,\n                    date_format=date_format\n                    )\n\n\n    def _setup_root_logger(self):\n        \"\"\"Setup the root PathSim logger with default configuration.\n\n        Creates the 'pathsim' root logger and initializes it with no handlers.\n        Handlers are added via the configure() method. Also sets up Python\n        warnings to be captured through the logging system.\n        \"\"\"\n\n        #get the root pathsim logger\n        self.root_logger = logging.getLogger(\"pathsim\")\n\n        #prevent propagation to root logger\n        self.root_logger.propagate = False\n\n        #capture Python warnings through logging\n        logging.captureWarnings(True)\n\n        #store configuration state\n        self._enabled = False\n        self._output = None\n        self._level = logging.INFO\n        self._format = \"%(asctime)s - %(levelname)s - %(message)s\"\n        self._date_format = '%H:%M:%S'  #shorter timestamp format\n\n        #store handler reference for reconfiguration\n        self._current_handler = None\n\n\n    def configure(self, enabled=True, output=None, level=logging.INFO, \n                  format=None, date_format=None):\n        \"\"\"Configure the root PathSim logger and all child loggers.\n\n        This method sets up the logging system with the specified parameters.\n        All loggers created via get_logger() will inherit this configuration.\n        Can be called multiple times to reconfigure logging.\n\n        Parameters\n        ----------\n        enabled : bool, optional\n            Whether logging is enabled. If False, all logging is disabled.\n            Defaults to True.\n        output : str or None, optional\n            Output destination for logs. If a string, interpreted as a file path\n            and logs are written to that file. If None, logs are written to stdout.\n            Defaults to None (stdout).\n        level : int, optional\n            Logging level (e.g., logging.DEBUG, logging.INFO, logging.WARNING).\n            Defaults to logging.INFO.\n        format : str or None, optional\n            Log message format string. If None, uses default format.\n            Defaults to \"%(asctime)s - %(levelname)s - %(message)s\".\n        date_format : str or None, optional\n            Date format string for timestamps (e.g., '%H:%M:%S').\n            If None, uses default format. Defaults to None.\n\n        Examples\n        --------\n\n        .. code-block:: python\n\n            mgr = LoggerManager()\n\n            # Log to stdout with INFO level\n            mgr.configure(enabled=True)\n\n            # Log to file with DEBUG level\n            mgr.configure(enabled=True, output=\"debug.log\", level=logging.DEBUG)\n\n            # Disable all logging\n            mgr.configure(enabled=False)\n\n            # Custom format with time only\n            mgr.configure(\n                enabled=True,\n                format=\"%(asctime)s - %(message)s\",\n                date_format='%H:%M:%S'\n            )\n\n        \"\"\"\n\n        #store configuration\n        self._enabled = enabled\n        self._output = output\n        self._level = level\n        self._format = format or self._format\n        self._date_format = date_format\n\n        #remove existing handler if present\n        if self._current_handler is not None:\n            self.root_logger.removeHandler(self._current_handler)\n            self._current_handler.close()\n            self._current_handler = None\n\n        #if logging is disabled, remove all handlers and return\n        if not enabled:\n            self.root_logger.handlers.clear()\n            self.root_logger.setLevel(logging.CRITICAL + 1)  #effectively disable\n            return\n\n        #create appropriate handler\n        if isinstance(output, str):\n            #file handler for logging to file\n            handler = logging.FileHandler(output)\n        else:\n            #stream handler for logging to stdout\n            handler = logging.StreamHandler(sys.stdout)\n\n        #set formatter\n        formatter = logging.Formatter(self._format, datefmt=self._date_format)\n        handler.setFormatter(formatter)\n\n        #add handler to root logger\n        self.root_logger.addHandler(handler)\n        self.root_logger.setLevel(level)\n\n        #store handler reference\n        self._current_handler = handler\n\n\n    def get_logger(self, name):\n        \"\"\"Get or create a logger with PathSim hierarchy.\n\n        Returns a logger under the 'pathsim' namespace. The logger inherits\n        configuration from the root logger but can be individually configured\n        via set_level().\n\n        Parameters\n        ----------\n        name : str\n            Name of the logger, will be prefixed with 'pathsim.' to create\n            hierarchical logger (e.g., 'simulation' -> 'pathsim.simulation').\n\n        Returns\n        -------\n        logging.Logger\n            Logger instance with the specified name under pathsim hierarchy.\n\n        Examples\n        --------\n\n        .. code-block:: python\n\n            mgr = LoggerManager()\n            mgr.configure(enabled=True)\n\n            # Get logger for simulation module\n            sim_logger = mgr.get_logger(\"simulation\")\n            sim_logger.info(\"Starting simulation\")\n\n            # Get logger for progress tracking\n            progress_logger = mgr.get_logger(\"progress.TRANSIENT\")\n            progress_logger.debug(\"Progress update\")\n\n        \"\"\"\n\n        #create full logger name with pathsim prefix\n        full_name = f\"pathsim.{name}\"\n\n        #get or create logger\n        logger = logging.getLogger(full_name)\n\n        #ensure logger propagates to root pathsim logger\n        logger.propagate = True\n\n        return logger\n\n\n    def set_level(self, level, module=None):\n        \"\"\"Set logging level globally or for a specific module.\n\n        Allows fine-grained control over logging verbosity. Can set the level\n        for all loggers (when module=None) or for a specific logger in the\n        hierarchy.\n\n        Parameters\n        ----------\n        level : int\n            Logging level (e.g., logging.DEBUG, logging.INFO, logging.WARNING,\n            logging.ERROR, logging.CRITICAL).\n        module : str or None, optional\n            Module name to set level for (e.g., 'progress', 'analysis.timer').\n            If None, sets level for the root pathsim logger, affecting all\n            child loggers that don't have their own level set. Defaults to None.\n\n        Examples\n        --------\n\n        .. code-block:: python\n\n            mgr = LoggerManager()\n            mgr.configure(enabled=True)\n\n            # Set global level to INFO\n            mgr.set_level(logging.INFO)\n\n            # Set debug level for progress tracking only\n            mgr.set_level(logging.DEBUG, \"progress\")\n\n            # Quiet analysis logs\n            mgr.set_level(logging.WARNING, \"analysis\")\n\n        \"\"\"\n\n        if module is None:\n            #set level for root pathsim logger\n            self.root_logger.setLevel(level)\n            self._level = level\n        else:\n            #set level for specific module logger\n            logger = self.get_logger(module)\n            logger.setLevel(level)\n\n\n    def is_enabled(self):\n        \"\"\"Check if logging is currently enabled.\n\n        Returns\n        -------\n        bool\n            True if logging is enabled, False otherwise.\n\n        \"\"\"\n        return self._enabled\n\n\n    def get_effective_level(self, module=None):\n        \"\"\"Get the effective logging level.\n\n        Parameters\n        ----------\n        module : str or None, optional\n            Module name to check level for. If None, returns root logger level.\n            Defaults to None.\n\n        Returns\n        -------\n        int\n            The effective logging level (e.g., logging.INFO).\n\n        \"\"\"\n        if module is None:\n            return self.root_logger.level\n        else:\n            logger = self.get_logger(module)\n            return logger.getEffectiveLevel()",
          "bases": [],
          "methods": [
            {
              "name": "__new__",
              "description": "Ensure only one instance exists (singleton pattern).",
              "docstring_html": "<p>Ensure only one instance exists (singleton pattern).</p>\n",
              "source": "def __new__(cls, enabled=False, output=None, level=logging.INFO,\n            format=None, date_format='%H:%M:%S'):\n    \"\"\"Ensure only one instance exists (singleton pattern).\"\"\"\n    if cls._instance is None:\n        cls._instance = super().__new__(cls)\n    return cls._instance",
              "signature": "(cls, enabled = False, output = None, level = logging.INFO, format = None, date_format = '%H:%M:%S')",
              "parameters": [
                {
                  "name": "cls",
                  "type": null,
                  "default": null,
                  "description": ""
                },
                {
                  "name": "enabled",
                  "type": null,
                  "default": "False",
                  "description": ""
                },
                {
                  "name": "output",
                  "type": null,
                  "default": "None",
                  "description": ""
                },
                {
                  "name": "level",
                  "type": null,
                  "default": "logging.INFO",
                  "description": ""
                },
                {
                  "name": "format",
                  "type": null,
                  "default": "None",
                  "description": ""
                },
                {
                  "name": "date_format",
                  "type": null,
                  "default": "'%H:%M:%S'",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "__init__",
              "description": "Initialize the logger manager and setup root logger.",
              "docstring_html": "<p>Initialize the logger manager and setup root logger.</p>\n<p>Configuration is applied immediately on first instantiation if enabled=True.\nSubsequent instantiations return the existing singleton (parameters ignored).\nUse configure() to change settings after initialization.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>enabled <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool, optional</span></dt>\n<dd>Whether logging is enabled. Defaults to False.</dd>\n<dt>output <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">str or None, optional</span></dt>\n<dd>Output destination. If string, logs to file. If None, logs to stdout.\nDefaults to None.</dd>\n<dt>level <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int, optional</span></dt>\n<dd>Logging level. Defaults to logging.INFO.</dd>\n<dt>format <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">str or None, optional</span></dt>\n<dd>Log message format. Defaults to &quot;%(asctime)s - %(levelname)s - %(message)s&quot;.</dd>\n<dt>date_format <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">str or None, optional</span></dt>\n<dd>Date format for timestamps. Defaults to '%H:%M:%S'.</dd>\n</dl>\n",
              "source": "def __init__(self, enabled=False, output=None, level=logging.INFO,\n             format=None, date_format='%H:%M:%S'):\n    \"\"\"Initialize the logger manager and setup root logger.\n\n    Configuration is applied immediately on first instantiation if enabled=True.\n    Subsequent instantiations return the existing singleton (parameters ignored).\n    Use configure() to change settings after initialization.\n\n    Parameters\n    ----------\n    enabled : bool, optional\n        Whether logging is enabled. Defaults to False.\n    output : str or None, optional\n        Output destination. If string, logs to file. If None, logs to stdout.\n        Defaults to None.\n    level : int, optional\n        Logging level. Defaults to logging.INFO.\n    format : str or None, optional\n        Log message format. Defaults to \"%(asctime)s - %(levelname)s - %(message)s\".\n    date_format : str or None, optional\n        Date format for timestamps. Defaults to '%H:%M:%S'.\n    \"\"\"\n    if not LoggerManager._initialized:\n        self._setup_root_logger()\n        LoggerManager._initialized = True\n\n        #apply configuration if enabled\n        if enabled:\n            self.configure(\n                enabled=True,\n                output=output,\n                level=level,\n                format=format,\n                date_format=date_format\n                )",
              "signature": "(enabled = False, output = None, level = logging.INFO, format = None, date_format = '%H:%M:%S')",
              "parameters": [
                {
                  "name": "enabled",
                  "type": null,
                  "default": "False",
                  "description": "Whether logging is enabled. Defaults to False."
                },
                {
                  "name": "output",
                  "type": null,
                  "default": "None",
                  "description": "Output destination. If string, logs to file. If None, logs to stdout. Defaults to None."
                },
                {
                  "name": "level",
                  "type": null,
                  "default": "logging.INFO",
                  "description": "Logging level. Defaults to logging.INFO."
                },
                {
                  "name": "format",
                  "type": null,
                  "default": "None",
                  "description": "Log message format. Defaults to \"%(asctime)s - %(levelname)s - %(message)s\"."
                },
                {
                  "name": "date_format",
                  "type": null,
                  "default": "'%H:%M:%S'",
                  "description": "Date format for timestamps. Defaults to '%H:%M:%S'."
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "_setup_root_logger",
              "description": "Setup the root PathSim logger with default configuration.",
              "docstring_html": "<p>Setup the root PathSim logger with default configuration.</p>\n<p>Creates the 'pathsim' root logger and initializes it with no handlers.\nHandlers are added via the configure() method. Also sets up Python\nwarnings to be captured through the logging system.</p>\n",
              "source": "def _setup_root_logger(self):\n    \"\"\"Setup the root PathSim logger with default configuration.\n\n    Creates the 'pathsim' root logger and initializes it with no handlers.\n    Handlers are added via the configure() method. Also sets up Python\n    warnings to be captured through the logging system.\n    \"\"\"\n\n    #get the root pathsim logger\n    self.root_logger = logging.getLogger(\"pathsim\")\n\n    #prevent propagation to root logger\n    self.root_logger.propagate = False\n\n    #capture Python warnings through logging\n    logging.captureWarnings(True)\n\n    #store configuration state\n    self._enabled = False\n    self._output = None\n    self._level = logging.INFO\n    self._format = \"%(asctime)s - %(levelname)s - %(message)s\"\n    self._date_format = '%H:%M:%S'  #shorter timestamp format\n\n    #store handler reference for reconfiguration\n    self._current_handler = None",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "configure",
              "description": "Configure the root PathSim logger and all child loggers.",
              "docstring_html": "<p>Configure the root PathSim logger and all child loggers.</p>\n<p>This method sets up the logging system with the specified parameters.\nAll loggers created via get_logger() will inherit this configuration.\nCan be called multiple times to reconfigure logging.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>enabled <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool, optional</span></dt>\n<dd>Whether logging is enabled. If False, all logging is disabled.\nDefaults to True.</dd>\n<dt>output <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">str or None, optional</span></dt>\n<dd>Output destination for logs. If a string, interpreted as a file path\nand logs are written to that file. If None, logs are written to stdout.\nDefaults to None (stdout).</dd>\n<dt>level <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int, optional</span></dt>\n<dd>Logging level (e.g., logging.DEBUG, logging.INFO, logging.WARNING).\nDefaults to logging.INFO.</dd>\n<dt>format <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">str or None, optional</span></dt>\n<dd>Log message format string. If None, uses default format.\nDefaults to &quot;%(asctime)s - %(levelname)s - %(message)s&quot;.</dd>\n<dt>date_format <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">str or None, optional</span></dt>\n<dd>Date format string for timestamps (e.g., '%H:%M:%S').\nIf None, uses default format. Defaults to None.</dd>\n</dl>\n<p><strong>Examples</strong></p>\n<pre class=\"code python literal-block\">\n<span class=\"n\">mgr</span> <span class=\"o\">=</span> <span class=\"n\">LoggerManager</span><span class=\"p\">()</span><span class=\"w\">\n\n</span><span class=\"c1\"># Log to stdout with INFO level</span><span class=\"w\">\n</span><span class=\"n\">mgr</span><span class=\"o\">.</span><span class=\"n\">configure</span><span class=\"p\">(</span><span class=\"n\">enabled</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span><span class=\"w\">\n\n</span><span class=\"c1\"># Log to file with DEBUG level</span><span class=\"w\">\n</span><span class=\"n\">mgr</span><span class=\"o\">.</span><span class=\"n\">configure</span><span class=\"p\">(</span><span class=\"n\">enabled</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">,</span> <span class=\"n\">output</span><span class=\"o\">=</span><span class=\"s2\">&quot;debug.log&quot;</span><span class=\"p\">,</span> <span class=\"n\">level</span><span class=\"o\">=</span><span class=\"n\">logging</span><span class=\"o\">.</span><span class=\"n\">DEBUG</span><span class=\"p\">)</span><span class=\"w\">\n\n</span><span class=\"c1\"># Disable all logging</span><span class=\"w\">\n</span><span class=\"n\">mgr</span><span class=\"o\">.</span><span class=\"n\">configure</span><span class=\"p\">(</span><span class=\"n\">enabled</span><span class=\"o\">=</span><span class=\"kc\">False</span><span class=\"p\">)</span><span class=\"w\">\n\n</span><span class=\"c1\"># Custom format with time only</span><span class=\"w\">\n</span><span class=\"n\">mgr</span><span class=\"o\">.</span><span class=\"n\">configure</span><span class=\"p\">(</span><span class=\"w\">\n</span>    <span class=\"n\">enabled</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">,</span><span class=\"w\">\n</span>    <span class=\"nb\">format</span><span class=\"o\">=</span><span class=\"s2\">&quot;</span><span class=\"si\">%(asctime)s</span><span class=\"s2\"> - </span><span class=\"si\">%(message)s</span><span class=\"s2\">&quot;</span><span class=\"p\">,</span><span class=\"w\">\n</span>    <span class=\"n\">date_format</span><span class=\"o\">=</span><span class=\"s1\">'%H:%M:%S'</span><span class=\"w\">\n</span><span class=\"p\">)</span>\n</pre>\n",
              "source": "def configure(self, enabled=True, output=None, level=logging.INFO, \n              format=None, date_format=None):\n    \"\"\"Configure the root PathSim logger and all child loggers.\n\n    This method sets up the logging system with the specified parameters.\n    All loggers created via get_logger() will inherit this configuration.\n    Can be called multiple times to reconfigure logging.\n\n    Parameters\n    ----------\n    enabled : bool, optional\n        Whether logging is enabled. If False, all logging is disabled.\n        Defaults to True.\n    output : str or None, optional\n        Output destination for logs. If a string, interpreted as a file path\n        and logs are written to that file. If None, logs are written to stdout.\n        Defaults to None (stdout).\n    level : int, optional\n        Logging level (e.g., logging.DEBUG, logging.INFO, logging.WARNING).\n        Defaults to logging.INFO.\n    format : str or None, optional\n        Log message format string. If None, uses default format.\n        Defaults to \"%(asctime)s - %(levelname)s - %(message)s\".\n    date_format : str or None, optional\n        Date format string for timestamps (e.g., '%H:%M:%S').\n        If None, uses default format. Defaults to None.\n\n    Examples\n    --------\n\n    .. code-block:: python\n\n        mgr = LoggerManager()\n\n        # Log to stdout with INFO level\n        mgr.configure(enabled=True)\n\n        # Log to file with DEBUG level\n        mgr.configure(enabled=True, output=\"debug.log\", level=logging.DEBUG)\n\n        # Disable all logging\n        mgr.configure(enabled=False)\n\n        # Custom format with time only\n        mgr.configure(\n            enabled=True,\n            format=\"%(asctime)s - %(message)s\",\n            date_format='%H:%M:%S'\n        )\n\n    \"\"\"\n\n    #store configuration\n    self._enabled = enabled\n    self._output = output\n    self._level = level\n    self._format = format or self._format\n    self._date_format = date_format\n\n    #remove existing handler if present\n    if self._current_handler is not None:\n        self.root_logger.removeHandler(self._current_handler)\n        self._current_handler.close()\n        self._current_handler = None\n\n    #if logging is disabled, remove all handlers and return\n    if not enabled:\n        self.root_logger.handlers.clear()\n        self.root_logger.setLevel(logging.CRITICAL + 1)  #effectively disable\n        return\n\n    #create appropriate handler\n    if isinstance(output, str):\n        #file handler for logging to file\n        handler = logging.FileHandler(output)\n    else:\n        #stream handler for logging to stdout\n        handler = logging.StreamHandler(sys.stdout)\n\n    #set formatter\n    formatter = logging.Formatter(self._format, datefmt=self._date_format)\n    handler.setFormatter(formatter)\n\n    #add handler to root logger\n    self.root_logger.addHandler(handler)\n    self.root_logger.setLevel(level)\n\n    #store handler reference\n    self._current_handler = handler",
              "signature": "(enabled = True, output = None, level = logging.INFO, format = None, date_format = None)",
              "parameters": [
                {
                  "name": "enabled",
                  "type": null,
                  "default": "True",
                  "description": "Whether logging is enabled. If False, all logging is disabled. Defaults to True."
                },
                {
                  "name": "output",
                  "type": null,
                  "default": "None",
                  "description": "Output destination for logs. If a string, interpreted as a file path and logs are written to that file. If None, logs are written to stdout. Defaults to None (stdout)."
                },
                {
                  "name": "level",
                  "type": null,
                  "default": "logging.INFO",
                  "description": "Logging level (e.g., logging.DEBUG, logging.INFO, logging.WARNING). Defaults to logging.INFO."
                },
                {
                  "name": "format",
                  "type": null,
                  "default": "None",
                  "description": "Log message format string. If None, uses default format. Defaults to \"%(asctime)s - %(levelname)s - %(message)s\"."
                },
                {
                  "name": "date_format",
                  "type": null,
                  "default": "None",
                  "description": "Date format string for timestamps (e.g., '%H:%M:%S'). If None, uses default format. Defaults to None."
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "get_logger",
              "description": "Get or create a logger with PathSim hierarchy.",
              "docstring_html": "<p>Get or create a logger with PathSim hierarchy.</p>\n<p>Returns a logger under the 'pathsim' namespace. The logger inherits\nconfiguration from the root logger but can be individually configured\nvia set_level().</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>name <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">str</span></dt>\n<dd>Name of the logger, will be prefixed with 'pathsim.' to create\nhierarchical logger (e.g., 'simulation' -&gt; 'pathsim.simulation').</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>logging.Logger</dt>\n<dd>Logger instance with the specified name under pathsim hierarchy.</dd>\n</dl>\n<p><strong>Examples</strong></p>\n<pre class=\"code python literal-block\">\n<span class=\"n\">mgr</span> <span class=\"o\">=</span> <span class=\"n\">LoggerManager</span><span class=\"p\">()</span><span class=\"w\">\n</span><span class=\"n\">mgr</span><span class=\"o\">.</span><span class=\"n\">configure</span><span class=\"p\">(</span><span class=\"n\">enabled</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span><span class=\"w\">\n\n</span><span class=\"c1\"># Get logger for simulation module</span><span class=\"w\">\n</span><span class=\"n\">sim_logger</span> <span class=\"o\">=</span> <span class=\"n\">mgr</span><span class=\"o\">.</span><span class=\"n\">get_logger</span><span class=\"p\">(</span><span class=\"s2\">&quot;simulation&quot;</span><span class=\"p\">)</span><span class=\"w\">\n</span><span class=\"n\">sim_logger</span><span class=\"o\">.</span><span class=\"n\">info</span><span class=\"p\">(</span><span class=\"s2\">&quot;Starting simulation&quot;</span><span class=\"p\">)</span><span class=\"w\">\n\n</span><span class=\"c1\"># Get logger for progress tracking</span><span class=\"w\">\n</span><span class=\"n\">progress_logger</span> <span class=\"o\">=</span> <span class=\"n\">mgr</span><span class=\"o\">.</span><span class=\"n\">get_logger</span><span class=\"p\">(</span><span class=\"s2\">&quot;progress.TRANSIENT&quot;</span><span class=\"p\">)</span><span class=\"w\">\n</span><span class=\"n\">progress_logger</span><span class=\"o\">.</span><span class=\"n\">debug</span><span class=\"p\">(</span><span class=\"s2\">&quot;Progress update&quot;</span><span class=\"p\">)</span>\n</pre>\n",
              "source": "def get_logger(self, name):\n    \"\"\"Get or create a logger with PathSim hierarchy.\n\n    Returns a logger under the 'pathsim' namespace. The logger inherits\n    configuration from the root logger but can be individually configured\n    via set_level().\n\n    Parameters\n    ----------\n    name : str\n        Name of the logger, will be prefixed with 'pathsim.' to create\n        hierarchical logger (e.g., 'simulation' -> 'pathsim.simulation').\n\n    Returns\n    -------\n    logging.Logger\n        Logger instance with the specified name under pathsim hierarchy.\n\n    Examples\n    --------\n\n    .. code-block:: python\n\n        mgr = LoggerManager()\n        mgr.configure(enabled=True)\n\n        # Get logger for simulation module\n        sim_logger = mgr.get_logger(\"simulation\")\n        sim_logger.info(\"Starting simulation\")\n\n        # Get logger for progress tracking\n        progress_logger = mgr.get_logger(\"progress.TRANSIENT\")\n        progress_logger.debug(\"Progress update\")\n\n    \"\"\"\n\n    #create full logger name with pathsim prefix\n    full_name = f\"pathsim.{name}\"\n\n    #get or create logger\n    logger = logging.getLogger(full_name)\n\n    #ensure logger propagates to root pathsim logger\n    logger.propagate = True\n\n    return logger",
              "signature": "(name)",
              "parameters": [
                {
                  "name": "name",
                  "type": null,
                  "default": null,
                  "description": "Name of the logger, will be prefixed with 'pathsim.' to create hierarchical logger (e.g., 'simulation' -> 'pathsim.simulation')."
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "set_level",
              "description": "Set logging level globally or for a specific module.",
              "docstring_html": "<p>Set logging level globally or for a specific module.</p>\n<p>Allows fine-grained control over logging verbosity. Can set the level\nfor all loggers (when module=None) or for a specific logger in the\nhierarchy.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>level <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>Logging level (e.g., logging.DEBUG, logging.INFO, logging.WARNING,\nlogging.ERROR, logging.CRITICAL).</dd>\n<dt>module <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">str or None, optional</span></dt>\n<dd>Module name to set level for (e.g., 'progress', 'analysis.timer').\nIf None, sets level for the root pathsim logger, affecting all\nchild loggers that don't have their own level set. Defaults to None.</dd>\n</dl>\n<p><strong>Examples</strong></p>\n<pre class=\"code python literal-block\">\n<span class=\"n\">mgr</span> <span class=\"o\">=</span> <span class=\"n\">LoggerManager</span><span class=\"p\">()</span><span class=\"w\">\n</span><span class=\"n\">mgr</span><span class=\"o\">.</span><span class=\"n\">configure</span><span class=\"p\">(</span><span class=\"n\">enabled</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span><span class=\"w\">\n\n</span><span class=\"c1\"># Set global level to INFO</span><span class=\"w\">\n</span><span class=\"n\">mgr</span><span class=\"o\">.</span><span class=\"n\">set_level</span><span class=\"p\">(</span><span class=\"n\">logging</span><span class=\"o\">.</span><span class=\"n\">INFO</span><span class=\"p\">)</span><span class=\"w\">\n\n</span><span class=\"c1\"># Set debug level for progress tracking only</span><span class=\"w\">\n</span><span class=\"n\">mgr</span><span class=\"o\">.</span><span class=\"n\">set_level</span><span class=\"p\">(</span><span class=\"n\">logging</span><span class=\"o\">.</span><span class=\"n\">DEBUG</span><span class=\"p\">,</span> <span class=\"s2\">&quot;progress&quot;</span><span class=\"p\">)</span><span class=\"w\">\n\n</span><span class=\"c1\"># Quiet analysis logs</span><span class=\"w\">\n</span><span class=\"n\">mgr</span><span class=\"o\">.</span><span class=\"n\">set_level</span><span class=\"p\">(</span><span class=\"n\">logging</span><span class=\"o\">.</span><span class=\"n\">WARNING</span><span class=\"p\">,</span> <span class=\"s2\">&quot;analysis&quot;</span><span class=\"p\">)</span>\n</pre>\n",
              "source": "def set_level(self, level, module=None):\n    \"\"\"Set logging level globally or for a specific module.\n\n    Allows fine-grained control over logging verbosity. Can set the level\n    for all loggers (when module=None) or for a specific logger in the\n    hierarchy.\n\n    Parameters\n    ----------\n    level : int\n        Logging level (e.g., logging.DEBUG, logging.INFO, logging.WARNING,\n        logging.ERROR, logging.CRITICAL).\n    module : str or None, optional\n        Module name to set level for (e.g., 'progress', 'analysis.timer').\n        If None, sets level for the root pathsim logger, affecting all\n        child loggers that don't have their own level set. Defaults to None.\n\n    Examples\n    --------\n\n    .. code-block:: python\n\n        mgr = LoggerManager()\n        mgr.configure(enabled=True)\n\n        # Set global level to INFO\n        mgr.set_level(logging.INFO)\n\n        # Set debug level for progress tracking only\n        mgr.set_level(logging.DEBUG, \"progress\")\n\n        # Quiet analysis logs\n        mgr.set_level(logging.WARNING, \"analysis\")\n\n    \"\"\"\n\n    if module is None:\n        #set level for root pathsim logger\n        self.root_logger.setLevel(level)\n        self._level = level\n    else:\n        #set level for specific module logger\n        logger = self.get_logger(module)\n        logger.setLevel(level)",
              "signature": "(level, module = None)",
              "parameters": [
                {
                  "name": "level",
                  "type": null,
                  "default": null,
                  "description": "Logging level (e.g., logging.DEBUG, logging.INFO, logging.WARNING, logging.ERROR, logging.CRITICAL)."
                },
                {
                  "name": "module",
                  "type": null,
                  "default": "None",
                  "description": "Module name to set level for (e.g., 'progress', 'analysis.timer'). If None, sets level for the root pathsim logger, affecting all child loggers that don't have their own level set. Defaults to None."
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "is_enabled",
              "description": "Check if logging is currently enabled.",
              "docstring_html": "<p>Check if logging is currently enabled.</p>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>bool</dt>\n<dd>True if logging is enabled, False otherwise.</dd>\n</dl>\n",
              "source": "def is_enabled(self):\n    \"\"\"Check if logging is currently enabled.\n\n    Returns\n    -------\n    bool\n        True if logging is enabled, False otherwise.\n\n    \"\"\"\n    return self._enabled",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "get_effective_level",
              "description": "Get the effective logging level.",
              "docstring_html": "<p>Get the effective logging level.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>module <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">str or None, optional</span></dt>\n<dd>Module name to check level for. If None, returns root logger level.\nDefaults to None.</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>int</dt>\n<dd>The effective logging level (e.g., logging.INFO).</dd>\n</dl>\n",
              "source": "def get_effective_level(self, module=None):\n    \"\"\"Get the effective logging level.\n\n    Parameters\n    ----------\n    module : str or None, optional\n        Module name to check level for. If None, returns root logger level.\n        Defaults to None.\n\n    Returns\n    -------\n    int\n        The effective logging level (e.g., logging.INFO).\n\n    \"\"\"\n    if module is None:\n        return self.root_logger.level\n    else:\n        logger = self.get_logger(module)\n        return logger.getEffectiveLevel()",
              "signature": "(module = None)",
              "parameters": [
                {
                  "name": "module",
                  "type": null,
                  "default": "None",
                  "description": "Module name to check level for. If None, returns root logger level. Defaults to None."
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "_instance",
              "description": "",
              "type": null,
              "value": "None"
            },
            {
              "name": "_initialized",
              "description": "",
              "type": null,
              "value": "False"
            }
          ],
          "parameters": [
            {
              "name": "enabled",
              "type": null,
              "default": "False",
              "description": "Whether logging is enabled. Defaults to False."
            },
            {
              "name": "output",
              "type": null,
              "default": "None",
              "description": "Output destination. If string, logs to file. If None, logs to stdout. Defaults to None."
            },
            {
              "name": "level",
              "type": null,
              "default": "logging.INFO",
              "description": "Logging level. Defaults to logging.INFO."
            },
            {
              "name": "format",
              "type": null,
              "default": "None",
              "description": "Log message format. Defaults to \"%(asctime)s - %(levelname)s - %(message)s\"."
            },
            {
              "name": "date_format",
              "type": null,
              "default": "'%H:%M:%S'",
              "description": "Date format for timestamps. Defaults to '%H:%M:%S'."
            }
          ]
        }
      ],
      "functions": []
    },
    "pathsim.utils.portreference": {
      "name": "pathsim.utils.portreference",
      "description": "",
      "docstring_html": "",
      "classes": [
        {
          "name": "PortReference",
          "description": "Container class that holds a reference to a block and a list of ports.",
          "docstring_html": "<p>Container class that holds a reference to a block and a list of ports.\nOptimized with cached integer indices for ultra-fast transfers.</p>\n<div class=\"section\" id=\"note\">\n<h4>Note</h4>\n<p>The default port, when no ports are defined in the arguments is <cite>0</cite>.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>block <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">Block</span></dt>\n<dd>internal block reference</dd>\n<dt>ports <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">list[int, str]</span></dt>\n<dd>list of port indices or names</dd>\n</dl>\n</div>\n",
          "source": "class PortReference:\n    \"\"\"Container class that holds a reference to a block and a list of ports.\n    Optimized with cached integer indices for ultra-fast transfers.\n\n    Note\n    ----\n    The default port, when no ports are defined in the arguments is `0`.\n\n    Parameters\n    ----------\n    block : Block\n        internal block reference\n    ports : list[int, str]\n        list of port indices or names\n    \"\"\"\n\n    __slots__ = [\"block\", \"ports\", \"_input_indices\", \"_output_indices\"]\n\n    def __init__(self, block=None, ports=None):\n\n        # Default port is '0'\n        _ports = [0] if ports is None else ports \n\n        # Type validation for ports\n        if not isinstance(_ports, list):            \n            raise ValueError(f\"'ports' must be list[int, str] but is '{type(_ports)}'!\")\n\n        for p in _ports:\n            # Type validation for individual ports\n            if not isinstance(p, (int, str)):\n                raise ValueError(f\"Port '{p}' must be (int, str) but is '{type(p)}'!\")\n\n            # Validation for positive integer\n            if isinstance(p, int) and p < 0:\n                raise ValueError(f\"Port '{p}' is int but must be positive!\")\n\n            # Key existence validation for string ports\n            if not (p in block.inputs or p in block.outputs):        \n                raise ValueError(f\"Port alias '{p}' not defined for Block {block}!\")\n\n        # Port uniqueness validation\n        if len(_ports) != len(set(_ports)):\n            raise ValueError(\"'ports' must be unique!\")\n\n        self.block = block\n        self.ports = _ports\n\n        # Cache for resolved integer indices (lazily initialized)\n        self._input_indices = None\n        self._output_indices = None\n\n\n    def __len__(self):\n        \"\"\"The number of ports managed by 'PortReference'\"\"\"\n        return len(self.ports)\n\n\n    def _get_input_indices(self):\n        \"\"\"Get cached input indices, resolving string aliases to integers.\n        Also expands the input array if needed.\n        \"\"\"\n        if self._input_indices is None:\n\n            # Resolve indices/aliases through mapping   \n            self._input_indices = np.array([\n                self.block.inputs._map(p) for p in self.ports\n                ], dtype=np.intp)\n\n            # Resize register to accommodate indices\n            max_idx = self._input_indices.max()\n            self.block.inputs.resize(max_idx + 1)\n\n        return self._input_indices\n\n\n    def _get_output_indices(self):\n        \"\"\"Get cached output indices, resolving string aliases to integers.\n        Also expands the output array if needed.\n        \"\"\"\n        if self._output_indices is None:\n\n            # Resolve indices/aliases through mapping            \n            self._output_indices = np.array([\n                self.block.outputs._map(p) for p in self.ports\n                ], dtype=np.intp)\n\n            # Resize register to accommodate indices\n            max_idx = self._output_indices.max()\n            self.block.outputs.resize(max_idx + 1)\n\n        return self._output_indices\n\n\n    def _validate_input_ports(self):\n        \"\"\"Check the existence of the input ports, specifically string port \n        aliases for the block inputs. Raises a ValueError if not existent.\n        \"\"\"\n        for p in self.ports:\n            if not p in self.block.inputs:\n                raise ValueError(f\"Input port '{p}' not defined for Block {self.block}!\")\n\n\n    def _validate_output_ports(self):\n        \"\"\"Check the existence of the output ports, specifically string port \n        aliases for the block outputs. Raises a ValueError if not existent.\n        \"\"\"\n        for p in self.ports:\n            if not p in self.block.outputs:\n                raise ValueError(f\"Output port '{p}' not defined for Block {self.block}!\")\n\n\n    def to(self, other):\n        \"\"\"Transfer the data between two `PortReference` instances, \n        in this direction `self` -> `other`. From outputs to inputs.\n\n        Uses numpy fancy indexing with cached integer indices.\n\n        Parameters\n        ----------\n        other : PortReference\n            the `PortReference` instance to transfer data to from `self`\n        \"\"\"\n\n        # Get cached integer indices (lazy, resolved once, reused forever)\n        src_indices = self._get_output_indices()\n        dst_indices = other._get_input_indices()\n\n        # Single vectorized transfer \n        other.block.inputs._data[dst_indices] = self.block.outputs._data[src_indices]\n\n\n    def get_inputs(self):\n        \"\"\"Return the input values of the block at specified ports\n\n        Returns\n        -------\n        out : numpy.ndarray\n            input values of block\n        \"\"\"\n        indices = self._get_input_indices()\n        return self.block.inputs._data[indices]\n\n\n    def set_inputs(self, vals):\n        \"\"\"Set the block inputs with values at specified ports\n\n        Parameters\n        ----------\n        vals : array-like\n            values to set at block input ports\n        \"\"\"\n        if not isinstance(vals, np.ndarray):\n            vals = np.asarray(vals)\n        indices = self._get_input_indices()\n        self.block.inputs._data[indices] = vals\n\n\n    def get_outputs(self):\n        \"\"\"Return the output values of the block at specified ports\n\n        Returns\n        -------\n        out : numpy.ndarray\n            output values of block\n        \"\"\"\n        indices = self._get_output_indices()\n        return self.block.outputs._data[indices]\n\n\n    def set_outputs(self, vals):\n        \"\"\"Set the block outputs with values at specified ports\n\n        Parameters\n        ----------\n        vals : array-like\n            values to set at block output ports\n        \"\"\"\n        if not isinstance(vals, np.ndarray):\n            vals = np.asarray(vals)\n        indices = self._get_output_indices()\n        self.block.outputs._data[indices] = vals\n\n\n    def to_dict(self):\n        \"\"\"Serialization into dict\"\"\"\n        return {\n            \"block\": id(self.block),\n            \"ports\": self.ports\n        }",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, block=None, ports=None):\n\n    # Default port is '0'\n    _ports = [0] if ports is None else ports \n\n    # Type validation for ports\n    if not isinstance(_ports, list):            \n        raise ValueError(f\"'ports' must be list[int, str] but is '{type(_ports)}'!\")\n\n    for p in _ports:\n        # Type validation for individual ports\n        if not isinstance(p, (int, str)):\n            raise ValueError(f\"Port '{p}' must be (int, str) but is '{type(p)}'!\")\n\n        # Validation for positive integer\n        if isinstance(p, int) and p < 0:\n            raise ValueError(f\"Port '{p}' is int but must be positive!\")\n\n        # Key existence validation for string ports\n        if not (p in block.inputs or p in block.outputs):        \n            raise ValueError(f\"Port alias '{p}' not defined for Block {block}!\")\n\n    # Port uniqueness validation\n    if len(_ports) != len(set(_ports)):\n        raise ValueError(\"'ports' must be unique!\")\n\n    self.block = block\n    self.ports = _ports\n\n    # Cache for resolved integer indices (lazily initialized)\n    self._input_indices = None\n    self._output_indices = None",
              "signature": "(block = None, ports = None)",
              "parameters": [
                {
                  "name": "block",
                  "type": null,
                  "default": "None",
                  "description": ""
                },
                {
                  "name": "ports",
                  "type": null,
                  "default": "None",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "_get_input_indices",
              "description": "Get cached input indices, resolving string aliases to integers.",
              "docstring_html": "<p>Get cached input indices, resolving string aliases to integers.\nAlso expands the input array if needed.</p>\n",
              "source": "def _get_input_indices(self):\n    \"\"\"Get cached input indices, resolving string aliases to integers.\n    Also expands the input array if needed.\n    \"\"\"\n    if self._input_indices is None:\n\n        # Resolve indices/aliases through mapping   \n        self._input_indices = np.array([\n            self.block.inputs._map(p) for p in self.ports\n            ], dtype=np.intp)\n\n        # Resize register to accommodate indices\n        max_idx = self._input_indices.max()\n        self.block.inputs.resize(max_idx + 1)\n\n    return self._input_indices",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "_get_output_indices",
              "description": "Get cached output indices, resolving string aliases to integers.",
              "docstring_html": "<p>Get cached output indices, resolving string aliases to integers.\nAlso expands the output array if needed.</p>\n",
              "source": "def _get_output_indices(self):\n    \"\"\"Get cached output indices, resolving string aliases to integers.\n    Also expands the output array if needed.\n    \"\"\"\n    if self._output_indices is None:\n\n        # Resolve indices/aliases through mapping            \n        self._output_indices = np.array([\n            self.block.outputs._map(p) for p in self.ports\n            ], dtype=np.intp)\n\n        # Resize register to accommodate indices\n        max_idx = self._output_indices.max()\n        self.block.outputs.resize(max_idx + 1)\n\n    return self._output_indices",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "_validate_input_ports",
              "description": "Check the existence of the input ports, specifically string port",
              "docstring_html": "<p>Check the existence of the input ports, specifically string port\naliases for the block inputs. Raises a ValueError if not existent.</p>\n",
              "source": "def _validate_input_ports(self):\n    \"\"\"Check the existence of the input ports, specifically string port \n    aliases for the block inputs. Raises a ValueError if not existent.\n    \"\"\"\n    for p in self.ports:\n        if not p in self.block.inputs:\n            raise ValueError(f\"Input port '{p}' not defined for Block {self.block}!\")",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "_validate_output_ports",
              "description": "Check the existence of the output ports, specifically string port",
              "docstring_html": "<p>Check the existence of the output ports, specifically string port\naliases for the block outputs. Raises a ValueError if not existent.</p>\n",
              "source": "def _validate_output_ports(self):\n    \"\"\"Check the existence of the output ports, specifically string port \n    aliases for the block outputs. Raises a ValueError if not existent.\n    \"\"\"\n    for p in self.ports:\n        if not p in self.block.outputs:\n            raise ValueError(f\"Output port '{p}' not defined for Block {self.block}!\")",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "to",
              "description": "Transfer the data between two `PortReference` instances,",
              "docstring_html": "<p>Transfer the data between two <cite>PortReference</cite> instances,\nin this direction <cite>self</cite> -&gt; <cite>other</cite>. From outputs to inputs.</p>\n<p>Uses numpy fancy indexing with cached integer indices.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>other <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">PortReference</span></dt>\n<dd>the <cite>PortReference</cite> instance to transfer data to from <cite>self</cite></dd>\n</dl>\n",
              "source": "def to(self, other):\n    \"\"\"Transfer the data between two `PortReference` instances, \n    in this direction `self` -> `other`. From outputs to inputs.\n\n    Uses numpy fancy indexing with cached integer indices.\n\n    Parameters\n    ----------\n    other : PortReference\n        the `PortReference` instance to transfer data to from `self`\n    \"\"\"\n\n    # Get cached integer indices (lazy, resolved once, reused forever)\n    src_indices = self._get_output_indices()\n    dst_indices = other._get_input_indices()\n\n    # Single vectorized transfer \n    other.block.inputs._data[dst_indices] = self.block.outputs._data[src_indices]",
              "signature": "(other)",
              "parameters": [
                {
                  "name": "other",
                  "type": null,
                  "default": null,
                  "description": "the `PortReference` instance to transfer data to from `self`"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "get_inputs",
              "description": "Return the input values of the block at specified ports",
              "docstring_html": "<p>Return the input values of the block at specified ports</p>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>out <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">numpy.ndarray</span></dt>\n<dd>input values of block</dd>\n</dl>\n",
              "source": "def get_inputs(self):\n    \"\"\"Return the input values of the block at specified ports\n\n    Returns\n    -------\n    out : numpy.ndarray\n        input values of block\n    \"\"\"\n    indices = self._get_input_indices()\n    return self.block.inputs._data[indices]",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "set_inputs",
              "description": "Set the block inputs with values at specified ports",
              "docstring_html": "<p>Set the block inputs with values at specified ports</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>vals <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array-like</span></dt>\n<dd>values to set at block input ports</dd>\n</dl>\n",
              "source": "def set_inputs(self, vals):\n    \"\"\"Set the block inputs with values at specified ports\n\n    Parameters\n    ----------\n    vals : array-like\n        values to set at block input ports\n    \"\"\"\n    if not isinstance(vals, np.ndarray):\n        vals = np.asarray(vals)\n    indices = self._get_input_indices()\n    self.block.inputs._data[indices] = vals",
              "signature": "(vals)",
              "parameters": [
                {
                  "name": "vals",
                  "type": null,
                  "default": null,
                  "description": "values to set at block input ports"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "get_outputs",
              "description": "Return the output values of the block at specified ports",
              "docstring_html": "<p>Return the output values of the block at specified ports</p>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>out <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">numpy.ndarray</span></dt>\n<dd>output values of block</dd>\n</dl>\n",
              "source": "def get_outputs(self):\n    \"\"\"Return the output values of the block at specified ports\n\n    Returns\n    -------\n    out : numpy.ndarray\n        output values of block\n    \"\"\"\n    indices = self._get_output_indices()\n    return self.block.outputs._data[indices]",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "set_outputs",
              "description": "Set the block outputs with values at specified ports",
              "docstring_html": "<p>Set the block outputs with values at specified ports</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>vals <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array-like</span></dt>\n<dd>values to set at block output ports</dd>\n</dl>\n",
              "source": "def set_outputs(self, vals):\n    \"\"\"Set the block outputs with values at specified ports\n\n    Parameters\n    ----------\n    vals : array-like\n        values to set at block output ports\n    \"\"\"\n    if not isinstance(vals, np.ndarray):\n        vals = np.asarray(vals)\n    indices = self._get_output_indices()\n    self.block.outputs._data[indices] = vals",
              "signature": "(vals)",
              "parameters": [
                {
                  "name": "vals",
                  "type": null,
                  "default": null,
                  "description": "values to set at block output ports"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "to_dict",
              "description": "Serialization into dict",
              "docstring_html": "<p>Serialization into dict</p>\n",
              "source": "def to_dict(self):\n    \"\"\"Serialization into dict\"\"\"\n    return {\n        \"block\": id(self.block),\n        \"ports\": self.ports\n    }",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "block",
              "description": "",
              "type": null,
              "value": "block"
            },
            {
              "name": "ports",
              "description": "",
              "type": null,
              "value": "_ports"
            },
            {
              "name": "_input_indices",
              "description": "",
              "type": null,
              "value": "None"
            },
            {
              "name": "_output_indices",
              "description": "",
              "type": null,
              "value": "None"
            }
          ],
          "parameters": [
            {
              "name": "block",
              "type": null,
              "default": "None",
              "description": "internal block reference"
            },
            {
              "name": "ports",
              "type": null,
              "default": "None",
              "description": "list of port indices or names"
            }
          ]
        }
      ],
      "functions": []
    },
    "pathsim.utils.progresstracker": {
      "name": "pathsim.utils.progresstracker",
      "description": "",
      "docstring_html": "",
      "classes": [
        {
          "name": "ProgressTracker",
          "description": "A progress tracker for simulations with adaptive ETA and step rate display.",
          "docstring_html": "<p>A progress tracker for simulations with adaptive ETA and step rate display.</p>\n<p>Uses exponential moving average for stable rate estimates and smart ETA calculation.\nCan be used as both an iterator and a context manager.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>total_duration <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>The total simulation duration to track against. Must be positive.</dd>\n<dt>description <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">str, optional</span></dt>\n<dd>Description for log messages. Defaults to &quot;Progress&quot;.</dd>\n<dt>logger <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">logging.Logger, optional</span></dt>\n<dd>Logger instance. If None, uses LoggerManager. Defaults to None.</dd>\n<dt>log <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool, optional</span></dt>\n<dd>Enable logging. Defaults to True.</dd>\n<dt>log_level <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int, optional</span></dt>\n<dd>Logging level. Defaults to logging.INFO.</dd>\n<dt>min_log_interval <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float, optional</span></dt>\n<dd>Minimum seconds between logs. Defaults to LOG_MIN_INTERVAL.</dd>\n<dt>update_log_every <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float, optional</span></dt>\n<dd>Log every N progress fraction (e.g., 0.2 = 20%). Defaults to LOG_UPDATE_EVERY.</dd>\n<dt>bar_width <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int, optional</span></dt>\n<dd>Progress bar width in characters. Defaults to 20.</dd>\n<dt>ema_alpha <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float, optional</span></dt>\n<dd>EMA smoothing factor (0-1), lower = more smoothing. Defaults to 0.3.</dd>\n</dl>\n",
          "source": "class ProgressTracker:\n    \"\"\"A progress tracker for simulations with adaptive ETA and step rate display.\n\n    Uses exponential moving average for stable rate estimates and smart ETA calculation.\n    Can be used as both an iterator and a context manager.\n\n    Parameters\n    ----------\n    total_duration : float\n        The total simulation duration to track against. Must be positive.\n    description : str, optional\n        Description for log messages. Defaults to \"Progress\".\n    logger : logging.Logger, optional\n        Logger instance. If None, uses LoggerManager. Defaults to None.\n    log : bool, optional\n        Enable logging. Defaults to True.\n    log_level : int, optional\n        Logging level. Defaults to logging.INFO.\n    min_log_interval : float, optional\n        Minimum seconds between logs. Defaults to LOG_MIN_INTERVAL.\n    update_log_every : float, optional\n        Log every N progress fraction (e.g., 0.2 = 20%). Defaults to LOG_UPDATE_EVERY.\n    bar_width : int, optional\n        Progress bar width in characters. Defaults to 20.\n    ema_alpha : float, optional\n        EMA smoothing factor (0-1), lower = more smoothing. Defaults to 0.3.\n    \"\"\"\n\n    def __init__(\n        self,\n        total_duration,\n        description=\"Progress\",\n        logger=None,\n        log=True,\n        log_level=logging.INFO,\n        min_log_interval=LOG_MIN_INTERVAL,\n        update_log_every=LOG_UPDATE_EVERY,\n        bar_width=20,\n        ema_alpha=0.3\n        ):\n\n        if total_duration <= 0:\n            raise ValueError(\"total_duration must be positive\")\n        if not (0 < update_log_every <= 1):\n            raise ValueError(\"update_log_every must be in (0, 1]\")\n        if min_log_interval < 0:\n            raise ValueError(\"min_log_interval cannot be negative\")\n\n        self.total_duration = float(total_duration)\n        self.description = description\n        self.log = log\n        self.log_level = log_level\n        self.min_log_interval = min_log_interval\n        self.update_log_every = update_log_every\n        self.bar_width = bar_width\n        self.ema_alpha = max(0.01, min(1.0, ema_alpha))\n\n        #setup logger\n        if logger is None:\n            self.logger = LoggerManager().get_logger(f\"progress.{self.description}\")\n        else:\n            self.logger = logger\n\n        #state tracking\n        self.start_time = None\n        self._progress = 0.0\n        self._interrupted = False\n        self._closed = False\n\n        #stats\n        self.stats = {\"total_steps\": 0, \"successful_steps\": 0, \"runtime_ms\": 0.0}\n\n        #logging state\n        self._last_log_time = 0.0\n        self._last_log_progress = -self.update_log_every\n        self._last_log_steps = 0\n        self._last_logged_percentage = None\n\n        #EMA tracking\n        self._ema_progress_rate = None  #progress per second\n        self._ema_step_rate = None      #steps per second\n        self._last_update_time = None\n\n\n    @property\n    def current_progress(self):\n        \"\"\"Current progress fraction (0.0 to 1.0)\"\"\"\n        return self._progress\n\n\n    @current_progress.setter\n    def current_progress(self, value):\n        \"\"\"Set progress, clamped to [0.0, 1.0]\"\"\"\n        self._progress = max(0.0, min(1.0, float(value)))\n\n\n    # context manager ------------------------------------------------------------------\n\n    def __enter__(self):\n        \"\"\"Start tracker on context entry\"\"\"\n        self.start()\n        return self.__iter__()\n\n\n    def __exit__(self, exc_type, exc_value, traceback):\n        \"\"\"Close tracker on context exit\"\"\"\n        self.close()\n        return False\n\n\n    # iterator -------------------------------------------------------------------------\n\n    def __iter__(self):\n        \"\"\"Iterate while progress < 1.0\"\"\"\n        if self.start_time is None:\n            warnings.warn(\"ProgressTracker iterator started before calling start()\")\n            self.start()\n        while self.current_progress < 1.0:\n            yield self\n\n\n    # core methods ---------------------------------------------------------------------\n\n    def start(self):\n        \"\"\"Start the progress tracker\"\"\"\n        self.start_time = time.perf_counter()\n        self._last_log_time = self.start_time\n        self._last_update_time = self.start_time\n\n        if self.log:\n            self.logger.log(self.log_level,\n                f\"STARTING -> {self.description} (Duration: {self.total_duration:.2f}s)\")\n\n\n    def update(self, progress, success=True, **kwargs):\n        \"\"\"Update progress and optionally log\n\n        Parameters\n        ----------\n        progress : float\n            Progress fraction (0.0 to 1.0)\n        success : bool, optional\n            Whether this step was successful. Defaults to True.\n        **kwargs\n            Additional data (first key-value shown in logs if provided)\n        \"\"\"\n        if self._closed:\n            warnings.warn(\"ProgressTracker updated after being closed\")\n            return\n\n        if self.start_time is None:\n            warnings.warn(\"ProgressTracker updated before start()\")\n            self.start()\n\n        current_time = time.perf_counter()\n\n        #update stats\n        self.stats[\"total_steps\"] += 1\n        if success:\n            self.stats[\"successful_steps\"] += 1\n\n        #update progress\n        old_progress = self._progress\n        self.current_progress = progress\n\n        #update EMA rates\n        if self._last_update_time is not None:\n            dt = current_time - self._last_update_time\n            if dt > 1e-6:\n                #calculate instantaneous rates\n                progress_rate = (self._progress - old_progress) / dt\n                step_rate = 1.0 / dt\n\n                #apply EMA\n                if self._ema_progress_rate is None:\n                    self._ema_progress_rate = progress_rate\n                    self._ema_step_rate = step_rate\n                else:\n                    self._ema_progress_rate = (self.ema_alpha * progress_rate +\n                                               (1 - self.ema_alpha) * self._ema_progress_rate)\n                    self._ema_step_rate = (self.ema_alpha * step_rate +\n                                          (1 - self.ema_alpha) * self._ema_step_rate)\n\n        self._last_update_time = current_time\n\n        #log if needed\n        self._log_progress()\n\n\n    def interrupt(self):\n        \"\"\"Mark tracker as interrupted\"\"\"\n        self._interrupted = True\n\n\n    def close(self):\n        \"\"\"Close tracker and log final stats\"\"\"\n        if self._closed:\n            return\n\n        if self.start_time is not None:\n            runtime = time.perf_counter() - self.start_time\n            self.stats[\"runtime_ms\"] = runtime * 1000\n\n            if self.log:\n                status = \"INTERRUPTED\" if self._interrupted else \"FINISHED\"\n                self.logger.log(self.log_level,\n                    f\"{status} -> {self.description} \"\n                    f\"(total steps: {self.stats['total_steps']}, \"\n                    f\"successful: {self.stats['successful_steps']}, \"\n                    f\"runtime: {self.stats['runtime_ms']:.2f} ms)\")\n\n        self._closed = True\n\n\n    # logging --------------------------------------------------------------------------\n\n    def _log_progress(self):\n        \"\"\"Log progress if conditions met\"\"\"\n        if not self.log or self.start_time is None:\n            return\n\n        current_time = time.perf_counter()\n\n        #check if should log (skip initial 0% log)\n        time_passed = (current_time - self._last_log_time) >= self.min_log_interval\n        progress_milestone = self._progress >= (self._last_log_progress + self.update_log_every)\n\n        if not (time_passed or progress_milestone):\n            return\n\n        #calculate display values\n        elapsed = current_time - self.start_time\n        percentage = int(self._progress * 100)\n\n        #skip 0% and duplicate percentages\n        if percentage == 0 or percentage == self._last_logged_percentage:\n            return\n\n        #ETA from EMA progress rate\n        if self._ema_progress_rate and self._ema_progress_rate > 1e-6 and self._progress < 1.0:\n            eta = (1.0 - self._progress) / self._ema_progress_rate\n        else:\n            eta = None\n\n        #step rate from EMA\n        step_rate = self._ema_step_rate if self._ema_step_rate else None\n\n        #format and log\n        bar = self._render_bar(self._progress)\n        time_str = f\"{self._format_time(elapsed)}<{self._format_time(eta)}\"\n        rate_str = self._format_rate(step_rate) if step_rate else \"N/A\"\n\n        msg = f\"{bar} {percentage:3d}% | {time_str} | {rate_str}\"\n        self.logger.log(self.log_level, msg)\n\n        #update logging state\n        self._last_log_time = current_time\n        self._last_log_progress = (self._progress // self.update_log_every) * self.update_log_every\n        self._last_logged_percentage = percentage\n\n\n    def _render_bar(self, progress):\n        \"\"\"Render ASCII progress bar\"\"\"\n        filled = int(progress * self.bar_width)\n        empty = self.bar_width - filled\n        return '#' * filled + '-' * empty\n\n\n    def _format_time(self, seconds):\n        \"\"\"Format time adaptively: 5.2s, 05:23, or 01:23:45\"\"\"\n        if seconds is None or seconds < 0 or not (0 <= seconds < float('inf')):\n            return \"--:--\"\n\n        if seconds < 60:\n            return f\"{seconds:.1f}s\"\n        elif seconds < 3600:\n            m, s = divmod(int(seconds), 60)\n            return f\"{m:02d}:{s:02d}\"\n        else:\n            h, m = divmod(int(seconds // 60), 60)\n            s = int(seconds % 60)\n            return f\"{h:02d}:{m:02d}:{s:02d}\"\n\n\n    def _format_rate(self, rate):\n        \"\"\"Format rate adaptively\"\"\"\n        if rate is None or rate <= 0:\n            return \"N/A\"\n\n        if rate < 0.1:\n            return f\"{rate * 60:.1f} it/min\"\n        elif rate < 1:\n            return f\"{rate:.2f} it/s\"\n        else:\n            return f\"{rate:.1f} it/s\"",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(\n    self,\n    total_duration,\n    description=\"Progress\",\n    logger=None,\n    log=True,\n    log_level=logging.INFO,\n    min_log_interval=LOG_MIN_INTERVAL,\n    update_log_every=LOG_UPDATE_EVERY,\n    bar_width=20,\n    ema_alpha=0.3\n    ):\n\n    if total_duration <= 0:\n        raise ValueError(\"total_duration must be positive\")\n    if not (0 < update_log_every <= 1):\n        raise ValueError(\"update_log_every must be in (0, 1]\")\n    if min_log_interval < 0:\n        raise ValueError(\"min_log_interval cannot be negative\")\n\n    self.total_duration = float(total_duration)\n    self.description = description\n    self.log = log\n    self.log_level = log_level\n    self.min_log_interval = min_log_interval\n    self.update_log_every = update_log_every\n    self.bar_width = bar_width\n    self.ema_alpha = max(0.01, min(1.0, ema_alpha))\n\n    #setup logger\n    if logger is None:\n        self.logger = LoggerManager().get_logger(f\"progress.{self.description}\")\n    else:\n        self.logger = logger\n\n    #state tracking\n    self.start_time = None\n    self._progress = 0.0\n    self._interrupted = False\n    self._closed = False\n\n    #stats\n    self.stats = {\"total_steps\": 0, \"successful_steps\": 0, \"runtime_ms\": 0.0}\n\n    #logging state\n    self._last_log_time = 0.0\n    self._last_log_progress = -self.update_log_every\n    self._last_log_steps = 0\n    self._last_logged_percentage = None\n\n    #EMA tracking\n    self._ema_progress_rate = None  #progress per second\n    self._ema_step_rate = None      #steps per second\n    self._last_update_time = None",
              "signature": "(total_duration, description = 'Progress', logger = None, log = True, log_level = logging.INFO, min_log_interval = LOG_MIN_INTERVAL, update_log_every = LOG_UPDATE_EVERY, bar_width = 20, ema_alpha = 0.3)",
              "parameters": [
                {
                  "name": "total_duration",
                  "type": null,
                  "default": null,
                  "description": ""
                },
                {
                  "name": "description",
                  "type": null,
                  "default": "'Progress'",
                  "description": ""
                },
                {
                  "name": "logger",
                  "type": null,
                  "default": "None",
                  "description": ""
                },
                {
                  "name": "log",
                  "type": null,
                  "default": "True",
                  "description": ""
                },
                {
                  "name": "log_level",
                  "type": null,
                  "default": "logging.INFO",
                  "description": ""
                },
                {
                  "name": "min_log_interval",
                  "type": null,
                  "default": "LOG_MIN_INTERVAL",
                  "description": ""
                },
                {
                  "name": "update_log_every",
                  "type": null,
                  "default": "LOG_UPDATE_EVERY",
                  "description": ""
                },
                {
                  "name": "bar_width",
                  "type": null,
                  "default": "20",
                  "description": ""
                },
                {
                  "name": "ema_alpha",
                  "type": null,
                  "default": "0.3",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "start",
              "description": "Start the progress tracker",
              "docstring_html": "<p>Start the progress tracker</p>\n",
              "source": "def start(self):\n    \"\"\"Start the progress tracker\"\"\"\n    self.start_time = time.perf_counter()\n    self._last_log_time = self.start_time\n    self._last_update_time = self.start_time\n\n    if self.log:\n        self.logger.log(self.log_level,\n            f\"STARTING -> {self.description} (Duration: {self.total_duration:.2f}s)\")",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "update",
              "description": "Update progress and optionally log",
              "docstring_html": "<p>Update progress and optionally log</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>progress <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>Progress fraction (0.0 to 1.0)</dd>\n<dt>success <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool, optional</span></dt>\n<dd>Whether this step was successful. Defaults to True.</dd>\n<dt>**kwargs</dt>\n<dd>Additional data (first key-value shown in logs if provided)</dd>\n</dl>\n",
              "source": "def update(self, progress, success=True, **kwargs):\n    \"\"\"Update progress and optionally log\n\n    Parameters\n    ----------\n    progress : float\n        Progress fraction (0.0 to 1.0)\n    success : bool, optional\n        Whether this step was successful. Defaults to True.\n    **kwargs\n        Additional data (first key-value shown in logs if provided)\n    \"\"\"\n    if self._closed:\n        warnings.warn(\"ProgressTracker updated after being closed\")\n        return\n\n    if self.start_time is None:\n        warnings.warn(\"ProgressTracker updated before start()\")\n        self.start()\n\n    current_time = time.perf_counter()\n\n    #update stats\n    self.stats[\"total_steps\"] += 1\n    if success:\n        self.stats[\"successful_steps\"] += 1\n\n    #update progress\n    old_progress = self._progress\n    self.current_progress = progress\n\n    #update EMA rates\n    if self._last_update_time is not None:\n        dt = current_time - self._last_update_time\n        if dt > 1e-6:\n            #calculate instantaneous rates\n            progress_rate = (self._progress - old_progress) / dt\n            step_rate = 1.0 / dt\n\n            #apply EMA\n            if self._ema_progress_rate is None:\n                self._ema_progress_rate = progress_rate\n                self._ema_step_rate = step_rate\n            else:\n                self._ema_progress_rate = (self.ema_alpha * progress_rate +\n                                           (1 - self.ema_alpha) * self._ema_progress_rate)\n                self._ema_step_rate = (self.ema_alpha * step_rate +\n                                      (1 - self.ema_alpha) * self._ema_step_rate)\n\n    self._last_update_time = current_time\n\n    #log if needed\n    self._log_progress()",
              "signature": "(progress, success = True, kwargs = {})",
              "parameters": [
                {
                  "name": "progress",
                  "type": null,
                  "default": null,
                  "description": "Progress fraction (0.0 to 1.0)"
                },
                {
                  "name": "success",
                  "type": null,
                  "default": "True",
                  "description": "Whether this step was successful. Defaults to True. **kwargs Additional data (first key-value shown in logs if provided)"
                },
                {
                  "name": "kwargs",
                  "type": null,
                  "default": "{}",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "interrupt",
              "description": "Mark tracker as interrupted",
              "docstring_html": "<p>Mark tracker as interrupted</p>\n",
              "source": "def interrupt(self):\n    \"\"\"Mark tracker as interrupted\"\"\"\n    self._interrupted = True",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "close",
              "description": "Close tracker and log final stats",
              "docstring_html": "<p>Close tracker and log final stats</p>\n",
              "source": "def close(self):\n    \"\"\"Close tracker and log final stats\"\"\"\n    if self._closed:\n        return\n\n    if self.start_time is not None:\n        runtime = time.perf_counter() - self.start_time\n        self.stats[\"runtime_ms\"] = runtime * 1000\n\n        if self.log:\n            status = \"INTERRUPTED\" if self._interrupted else \"FINISHED\"\n            self.logger.log(self.log_level,\n                f\"{status} -> {self.description} \"\n                f\"(total steps: {self.stats['total_steps']}, \"\n                f\"successful: {self.stats['successful_steps']}, \"\n                f\"runtime: {self.stats['runtime_ms']:.2f} ms)\")\n\n    self._closed = True",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "_log_progress",
              "description": "Log progress if conditions met",
              "docstring_html": "<p>Log progress if conditions met</p>\n",
              "source": "def _log_progress(self):\n    \"\"\"Log progress if conditions met\"\"\"\n    if not self.log or self.start_time is None:\n        return\n\n    current_time = time.perf_counter()\n\n    #check if should log (skip initial 0% log)\n    time_passed = (current_time - self._last_log_time) >= self.min_log_interval\n    progress_milestone = self._progress >= (self._last_log_progress + self.update_log_every)\n\n    if not (time_passed or progress_milestone):\n        return\n\n    #calculate display values\n    elapsed = current_time - self.start_time\n    percentage = int(self._progress * 100)\n\n    #skip 0% and duplicate percentages\n    if percentage == 0 or percentage == self._last_logged_percentage:\n        return\n\n    #ETA from EMA progress rate\n    if self._ema_progress_rate and self._ema_progress_rate > 1e-6 and self._progress < 1.0:\n        eta = (1.0 - self._progress) / self._ema_progress_rate\n    else:\n        eta = None\n\n    #step rate from EMA\n    step_rate = self._ema_step_rate if self._ema_step_rate else None\n\n    #format and log\n    bar = self._render_bar(self._progress)\n    time_str = f\"{self._format_time(elapsed)}<{self._format_time(eta)}\"\n    rate_str = self._format_rate(step_rate) if step_rate else \"N/A\"\n\n    msg = f\"{bar} {percentage:3d}% | {time_str} | {rate_str}\"\n    self.logger.log(self.log_level, msg)\n\n    #update logging state\n    self._last_log_time = current_time\n    self._last_log_progress = (self._progress // self.update_log_every) * self.update_log_every\n    self._last_logged_percentage = percentage",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "_render_bar",
              "description": "Render ASCII progress bar",
              "docstring_html": "<p>Render ASCII progress bar</p>\n",
              "source": "def _render_bar(self, progress):\n    \"\"\"Render ASCII progress bar\"\"\"\n    filled = int(progress * self.bar_width)\n    empty = self.bar_width - filled\n    return '#' * filled + '-' * empty",
              "signature": "(progress)",
              "parameters": [
                {
                  "name": "progress",
                  "type": null,
                  "default": null,
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "_format_time",
              "description": "Format time adaptively: 5.2s, 05:23, or 01:23:45",
              "docstring_html": "<p>Format time adaptively: 5.2s, 05:23, or 01:23:45</p>\n",
              "source": "def _format_time(self, seconds):\n    \"\"\"Format time adaptively: 5.2s, 05:23, or 01:23:45\"\"\"\n    if seconds is None or seconds < 0 or not (0 <= seconds < float('inf')):\n        return \"--:--\"\n\n    if seconds < 60:\n        return f\"{seconds:.1f}s\"\n    elif seconds < 3600:\n        m, s = divmod(int(seconds), 60)\n        return f\"{m:02d}:{s:02d}\"\n    else:\n        h, m = divmod(int(seconds // 60), 60)\n        s = int(seconds % 60)\n        return f\"{h:02d}:{m:02d}:{s:02d}\"",
              "signature": "(seconds)",
              "parameters": [
                {
                  "name": "seconds",
                  "type": null,
                  "default": null,
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "_format_rate",
              "description": "Format rate adaptively",
              "docstring_html": "<p>Format rate adaptively</p>\n",
              "source": "def _format_rate(self, rate):\n    \"\"\"Format rate adaptively\"\"\"\n    if rate is None or rate <= 0:\n        return \"N/A\"\n\n    if rate < 0.1:\n        return f\"{rate * 60:.1f} it/min\"\n    elif rate < 1:\n        return f\"{rate:.2f} it/s\"\n    else:\n        return f\"{rate:.1f} it/s\"",
              "signature": "(rate)",
              "parameters": [
                {
                  "name": "rate",
                  "type": null,
                  "default": null,
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "total_duration",
              "description": "",
              "type": null,
              "value": "float(total_duration)"
            },
            {
              "name": "description",
              "description": "",
              "type": null,
              "value": "description"
            },
            {
              "name": "log",
              "description": "",
              "type": null,
              "value": "log"
            },
            {
              "name": "log_level",
              "description": "",
              "type": null,
              "value": "log_level"
            },
            {
              "name": "min_log_interval",
              "description": "",
              "type": null,
              "value": "min_log_interval"
            },
            {
              "name": "update_log_every",
              "description": "",
              "type": null,
              "value": "update_log_every"
            },
            {
              "name": "bar_width",
              "description": "",
              "type": null,
              "value": "bar_width"
            },
            {
              "name": "ema_alpha",
              "description": "",
              "type": null,
              "value": "max(0.01, min(1.0, ema_alpha))"
            },
            {
              "name": "logger",
              "description": "",
              "type": null,
              "value": "LoggerManager().get_logger(f'progress.{self.description}')"
            },
            {
              "name": "start_time",
              "description": "",
              "type": null,
              "value": "None"
            },
            {
              "name": "_progress",
              "description": "",
              "type": null,
              "value": "0.0"
            },
            {
              "name": "_interrupted",
              "description": "",
              "type": null,
              "value": "False"
            },
            {
              "name": "_closed",
              "description": "",
              "type": null,
              "value": "False"
            },
            {
              "name": "stats",
              "description": "",
              "type": null,
              "value": "{'total_steps': 0, 'successful_steps': 0, 'runtime_ms': 0.0}"
            },
            {
              "name": "_last_log_time",
              "description": "",
              "type": null,
              "value": "0.0"
            },
            {
              "name": "_last_log_progress",
              "description": "",
              "type": null,
              "value": "-self.update_log_every"
            },
            {
              "name": "_last_log_steps",
              "description": "",
              "type": null,
              "value": "0"
            },
            {
              "name": "_last_logged_percentage",
              "description": "",
              "type": null,
              "value": "None"
            },
            {
              "name": "_ema_progress_rate",
              "description": "",
              "type": null,
              "value": "None"
            },
            {
              "name": "_ema_step_rate",
              "description": "",
              "type": null,
              "value": "None"
            },
            {
              "name": "_last_update_time",
              "description": "",
              "type": null,
              "value": "None"
            },
            {
              "name": "current_progress",
              "description": "Current progress fraction (0.0 to 1.0)",
              "type": null,
              "value": null
            }
          ],
          "parameters": [
            {
              "name": "total_duration",
              "type": null,
              "default": null,
              "description": "The total simulation duration to track against. Must be positive."
            },
            {
              "name": "description",
              "type": null,
              "default": "'Progress'",
              "description": "Description for log messages. Defaults to \"Progress\"."
            },
            {
              "name": "logger",
              "type": null,
              "default": "None",
              "description": "Logger instance. If None, uses LoggerManager. Defaults to None."
            },
            {
              "name": "log",
              "type": null,
              "default": "True",
              "description": "Enable logging. Defaults to True."
            },
            {
              "name": "log_level",
              "type": null,
              "default": "logging.INFO",
              "description": "Logging level. Defaults to logging.INFO."
            },
            {
              "name": "min_log_interval",
              "type": null,
              "default": "LOG_MIN_INTERVAL",
              "description": "Minimum seconds between logs. Defaults to LOG_MIN_INTERVAL."
            },
            {
              "name": "update_log_every",
              "type": null,
              "default": "LOG_UPDATE_EVERY",
              "description": "Log every N progress fraction (e.g., 0.2 = 20%). Defaults to LOG_UPDATE_EVERY."
            },
            {
              "name": "bar_width",
              "type": null,
              "default": "20",
              "description": "Progress bar width in characters. Defaults to 20."
            },
            {
              "name": "ema_alpha",
              "type": null,
              "default": "0.3",
              "description": "EMA smoothing factor (0-1), lower = more smoothing. Defaults to 0.3."
            }
          ]
        }
      ],
      "functions": []
    },
    "pathsim.utils.realtimeplotter": {
      "name": "pathsim.utils.realtimeplotter",
      "description": "",
      "docstring_html": "",
      "classes": [
        {
          "name": "RealtimePlotter",
          "description": "Class that manages a realtime plotting window that",
          "docstring_html": "<p>Class that manages a realtime plotting window that\ncan stream in x-y-data and update accordingly</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>max_samples <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>maximum number of samples to plot</dd>\n<dt>update_interval <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>time in seconds between refreshs</dd>\n<dt>labels <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">list[str]</span></dt>\n<dd>labels for plot traces</dd>\n<dt>x_label <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">str</span></dt>\n<dd>label for x-axis</dd>\n<dt>y_label <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">str</span></dt>\n<dd>label for y-axis</dd>\n</dl>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>fig <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">matplotlib.pyplot.figure</span></dt>\n<dd>internal figure of the realtime plotter</dd>\n<dt>ax <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">matplotlib.pyplot.axis</span></dt>\n<dd>internal axis of the realtime plotter</dd>\n</dl>\n",
          "source": "class RealtimePlotter:\n    \"\"\"Class that manages a realtime plotting window that \n    can stream in x-y-data and update accordingly\n\n    Parameters\n    ----------\n    max_samples : int\n        maximum number of samples to plot\n    update_interval : float\n        time in seconds between refreshs\n    labels : list[str]\n        labels for plot traces\n    x_label : str\n        label for x-axis\n    y_label : str\n        label for y-axis\n\n    Attributes\n    ----------\n    fig : matplotlib.pyplot.figure\n        internal figure of the realtime plotter\n    ax : matplotlib.pyplot.axis\n        internal axis of the realtime plotter\n    \"\"\"\n\n    def __init__(self, max_samples=None, update_interval=1, labels=[], x_label=\"\", y_label=\"\"):\n\n        #plotter settings\n        self.max_samples = max_samples\n        self.update_interval = update_interval\n        self.labels = labels\n        self.x_label = x_label\n        self.y_label = y_label\n\n        #figure initialization\n        self.fig, self.ax = plt.subplots(nrows=1, \n                                         ncols=1, \n                                         figsize=(8,4), \n                                         tight_layout=True, \n                                         dpi=120)\n\n        #custom colors\n        self.ax.set_prop_cycle(color=COLORS_ALL)\n\n        #plot settings\n        self.ax.set_xlabel(self.x_label)\n        self.ax.set_ylabel(self.y_label)\n        self.ax.grid(True)\n\n        #data and lines (traces) for plotting\n        self.lines = []\n        self.data = []\n\n        #tracking update time\n        self.last_update = time.time()\n\n        #flag for running mode\n        self.is_running = True\n\n        # Connect the close event to the on_close method\n        self.fig.canvas.mpl_connect(\"close_event\", self.on_close)\n\n        # Initialize legend\n        self.legend = None\n        self.lined = {}\n\n        #show the plotting window\n        self.show()\n\n\n    def update_all(self, x, y):\n        \"\"\"update the plot completely with new data\n\n        Parameters\n        ----------\n        x : array[float]\n            new x values to plot\n        y : array[float]\n            new y values to plot\n        \"\"\"\n\n        #not running? -> quit early\n        if not self.is_running:\n            return False\n\n        #no data yet? -> initialize lines\n        if not self.data:\n\n            #data initialization\n            for i, val in enumerate(y):\n                self.data.append({\"x\": [], \"y\": []})\n\n                #label selection and line (trace) initialization\n                label = self.labels[i] if i < len(self.labels) else f\"port {i}\"\n                line, = self.ax.plot([], [], lw=1.5, label=label)\n                self.lines.append(line)\n\n            # Create legend\n            self.legend = self.ax.legend(fancybox=False, ncols=int(np.ceil(len(y)/4)), loc=\"lower left\")\n            self._setup_legend_picking()\n\n        #check if new update of plot is required\n        current_time = time.time()\n        if current_time - self.last_update > self.update_interval:        \n\n            #replace the data\n            for i, val in enumerate(y):\n                self.data[i][\"x\"] = x\n                self.data[i][\"y\"] = val\n\n            self._update_plot()\n            self.last_update = current_time\n\n        return True\n\n\n    def update(self, x, y):\n        \"\"\"update the plot with new data\n\n        Parameters\n        ----------\n        x : float\n            new x value to add\n        y : float\n            new y value to add\n        \"\"\"\n\n        #not running? -> quit early\n        if not self.is_running:\n            return False\n\n        #no data yet? -> initialize lines\n        if not self.data:\n\n            #vectorial data -> multiple traces\n            if np.isscalar(y):\n\n                #size of data\n                n = 1\n\n                #check if rolling window plot\n                if self.max_samples is None:\n                    self.data.append({\"x\": [], \"y\": []})\n                else:\n                    self.data.append({\"x\": deque(maxlen=self.max_samples), \n                                      \"y\": deque(maxlen=self.max_samples)})\n\n                #label selection and line (trace) initialization\n                label = self.labels[0] if self.labels else \"port 0\"\n                line, = self.ax.plot([], [], lw=1.5, label=label)\n                self.lines.append(line)\n\n            else:\n\n                #size of data\n                n = len(y)\n\n                for i in range(n):\n\n                    #check if rolling window plot\n                    if self.max_samples is None:\n                        self.data.append({\"x\": [], \"y\": []})\n                    else:\n                        self.data.append({\"x\": deque(maxlen=self.max_samples), \n                                          \"y\": deque(maxlen=self.max_samples)})\n\n                    #label selection and line (trace) initialization\n                    label = self.labels[i] if i < len(self.labels) else f\"port {i}\"\n                    line, = self.ax.plot([], [], lw=1.5, label=label)\n                    self.lines.append(line)\n\n            # Create legend\n            self.legend = self.ax.legend(fancybox=False, ncols=int(np.ceil(n/4)), loc=\"lower left\")\n            self._setup_legend_picking()\n\n        #add the data\n        if np.isscalar(y):\n            self.data[0][\"x\"].append(x)\n            self.data[0][\"y\"].append(y)\n        else:\n            for i, val in enumerate(y):\n                self.data[i][\"x\"].append(x)\n                self.data[i][\"y\"].append(val)\n\n        #check if new update of plot is required\n        current_time = time.time()\n        if current_time - self.last_update > self.update_interval:\n            self._update_plot()\n            self.last_update = current_time\n\n        return True\n\n\n    def _update_plot(self):\n\n        #set the data to the lines (traces) of the plot\n        for i, line in enumerate(self.lines):\n            line.set_data(self.data[i][\"x\"], self.data[i][\"y\"])\n\n        #rescale the window\n        self.ax.relim()\n        self.ax.autoscale_view()\n\n        #redraw the figure\n        self.fig.canvas.draw()\n        self.fig.canvas.flush_events()\n\n\n    def show(self):\n        plt.show(block=False)\n\n\n    def on_close(self, event):\n        self.is_running = False\n\n\n    def _setup_legend_picking(self):\n\n        #setup the picking for the legend lines\n        for legline, origline in zip(self.legend.get_lines(), self.lines):\n            legline.set_picker(5)  # 5 points tolerance\n            self.lined[legline] = origline\n\n        def on_pick(event):\n            legline = event.artist\n            origline = self.lined[legline]\n            visible = not origline.get_visible()\n            origline.set_visible(visible)\n            legline.set_alpha(1.0 if visible else 0.2)\n            self.fig.canvas.draw()\n\n        self.fig.canvas.mpl_connect(\"pick_event\", on_pick)",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, max_samples=None, update_interval=1, labels=[], x_label=\"\", y_label=\"\"):\n\n    #plotter settings\n    self.max_samples = max_samples\n    self.update_interval = update_interval\n    self.labels = labels\n    self.x_label = x_label\n    self.y_label = y_label\n\n    #figure initialization\n    self.fig, self.ax = plt.subplots(nrows=1, \n                                     ncols=1, \n                                     figsize=(8,4), \n                                     tight_layout=True, \n                                     dpi=120)\n\n    #custom colors\n    self.ax.set_prop_cycle(color=COLORS_ALL)\n\n    #plot settings\n    self.ax.set_xlabel(self.x_label)\n    self.ax.set_ylabel(self.y_label)\n    self.ax.grid(True)\n\n    #data and lines (traces) for plotting\n    self.lines = []\n    self.data = []\n\n    #tracking update time\n    self.last_update = time.time()\n\n    #flag for running mode\n    self.is_running = True\n\n    # Connect the close event to the on_close method\n    self.fig.canvas.mpl_connect(\"close_event\", self.on_close)\n\n    # Initialize legend\n    self.legend = None\n    self.lined = {}\n\n    #show the plotting window\n    self.show()",
              "signature": "(max_samples = None, update_interval = 1, labels = [], x_label = '', y_label = '')",
              "parameters": [
                {
                  "name": "max_samples",
                  "type": null,
                  "default": "None",
                  "description": ""
                },
                {
                  "name": "update_interval",
                  "type": null,
                  "default": "1",
                  "description": ""
                },
                {
                  "name": "labels",
                  "type": null,
                  "default": "[]",
                  "description": ""
                },
                {
                  "name": "x_label",
                  "type": null,
                  "default": "''",
                  "description": ""
                },
                {
                  "name": "y_label",
                  "type": null,
                  "default": "''",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "update_all",
              "description": "update the plot completely with new data",
              "docstring_html": "<p>update the plot completely with new data</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>x <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array[float]</span></dt>\n<dd>new x values to plot</dd>\n<dt>y <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array[float]</span></dt>\n<dd>new y values to plot</dd>\n</dl>\n",
              "source": "def update_all(self, x, y):\n    \"\"\"update the plot completely with new data\n\n    Parameters\n    ----------\n    x : array[float]\n        new x values to plot\n    y : array[float]\n        new y values to plot\n    \"\"\"\n\n    #not running? -> quit early\n    if not self.is_running:\n        return False\n\n    #no data yet? -> initialize lines\n    if not self.data:\n\n        #data initialization\n        for i, val in enumerate(y):\n            self.data.append({\"x\": [], \"y\": []})\n\n            #label selection and line (trace) initialization\n            label = self.labels[i] if i < len(self.labels) else f\"port {i}\"\n            line, = self.ax.plot([], [], lw=1.5, label=label)\n            self.lines.append(line)\n\n        # Create legend\n        self.legend = self.ax.legend(fancybox=False, ncols=int(np.ceil(len(y)/4)), loc=\"lower left\")\n        self._setup_legend_picking()\n\n    #check if new update of plot is required\n    current_time = time.time()\n    if current_time - self.last_update > self.update_interval:        \n\n        #replace the data\n        for i, val in enumerate(y):\n            self.data[i][\"x\"] = x\n            self.data[i][\"y\"] = val\n\n        self._update_plot()\n        self.last_update = current_time\n\n    return True",
              "signature": "(x, y)",
              "parameters": [
                {
                  "name": "x",
                  "type": null,
                  "default": null,
                  "description": "new x values to plot"
                },
                {
                  "name": "y",
                  "type": null,
                  "default": null,
                  "description": "new y values to plot"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "update",
              "description": "update the plot with new data",
              "docstring_html": "<p>update the plot with new data</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>x <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>new x value to add</dd>\n<dt>y <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>new y value to add</dd>\n</dl>\n",
              "source": "def update(self, x, y):\n    \"\"\"update the plot with new data\n\n    Parameters\n    ----------\n    x : float\n        new x value to add\n    y : float\n        new y value to add\n    \"\"\"\n\n    #not running? -> quit early\n    if not self.is_running:\n        return False\n\n    #no data yet? -> initialize lines\n    if not self.data:\n\n        #vectorial data -> multiple traces\n        if np.isscalar(y):\n\n            #size of data\n            n = 1\n\n            #check if rolling window plot\n            if self.max_samples is None:\n                self.data.append({\"x\": [], \"y\": []})\n            else:\n                self.data.append({\"x\": deque(maxlen=self.max_samples), \n                                  \"y\": deque(maxlen=self.max_samples)})\n\n            #label selection and line (trace) initialization\n            label = self.labels[0] if self.labels else \"port 0\"\n            line, = self.ax.plot([], [], lw=1.5, label=label)\n            self.lines.append(line)\n\n        else:\n\n            #size of data\n            n = len(y)\n\n            for i in range(n):\n\n                #check if rolling window plot\n                if self.max_samples is None:\n                    self.data.append({\"x\": [], \"y\": []})\n                else:\n                    self.data.append({\"x\": deque(maxlen=self.max_samples), \n                                      \"y\": deque(maxlen=self.max_samples)})\n\n                #label selection and line (trace) initialization\n                label = self.labels[i] if i < len(self.labels) else f\"port {i}\"\n                line, = self.ax.plot([], [], lw=1.5, label=label)\n                self.lines.append(line)\n\n        # Create legend\n        self.legend = self.ax.legend(fancybox=False, ncols=int(np.ceil(n/4)), loc=\"lower left\")\n        self._setup_legend_picking()\n\n    #add the data\n    if np.isscalar(y):\n        self.data[0][\"x\"].append(x)\n        self.data[0][\"y\"].append(y)\n    else:\n        for i, val in enumerate(y):\n            self.data[i][\"x\"].append(x)\n            self.data[i][\"y\"].append(val)\n\n    #check if new update of plot is required\n    current_time = time.time()\n    if current_time - self.last_update > self.update_interval:\n        self._update_plot()\n        self.last_update = current_time\n\n    return True",
              "signature": "(x, y)",
              "parameters": [
                {
                  "name": "x",
                  "type": null,
                  "default": null,
                  "description": "new x value to add"
                },
                {
                  "name": "y",
                  "type": null,
                  "default": null,
                  "description": "new y value to add"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "_update_plot",
              "description": "",
              "docstring_html": "",
              "source": "def _update_plot(self):\n\n    #set the data to the lines (traces) of the plot\n    for i, line in enumerate(self.lines):\n        line.set_data(self.data[i][\"x\"], self.data[i][\"y\"])\n\n    #rescale the window\n    self.ax.relim()\n    self.ax.autoscale_view()\n\n    #redraw the figure\n    self.fig.canvas.draw()\n    self.fig.canvas.flush_events()",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "show",
              "description": "",
              "docstring_html": "",
              "source": "def show(self):\n    plt.show(block=False)",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "on_close",
              "description": "",
              "docstring_html": "",
              "source": "def on_close(self, event):\n    self.is_running = False",
              "signature": "(event)",
              "parameters": [
                {
                  "name": "event",
                  "type": null,
                  "default": null,
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "_setup_legend_picking",
              "description": "",
              "docstring_html": "",
              "source": "def _setup_legend_picking(self):\n\n    #setup the picking for the legend lines\n    for legline, origline in zip(self.legend.get_lines(), self.lines):\n        legline.set_picker(5)  # 5 points tolerance\n        self.lined[legline] = origline\n\n    def on_pick(event):\n        legline = event.artist\n        origline = self.lined[legline]\n        visible = not origline.get_visible()\n        origline.set_visible(visible)\n        legline.set_alpha(1.0 if visible else 0.2)\n        self.fig.canvas.draw()\n\n    self.fig.canvas.mpl_connect(\"pick_event\", on_pick)",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "max_samples",
              "description": "",
              "type": null,
              "value": "max_samples"
            },
            {
              "name": "update_interval",
              "description": "",
              "type": null,
              "value": "update_interval"
            },
            {
              "name": "labels",
              "description": "",
              "type": null,
              "value": "labels"
            },
            {
              "name": "x_label",
              "description": "",
              "type": null,
              "value": "x_label"
            },
            {
              "name": "y_label",
              "description": "",
              "type": null,
              "value": "y_label"
            },
            {
              "name": "lines",
              "description": "",
              "type": null,
              "value": "[]"
            },
            {
              "name": "data",
              "description": "",
              "type": null,
              "value": "[]"
            },
            {
              "name": "last_update",
              "description": "",
              "type": null,
              "value": "time.time()"
            },
            {
              "name": "is_running",
              "description": "",
              "type": null,
              "value": "True"
            },
            {
              "name": "legend",
              "description": "",
              "type": null,
              "value": "None"
            },
            {
              "name": "lined",
              "description": "",
              "type": null,
              "value": "{}"
            }
          ],
          "parameters": [
            {
              "name": "max_samples",
              "type": null,
              "default": "None",
              "description": "maximum number of samples to plot"
            },
            {
              "name": "update_interval",
              "type": null,
              "default": "1",
              "description": "time in seconds between refreshs"
            },
            {
              "name": "labels",
              "type": null,
              "default": "[]",
              "description": "labels for plot traces"
            },
            {
              "name": "x_label",
              "type": null,
              "default": "''",
              "description": "label for x-axis"
            },
            {
              "name": "y_label",
              "type": null,
              "default": "''",
              "description": "label for y-axis"
            }
          ]
        }
      ],
      "functions": []
    },
    "pathsim.utils.register": {
      "name": "pathsim.utils.register",
      "description": "",
      "docstring_html": "",
      "classes": [
        {
          "name": "Register",
          "description": "This class is a intended to be used for the inputs and outputs of blocks.",
          "docstring_html": "<p>This class is a intended to be used for the inputs and outputs of blocks.</p>\n<p>Its basic functionality is similar to a <cite>dict</cite> but with some additional methods\nand implemented as a numpy array for fast data transfer.</p>\n<p>The core functionality is that values can be added dynamically and the size of the\nregister doesnt have to be specified. It also implements some methods to interact\nwith numpy arrays and to streamline convergence checks.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>size <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int, optional</span></dt>\n<dd>initial size of the register</dd>\n<dt>mapping <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">dict[str: int]</span></dt>\n<dd>string aliases for integer ports</dd>\n</dl>\n<p><strong>Attributes</strong></p>\n<dl class=\"docutils\">\n<dt>_data <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">np.ndarray</span></dt>\n<dd>internal numpy array that holds the values</dd>\n<dt>_mapping <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">dict[str: int]</span></dt>\n<dd>internal mapping for port aliases from string to int (index)</dd>\n</dl>\n",
          "source": "class Register:\n    \"\"\"This class is a intended to be used for the inputs and outputs of blocks. \n\n    Its basic functionality is similar to a `dict` but with some additional methods \n    and implemented as a numpy array for fast data transfer. \n\n    The core functionality is that values can be added dynamically and the size of the \n    register doesnt have to be specified. It also implements some methods to interact \n    with numpy arrays and to streamline convergence checks.\n\n    Parameters\n    ----------\n    size : int, optional\n        initial size of the register \n    mapping : dict[str: int]\n        string aliases for integer ports\n\n    Attributes\n    ----------\n    _data : np.ndarray\n        internal numpy array that holds the values\n    _mapping : dict[str: int]\n        internal mapping for port aliases from string to int (index)\n    \"\"\"\n\n    __slots__ = [\"_data\", \"_mapping\"]\n\n    def __init__(self, size=None, mapping=None, dtype=np.float64):\n        self._data = np.zeros(1 if size is None else size, dtype=dtype)\n        self._mapping = {} if mapping is None else mapping\n\n\n    def _map(self, key):\n        \"\"\"Map string keys to integers defined in '_mapping'\n\n        Parameters\n        ----------\n        key : int, str\n            port key, to map to index\n\n        Returns\n        -------\n        _key : int\n            port index \n        \"\"\"\n        return self._mapping.get(key, key)\n\n\n    def _get_max_index(self, key):\n        \"\"\"Identify max index from different key types.\"\"\"\n        if isinstance(key, int):\n            return key\n        elif isinstance(key, slice):\n            return key.stop - 1 if key.stop is not None else -1\n        elif isinstance(key, (list, tuple, np.ndarray)):\n            return max(key) if key else -1\n        return -1\n\n\n    def __len__(self):\n        return len(self._data)\n\n\n    def __iter__(self):\n        \"\"\"Iteration and unpacking into tuples or lists\"\"\"\n        return iter(self._data)\n\n\n    def __getitem__(self, key):\n        \"\"\"Get the value for direct access to the \n        register values.\n\n        Parameters\n        ----------\n        key : int, str\n            port key, where to get value from\n\n        Returns\n        -------\n        out : float, obj\n            value from port at `key` position\n        \"\"\"\n        if isinstance(key, str):\n            key = self._map(key)\n            if not isinstance(key, int):\n                return 0.0\n\n        if isinstance(key, int):\n            if key < 0 or key >= len(self._data):\n                return 0.0\n            return self._data[key]\n\n        return self._data[key]\n\n\n    def __setitem__(self, key, value):\n        \"\"\"Set the value at key index for direct access\n        to the register values.\n\n        Parameters\n        ----------\n        key : int, str\n            port key, where to set value\n        val : float, obj\n            value to set at port\n        \"\"\"\n        max_idx = self._get_max_index(self._map(key))\n        self.resize(max_idx + 1)\n\n        #convert to scalar if needed to avoid numpy deprecation warning\n        if isinstance(value, np.ndarray) and value.ndim == 0:\n            value = value.item()\n\n        self._data[key] = value\n\n\n    def resize(self, size):\n        \"\"\"Resize the internal data array to accommodate more entries.\n\n        Creates a new zero-filled array instead of in-place resize to avoid\n        numpy ValueError when other references to the array exist (e.g., from\n        fancy indexing in PortReference).\n\n        Parameters\n        ----------\n        size : int\n            new size for the internal data array\n        \"\"\"\n        if size > len(self._data):\n            new_data = np.zeros(size)\n            new_data[:len(self._data)] = self._data\n            self._data = new_data          \n\n\n    def reset(self):\n        \"\"\"Set all stored values to zero.\"\"\"\n        self._data[:] = 0.0\n\n\n    def to_array(self):\n        \"\"\"Returns a copy of the internal array.\n\n        Returns\n        -------\n        arr : np.ndarray\n            converted register as array\n        \"\"\"\n        return self._data.copy()\n\n\n    def update_from_array(self, arr):\n        \"\"\"Update the register values from an array in place.\n\n        Parameters\n        ----------\n        arr : np.ndarray, list, tuple, float\n            array or scalar that is used to update internal register values\n        \"\"\"\n        if isinstance(arr, (np.ndarray, list, tuple)):\n            n = len(arr)\n            if n > len(self._data):\n                self.resize(n)\n            self._data[:n] = arr\n        else:\n            self._data[0] = arr\n\n\n    def __contains__(self, key):\n        \"\"\"Check if a key is in mapping or is valid integer index.\"\"\"\n        return key in self._mapping or isinstance(key, int)",
          "bases": [],
          "methods": [
            {
              "name": "__init__",
              "description": "",
              "docstring_html": "",
              "source": "def __init__(self, size=None, mapping=None, dtype=np.float64):\n    self._data = np.zeros(1 if size is None else size, dtype=dtype)\n    self._mapping = {} if mapping is None else mapping",
              "signature": "(size = None, mapping = None, dtype = np.float64)",
              "parameters": [
                {
                  "name": "size",
                  "type": null,
                  "default": "None",
                  "description": ""
                },
                {
                  "name": "mapping",
                  "type": null,
                  "default": "None",
                  "description": ""
                },
                {
                  "name": "dtype",
                  "type": null,
                  "default": "np.float64",
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "_map",
              "description": "Map string keys to integers defined in '_mapping'",
              "docstring_html": "<p>Map string keys to integers defined in '_mapping'</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>key <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int, str</span></dt>\n<dd>port key, to map to index</dd>\n</dl>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>_key <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>port index</dd>\n</dl>\n",
              "source": "def _map(self, key):\n    \"\"\"Map string keys to integers defined in '_mapping'\n\n    Parameters\n    ----------\n    key : int, str\n        port key, to map to index\n\n    Returns\n    -------\n    _key : int\n        port index \n    \"\"\"\n    return self._mapping.get(key, key)",
              "signature": "(key)",
              "parameters": [
                {
                  "name": "key",
                  "type": null,
                  "default": null,
                  "description": "port key, to map to index"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "_get_max_index",
              "description": "Identify max index from different key types.",
              "docstring_html": "<p>Identify max index from different key types.</p>\n",
              "source": "def _get_max_index(self, key):\n    \"\"\"Identify max index from different key types.\"\"\"\n    if isinstance(key, int):\n        return key\n    elif isinstance(key, slice):\n        return key.stop - 1 if key.stop is not None else -1\n    elif isinstance(key, (list, tuple, np.ndarray)):\n        return max(key) if key else -1\n    return -1",
              "signature": "(key)",
              "parameters": [
                {
                  "name": "key",
                  "type": null,
                  "default": null,
                  "description": ""
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "resize",
              "description": "Resize the internal data array to accommodate more entries.",
              "docstring_html": "<p>Resize the internal data array to accommodate more entries.</p>\n<p>Creates a new zero-filled array instead of in-place resize to avoid\nnumpy ValueError when other references to the array exist (e.g., from\nfancy indexing in PortReference).</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>size <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>new size for the internal data array</dd>\n</dl>\n",
              "source": "def resize(self, size):\n    \"\"\"Resize the internal data array to accommodate more entries.\n\n    Creates a new zero-filled array instead of in-place resize to avoid\n    numpy ValueError when other references to the array exist (e.g., from\n    fancy indexing in PortReference).\n\n    Parameters\n    ----------\n    size : int\n        new size for the internal data array\n    \"\"\"\n    if size > len(self._data):\n        new_data = np.zeros(size)\n        new_data[:len(self._data)] = self._data\n        self._data = new_data",
              "signature": "(size)",
              "parameters": [
                {
                  "name": "size",
                  "type": null,
                  "default": null,
                  "description": "new size for the internal data array"
                }
              ],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "reset",
              "description": "Set all stored values to zero.",
              "docstring_html": "<p>Set all stored values to zero.</p>\n",
              "source": "def reset(self):\n    \"\"\"Set all stored values to zero.\"\"\"\n    self._data[:] = 0.0",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "to_array",
              "description": "Returns a copy of the internal array.",
              "docstring_html": "<p>Returns a copy of the internal array.</p>\n<p><strong>Returns</strong></p>\n<dl class=\"docutils\">\n<dt>arr <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">np.ndarray</span></dt>\n<dd>converted register as array</dd>\n</dl>\n",
              "source": "def to_array(self):\n    \"\"\"Returns a copy of the internal array.\n\n    Returns\n    -------\n    arr : np.ndarray\n        converted register as array\n    \"\"\"\n    return self._data.copy()",
              "signature": "()",
              "parameters": [],
              "returns": null,
              "method_type": "method"
            },
            {
              "name": "update_from_array",
              "description": "Update the register values from an array in place.",
              "docstring_html": "<p>Update the register values from an array in place.</p>\n<p><strong>Parameters</strong></p>\n<dl class=\"docutils\">\n<dt>arr <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">np.ndarray, list, tuple, float</span></dt>\n<dd>array or scalar that is used to update internal register values</dd>\n</dl>\n",
              "source": "def update_from_array(self, arr):\n    \"\"\"Update the register values from an array in place.\n\n    Parameters\n    ----------\n    arr : np.ndarray, list, tuple, float\n        array or scalar that is used to update internal register values\n    \"\"\"\n    if isinstance(arr, (np.ndarray, list, tuple)):\n        n = len(arr)\n        if n > len(self._data):\n            self.resize(n)\n        self._data[:n] = arr\n    else:\n        self._data[0] = arr",
              "signature": "(arr)",
              "parameters": [
                {
                  "name": "arr",
                  "type": null,
                  "default": null,
                  "description": "array or scalar that is used to update internal register values"
                }
              ],
              "returns": null,
              "method_type": "method"
            }
          ],
          "attributes": [
            {
              "name": "_data",
              "description": "",
              "type": null,
              "value": "np.zeros(1 if size is None else size, dtype=dtype)"
            },
            {
              "name": "_mapping",
              "description": "",
              "type": null,
              "value": "{} if mapping is None else mapping"
            }
          ],
          "parameters": [
            {
              "name": "size",
              "type": null,
              "default": "None",
              "description": "initial size of the register"
            },
            {
              "name": "mapping",
              "type": null,
              "default": "None",
              "description": "string aliases for integer ports"
            },
            {
              "name": "dtype",
              "type": null,
              "default": "np.float64",
              "description": ""
            }
          ]
        }
      ],
      "functions": []
    }
  }
}